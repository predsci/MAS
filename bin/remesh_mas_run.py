#!/usr/bin/env python3
import os
import os.path
import signal
import subprocess
import numpy as np
import argparse
import psi_io

"""
REMESH_MAS_RUN: Version 2.2.2

Remesh specified sequence number of a MAS run to a new resolution
specified by 1D mesh files generated by the PSI mesh generator 
(or extract_PSI_meshes_from_3D_B.py).

This script assumes one wants to only remesh the energized part of the
magnetic field to add to the new run.  Therfore, one must specify the location of
the potential field (typically sequence 001 of a fresh MAS relaxation run).

The output is the remeshed fields for the specified model, and 
the lines to insert into the input file of the new run.


Note: This script uses the PSI tools: SDS_FUNC, REMESH_GENERAL.


NOTES:

### Key Choices:
1) Interpolator and method
 - Do we care about monotonicity (pchip) or guaranteed 2nd order smooth (cubic)?
 
2) Filter settings
 - Use of filters is APPLICATION DEPENDENT!
 - Do we care about preserving sharp discontinuities? May NOT want to filter.
 - Do we want to remove grid level oscillations? May want to filter.
 - Are we remeshing in one direction only (e.g. high->low) or both directions?
   - This will determine if you want to filter before OR after OR both.
 - Are you making a pretty image? You may want to use the compensator -comp
   - BUT compensator adds ringing. This may create negative values in a non-negative field.
   --> use the -log flag if you care about preserving non-negativity.

3) Log interpolation for non-negative, non-zero scalars
 - Do we care about "sharpness" (use log) or integral preserving accuracy (don't use log)?
 - Log interpolation uses very different weighting for strong gradients and is scale dependent.
   This changes integral preserving properties and the behavior of the -comp filter.

I Break these down into three basic classes of remesh styles and parameter selection
  - I recommend "C" for remeshing CORHEL BG --> CME runs. It is most like the old RBF style.
  - We may want to try "A" once and/or for remeshing the CME later in time.


Changelog:

    1.0, CD, 2020/07/29
        - Initial Version

    2.0, RC, 2020/08/21
        - Made example script into tool.

    2.1, RC, 2020/09/16
        - Bug fix in MAS input file text output.        

    2.2.2, RC, 2023/02/01
       - Added thermo_2t_wtd option.
"""

def signal_handler(signal, frame):
        print('You pressed Ctrl+C! Stopping!')
        sys.exit(0)
signal.signal(signal.SIGINT, signal_handler)


def argParsing():

    parser = argparse.ArgumentParser(description='remesh_mas_run')

    parser.add_argument('-dir_orig',
                        help='Directory (full path) of MAS run to remesh.',
                        dest='dir_orig',
                        required=True)

    parser.add_argument('-idx_orig',
                        help='Sequence number of MAS run to remesh.',
                        dest='idx_orig',
                        required=True)

    parser.add_argument('-model',
                        help='MAS model.  This sets preset field lists to remesh.  Options are: [zb | poly | thermo | thermo_pw | thermo_wtd]',
                        dest='model',
                        required=True)

    parser.add_argument('-field_list',
                        help='List of fields to remesh.  Overides model parameter.',
                        dest='field_list',
                        required=False)

    parser.add_argument('-dir_pot',
                        help='Directory (full path) of MAS potential field.  If not specified, will assume sequence 1 of original MAS run B field is potential field.',
                        dest='dir_pot',
                        required=False)

    parser.add_argument('-idx_pot',
                        help='Sequence number of MAS potential field output. Default is 1.',
                        dest='idx_pot',
                        default=1,
                        required=False)

    parser.add_argument('-pot_br',
                        help='Br file of potential field. Overides dir_pot/idx_pot.',
                        dest='pot_br',
                        required=False)

    parser.add_argument('-pot_bt',
                        help='Bt file of potential field. Overides dir_pot/idx_pot.',
                        dest='pot_bt',
                        required=False)

    parser.add_argument('-pot_bp',
                        help='Bp file of potential field. Overides dir_pot/idx_pot.',
                        dest='pot_bp',
                        required=False)

    parser.add_argument('-mesh_prefix',
                        help='<{FULL-PATH}/filename_prefix> of 1D mesh files.  It is assumed that there are 6 1D hdf mesh files (r,t,p for the half and main mesh).  The filenames for the 6 files are assumed to be <mesh_prefix>_[half|main]_[r|t|p].<fmt_in>',
                        dest='mesh_prefix',
                        required=True)

    parser.add_argument('-dir_out',
                        help='Output directory to place remeshed files.',
                        dest='dir_out',
                        default='.',
                        required=False)

    parser.add_argument('-method',
                        help='Remeshing method preset.  Options are A: Accurate but NOT smooth, B:Intermediate Smooth/Accurate, and C: Super Smooth/Less Accurate.',
                        dest='method',
                        default='C',
                        required=False)

    parser.add_argument('-seq_len',
                        help='Length of sequence numbers of MAS files (001 vs 000001).  Default is 3.',
                        dest='seq_len',
                        default=3,
                        required=False)

    parser.add_argument('-fmt_in',
                        help='File format for input fields and meshes [hdf|h5].  Default is hdf.',
                        dest='fmtin',
                        default='hdf',
                        required=False)

    parser.add_argument('-fmt_out',
                        help='File format for output fields [hdf|h5].  Default is h5.',
                        dest='fmtout',
                        default='h5',
                        required=False)

    parser.add_argument('-v',
                        help='Verbose mode.',
                        dest='verbose',
                        default=False,
                        action='store_true',
                        required=False)

    return parser.parse_args()

## Get input agruments:
args = argParsing()

print("")
print('Starting REMESH_MAS_RUN...')
print("")
# Extension we are inputting from and outputting to (.hdf or .h5).
extin = '.'+args.fmtin
extout = '.'+args.fmtout
if (args.verbose):
    print('-> Input files extension set to: %s' % extin)
    print('-> Output files extension set to: %s' % extout)

# Get formatting string for sequence number based on length.
seqfstr='%0'+str(args.seq_len)+'d'

# Directory and mas sequence number of the ORIGIN run.
dir_src = args.dir_orig #'/data/Dropbox/PSI/MAS/DEV/remesh/runs/mar2012/mar2012_ulow_relaxation'
seq_src = seqfstr % int(args.idx_orig) #'002'
if (args.verbose):
    print('-> Remeshing from MAS run files: %s' % dir_src+'/*'+seq_src+extin)

# Directory and mas sequence number of POTENTIAL FIELD on the same MAS mesh as ORIGIN.
# If not specified, assume ORIGIN 001 B is potential field.

if (args.dir_pot is None):
    dir_pot = dir_src
    seq_pot = seqfstr % 1
else:
    dir_pot = args.dir_pot
    seq_pot = seqfstr % int(args.idx_pot)
if (args.verbose):
    print('-> Using potential field from files: %s' % dir_pot+'/b[rtp]'+seq_pot+extin)

# Directory and string tag of 1D mesh files for DESTINATION mesh.
mesh_prefix = args.mesh_prefix
if (args.verbose):
    print('-> Using 1D mesh files: %s' % mesh_prefix+'_[main|half]_[r|t|p]'+extin)

# Output directory for REMESHED data.
output_dir = args.dir_out#'/data/Dropbox/PSI/MAS/DEV/remesh/runs/mar2012/mas2012_ulow_remeshed_to_med'
if (args.verbose):
    print('-> Remeshed files will be output to: %s' % output_dir+'/<field>_remesh'+extout)


# List of variables to remesh  zb | poly | thermo | thermo_pw | thermo_wtd | thermo_2t_wtd
if (args.model == 'zb'):
    remesh_vars = ['rho', 't', 'br_sub', 'bt_sub', 'bp_sub', 'vr', 'vt', 'vp']
elif (args.model == 'poly'):
    remesh_vars = ['rho', 't', 'br_sub', 'bt_sub', 'bp_sub', 'vr', 'vt', 'vp']
elif (args.model == 'thermo'):
    remesh_vars = ['rho', 't', 'br_sub', 'bt_sub', 'bp_sub', 'vr', 'vt', 'vp']
elif (args.model == 'thermo_pw'):
    remesh_vars = ['rho', 't', 'ep', 'em', 'br_sub', 'bt_sub', 'bp_sub', 'vr', 'vt', 'vp']
elif (args.model == 'thermo_wtd'):
    remesh_vars = ['rho', 't', 'ep', 'em', 'zp', 'zm', 'br_sub', 'bt_sub', 'bp_sub', 'vr', 'vt', 'vp']
elif (args.model == 'thermo_2t_wtd'):
    remesh_vars = ['rho', 'tp', 'te', 'ep', 'em', 'zp', 'zm', 'br_sub', 'bt_sub', 'bp_sub', 'vr', 'vt', 'vp']
else:
    remesh_vars = args.field_list.split(",")
if (args.verbose):
    print('-> Fields to be remeshed: '+",".join(remesh_vars))

remesh_style = args.method

# Option A: Accurate but NOT smooth (Monotonic, Integral Preserving). Use for well resolved cases.
if remesh_style == 'A':
    interpolator = 'pchip'
    method = 'integral'
    nfilt_before = 0
    nfilt_after = 0
    kernel = '121'
    use_compensator = False
    do_log_non_neg = False

# Option B: Intermediate Smooth/Accurate, keep monotonicity but use log, spread solution out.
elif remesh_style == 'B':
    interpolator = 'pchip'
    method = 'integral'
    nfilt_before = 1
    nfilt_after = 1
    kernel = '131'
    use_compensator = False
    do_log_non_neg = True

# Option C: Super Smooth, kill grid oscillations while preserving shape (lose monotonicity/accuracy).
elif remesh_style == 'C':
    interpolator = 'cubic'
    method = 'integral'
    nfilt_before = 1
    nfilt_after = 1
    kernel = '121'
    use_compensator = True
    do_log_non_neg = True

if (args.verbose):
    print('-> Selected remesh method: '+remesh_style)
    print('   - interpolator = '+ interpolator)
    print('   - method = '+ method)
    print('   - nfilt_before = '+str(nfilt_before))
    print('   - nfilt_after = '+str(nfilt_after))
    print('   - kernel = '+ kernel)
    print('   - use_compensator = '+str(use_compensator))
    print('   - do_log_non_neg = '+str(do_log_non_neg))

# ----------------------------------------------------------------------
# Hardcoded MAS information
# ----------------------------------------------------------------------

# Master lists of all mas variables in each half mesh dimension.
half_dict = {}
half_dict['r'] = ['rho', 't', 'ep', 'em', 'zp', 'zm', 'br', 'vt', 'vp', 'jt', 'jp', 'at', 'ap']
half_dict['t'] = ['rho', 't', 'ep', 'em', 'zp', 'zm', 'bt', 'vr', 'vp', 'jr', 'jp', 'ar', 'ap']
half_dict['p'] = ['rho', 't', 'ep', 'em', 'zp', 'zm', 'bp', 'vr', 'vt', 'jr', 'jt', 'ar', 'at']

# Master list of non-negative, non-zero MAS scalars.
mas_non_neg = ['rho', 't', 'te', 'tp', 'ep', 'em']


# ----------------------------------------------------------------------
# General Helper Methods
# ----------------------------------------------------------------------

def run_shell_command(command, dirname, debug=False):
    """
    Generic method for calling shell commands
    """
    process = subprocess.Popen(
        command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        shell=True, cwd=dirname)

    try:
        stdout, stderr = process.communicate(timeout=300)
        if debug:
            for line in stdout.strip().decode().splitlines():
                print(line)
            for line in stderr.strip().decode().splitlines():
                print(line)
    except subprocess.TimeoutExpired:
        process.kill()

    # check the return code here, if non-zero, print the output and raise an exception.
    if process.returncode != 0:
        print('')
        print(f'ERROR: run_shell_command returned a non-zero exit code! {process.returncode}')
        print(f'  Shell command: {command}')
        print('  STDOUT: ')
        for line in stdout.strip().decode().splitlines():
            print('    ' + line)
        print('  STDERR: ')
        for line in stderr.strip().decode().splitlines():
            print('    ' + line)
        raise RuntimeError(f'Shell command: {command} returned exit code: {process.returncode}')

    return process.returncode, stdout


def print_stdout(stdout):
    """
    Quick wrapper to print the output of a command line call.
    """
    for line in stdout.strip().decode().splitlines():
        print('    ' + line)


# ----------------------------------------------------------------------
# Script Specific Methods (Caution! I was lazy with the namespace...)
# ----------------------------------------------------------------------

def validate_non_negative_remesh(remesh_dir, remesh_vars, mas_non_neg):
    """
    Validate the results of a remesh by making sure that fields that should be
    non-negative ARE non-negative in the domain after a remesh.
    - Right now all non-negative fields are on the hhh mesh --> collapse outer
      layers of the fields to the main mesh boundaries (don't modify interior).
    """
    for var in set(remesh_vars).intersection(mas_non_neg):
        file = os.path.join(remesh_dir, var + '_remesh' + extout)
        rh, th, ph, f3d = psi_io.rdhdf_3d(file)

        # interp the edges in the r and t dimensions (f will be ordered p,t,r in python)
        f3d[:, 0, :] = 0.5*(f3d[:, 0, :] + f3d[:, 1, :])
        f3d[:, -1, :] = 0.5*(f3d[:, -1, :] + f3d[:, -2, :])
        f3d[:, :, 0] = 0.5*(f3d[:, :, 0] + f3d[:, :, 1])
        f3d[:, :, -1] = 0.5*(f3d[:, :, -1] + f3d[:, :, -2])

        # get the minimum value (neglect outer r BC for ep, em I think theres something fishy)
        if var in ['ep', 'em']:
            minval = np.min(f3d[:, :, 0:-1])
        else:
            minval = np.min(f3d)

        if minval < 0.0:
            raise ValueError(f'\n\n### ERROR in validate_non_negative_remesh!\n '
                             f' Remeshed var: {var} is negative inside the domain.')


# Create output directory if needed
if not os.path.isdir(output_dir):
     try:
         os.mkdir(output_dir)
     except OSError:
         print(f'Creation of a directory failed: {output_dir}')

# build the base command to remesh general
base_command = f'remesh_general -interpolator {interpolator} -method {method}'

if nfilt_before > 0:
    base_command = f'{base_command} -nfilt_before {nfilt_before}'

if nfilt_after > 0:
    base_command = f'{base_command} -nfilt_after {nfilt_after}'

if use_compensator:
    base_command = f'{base_command} -comp'

if kernel != '121':
    base_command = f'{base_command} -kernel {kernel}'

# Check to see if we need to subtract the b field
sub_vars = ['br_sub', 'bt_sub', 'bp_sub']
if not set(remesh_vars).isdisjoint(sub_vars):
    for var in sub_vars:
        var_in = var.split('_sub')[0]
        infile_mhd = os.path.join(dir_src, var_in + seq_src + extin)\

        # Set default potfield file name, then handle manual override:
        infile_pot = os.path.join(dir_pot, var_in + seq_pot + extin)
        if (args.pot_br is not None and var_in == "br"):
            infile_pot = args.pot_br
        if (args.pot_bt is not None and var_in == "bt"):
            infile_pot = args.pot_bt
        if (args.pot_bp is not None and var_in == "bp"):
            infile_pot = args.pot_bp

        outfile = os.path.join(output_dir, var + seq_src + extin)

        # skip if b_sub already exists
        if os.path.isfile(outfile):
            print(f' -> Subtracted {var + seq_src + extin} already exists!')
            continue

        for file in [infile_mhd, infile_pot]:
            try:
                os.path.isfile(file)
            except OSError:
                print(f'B Subtraction failed! Cant find: {file}')

        # Use SDS func to subtract the files (sub needs to be on disk anyway)
        print(f' -> Subtracting potential field from {var_in + seq_src + extin} to make {var + seq_src + extin}...')
        command = f'sds_func -func ax+by -x {infile_mhd} -y {infile_pot} -b -1.0 {outfile}'
        ierr, stdout = run_shell_command(command, output_dir)

if (args.verbose):
    print(' -> Starting remeshes...')

# Loop over files, remesh
for var in remesh_vars:

    # determine the base MAS var type if necessary (subtracted b and other types may be handled differently)
    var_type = var
    if '_sub' in var:
        var_type = var.split('_sub')[0]
        infile_mhd = os.path.join(output_dir, var + seq_src + extin)
    else:
        infile_mhd = os.path.join(dir_src, var + seq_src + extin)
    if var == 'te' or var == 'tp':
        var_type = 't'

    # Determine mesh filenames for each mesh direction (main or half).
    mesh_dict = {}
    for direction in ['r', 't', 'p']:
        if var_type in half_dict[direction]:
            type = 'half'
        else:
            type = 'main'
        mesh_dict[direction] = mesh_prefix + '_' + type + '_' + direction + extin

    # build any extra commands
    extra = ''
    if do_log_non_neg and var in mas_non_neg:
        extra = '-log'
    if args.verbose:
        extra = extra + ' -v'

    # remesh the file
    outfile = os.path.join(output_dir, var + '_remesh' + extout)

    print(f" -> Remeshing {var + seq_src + extin} to {var + '_remesh' + extout}...")

    command = f'{base_command} -x {mesh_dict["r"]} -y {mesh_dict["t"]} -z {mesh_dict["p"]}' \
             f' -mas {var_type} {extra} {infile_mhd} {outfile}'

    if args.verbose:
        print(command)

    ierr, stdout = run_shell_command(command, os.getcwd())

    if args.verbose:
        print_stdout(stdout)


# Check the output for non-negative values
if (args.verbose):
    print(' -> Validating non-negative fields...')

validate_non_negative_remesh(output_dir, remesh_vars, mas_non_neg)

if (args.verbose):
    print(' -> Done!')


# OUTPUT MAS IFILE PORTION FOR ADDING/INIT ALL FIELDS:

print("")
print("REMESH COMPLETED!")

with open(output_dir+'/insert_into_mas_input_file.txt', 'w') as f:
    var_count = 0
    for var in remesh_vars:
         var_file = var+'_remesh'+extout
         if '_sub' in var:
             var_action = 'add'
             field = var[0:2]
         else:
             var_action = 'initial'
             field = var
         var_count = var_count + 1
         print("load_fields(%d)%%field='%s'" % (var_count,field), file=f)
         print("load_fields(%d)%%fname='%s'" % (var_count,var_file), file=f)
         print("load_fields(%d)%%action='%s'" % (var_count,var_action), file=f)

print("")
print("MAS input file section written to: ")
print("")
print(output_dir+"/insert_into_mas_input_file.txt")
print("")


