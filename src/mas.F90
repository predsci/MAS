!#######################################################################
!
!   #################################################################
!   #                                                               #
!   #      _|      _|     _|_|       _|_|_|                         #
!   #      _|_|  _|_|   _|    _|   _|                               #
!   #      _|  _|  _|   _|_|_|_|     _|_|                           #
!   #      _|      _|   _|    _|         _|                         #
!   #      _|      _|   _|    _|   _|_|_|                           #
!   #                                                               #
!   #      MAS: Magnetohydrodynamic Algorithm outside a Sphere      #
!   #                                                               #
!   #      Authors:  Z. Mikic                                       #
!   #                J. Linker                                      #
!   #                R. Lionello                                    #
!   #                P. Riley                                       #
!   #                C. Downs                                       #
!   #                R. Caplan                                      #
!   #                M. Stulajter                                   #
!   #                                                               #
!   #      Predictive Science Inc.                                  #
!   #      San Diego, California, USA 92121                         #
!   #                                                               #
!   #      A code for the study of resistive MHD evolution          #
!   #      in 3D spherical geometry.                                #
!   #                                                               #
!   #################################################################
!
!#######################################################################
! Copyright 2025 Predictive Science Inc.
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!    http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
! implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!#######################################################################
!
!#######################################################################
!
! ****** Averaging macros in 3D.
!
#define AVG(A1,A2,A3,A4) A1(A2,A3,A4)
#define AVGR(A1,A2,A3,A4) (.5_r_typ*(A1(A2,A3,A4)+A1(A2-1,A3,A4)))
#define AVGT(A1,A2,A3,A4) (.5_r_typ*(A1(A2,A3,A4)+A1(A2,A3-1,A4)))
#define AVGP(A1,A2,A3,A4) (.5_r_typ*(A1(A2,A3,A4)+A1(A2,A3,A4-1)))
#define AVGRT(A1,A2,A3,A4) (.25_r_typ*(A1(A2,A3,A4)+A1(A2-1,A3,A4)+\
A1(A2,A3-1,A4)+A1(A2-1,A3-1,A4)))
#define AVGRP(A1,A2,A3,A4) (.25_r_typ*(A1(A2,A3,A4)+A1(A2-1,A3,A4)+\
A1(A2,A3,A4-1)+A1(A2-1,A3,A4-1)))
#define AVGTP(A1,A2,A3,A4) (.25_r_typ*(A1(A2,A3,A4)+A1(A2,A3-1,A4)+\
A1(A2,A3,A4-1)+A1(A2,A3-1,A4-1)))
#define AVGRTP(A1,A2,A3,A4) (.125_r_typ*(A1(A2,A3,A4)+A1(A2-1,A3,A4)+\
A1(A2,A3-1,A4)+A1(A2,A3,A4-1)+A1(A2-1,A3-1,A4)+A1(A2-1,A3,A4-1)+\
A1(A2,A3-1,A4-1)+A1(A2-1,A3-1,A4-1)))
!
! ****** Advection macros in 3D.
!
#define ADVR(A1,A2,A3,A4,A5) (.5_r_typ*((1._r_typ-A5)*A1(A2,A3,A4)+\
(1._r_typ+A5)*A1(A2-1,A3,A4)))
#define ADVT(A1,A2,A3,A4,A5) (.5_r_typ*((1._r_typ-A5)*A1(A2,A3,A4)+\
(1._r_typ+A5)*A1(A2,A3-1,A4)))
#define ADVP(A1,A2,A3,A4,A5) (.5_r_typ*((1._r_typ-A5)*A1(A2,A3,A4)+\
(1._r_typ+A5)*A1(A2,A3,A4-1)))
!
#define ADVCT(A1,A2,A3) (.5_r_typ*((1._r_typ-A3)*A1+(1._r_typ+A3)*A2))
!
! ****** Extrapolation macros in 3D.
!
#define EXTRAPR0(A1,A2,A3,A4) (A1(A2,A3,A4)+(A1(A2,A3,A4)\
-A1(A2+1,A3,A4))*dr(A2-1)*dr_i(A2))
#define EXTRAPR1(A1,A2,A3,A4) (A1(A2,A3,A4)+(A1(A2,A3,A4)\
-A1(A2-1,A3,A4))*dr(A2)*dr_i(A2-1))
#define EXTRAPR0H(A1,A2,A3,A4) (A1(A2,A3,A4)+0.5_r_typ*(A1(A2,A3,A4)\
-A1(A2+1,A3,A4))*dr(A2-1)*dr_i(A2))
#define EXTRAPR1H(A1,A2,A3,A4) (A1(A2,A3,A4)+0.5_r_typ*(A1(A2,A3,A4)\
-A1(A2-1,A3,A4))*dr(A2)*dr_i(A2-1))
!
! ****** Averaging macros in 2D.
!
#define AVG2(A1,A3,A4) A1(A3,A4)
#define AVGT2(A1,A3,A4) (.5_r_typ*(A1(A3,A4)+A1(A3-1,A4)))
#define AVGP2(A1,A3,A4) (.5_r_typ*(A1(A3,A4)+A1(A3,A4-1)))
#define AVGTP2(A1,A3,A4) (.25_r_typ*(A1(A3,A4)+A1(A3-1,A4)+\
A1(A3,A4-1)+A1(A3-1,A4-1)))
!
! ****** Advection macros in 2D.
!
#define ADVT2(A1,A3,A4,A5) (.5_r_typ*((1._r_typ-A5)*A1(A3,A4)+\
(1._r_typ+A5)*A1(A3-1,A4)))
#define ADVP2(A1,A3,A4,A5) (.5_r_typ*((1._r_typ-A5)*A1(A3,A4)+\
(1._r_typ+A5)*A1(A3,A4-1)))
!
!#######################################################################
module ident
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** Code name and version information.
!-----------------------------------------------------------------------
!
      character(*), parameter :: idcode='MAS'
      character(*), parameter :: vers='0.9.7.0'
      character(*), parameter :: update='07/07/2025'
      character(*), parameter :: branch_vers=''
      character(*), parameter :: source='mas.F90'
!
!-----------------------------------------------------------------------
! ****** Machine name and type.
!-----------------------------------------------------------------------
!
      character(512) :: machname=''
      character(512) :: machtype=''
!
!-----------------------------------------------------------------------
! ****** Compiler and flags.
!-----------------------------------------------------------------------
!
      character(1024) :: compiler=''
      character(1024) :: compiler_flags=''
!
!-----------------------------------------------------------------------
! ****** Run ID.
!-----------------------------------------------------------------------
!
      character(512) :: runid
!
end module
!#######################################################################
module number_types
!
!-----------------------------------------------------------------------
! ****** Basic number types.
! ****** This module is used to set the default precision for REALs.
!-----------------------------------------------------------------------
!
      use iso_fortran_env
!
!-----------------------------------------------------------------------
!
      implicit none
!
! ****** Set up the KIND values for the various REALs.
! ****** These can be compiler dependent.
!
      integer, parameter :: KIND_REAL_4=REAL32
      integer, parameter :: KIND_REAL_8=REAL64
!
! ****** KIND values for specifying the precision of REALs.
!
      integer, private, parameter :: r4=KIND_REAL_4
      integer, private, parameter :: r8=KIND_REAL_8
!
! ****** Select the number type for REALs (one of: R4|R8).
!
      integer, parameter :: r_typ=r8
      integer, parameter :: r_typ_sp=r4
!
end module
!#######################################################################
module debug
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** Debugging level.
!-----------------------------------------------------------------------
!
      integer :: idebug=0
!
end module
!#######################################################################
module constants
!
      use number_types
!
      implicit none
!
      real(r_typ), parameter :: pi=3.1415926535897932_r_typ
      real(r_typ), parameter :: sqrtpi=1.77245385090551601644_r_typ
!
end module
!#######################################################################
module globals
!
!-----------------------------------------------------------------------
! ****** Global and local number of mesh points and indices.
!-----------------------------------------------------------------------
!
      implicit none
!
! ****** Local mesh size.
!
      integer :: nr,nrm1,nrm2
      integer :: nt,ntm1,ntm2
      integer :: np,npm1,npm2
!
! ****** Dimensions of arrays on the "main" mesh for which
! ****** normal derivatives are needed (e.g., v).
!
      integer :: nrm
      integer :: ntm
      integer :: npm
!
! ****** Global mesh size.
!
      integer :: nr_g,nrm1_g,nrm2_g
      integer :: nt_g,ntm1_g,ntm2_g
      integer :: np_g,npm1_g,npm2_g
!
! ****** Flag to indicate an axisymmetric run.
!
      logical :: axisymmetric=.false.
!
! ****** Indices of start and end points in the global mesh
! ****** belonging to this processor.
!
      integer :: i0_g,i1_g
      integer :: j0_g,j1_g
      integer :: k0_g,k1_g
!
! ****** Flags to indicate whether this processor has points
! ****** on the physical boundaries.
!
      logical :: rb0,rb1
      logical :: tb0,tb1
!
! ****** Variables to define limits of theta loops for this
! ****** processor.
!
      integer :: jm0,jm1
      integer :: jh0,jh1
!
end module
!#######################################################################
module mesh
!
!-----------------------------------------------------------------------
! ****** Global and local meshes.
!-----------------------------------------------------------------------
!
      use number_types
      use constants
!
      implicit none
!
! ****** Local mesh.
!
      real(r_typ), dimension(:), allocatable, target :: r,rh
      real(r_typ), dimension(:), allocatable, target :: t,th
      real(r_typ), dimension(:), allocatable, target :: p,ph
!
      real(r_typ), dimension(:), allocatable :: dr,drh
      real(r_typ), dimension(:), allocatable :: dt,dth
      real(r_typ), dimension(:), allocatable, target :: dp,dph
!
      real(r_typ), dimension(:), allocatable :: st,ct,sth,cth
      real(r_typ), dimension(:), allocatable :: sp,cp,sph,cph
!
! ****** Inverse quantities (for efficiency).
!
      real(r_typ), dimension(:), allocatable :: r_i,rh_i
      real(r_typ), dimension(:), allocatable :: dr_i,drh_i
      real(r_typ), dimension(:), allocatable :: dt_i,dth_i
      real(r_typ), dimension(:), allocatable :: st_i,sth_i
      real(r_typ), dimension(:), allocatable :: dp_i,dph_i
!
! ****** Expansion factors and inverse of expansion factors.
!
      real(r_typ), dimension(:), allocatable, target :: fl_fac, &
                               fl_fach,fl_fac_i,fl_fach_i,fl_one,fl_oneh
!
! ****** True radial distances, which are different when computing
! ****** along field lines.
!
      real(r_typ), dimension(:), allocatable :: r_true,rh_true, &
      r_true_i,rh_true_i
!
! ****** Global mesh.
!
      real(r_typ), dimension(:), allocatable, target :: r_g,rh_g
      real(r_typ), dimension(:), allocatable, target :: t_g,th_g
      real(r_typ), dimension(:), allocatable, target :: p_g,ph_g
!
      real(r_typ), dimension(:), allocatable :: dr_g,drh_g
      real(r_typ), dimension(:), allocatable :: dt_g,dth_g
      real(r_typ), dimension(:), allocatable :: dp_g,dph_g
!
      real(r_typ), dimension(:), allocatable :: st_g,ct_g,sth_g,cth_g
      real(r_typ), dimension(:), allocatable :: sp_g,cp_g,sph_g,cph_g
!
! ****** Physical mesh size.
!
      real(r_typ), parameter, private :: one=1._r_typ
      real(r_typ), parameter, private :: two=2._r_typ
!
      real(r_typ) :: r0=1._r_typ
      real(r_typ) :: r1=30._r_typ
      real(r_typ), parameter :: t0=0.
      real(r_typ), parameter :: t1=pi
      real(r_typ), parameter :: p0=0.
      real(r_typ), parameter :: p1=two*pi
!
      real(r_typ), parameter :: pl=p1-p0
      real(r_typ), parameter :: pl_i=one/pl
!
! ****** Volume of the domain.
!
      real(r_typ) :: volume
!
! ****** Multiplier for the phi cell size.
! ****** This is used to get the correct behavior for
! ****** 2D (axisymmetric) runs.
!
      real(r_typ) :: dp_mult
!
end module
!#######################################################################
module mpidefs
!
!-----------------------------------------------------------------------
! ****** MPI variables, processor topology, and processor information.
!-----------------------------------------------------------------------
!
      use mpi
!
!-----------------------------------------------------------------------
!
      implicit none
!
! ****** Total number of processors.
!
      integer :: nproc
!
! ****** Total number of processors per node.
!
      integer :: nprocsh
!
! ****** Processor rank of this process in communicator
! ****** MPI_COMM_WORLD.
!
      integer :: iprocw
!
! ****** Processor rank of this process in communicator
! ****** comm_shared.
!
      integer :: iprocsh
!
! ****** Flag to designate that this is the processor with
! ****** rank 0 in communicator MPI_COMM_WORLD.
!
      logical :: iamp0
!
! ****** Communicator over all processors in the Cartesian topology.
!
      integer :: comm_all
!
! ****** Processor rank of this process in communicator
! ****** COMM_ALL.
!
      integer :: iproc
      character(12) :: iproc_str
!
! ****** Processor rank in communicator COMM_ALL for the
! ****** processor that has rank 0 in MPI_COMM_WORLD.
!
      integer :: iproc0
!
! ****** Communicators over all processors in the phi dimension.
!
      integer :: comm_phi
!
! ****** Communicator over all shared processors on the node.
!
      integer :: comm_shared
!
! ****** Communicators over all processors in the theta and phi
! ****** dimensions.
!
      integer :: comm_tp
!
! ****** Communicators over all processors in the r dimension.
!
      integer :: comm_r
!
! ****** Processor rank in communicator COMM_R of the processor
! ****** that contains the lower radial boundary r=R0.
!
      integer :: iproc_rb0
!
! ****** Processor coordinate indices of this process
! ****** in the Cartesian topology.
!
      integer :: iproc_r,iproc_t,iproc_p
!
! ****** Processor coordinate indices of the neighboring
! ****** processors in the Cartesian topology.
!
      integer :: iproc_rm,iproc_rp
      integer :: iproc_tm,iproc_tp
      integer :: iproc_pm,iproc_pp
!
! ****** Number of processors along r, theta, and phi.
!
      integer :: nproc_r,nproc_t,nproc_p
!
! ****** Number of processors in 2D theta-phi plane.
!
      integer :: nproc_tp
!
! ****** Processor coordinate indices in 2D theta-phi plane.
!
      integer :: iproc2d_tp
!
! ****** Number type for REALs to be used in MPI calls.
!
      integer :: ntype_real
!
end module
!#######################################################################
module decomposition_params
!
!-----------------------------------------------------------------------
! ****** Input parameters that define the domain decomposition
! ****** among processors.
!-----------------------------------------------------------------------
!
      implicit none
!
! ****** Number of processors per dimension.
!
      integer, dimension(3) :: nprocs=(/-1,-1,-1/)
!
! ****** Number of mesh points per processor.
!
      integer, parameter :: mx_procs_per_dim=100
      integer, dimension(mx_procs_per_dim) :: mp_r=0
      integer, dimension(mx_procs_per_dim) :: mp_t=0
      integer, dimension(mx_procs_per_dim) :: mp_p=0
!
! ****** Option to perform an "automatic" mesh decomposition.
!
      logical :: auto_decompose=.true.
!
! ****** Mesh sizes for the "automatic" mesh decomposition.
!
      integer :: nr_auto
      integer :: nt_auto
      integer :: np_auto
!
end module
!#######################################################################
module decomposition
!
!-----------------------------------------------------------------------
! ****** Information defining the domain decomposition.
!-----------------------------------------------------------------------
!
      implicit none
!
! ****** Define the structure type for storing the decomposition
! ****** information.
!
      type :: decomp_struct
        integer :: iproc_r
        integer :: iproc_t
        integer :: iproc_p
        integer :: nr
        integer :: nt
        integer :: np
        integer :: i0_g
        integer :: i1_g
        integer :: j0_g
        integer :: j1_g
        integer :: k0_g
        integer :: k1_g
        integer :: iproc_rm
        integer :: iproc_rp
        integer :: iproc_tm
        integer :: iproc_tp
        integer :: iproc_pm
        integer :: iproc_pp
      end type
!
! ****** Define the structure type for mapping local arrays
! ****** into global arrays.
!
      type :: map_struct
        integer :: n
        integer :: i0
        integer :: i1
        integer :: offset
      end type
!
! ****** Define the decomposition information structure.
!
      type(decomp_struct), dimension(:), allocatable :: decomp
!
! ****** Mapping structures for the different mesh types.
!
      type(map_struct), dimension(:), pointer :: map_rh
      type(map_struct), dimension(:), pointer :: map_rm
      type(map_struct), dimension(:), pointer :: map_th
      type(map_struct), dimension(:), pointer :: map_tm
      type(map_struct), dimension(:), pointer :: map_ph
      type(map_struct), dimension(:), pointer :: map_pm
!
      type(map_struct), dimension(:), pointer :: maptp_th
      type(map_struct), dimension(:), pointer :: maptp_tm
      type(map_struct), dimension(:), pointer :: maptp_ph
      type(map_struct), dimension(:), pointer :: maptp_pm
!
end module
!#######################################################################
module meshdef
!
!-----------------------------------------------------------------------
! ****** Variables that define the mesh-point distributions.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      integer, parameter :: nmseg=50
!
      real(r_typ), dimension(nmseg) :: drratio=0.
      real(r_typ), dimension(nmseg) :: dtratio=0.
      real(r_typ), dimension(nmseg) :: dpratio=0.
      real(r_typ), dimension(nmseg) :: rfrac=0.
      real(r_typ), dimension(nmseg) :: tfrac=0.
      real(r_typ), dimension(nmseg) :: pfrac=0.
!
      integer :: nfrmesh=5
      integer :: nftmesh=5
      integer :: nfpmesh=5
!
! ****** Shift for the specification of the phi mesh.
!
      real(r_typ) :: phishift=0.
!
end module
!#######################################################################
module types
!
!-----------------------------------------------------------------------
! ****** Definition of field data types.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Vector on the A mesh.
!
      type :: avec
        real(r_typ), dimension(:,:,:), allocatable :: r !(nrm1,nt,np)
        real(r_typ), dimension(:,:,:), allocatable :: t !(nr,ntm1,np)
        real(r_typ), dimension(:,:,:), allocatable :: p !(nr,nt,npm1)
      end type
!
! ****** Vector on the B mesh.
!
      type :: bvec
        real(r_typ), dimension(:,:,:), allocatable :: r !(nr,ntm1,npm1)
        real(r_typ), dimension(:,:,:), allocatable :: t !(nrm1,nt,npm1)
        real(r_typ), dimension(:,:,:), allocatable :: p !(nrm1,ntm1,np)
      end type
!
! ****** Vector on the v mesh.
!
      type :: vvec
        real(r_typ), dimension(:,:,:), pointer, contiguous :: r !(nrm,nt,np)
        real(r_typ), dimension(:,:,:), pointer, contiguous :: t !(nr,ntm,np)
        real(r_typ), dimension(:,:,:), pointer, contiguous :: p !(nr,nt,npm)
      end type
!
! ****** Vector on the half mesh.
!
      type :: hvec
        real(r_typ), dimension(:,:,:), allocatable :: r  !(nr,nt,np)
        real(r_typ), dimension(:,:,:), allocatable :: t  !(nr,nt,np)
        real(r_typ), dimension(:,:,:), allocatable :: p  !(nr,nt,np)
      end type
!
!-----------------------------------------------------------------------
! ****** Definition of boundary condition data types.
!-----------------------------------------------------------------------
!
! ****** Tangential components of A at the r boundaries.
!
      type :: avec_bctr
        real(r_typ), dimension(:,:), allocatable :: t !(ntm1,np)
        real(r_typ), dimension(:,:), allocatable :: p !(nt,npm1)
      end type
!
! ****** Components of B at the r boundaries.
!
      type :: bvec_bcr
        real(r_typ), dimension(:,:), allocatable :: r !(ntm1,npm1)
        real(r_typ), dimension(:,:), allocatable :: t !(nt,npm1)
        real(r_typ), dimension(:,:), allocatable :: p !(ntm1,np)
      end type
!
! ****** Components of v at the r boundaries.
!
      type :: vvec_bcr
        real(r_typ), dimension(:,:), pointer, contiguous :: r !(nt,np)
        real(r_typ), dimension(:,:), pointer, contiguous :: t !(ntm,np)
        real(r_typ), dimension(:,:), pointer, contiguous :: p !(nt,npm)
        real(r_typ), dimension(:,:), pointer, contiguous :: par !(nt,np)
      end type
!
! ****** Tangential components of A at the boundaries.
!
      type :: avec_bc
        type(avec_bctr) :: r0
        type(avec_bctr) :: r1
      end type
!
! ****** Components of B at the boundaries.
!
      type :: bvec_bc
        type(bvec_bcr) :: r0
        type(bvec_bcr) :: r1
      end type
!
! ****** Components of v at the boundaries.
!
      type :: vvec_bc
        type(vvec_bcr) :: r0
        type(vvec_bcr) :: r1
      end type
!
end module
!#######################################################################
module fields
!
!-----------------------------------------------------------------------
! ****** Storage for the primary fields.
!-----------------------------------------------------------------------
!
      use number_types
      use types
!
      implicit none
!
! ****** Primary fields at the current time step.
!
      type(avec),target :: a
      type(avec),target :: fj
      type(bvec),target :: b
      type(vvec),target :: v
      type(avec),target :: e
      real(r_typ), dimension(:,:,:), target, allocatable :: v_par
!
! ****** (nr,nt,np)
!
      real(r_typ), dimension(:,:,:), target, allocatable :: pres
      real(r_typ), dimension(:,:,:), target, allocatable :: rho
      real(r_typ), dimension(:,:,:), target, allocatable :: temp
      real(r_typ), dimension(:,:,:), target, allocatable :: temp_e
      real(r_typ), dimension(:,:,:), target, allocatable :: temp_e0
      real(r_typ), dimension(:,:,:), target, allocatable :: temp_p
      real(r_typ), dimension(:,:,:), target, allocatable :: temp_p0
      real(r_typ), dimension(:,:,:), target, allocatable :: heat
      real(r_typ), dimension(:,:,:), target, allocatable :: ep
      real(r_typ), dimension(:,:,:), target, allocatable :: em
      real(r_typ), dimension(:,:,:), target, allocatable :: rhoold
      real(r_typ), dimension(:,:,:), target, allocatable :: zp
      real(r_typ), dimension(:,:,:), target, allocatable :: zm
!
! ****** Fractional fcs (nr,nt,np,ncs)
!
      real(r_typ), dimension(:,:,:,:), target, allocatable :: fcs
      real(r_typ), dimension(:,:,:), target, allocatable :: fcsr0
      real(r_typ), dimension(:,:,:), target, allocatable :: fcsr0_ip_g, &
                                                fcsr0_ip0_g,fcsr0_ip1_g
!
!-----------------------------------------------------------------------
! ****** Radial limiter for WTD zw amplitude
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: zwlimit !(nr)
!
! ****** Velocity at the previous time step.
!
      type(vvec),target :: v_old
      real(r_typ), dimension(:,:,:), target, allocatable :: v_par_old
!
!-----------------------------------------------------------------------
! ****** Density profile for limiting the minimum rho on a local basis
!-----------------------------------------------------------------------
      real(r_typ), dimension(:,:,:), target, allocatable :: rho_limit
      !(nr,nt,np)
      real(r_typ), dimension(:,:,:), target, allocatable :: rho_temp
      !(nr,nt,np)
!
!-----------------------------------------------------------------------
! ****** Spatial profiles of viscosity and resistivity. (nrm,ntm,npm)
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), target, allocatable :: vis_prof
      real(r_typ), dimension(:,:,:), target, allocatable :: eta_prof
!
      real(r_typ), dimension(:,:,:), target, allocatable :: vis
      real(r_typ), dimension(:,:,:), target, allocatable :: eta
      real(r_typ), dimension(:,:,:), target, allocatable :: etacel
!
      real(r_typ), dimension(:,:,:), target, allocatable :: eta_av_ar
      real(r_typ), dimension(:,:,:), target, allocatable :: eta_av_at
      real(r_typ), dimension(:,:,:), target, allocatable :: eta_av_ap
!
!-----------------------------------------------------------------------
! ****** Spatial profile and BG vector potential for helicity pumping.
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), target, allocatable :: hpump_prof
      type(avec),target :: a_hpump
!
!-----------------------------------------------------------------------
! ****** Semi-implicit coefficient. (nrm,ntm,npm)
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), target, allocatable :: sifac
!
!-----------------------------------------------------------------------
! ****** Boundary conditions.
!-----------------------------------------------------------------------
!
      type(avec_bc) :: ab
      type(vvec_bc) :: vb
!
!-----------------------------------------------------------------------
! ****** Density and pressure at r=R0.
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:), target, allocatable :: rho0i !(nt,np)
      real(r_typ), dimension(:,:), target, allocatable :: rho0f !(nt,np)
      real(r_typ), dimension(:,:), target, allocatable :: rho0v !(nt,np)
      real(r_typ), dimension(:,:), target, allocatable :: pr0i  !(nt,np)
      real(r_typ), dimension(:,:), target, allocatable :: pr0f  !(nt,np)
      real(r_typ), dimension(:,:), target, allocatable :: pr0v  !(nt,np)
!
!-----------------------------------------------------------------------
! ****** Boundary condition for the temperature
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:), target, allocatable :: tr0v !(nt,np)
      real(r_typ), dimension(:,:), target, allocatable :: tr1v !(nt,np)
      real(r_typ), dimension(:,:), pointer :: tr1v_p !(nt,np)
!
!-----------------------------------------------------------------------
! ****** Boundary condition for the Alfven wave pressure
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:), target, allocatable :: embcr0re, &
       embcr1re,epbcr0re,epbcr1re !(nt,np)
      real(r_typ), dimension(:,:), target, allocatable :: zmbcr0re, &
       zmbcr1re,zpbcr0re,zpbcr1re !(nt,np)
!
!-----------------------------------------------------------------------
! ****** Parallel thermal conductivity and collisionless t.c. arrays.
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), allocatable :: fkrr, &
                               fktt,fkpp,fkrt,fkrp,fktp,dqdt !(nr,nt,np)
!
      real(r_typ), dimension(:), allocatable :: prof_nocoll!(nr)
      real(r_typ), dimension(:), allocatable :: prof_coll!(nr)
!
!-----------------------------------------------------------------------
! ****** Kappa mask.
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), allocatable :: kappa_mask
!
      type(vvec) :: vmoxrbb
!
!-----------------------------------------------------------------------
! ****** Boundary potential initial condition storage.
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:), target, allocatable :: psi_old
      real(r_typ), dimension(:,:), target, allocatable :: psi_n
      real(r_typ), dimension(:,:), target, allocatable :: psi_rn
      real(r_typ), dimension(:,:), target, allocatable :: psi_rnp1
      real(r_typ), dimension(:,:), target, allocatable :: phi_old
!
!-----------------------------------------------------------------------
! ****** Array to store the pw force vectors
!-----------------------------------------------------------------------
!
      type(vvec) :: fpw
!
!-----------------------------------------------------------------------
! ****** Arrays for radial pw cutoff.
!-----------------------------------------------------------------------
!
      real(r_typ),dimension(:), allocatable :: pw_rcut_main
      real(r_typ),dimension(:), allocatable :: pw_rcut_half
!
end module
!#######################################################################
module bhat_storage
!
      use number_types
!
      implicit none
!
! ****** Flag to indicate whether a b-hat mask is being used.
!
      logical :: use_bhat_mask=.false.
!
!-----------------------------------------------------------------------
! ****** b-hat mask.
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), target, allocatable :: bhat_mask
!
!-----------------------------------------------------------------------
! ****** b-hat vector on the HHH mesh.
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), target, allocatable :: bhat_r
      real(r_typ), dimension(:,:,:), target, allocatable :: bhat_t
      real(r_typ), dimension(:,:,:), target, allocatable :: bhat_p
!
end module
!#######################################################################
module upwind_resistivity
!
!-----------------------------------------------------------------------
! ****** Storage for the upwind resistivity that is used in the
! ****** implicit solve for A.
!-----------------------------------------------------------------------
!
      use number_types
      use types
!
      implicit none
!
      type :: uwres
        real(r_typ), dimension(:,:,:), allocatable :: rt !(nrm1,nt,np)
        real(r_typ), dimension(:,:,:), allocatable :: rp !(nrm1,nt,np)
        real(r_typ), dimension(:,:,:), allocatable :: tr !(nr,ntm1,np)
        real(r_typ), dimension(:,:,:), allocatable :: tp !(nr,ntm1,np)
        real(r_typ), dimension(:,:,:), allocatable :: pr !(nr,nt,npm1)
        real(r_typ), dimension(:,:,:), allocatable :: pt !(nr,nt,npm1)
        real(r_typ), dimension(:,:,:), allocatable :: i!(nrm1,ntm1,npm1)
      end type
!
      type(uwres),target :: eta_uw
!
end module
!#######################################################################
module potential_field
!
!-----------------------------------------------------------------------
! ****** Storage for the potential field solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Potential at the lower radial boundary r=R0.
!
      real(r_typ), dimension(:,:), allocatable :: psi_r0
!
! ****** Factors needed to apply the BCs at r=R0 and r=R1.
!
      real(r_typ) :: psi_bcfac0_n
      real(r_typ) :: psi_bcfac0_v
      real(r_typ) :: psi_bcfac1_n
!
! ****** Source-surface radius.
!
      real(r_typ) :: r_ss=-1._r_typ
!
end module
!#######################################################################
module characteristics
!
!-----------------------------------------------------------------------
! ****** Characteristic boundary conditions.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Values at the upper radial boundary.
!
      real(r_typ), dimension(:,:), allocatable :: cbc1_ub     !(nt,np)
      real(r_typ), dimension(:,:), allocatable :: cbc1_rhob   !(nt,np)
      real(r_typ), dimension(:,:), allocatable :: cbc1_pb     !(nt,np)
!
end module
!#######################################################################
module profile_def
!
!-----------------------------------------------------------------------
! ****** Definition of a three-value profile structure.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Definite a profile structure.
!
      type :: profile
        logical :: active=.false.
        real(r_typ) :: f(3)=1._r_typ
        real(r_typ) :: x(2)=(/-1.e20_r_typ,1.e20_r_typ/)
        real(r_typ) :: w(2)=1._r_typ
      end type
!
! ****** Profile properties:
!
! ****** Consider the value of the profile for argument value X.
!
! ****** The profile value goes from F(1) to F(2) as X increases
! ****** from below X(1) to above it, in a width W(1).  The profile
! ****** value changes from F(2) to F(3) as X increases from below
! ****** X(2) to above it, in a width W(2).  The values X(1) and X(2)
! ****** are intended to be monotonically increasing.
!
! ****** If a profile has not been activated (ACTIVE=.false.), its
! ****** value is 1. for all argument values.
!
! ****** To get step-like transitions at X(1) and/or X(2),
! ****** use widths W(1) and/or W(2) equal to 0.
!
! ****** The default values are ACTIVE=.false., F(:)=1.,
! ****** X(1)=-1e20, X(2)=1e20, and W(:)=1.
!
! ****** These defaults allow one to specify a (smooth) step-on
! ****** or step-off function in abbreviated form by only setting
! ****** X(1), W(1), F(1), and F(2).
!
! ****** For example, a profile that turns on at x=1.5, with a
! ****** width=.2, would be specified as:
! ******
! ******     X=1.5, W=.2, F=0.,1.
!
! ****** A profile that turns off at x=10, with a width=.5,
! ****** would be specified as:
! ******
! ******     X=10., W=.5, F=1.,0.
!
! ****** A profile that turns on at x=2, with a width=.1,
! ****** and turns off at x=5, with a width=.2, would be
! ****** specified as:
! ******
! ******     X=2.,5., W=.1,.2, F=0.,1.,0.
!
end module
!#######################################################################
module dissipation_profiles
!
!-----------------------------------------------------------------------
! ****** Variables to control viscosity and resistivity.
!-----------------------------------------------------------------------
!
      use number_types
      use profile_def
!
      implicit none
!
      integer, parameter :: mxnodes=20
!
!-----------------------------------------------------------------------
! ****** Viscosity spatial profile.
!-----------------------------------------------------------------------
!
      character(32) :: visc_profile='UNIFORM'
      real(r_typ) :: visc=1.e-5_r_typ
      real(r_typ) :: visc_low=1.e-5_r_typ
      real(r_typ) :: visc_high=1.e-5_r_typ
      real(r_typ) :: r_visc_crit=5._r_typ
      real(r_typ) :: dr_visc_crit=0.1_r_typ
      real(r_typ) :: visc_fac_0=1._r_typ
      real(r_typ) :: visc_fac_1=1._r_typ
      real(r_typ) :: visc_bg=0.
!
      type(profile) :: visc_profile_r
      character(256) :: visc_profile_tp_file='NO_DEFAULT'
      character(256) :: visc_profile_file='NO_DEFAULT'
!
      integer :: visc_subcycles=1
      integer :: visc_subcycles_max=60
      logical :: visc_auto_subcycle=.false.
      logical :: visc_rho_outside=.false.
!
!-----------------------------------------------------------------------
! ****** Resistivity spatial profile.
!-----------------------------------------------------------------------
!
      integer :: ifideal=1
      real(r_typ) :: slund=1.e5_r_typ
      real(r_typ) :: eta_bg=0.
!
      logical :: dynamic_eta=.false.
      character(32) :: eta_profile='UNIFORM'
      real(r_typ) :: eta_fac_0=1._r_typ
      real(r_typ) :: eta_fac_1=1._r_typ
      real(r_typ) :: r_eta_crit=3._r_typ
      real(r_typ) :: dr_eta_crit=.2_r_typ
      real(r_typ) :: slund_low=1.e5_r_typ
      real(r_typ) :: slund_high=1.e5_r_typ
      real(r_typ) :: phi_0=0., phi_1=0.
      real(r_typ) :: theta_0=0., theta_1=0.
!
      type(profile) :: eta_profile_r
      character(256) :: eta_profile_tp_file='NO_DEFAULT'
      character(256) :: eta_profile_file='NO_DEFAULT'
!
!-----------------------------------------------------------------------
! ****** Cell viscosity.
!-----------------------------------------------------------------------
!
      real(r_typ) :: recell=0.
      real(r_typ) :: recell_viscmax=1.e20_r_typ
      real(r_typ) :: recell_facx=1._r_typ
      real(r_typ) :: recell_facy=1._r_typ
!
!-----------------------------------------------------------------------
! ****** Cell resistivity.
!-----------------------------------------------------------------------
!
      real(r_typ) :: rmcell=2._r_typ
      real(r_typ) :: rmcell_etamax=1.e20_r_typ
!
!-----------------------------------------------------------------------
! ****** Diagnostic values.
!-----------------------------------------------------------------------
!
      real(r_typ) :: vcmin
      real(r_typ) :: vcmax
      real(r_typ) :: ecmin
      real(r_typ) :: ecmax
!
!-----------------------------------------------------------------------
! ****** Resistivity and viscosity time-profile factors.
!-----------------------------------------------------------------------
!
      real(r_typ) :: eta_factor
      real(r_typ) :: vis_factor
!
end module
!#######################################################################
module helicity_pumping_params
!
!-----------------------------------------------------------------------
! ****** Variables to control the helicity pumping options & profiles.
!-----------------------------------------------------------------------
!
      use number_types
      use profile_def
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** Static Spatial profile.
!-----------------------------------------------------------------------
!
      integer, parameter :: mxnodes=20
!
      character(32) :: hpump_profile='UNIFORM'
      real(r_typ) :: hpump_constant=1.e-5_r_typ
      real(r_typ) :: r_hpump_crit=5._r_typ
      real(r_typ) :: dr_hpump_crit=0.1_r_typ
      real(r_typ) :: hpump_fac_0=1._r_typ
      real(r_typ) :: hpump_fac_1=1._r_typ
!
      type(profile) :: hpump_profile_r
      character(256) :: hpump_profile_tp_file='NO_DEFAULT'
      character(256) :: hpump_profile_file='NO_DEFAULT'
!
end module
!
!#######################################################################
module time_profiles
!
      use number_types
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** Time profiles.
!-----------------------------------------------------------------------
!
! ****** Maximum number of time profiles that can be specified.
! ****** It does not make sense to specify a number here that is
! ****** larger than MX_TP_VARS.
!
      integer, parameter :: mx_tp_profs=27
!
! ****** Maximum number of nodes in a time profile.
!
      integer, parameter :: mx_tp_nodes=5000
!
! ****** Number of time-profile-controlled variables.
! ****** This must match the number of identifiers declared below.
!
      integer, parameter :: mx_tp_vars=27
!
! ****** Identifiers for time-profile-controlled variables.
! ****** These indentifiers must match the names specified in
! ****** TP_VARS(:)%NAME below in their order.
!
      integer, parameter :: TP_INDEX_ETA       =1
      integer, parameter :: TP_INDEX_VISC      =2
      integer, parameter :: TP_INDEX_V0        =3
      integer, parameter :: TP_INDEX_EFLUX_PSI =4
      integer, parameter :: TP_INDEX_EFLUX_PHI =5
      integer, parameter :: TP_INDEX_FLOW_NORM =6
      integer, parameter :: TP_INDEX_FLOW_TRANS=7
      integer, parameter :: TP_INDEX_ETA_PHOT  =8
      integer, parameter :: TP_INDEX_PW        =9
      integer, parameter :: TP_INDEX_EFLUX_VR =10
      integer, parameter :: TP_INDEX_EFLUX_BR =11
      integer, parameter :: TP_INDEX_EDRIVE_E0=12
      integer, parameter :: TP_INDEX_EDRIVE_ER=13
      integer, parameter :: TP_INDEX_EDRIVE_ET=14
      integer, parameter :: TP_INDEX_EDRIVE_EP=15
      integer, parameter :: TP_INDEX_EDRIVE_VR=16
      integer, parameter :: TP_INDEX_EDRIVE_VT=17
      integer, parameter :: TP_INDEX_EDRIVE_VP=18
      integer, parameter :: TP_INDEX_RHO_LIMIT=19
      integer, parameter :: TP_INDEX_IO_DUMP_3D=20
      integer, parameter :: TP_INDEX_IO_DUMP_TRACERS=21
      integer, parameter :: TP_INDEX_IO_DUMP_SLICES=22
      integer, parameter :: TP_INDEX_HELICITY_PUMPING=23
      integer, parameter :: TP_INDEX_OHMIC    =24
      integer, parameter :: TP_INDEX_ZW_HEAT  =25
      integer, parameter :: TP_INDEX_ZW_PRES  =26
      integer, parameter :: TP_INDEX_TDC_PHI  =27
!
! ****** Definition of a time profile structure.
!
      type :: tp_profile_struct
        real(r_typ), dimension(mx_tp_nodes) :: t
        real(r_typ), dimension(mx_tp_nodes) :: f
        character(256), dimension(mx_tp_nodes) :: filename
        character(24), dimension(mx_tp_vars) :: vars
        logical, dimension(mx_tp_nodes) :: on
        integer :: nodes
        integer :: nvars
        real(r_typ) :: value
      end type
!
! ****** Definition of a time-profile-controlled variable structure.
!
      type :: tp_variable
        character(24) :: name
        integer :: index
        real(r_typ) :: value
      end type
!
      integer, private :: i,j
      real(r_typ), parameter, private :: one=1._r_typ
!
! ****** Storage for the time-profile-controlled variables.
!
      type(tp_variable), dimension(mx_tp_vars) :: tp_vars
!
! ****** Initialization of the time-profile-controlled variables.
!
      data tp_vars(TP_INDEX_ETA  )%name/'eta'/
      data tp_vars(TP_INDEX_VISC )%name/'visc'/
      data tp_vars(TP_INDEX_V0   )%name/'v0'/
      data tp_vars(TP_INDEX_EFLUX_PSI)%name/'eflux_psi_e0'/
      data tp_vars(TP_INDEX_EFLUX_PHI)%name/'eflux_phi_e0'/
      data tp_vars(TP_INDEX_FLOW_NORM)%name/'flow_norm_factor'/
      data tp_vars(TP_INDEX_FLOW_TRANS)%name/'flow_trans_factor'/
      data tp_vars(TP_INDEX_ETA_PHOT)%name/'eta_photosphere'/
      data tp_vars(TP_INDEX_PW)%name/'pw0_factor'/
      data tp_vars(TP_INDEX_EFLUX_VR)%name/'eflux_vr'/
      data tp_vars(TP_INDEX_EFLUX_BR)%name/'eflux_br'/
      data tp_vars(TP_INDEX_EDRIVE_E0)%name/'edrive_e0'/
      data tp_vars(TP_INDEX_EDRIVE_ER)%name/'edrive_er'/
      data tp_vars(TP_INDEX_EDRIVE_ET)%name/'edrive_et'/
      data tp_vars(TP_INDEX_EDRIVE_EP)%name/'edrive_ep'/
      data tp_vars(TP_INDEX_EDRIVE_VR)%name/'edrive_vr'/
      data tp_vars(TP_INDEX_EDRIVE_VT)%name/'edrive_vt'/
      data tp_vars(TP_INDEX_EDRIVE_VP)%name/'edrive_vp'/
      data tp_vars(TP_INDEX_RHO_LIMIT)%name/'rho_limit'/
      data tp_vars(TP_INDEX_IO_DUMP_3D)%name/'io_dump_3d'/
      data tp_vars(TP_INDEX_IO_DUMP_TRACERS)%name/'io_dump_tracers'/
      data tp_vars(TP_INDEX_IO_DUMP_SLICES)%name/'io_dump_slices'/
      data tp_vars(TP_INDEX_HELICITY_PUMPING)%name/'helicity_pumping'/
      data tp_vars(TP_INDEX_OHMIC)%name/'ohmic_heating_factor'/
      data tp_vars(TP_INDEX_ZW_HEAT)%name/'zw_heat_factor'/
      data tp_vars(TP_INDEX_ZW_PRES)%name/'zw_pressure_factor'/
      data tp_vars(TP_INDEX_TDC_PHI)%name/'tdc_phi'/
!
      data (tp_vars(i)%index,i=1,mx_tp_vars)/mx_tp_vars*0/
      data (tp_vars(i)%value,i=1,mx_tp_vars)/mx_tp_vars*one/
!
! ****** Storage for the time profiles.
!
      type(tp_profile_struct), dimension(mx_tp_profs) :: tprofile
!
! ****** Initialization of the time profiles.
!
      integer, parameter, private :: nd=mx_tp_profs*mx_tp_nodes
      integer, parameter, private :: nv=mx_tp_profs*mx_tp_vars
!
      real(r_typ), parameter :: NULL_VALUE_TP=-1._r_typ
!
      data ((tprofile(i)%t(j),j=1,mx_tp_nodes),i=1,mx_tp_profs) &
           /nd*NULL_VALUE_TP/
      data ((tprofile(i)%f(j),j=1,mx_tp_nodes),i=1,mx_tp_profs) &
           /nd*one/
      data ((tprofile(i)%vars(j),j=1,mx_tp_vars),i=1,mx_tp_profs) &
           /nv*' '/
      data ((tprofile(i)%filename(j),j=1,mx_tp_nodes),i=1,mx_tp_profs) &
           /nd*' '/
      data ((tprofile(i)%on(j),j=1,mx_tp_nodes),i=1,mx_tp_profs) &
           /nd*.true./
      data (tprofile(i)%nodes,i=1,mx_tp_profs) &
           /mx_tp_profs*0/
      data (tprofile(i)%nvars,i=1,mx_tp_profs) &
           /mx_tp_profs*0/
      data (tprofile(i)%value,i=1,mx_tp_profs) &
           /mx_tp_profs*one/
!
end module
!#######################################################################
module cgcom
!
      use number_types
      use types
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** CG field solver parameters.
!-----------------------------------------------------------------------
!
      integer :: ifprec_t=3
      integer :: ifprec_v=3
      integer :: ifprec_a=1
      integer :: ifprec_pot2d=3
      integer :: ifprec_pot3d=1
      integer :: ifprec_divb=3
      logical :: ifprec_32=.false.
!
      integer :: ncgmax=100000
      integer :: ncghist=0
!
!-----------------------------------------------------------------------
! ****** CG field solver variables.
!-----------------------------------------------------------------------
!
      integer     :: ncg
      real(r_typ) :: epsn
      real(r_typ) :: bnrm,rnrm
      real(r_typ) :: epscg_desired
!
!-----------------------------------------------------------------------
! ****** Definition of solve types.
!-----------------------------------------------------------------------
!
      integer, parameter :: ST_A     =1
      integer, parameter :: ST_V     =2
      integer, parameter :: ST_POT2D =3
      integer, parameter :: ST_POT3D =4
      integer, parameter :: ST_T     =5
      integer, parameter :: ST_POT2DH=6
      integer, parameter :: ST_V_PAR =7
      integer, parameter :: ST_DIVB  =8
!
!-----------------------------------------------------------------------
! ****** Definition of equation types.
!-----------------------------------------------------------------------
!
      integer, parameter :: EQ_SI_PREDICTOR =1
      integer, parameter :: EQ_SI_CORRECTOR =2
      integer, parameter :: EQ_A            =3
      integer, parameter :: EQ_VISC         =4
      integer, parameter :: EQ_POT2D        =5
      integer, parameter :: EQ_POT3D        =6
      integer, parameter :: EQ_TE           =7
      integer, parameter :: EQ_TP           =8
      integer, parameter :: EQ_POT2DH       =9
      integer, parameter :: EQ_POT2D_NEWFLUX=10
      integer, parameter :: EQ_DIVB         =11
!
!-----------------------------------------------------------------------
! ****** Size of current 1D CG vectors.
!-----------------------------------------------------------------------
!
      integer :: N_CG
!
!-----------------------------------------------------------------------
! ****** Scratch space for the CG iteration vectors.
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(:), allocatable :: p_cg
      real(r_typ_sp), dimension(:), allocatable :: p_cg_sp
      real(r_typ),    dimension(:), allocatable :: ap_cg
      real(r_typ_sp), dimension(:), allocatable :: ap_cg_sp
!
!-----------------------------------------------------------------------
! ****** Scratch storage for use in ax.
!-----------------------------------------------------------------------
!
      type(vvec) :: ps_v
      type(avec) :: ps_a
      real(r_typ), dimension(:,:,:), allocatable :: ps_v_par
      real(r_typ), dimension(:,:,:), allocatable :: ps_t
      real(r_typ), dimension(:,:,:), allocatable :: ps_pot3d
      real(r_typ), dimension(:,:), allocatable :: ps_pot2d
      real(r_typ), dimension(:,:), allocatable :: ps_pot2dh
      real(r_typ), dimension(:,:,:), allocatable :: ps_divb
!
!-----------------------------------------------------------------------
! ****** Current solve type.
!-----------------------------------------------------------------------
!
      integer :: solve_type
!
!-----------------------------------------------------------------------
! ****** Equation being solved.
!-----------------------------------------------------------------------
!
      integer :: equation_solved
!
!-----------------------------------------------------------------------
! ****** CG field solver counters.
!-----------------------------------------------------------------------
!
      integer :: nsolves_a=0
      integer :: nsolves_si_p=0
      integer :: nsolves_si_c=0
      integer :: nsolves_visc=0
      integer :: nsolves_pot2d=0
      integer :: nsolves_pot2d_newflux=0
      integer :: nsolves_pot2dh=0
      integer :: nsolves_pot3d=0
      integer :: nsolves_te=0
      integer :: nsolves_tp=0
      integer :: nsolves_divb=0
      integer :: ntotal_a=0
      integer :: ntotal_si_p=0
      integer :: ntotal_si_c=0
      integer :: ntotal_visc=0
      integer :: ntotal_pot2d=0
      integer :: ntotal_pot2d_newflux=0
      integer :: ntotal_pot2dh=0
      integer :: ntotal_pot3d=0
      integer :: ntotal_te=0
      integer :: ntotal_tp=0
      integer :: ntotal_divb=0
!
!-----------------------------------------------------------------------
! ****** Type definition for CG solver vectors.
!-----------------------------------------------------------------------
!
      type :: cg_3d
        real(r_typ), dimension(:,:,:), pointer, contiguous :: f
      end type
!
end module
!#######################################################################
module matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the matrix for the 2D potential field solve
! ****** at the lower radial boundary.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ), dimension(:,:,:), allocatable :: a_dia
!
      real(r_typ),    dimension(:), allocatable :: a_dia_i
      real(r_typ_sp), dimension(:), allocatable :: a_dia_i_sp
!
      integer, dimension(5) :: a_dia_offsets
!
      integer :: N_cgvec,M_nnz,j0
!
      real(r_typ),    dimension(:), allocatable :: a_csr
      real(r_typ),    dimension(:), allocatable :: lu_csr
      real(r_typ_sp), dimension(:), allocatable :: lu_csr_sp
      real(r_typ),    dimension(:), allocatable :: a_csr_d
      real(r_typ_sp), dimension(:), allocatable :: a_csr_d_sp
      integer, dimension(:), allocatable :: lu_csr_ja
      integer, dimension(:), allocatable :: a_csr_ia
      integer, dimension(:), allocatable :: a_csr_ja
      integer, dimension(:), allocatable :: a_N1
      integer, dimension(:), allocatable :: a_N2
      integer, dimension(:), allocatable :: a_csr_dptr
end module
!#######################################################################
module matrix_storage_pot2dh_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the matrix for the 2D potential field solve
! ****** on the half mesh at the lower radial boundary.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ), dimension(:,:,:), allocatable :: a_dia
!
      real(r_typ),    dimension(:), allocatable :: a_dia_i
      real(r_typ_sp), dimension(:), allocatable :: a_dia_i_sp
!
      integer, dimension(5) :: a_dia_offsets
!
      integer :: N_cgvec,M_nnz
!
      real(r_typ),    dimension(:), allocatable :: a_csr
      real(r_typ),    dimension(:), allocatable :: lu_csr
      real(r_typ_sp), dimension(:), allocatable :: lu_csr_sp
      real(r_typ),    dimension(:), allocatable :: a_csr_d
      real(r_typ_sp), dimension(:), allocatable :: a_csr_d_sp
      integer, dimension(:), allocatable :: lu_csr_ja
      integer, dimension(:), allocatable :: a_csr_ia
      integer, dimension(:), allocatable :: a_csr_ja
      integer, dimension(:), allocatable :: a_N1
      integer, dimension(:), allocatable :: a_N2
      integer, dimension(:), allocatable :: a_csr_dptr
!
end module
!#######################################################################
module matrix_storage_pot3d_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the 3D potential field solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      integer :: j0,j1
!
      real(r_typ), dimension(:,:,:,:), allocatable :: a_dia
!
      real(r_typ), dimension(:,:,:), allocatable :: a000
      real(r_typ), dimension(:,:,:), allocatable :: ap00
      real(r_typ), dimension(:,:,:), allocatable :: a0p0
      real(r_typ), dimension(:,:,:), allocatable :: a00p
!
      real(r_typ), dimension(:), allocatable :: a_dia_i
!
      integer, dimension(7) :: a_dia_offsets
!
      integer :: N_cgvec,M_nnz
!
      real(r_typ), dimension(:), allocatable :: a_csr
      real(r_typ), dimension(:), allocatable :: lu_csr
      real(r_typ), dimension(:), allocatable :: a_csr_d
      integer, dimension(:), allocatable :: lu_csr_ja
      integer, dimension(:), allocatable :: a_csr_ia
      integer, dimension(:), allocatable :: a_csr_ja
      integer, dimension(:), allocatable :: a_N1
      integer, dimension(:), allocatable :: a_N2
      integer, dimension(:), allocatable :: a_csr_dpt
!
end module
!#######################################################################
module matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the 3D divergence cleaning solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      integer :: i0
!
      real(r_typ), dimension(:,:,:,:), allocatable :: a_dia
      real(r_typ),    dimension(:),    allocatable :: a_dia_i
      real(r_typ_sp), dimension(:),    allocatable :: a_dia_i_sp
!
      integer,     dimension(7) :: a_dia_offsets
!
      integer :: M_nnz, N_cgvec
!
      real(r_typ),    dimension(:), allocatable :: a_csr
      real(r_typ),    dimension(:), allocatable :: lu_csr
      real(r_typ_sp), dimension(:), allocatable :: lu_csr_sp
      real(r_typ),    dimension(:), allocatable :: a_csr_d
      real(r_typ_sp), dimension(:), allocatable :: a_csr_d_sp
      integer, dimension(:), allocatable :: lu_csr_ja
      integer, dimension(:), allocatable :: a_csr_ia
      integer, dimension(:), allocatable :: a_csr_ja
      integer, dimension(:), allocatable :: a_N1
      integer, dimension(:), allocatable :: a_N2
      integer, dimension(:), allocatable :: a_csr_dptr
!
end module
!#######################################################################
module matrix_storage_a_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the a solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ), dimension(:), allocatable :: a_dia_i
!
      integer :: N_cgvec,N_ar,N_at,N_ap
!
end module
!#######################################################################
module matrix_storage_v_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the matrix for the v solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ), dimension(:,:,:,:), allocatable :: a_r
      real(r_typ), dimension(:,:,:,:), allocatable :: a_t
      real(r_typ), dimension(:,:,:,:), allocatable :: a_p
      real(r_typ),    dimension(:), allocatable :: a_dia_i
      real(r_typ_sp), dimension(:), allocatable :: a_dia_i_sp
!
      integer, dimension(15) :: a_vr_offsets
      integer, dimension(15) :: a_vt_offsets
      integer, dimension(15) :: a_vp_offsets
!
      integer :: N_vr,N_vt,N_vp,N_cgvec,M_nzz
!
      real(r_typ),    dimension(:), allocatable :: a_csr
      real(r_typ),    dimension(:), allocatable :: lu_csr
      real(r_typ_sp), dimension(:), allocatable :: lu_csr_sp
      real(r_typ),    dimension(:), allocatable :: a_csr_d
      real(r_typ_sp), dimension(:), allocatable :: a_csr_d_sp
      integer, dimension(:), allocatable :: lu_csr_ja
      integer, dimension(:), allocatable :: a_csr_ia
      integer, dimension(:), allocatable :: a_csr_ja
      integer, dimension(:), allocatable :: a_N1
      integer, dimension(:), allocatable :: a_N2
      integer, dimension(:), allocatable :: a_csr_dptr
!
end module
!#######################################################################
module matrix_storage_v_par_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the matrix for the parallel flow solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ), dimension(:,:,:,:), allocatable :: a_dia
      real(r_typ),    dimension(:), allocatable :: a_dia_i
      real(r_typ_sp), dimension(:), allocatable :: a_dia_i_sp
!
      integer,     dimension(7) :: a_dia_offsets
!
      integer :: M_nnz, N_cgvec
!
      real(r_typ),    dimension(:), allocatable :: a_csr
      real(r_typ),    dimension(:), allocatable :: lu_csr
      real(r_typ_sp), dimension(:), allocatable :: lu_csr_sp
      real(r_typ),    dimension(:), allocatable :: a_csr_d
      real(r_typ_sp), dimension(:), allocatable :: a_csr_d_sp
      integer, dimension(:), allocatable :: lu_csr_ja
      integer, dimension(:), allocatable :: a_csr_ia
      integer, dimension(:), allocatable :: a_csr_ja
      integer, dimension(:), allocatable :: a_N1
      integer, dimension(:), allocatable :: a_N2
      integer, dimension(:), allocatable :: a_csr_dptr
!
end module
!#######################################################################
module matrix_storage_t_solve
!
!-----------------------------------------------------------------------
! ****** Storage for the matrix for the thermal conduction solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ), dimension(:,:,:,:), allocatable :: a_dia
      real(r_typ),    dimension(:), allocatable :: a_dia_i
      real(r_typ_sp), dimension(:), allocatable :: a_dia_i_sp
!
      integer,     dimension(19) :: a_dia_offsets
!
      integer :: M_nnz, N_cgvec
!
      real(r_typ),    dimension(:), allocatable :: a_csr
      real(r_typ),    dimension(:), allocatable :: lu_csr
      real(r_typ_sp), dimension(:), allocatable :: lu_csr_sp
      real(r_typ),    dimension(:), allocatable :: a_csr_d
      real(r_typ_sp), dimension(:), allocatable :: a_csr_d_sp
      integer, dimension(:), allocatable :: lu_csr_ja
      integer, dimension(:), allocatable :: a_csr_ia
      integer, dimension(:), allocatable :: a_csr_ja
      integer, dimension(:), allocatable :: a_N1
      integer, dimension(:), allocatable :: a_N2
      integer, dimension(:), allocatable :: a_csr_dptr
end module
!#######################################################################
module sts
!
!-----------------------------------------------------------------------
! ****** Parameters and arrays used for super time-stepping method.
!-----------------------------------------------------------------------
!
      use number_types
      use types
!
      implicit none
!
      logical :: use_sts_tc=.false.
      logical :: use_exp_tc=.false.
!
      logical :: use_sts_visc=.false.
      logical :: use_exp_visc=.false.
!
      integer :: sts_type=3
!
      integer(8) :: sts_s
!
      real(r_typ), dimension(:), allocatable :: sts_uj
      real(r_typ), dimension(:), allocatable :: sts_vj
      real(r_typ), dimension(:), allocatable :: sts_ubj
      real(r_typ), dimension(:), allocatable :: sts_gj
      real(r_typ), dimension(:), allocatable :: sts_b
!
      real(r_typ), dimension(:), allocatable :: u0
      real(r_typ), dimension(:), allocatable :: dty0
      real(r_typ), dimension(:), allocatable :: ykm1
      real(r_typ), dimension(:), allocatable :: ukm1
      real(r_typ), dimension(:), allocatable :: ukm2
!
end module
!#######################################################################
module timing
!
!-----------------------------------------------------------------------
! ****** Timing variables.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Flag to turn the timing measurement on and off.
!
      logical :: use_timer=.true.
!
! ****** Type of timer to use.
!
      logical :: use_mpi_timer=.true.
!
! ****** Option to dump detailed timing output to log files.
!
      logical :: timer_log=.false.
!
! ****** Total CPU time used by the code.
!
      real(r_typ) :: total_cpu_time=0.
!
! ****** Total communication time used by the code.
!
      real(r_typ) :: total_comm_time=0.
!
! ****** Variable to assist in tracking the total communication time.
!
      integer :: comm_time_track_id=0
!
! ****** Maximum number of nested timing levels.
!
      integer, parameter :: nlevels=8
!
! ****** Present timing level.
!
      integer :: level=0
!
! ****** Time value from MPI_WTIME at the start of the program.
! ****** This is used in implementing the wall-clock time limit
! ****** and to remove the possible offset in the time reported
! ****** by MPI_WTIME.
!
      real(r_typ) :: time_at_start_of_program
!
!-----------------------------------------------------------------------
! ****** Type definition for a timer structure.
!-----------------------------------------------------------------------
!
      type :: timer_struct
        character(24) :: label
        logical :: active
        logical :: comm
        integer, dimension(nlevels) :: ncalls
        real(r_typ), dimension(nlevels) :: tused
        real(r_typ), dimension(nlevels) :: tstart
      end type
!
! ****** Timer task identifiers.
!
! ****** IMPORTANT: Put TIME_TOTAL as the last entry to track the
! ****** total CPU time used.
!
      integer, parameter :: TIME_SEAM    = 1
      integer, parameter :: TIME_SUM     = 2
      integer, parameter :: TIME_MINMAX  = 3
      integer, parameter :: TIME_SUMPHI  = 4
      integer, parameter :: TIME_CIO     = 5
      integer, parameter :: TIME_STARTUP = 6
      integer, parameter :: TIME_ADVRHO  = 7
      integer, parameter :: TIME_ADVTE   = 8
      integer, parameter :: TIME_ADVTP   = 9
      integer, parameter :: TIME_ADVTCE  =10
      integer, parameter :: TIME_ADVTCP  =11
      integer, parameter :: TIME_ADVA    =12
      integer, parameter :: TIME_ADVV    =13
      integer, parameter :: TIME_ADVVISC =14
      integer, parameter :: TIME_ADVPW   =15
      integer, parameter :: TIME_ADVZW   =16
      integer, parameter :: TIME_ADVPARTICLES=17
      integer, parameter :: TIME_V_SOLVER=18
      integer, parameter :: TIME_SOLVE   =19
      integer, parameter :: TIME_CGDOT   =20
      integer, parameter :: TIME_POT2D   =21
      integer, parameter :: TIME_POT3D   =22
      integer, parameter :: TIME_POT2DH  =23
      integer, parameter :: TIME_IO      =24
      integer, parameter :: TIME_OTHER   =25
      integer, parameter :: TIME_TOTAL   =26
!
! ****** Number of timer tasks.
!
      integer, parameter :: ntimers=TIME_TOTAL
!
! ****** Timer tasks array.
!
      type(timer_struct), dimension(ntimers) :: ttask
!
      integer, private :: i,j
      integer, parameter, private :: nd=ntimers*nlevels
!
      data (ttask(i)%label,i=1,ntimers)/'Comm. time: seam        ', &
                                        'Comm. time: global sum  ', &
                                        'Comm. time: min/max     ', &
                                        'Comm. time: sumphi      ', &
                                        'Comm. time: i/o         ', &
                                        'Time: start-up          ', &
                                        'Time: advrho            ', &
                                        'Time: advte             ', &
                                        'Time: advtp             ', &
                                        'Time: advtce            ', &
                                        'Time: advtcp            ', &
                                        'Time: adva              ', &
                                        'Time: advv              ', &
                                        'Time: advvisc           ', &
                                        'Time: advpw             ', &
                                        'Time: advzw             ', &
                                        'Time: advparticles      ', &
                                        'Time: v_solver          ', &
                                        'Time: solve             ', &
                                        'Time: cgdot             ', &
                                        'Time: pot_2d            ', &
                                        'Time: pot_3d            ', &
                                        'Time: pot_2dh           ', &
                                        'Time: i/o               ', &
                                        'Time: other             ', &
                                        'Total time              '/
!
      data (ttask(i)%active,i=1,ntimers)/ntimers*.false./
      data (ttask(i)%comm  , &
            i=1,ntimers)/5*.true.,21*.false./
      data ((ttask(i)%ncalls(j),i=1,ntimers),j=1,nlevels)/nd*0/
      data ((ttask(i)%tused (j),i=1,ntimers),j=1,nlevels)/nd*0./
      data ((ttask(i)%tstart(j),i=1,ntimers),j=1,nlevels)/nd*0./
!
end module
!#######################################################################
module time_limit
!
!-----------------------------------------------------------------------
! ****** Variables related to the wall-clock time limit.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      logical :: use_wallclock_limit=.false.
!
! ****** Time [seconds] that is reserved for final diagostics.
! ****** The code needs to be able to write the final diagnostics
! ****** and restart file in this time interval.
!
      real(r_typ) :: t_wc_reserved=600.
!
      real(r_typ) :: t_wc_limit
      real(r_typ) :: t_wc_elapsed
!
end module
!#######################################################################
module rp1d_def
!
!-----------------------------------------------------------------------
! ****** Define a structure to hold a REAL 1D pointer.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      type :: rp1d
        real(r_typ), dimension(:), pointer, contiguous :: f
      end type
!
end module
!#######################################################################
module sds_def
!
!-----------------------------------------------------------------------
! ****** Definition of the SDS data structure.
!-----------------------------------------------------------------------
!
      use number_types
      use rp1d_def
!
      implicit none
!
      integer, parameter, private :: mxdim=3
!
      type :: sds
        integer :: ndim
        integer, dimension(mxdim) :: dims
        logical :: scale
        logical :: hdf32
        type(rp1d), dimension(mxdim) :: scales
        real(r_typ), dimension(:,:,:), pointer, contiguous :: f
      end type
!
end module
!#######################################################################
module vars
!
      use number_types
      use constants
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** File names.
!-----------------------------------------------------------------------
!
! ****** Set this to use the old style mas text output filenames.
! ****** E.g. o<RUNID>,t<RUNID>,w<RUNID>,h<RUNID>,v<RUNID>, etc.
!
      logical :: legacy_output_filenames=.true.
!
      character(512) :: infile=' '
      character(512) :: outfile=' '
      character(512) :: warnfile=' '
      character(512)  :: dump3dfile     ='mas_dumps_3d.txt'
      character(512)  :: dumpslicefile  ='mas_dumps_slices.txt'
      character(512)  :: dumptracerfile ='mas_dumps_tracers.txt'
      character(512)  :: dumprsfile     ='mas_dumps_restarts.txt'
!
!-----------------------------------------------------------------------
! ****** Restart files.
!-----------------------------------------------------------------------
!
! ****** Restart files can either be a single file, a three-part
! ****** file, or a fifteen-part file.
!
! ****** The number of parts should thus be set to 1, 3, 15, or 17.
!
! ****** Number of input restart file parts.
!
      integer :: n_rs_input_file_parts=1
!
      character(256) :: rsifile=' '
      character(256) :: rsifile_prefix=' '
      character(256) :: rsifile_root=' '
      character(256), dimension(17) :: rsifile_parts=' '
      character(256) :: fname_restart_fcs=' '
!
! ****** Flag to write a restart file at the end of the run.
!
      logical :: rs_final=.true.
!
!-----------------------------------------------------------------------
! ****** Time step related variables.
!-----------------------------------------------------------------------
!
      integer :: ntime=0
      integer :: ntime_rs=0
      integer :: ntmax=1000000
      real(r_typ) :: tmax=100._r_typ
      real(r_typ) :: dtmin=.001_r_typ
      real(r_typ) :: dtmax=1._r_typ
!
      real(r_typ) :: time=0._r_typ
      real(r_typ) :: time_at_start=-1._r_typ
      real(r_typ) :: dtime=1._r_typ
      real(r_typ) :: dtime_old=1._r_typ
      real(r_typ) :: dtime_avg=0.
      character(7) :: dtime_set_reason=' (dtmx)'
      real(r_typ) :: dt_max_increase_fac=0.05_r_typ
      real(r_typ) :: dt_max_wave_cfl=1000.0_r_typ
      real(r_typ) :: dt_init=0.
      logical :: use_dt_init_on_restart=.false.
!
      real(r_typ) :: cfl=.4_r_typ
!
      real(r_typ) :: gamma=1.666666666666667_r_typ
!
      logical :: advance_v=.true.
      logical :: advance_a=.true.
      logical :: advance_t=.true.
      logical :: advance_tp=.false.
      logical :: advance_rho=.true.
      logical :: advance_tc=.false.
      logical :: advance_pw=.false.
      logical :: advance_fcs=.false.
      logical :: advance_zw=.false.
!
      integer :: ifvdgv=1
!
! ****** Predictor switches and fractions.
!
      logical :: pred_v=.true.
      logical :: pred_a=.true.
      logical :: pred_t=.true.
      logical :: pred_rho=.true.
!
      real(r_typ) :: betapc_v_flow=0.
      real(r_typ) :: betapc_v_wave=.5_r_typ
!
      real(r_typ) :: betapc_a=.5_r_typ
!
      real(r_typ) :: betapc_t_flow=0.
      real(r_typ) :: betapc_t_wave=.5_r_typ
!
      real(r_typ) :: betapc_rho_flow=0.
      real(r_typ) :: betapc_rho_wave=.5_r_typ
!
      real(r_typ) :: betapc_si=1._r_typ
!
      real(r_typ) :: fac_cflv=1._r_typ
!
! ****** Flag to use the experimental A advance that uses centered
! ****** (v x B) with implicit upwind resistivity.
!
      logical :: experimental_a_advance=.false.
!
! ****** Semi-implicit term.
!
      integer :: isitype=1
      real(r_typ) :: simult=1.1_r_typ
      logical :: si_aggressive=.true.
      logical :: si_local_kv=.true.
!
!-----------------------------------------------------------------------
! ****** Tolerance for the CG solves.
!-----------------------------------------------------------------------
!
      real(r_typ) :: epscg_a=1.e-9_r_typ
      real(r_typ) :: epscg_v=1.e-9_r_typ
      real(r_typ) :: epscg_t=1.e-9_r_typ
      real(r_typ) :: epscg_potfld=1.e-9_r_typ
      real(r_typ) :: epscg_newflux=1.e-9_r_typ
      real(r_typ) :: epscg_divb=1.e-9_r_typ
!
!-----------------------------------------------------------------------
! ****** Advection parameters.
!-----------------------------------------------------------------------
!
      real(r_typ) :: upwind_a=1._r_typ
      real(r_typ) :: upwind_ar=0.
      real(r_typ) :: upwind_at=0.
      real(r_typ) :: upwind_ap=0.
      real(r_typ) :: upwind_v=1._r_typ
      real(r_typ) :: upwind_t=1._r_typ
      real(r_typ) :: upwind_rho=1._r_typ
!
!-----------------------------------------------------------------------
! ****** Miscellaneous.
!-----------------------------------------------------------------------
!
      logical :: dryrun=.false.
      logical :: ifabort=.false.
      logical :: ifend=.false.
      logical :: use_old_jxb=.false.
      logical :: use_old_vdgv=.true.
!
!-----------------------------------------------------------------------
! ****** HDF precision.
!-----------------------------------------------------------------------
!
! ****** Set HDF32=.true. to write 32-bit floats, and
! ****** HDF32=.false. to write 64-bit floats.
!
      logical :: hdf32=.true.
!
!-----------------------------------------------------------------------
! ****** Length of sequence numbers in names of HDF output files.
!-----------------------------------------------------------------------
!
! ****** Set LONG_SEQUENCE_NUMBERS=.true. to use 6-digit sequence
! ****** numbers.  Set LONG_SEQUENCE_NUMBERS=.false. to use 3-digit
! ****** sequence numbers.
!
      logical :: long_sequence_numbers=.false.
!
!-----------------------------------------------------------------------
! ****** Length of sequence numbers in names of HDF input files.
!-----------------------------------------------------------------------
!
! ****** Set LONG_SEQUENCE_NUMBERS_INPUT=.true. to use 6-digit sequence
! ****** numbers. Set LONG_SEQUENCE_NUMBERS_INPUT=.false. to use 3-digit
! ****** sequence numbers.
!
      logical :: long_sequence_numbers_input=.false.
!
!-----------------------------------------------------------------------
! ****** Magnetic field input.
!-----------------------------------------------------------------------
!
      logical :: b_in_gauss=.true.
      real(r_typ) :: b0=0.
      character(256) :: bnfile=' '
      character(256) :: bnfile_out='br_photo.h5'
      character(16) :: potential_field_bc='CLOSED_WALL'
      logical :: allow_unbalanced_flux=.false.
      character(256) :: afile=' '
      integer :: loaded_b_clean_method=3
!
!-----------------------------------------------------------------------
! ****** Magnetic monopole parameters.
!-----------------------------------------------------------------------
!
      real(r_typ) :: br00=0
      logical :: br_mono_active=.false.
      real(r_typ) :: fmaxef=1._r_typ
      real(r_typ) :: r1ef=1.3_r_typ
      real(r_typ) :: sigmaef=.5_r_typ
      real(r_typ), dimension(:), allocatable :: br_mono !(nr)
      real(r_typ), dimension(:), allocatable :: grav !(nrm)
      character(256) :: fl_file=' '
      logical :: fl_compute=.false.
!
!-----------------------------------------------------------------------
! ****** Dipole tilt and field strength.
!-----------------------------------------------------------------------
!
      real(r_typ) :: dipangle=0.
      real(r_typ) :: b0_dipole=1._r_typ
!
!-----------------------------------------------------------------------
! ****** Gravity at the solar surface.
!-----------------------------------------------------------------------
!
      real(r_typ) :: g0=.823_r_typ
!
!-----------------------------------------------------------------------
! ****** Density and temperature at r=R0.
!-----------------------------------------------------------------------
!
      type :: hs_var
        real(r_typ) :: rho0i
        real(r_typ) :: rho0f
        real(r_typ) :: rho1i
        real(r_typ) :: rho1f
        real(r_typ) :: b0
        real(r_typ) :: b1
        real(r_typ) :: t0i
        real(r_typ) :: t0f
        real(r_typ) :: t1i
        real(r_typ) :: t1f
        real(r_typ) :: time0
        real(r_typ) :: time1
      end type
!
      type(hs_var) :: hs
!
      data hs%rho0i/2._r_typ/
      data hs%rho0f/2._r_typ/
      data hs%rho1i/40._r_typ/
      data hs%rho1f/100._r_typ/
      data hs%b0/1.e10_r_typ/
      data hs%b1/2.e10_r_typ/
      data hs%t0i/1.8e6_r_typ/
      data hs%t0f/1.8e6_r_typ/
      data hs%t1i/2.e5_r_typ/
      data hs%t1f/1.8e6_r_typ/
      data hs%time0/0./
      data hs%time1/10._r_typ/
!
      real(r_typ) :: rho0=1._r_typ
      real(r_typ) :: tbc0=2.e4_r_typ
!
!-----------------------------------------------------------------------
! ****** Density for zero-beta model.
!-----------------------------------------------------------------------
!
! ****** Option to select the type of zero-beta density profile
! ****** initialization.
!
      character(32) :: zb_rho_profile='GENERATE_INTERNALLY'
!
      character(512) :: zb_rho_file='NO_DEFAULT'
!
      type :: zb_var
        real(r_typ) :: rho0
        real(r_typ) :: rho1
        real(r_typ) :: rho00
        real(r_typ) :: rhoexp
        real(r_typ) :: b0
        real(r_typ) :: b1
        real(r_typ) :: lam_r0
        real(r_typ) :: lam_r1
        real(r_typ) :: lam_l0
        real(r_typ) :: lam_l1
       end type
!
      type(zb_var) :: zb
!
      data zb%rho0/0./
      data zb%rho1/0./
      data zb%rho00/1._r_typ/
      data zb%rhoexp/4._r_typ/
      data zb%b0/1._r_typ/
      data zb%b1/2._r_typ/
      data zb%lam_r0/1._r_typ/
      data zb%lam_r1/1.1_r_typ/
      data zb%lam_l0/.005_r_typ/
      data zb%lam_l1/.015_r_typ/
!
!-----------------------------------------------------------------------
! ****** Characteristic BCs.
!-----------------------------------------------------------------------
!
      logical :: char_bc0=.true.
      logical :: char_bc1=.true.
!
      logical :: ubzero=.false.
      integer :: nfiltub=2
!
!-----------------------------------------------------------------------
! ****** Pole filtering.
!-----------------------------------------------------------------------
!
      logical :: filter_poles=.false.
      logical :: pole_filter_t=.false.
      logical :: pole_filter_rho=.false.
      logical :: pole_filter_pw=.false.
      logical :: pole_filter_z=.false.
      logical :: pole_filter_vr=.false.
!
! *** Limit (fix) supersonic inflow at r0.
!
      type :: euo_param
        logical :: limit_supersonic_inflow
      end type
!
      type(euo_param) :: expert_user_override
!
      data expert_user_override%limit_supersonic_inflow/.false./
!
!-----------------------------------------------------------------------
! ****** Initial state.
!-----------------------------------------------------------------------
!
      character(32) :: initial_field='DIPOLE'
      character(32) :: initial_plasma='ZERO-BETA'
      character(256) :: onedfile=' '
      character(256) :: twodfile_vr=' '
      character(256) :: twodfile_rho=' '
      character(256) :: twodfile_t=' '
      logical :: const_t_rho=.false.
!
!-----------------------------------------------------------------------
! ****** Alfven wave tests.
!-----------------------------------------------------------------------
!
      integer :: wave_mode_r=1
      integer :: wave_mode_t=1
      real(r_typ) :: wave_amplitude=1.e-6_r_typ
      real(r_typ) :: wave_rotation_t=0
!
!-----------------------------------------------------------------------
! ****** Sub-surface dipoles.
!-----------------------------------------------------------------------
!
      integer, parameter :: n_ssdip_max=10
!
      integer :: n_ssdip=1
      real(r_typ), dimension(n_ssdip_max) :: r_ssdip=.8_r_typ
      real(r_typ), dimension(n_ssdip_max) :: t_ssdip=pi
      real(r_typ), dimension(n_ssdip_max) :: p_ssdip=pi
      real(r_typ), dimension(n_ssdip_max) :: alpha_ssdip=0.
      real(r_typ), dimension(n_ssdip_max) :: b0_ssdip=1._r_typ
!
!-----------------------------------------------------------------------
! ****** Transverse magnetic field advected in by normal flow
! ****** at r=R0.
!-----------------------------------------------------------------------
!
      real(r_typ) :: bt_photo_in=0.
      real(r_typ) :: bp_photo_in=0.
!
!-----------------------------------------------------------------------
! ****** Debugging variables.
!-----------------------------------------------------------------------
!
! ****** Matrix diagnostics.
!
      logical :: print_matrix_pot2d=.false.
      logical :: print_matrix_pot3d=.false.
      logical :: print_matrix_adva=.false.
      logical :: print_matrix_advv=.false.
      logical :: print_matrix_t=.false.
!
!-----------------------------------------------------------------------
! ****** Normalization variables.
!-----------------------------------------------------------------------
!
! ****** Solar radius [cm].
!
      real(r_typ), parameter :: rsun=6.96e10_r_typ
!
! ****** Solar gravity at r=RSUN [cm/s**2].
!
      real(r_typ), parameter :: g0phys=0.274e5_r_typ
!
! ****** Solar gravity in normalized units.
!
      real(r_typ), parameter :: g0norm=0.823_r_typ
!
! ****** Number density corresponding to a normalized number
! ****** density of 1 [/cm**3].
!
      real(r_typ), parameter :: fn0phys=1.e8_r_typ
!
! ****** Proton mass [g].
!
      real(r_typ), parameter :: fmp=1.6726e-24_r_typ
!
! ****** Boltzmann's constant [erg/K].
!
      real(r_typ), parameter :: boltz=1.3807e-16_r_typ
!
! ****** Magnitude of the Spitzer parallel electron thermal
! ****** conductivity, kappa = 9.e-7*T**2.5 [erg/s/cm/K],
! ****** where T is in degrees Kelvin.
!
      real(r_typ), parameter :: fkspitz=9.e-7_r_typ
      real(r_typ), parameter :: fkspitz_p=2.1003328012116583e-8_r_typ
!                               (fkspitz*0.02333703112457398)
!
!-----------------------------------------------------------------------
!
!-----------------------------------------------------------------------
! ****** Collisonal (Spitzer) thermal conduction.
!-----------------------------------------------------------------------
!
! ****** Factor to multiply fkspitz in thermal conduction solver.
!
      real(r_typ) :: tcond=0.
!
! ****** Factor to multiply fkspitz in proton thermal conduction solver.
!
      real(r_typ) :: tcondp=0.
!
! ****** Normalization for kappa (kappa_phys=kappa_code*fn_kappa).
!
      real(r_typ) :: fn_kappa
!
! ****** Radial profile.
!
      real(r_typ) :: tc_r=10._r_typ
      real(r_typ) :: tc_dr=5._r_typ
      real(r_typ) :: tc_fac0=1._r_typ
      real(r_typ) :: tc_fac1=0.
!
! ****** Kappa cutoff.
!
      real(r_typ) :: t_cutoff1=500000._r_typ
!$acc declare create(t_cutoff1)
!
! ****** Number of times to filter kappa.
!
      integer :: nfilt_kappa=0
!
! ****** Thermal conduction sub-cycle control.
!
      integer :: tc_subcycles=1
      integer :: tc_subcycles_max=60
      logical :: tc_auto_subcycle=.false.
!
!-----------------------------------------------------------------------
! ****** Collisonless thermal conduction.
!-----------------------------------------------------------------------
!
! ****** Factor to multiply collisonless thermal conduction term.
!
      real(r_typ) :: alpha_nocoll=0.
!
! ****** Factor to multiply collisonless thermal conduction term for Tp
!
      real(r_typ) :: alpha_nocoll_p=0.
!
! ****** Flag to use old radial-only collisionless thermal conduction.
!
      logical :: use_radial_nocoll=.false.
!
! ****** Radial profile parameters.
!
      real(r_typ) :: tc_nocoll_r=10._r_typ
      real(r_typ) :: tc_nocoll_dr=5._r_typ
!
!-----------------------------------------------------------------------
! ****** Normalization.
!-----------------------------------------------------------------------
!
      real(r_typ) :: he_rho,he_frac=0.,he_p,he_np,he_p_e,he_p_p,he_p_x, &
                     fnorml,fnormt,fnormm, &
                     fn_n,fn_rho,fn_p,fn_t,fn_v,fn_b,fn_heat, &
                     fn_q0,fn_rd1,fn_rd2
!
      logical :: iftfloor=.false.
      real(r_typ) :: tfloor=20000._r_typ
      real(r_typ) :: tchromo=20000._r_typ
!
      real(r_typ) :: pw0_factor
!
! ****** Solution checks
!
      logical :: ifcheck0rho=.true.
      logical :: ifcheck0temp=.true.
      logical :: ifcheck0pres=.true.
      logical :: ifcheck0pw=.true.
!
!-----------------------------------------------------------------------
! ****** Density limiters.
!-----------------------------------------------------------------------
!
      logical :: ifrholimit=.false.
      real(r_typ) :: rho_limit_factor=0.001_r_typ
      real(r_typ) :: rho_limit_tprof=1._r_typ
      character(256) :: rho_limit_file=' '
!
      real(r_typ) :: max_alfven_speed_rho_mod=0.
!
      real(r_typ) :: rhobc_maxfac_r1=-HUGE(1._r_typ)
!
      real(r_typ) :: eta_uw_mult=1._r_typ
!
! ****** Flag to set the parallel part of the flow to zero.
!
      logical :: zero_v_parallel=.false.
!
! ****** Flag to run the model that has only parallel flow.
! ****** This assumes that the magnetic field is frozen and
! ****** does not compute perpendicular force balance.
!
      logical :: freeze_b=.false.
!
! ****** File from which to read a mask that transitions kappa
! ****** from a field-aligned tensor to an isotropic thermal
! ****** conductivity.
!
      character(256) :: kappa_mask_file=' '
!
      logical :: use_kappa_mask=.false.
!
! ****** File from which to read a mask that transitions b-hat
! ****** from being aligned along B to being radially aligned.
!
      character(256) :: bhat_mask_file=' '
!
!-----------------------------------------------------------------------
! ****** Radiative loss.
!-----------------------------------------------------------------------
!
! ****** Radiation loss function Q(T) normalization.
!
      real(r_typ) :: fn_qrad
!
! ****** Select radiative loss (radloss>0) and modify it by
! ****** the factor radloss as Q=radloss*Q.
!
      real(r_typ) :: radloss=0.
!
! ****** Name of seleted radiative loss function.
!
      character(32) :: rad_law='ATHAY'
!
! ****** Apply radiative loss function implicitly.
!
      integer :: ifimplrad=0
!
! ****** Flag to apply the legacy reduction of Q at the base of the
! ****** chromosphere (developed by Yung Mok).  This option is not
! ****** recommended; it is provided for backward compatibility.
!
      logical :: legacy_q_chromo_reduction=.false.
!
!-----------------------------------------------------------------------
! ****** Co-rotating/inertial frame parameters.
!-----------------------------------------------------------------------
!
      character(64) :: calculation_frame='INERTIAL'
      character(64) :: restart_calculation_frame='FLAG'
      real(r_typ) :: omega_corotate=0.004144_r_typ
!
!-----------------------------------------------------------------------
! ****** Fractional charge states variables.
!-----------------------------------------------------------------------
!
      integer :: i_chemi_eigen(30),ncs
!
!-----------------------------------------------------------------------
! ****** Electron-proton collision coefficients
!-----------------------------------------------------------------------
!
      real(r_typ) :: coulomb_log=20._r_typ
      real(r_typ) :: d_couple_2t=0._r_typ
      real(r_typ) :: f_heating=0.6_r_typ
!
!-----------------------------------------------------------------------
! ****** Helicity pumping global variables.
!-----------------------------------------------------------------------
!
      logical :: helicity_pumping=.false.
      logical :: hpump_step=.false.
      real(r_typ) :: hpump_cadence=0.
      real(r_typ) :: hpump_time_offset=0.
      real(r_typ) :: hpump_time_last=0.
      real(r_typ) :: hpump_time_now=0.
!
!-----------------------------------------------------------------------
! ****** PCHIP options.
!-----------------------------------------------------------------------
!
      logical :: if_pchip=.true.
!
!-----------------------------------------------------------------------
! ****** PW radial cutoff options.
!-----------------------------------------------------------------------
!
      logical :: use_pw_rcut=.false.
      real(r_typ) :: pw_rcut_r0=1.5
      real(r_typ) :: pw_rcut_width=0.1
!
end module
!#######################################################################
module vmod_fcs
!-----------------------------------------------------------------------
! ****** Parameters modifying vr in advfcs
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      logical :: if_vmod=.false.
      real(r_typ) :: dr_vmod=0.5_r_typ
      real(r_typ) ::  r_vmod=1.6_r_typ
      real(r_typ) ::  tmod0=1.0_r_typ
      real(r_typ) ::  tmod1=0.0_r_typ
      real(r_typ), dimension(:,:,:), allocatable  :: vmod
!
end module
!#######################################################################
module flow_def
!
!-----------------------------------------------------------------------
! ****** Definition of a flow specification structure.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      type :: flow_spec
        logical :: active
        character(32) :: type
        real(r_typ) :: mask_t0
        real(r_typ) :: mask_p0
        real(r_typ) :: mask_width_t
        real(r_typ) :: mask_width_p
        real(r_typ) :: mask_angle
        real(r_typ) :: dthmax
        real(r_typ) :: th0
        integer :: power
        character(256) :: file_r
        character(256) :: file_t
        character(256) :: file_p
        logical :: normalize_vtrans
        logical :: normalize_vnorm
      end type
!
end module
!#######################################################################
module shear_profile
!
      use number_types
      use flow_def
!
      implicit none
!
      type(flow_spec) :: shear
!
      data shear%active/.false./
      data shear%type/'VORTEX'/
      data shear%mask_t0/0./
      data shear%mask_p0/0./
      data shear%mask_width_t/.1_r_typ/
      data shear%mask_width_p/.1_r_typ/
      data shear%mask_angle/0./
      data shear%file_r/'NO_DEFAULT'/
      data shear%file_t/'NO_DEFAULT'/
      data shear%file_p/'NO_DEFAULT'/
      data shear%normalize_vtrans/.true./
      data shear%normalize_vnorm/.true./
!
      data shear%dthmax/0.6981_r_typ/
      data shear%th0/1.57079632679489661923_r_typ/
      data shear%power/4/
!
      real(r_typ), dimension(:,:), allocatable :: v_shear_t
      real(r_typ), dimension(:,:), allocatable :: v_shear_p
!
! ****** Differential rotation parameters.
!
      real(r_typ) :: arotate=0.,brotate=0.,crotate=0.
!
! ****** Meridional flow parameters.
!
      real(r_typ) :: v_north=0,v_south=0.
!
end module
!#######################################################################
module flow_profile
!
      use number_types
      use flow_def
!
      implicit none
!
      type(flow_spec) :: flow
!
      data flow%active/.false./
      data flow%type/'GENERATE_INTERNALLY'/
      data flow%mask_t0/0./
      data flow%mask_p0/0./
      data flow%mask_width_t/.1_r_typ/
      data flow%mask_width_p/.1_r_typ/
      data flow%mask_angle/0./
      data flow%file_r/'NO_DEFAULT'/
      data flow%file_t/'NO_DEFAULT'/
      data flow%file_p/'NO_DEFAULT'/
      data flow%normalize_vtrans/.true./
      data flow%normalize_vnorm/.true./
!
      real(r_typ), dimension(:,:), allocatable :: v_flow_r
      real(r_typ), dimension(:,:), allocatable :: v_flow_t
      real(r_typ), dimension(:,:), allocatable :: v_flow_p
!
end module
!#######################################################################
module eta_photosphere
!
      use number_types
!
      implicit none
!
! ****** Switch to use photospheric diffusion.
!
      logical :: ifeta_phot=.false.
!
! ****** Photospheric diffusion coefficient.
!
      real(r_typ) :: eta_phot=1.e-4_r_typ
!
! ****** File name from which to read the photospheric
! ****** diffusion profile.
!
      character(256) :: eta_phot_file=' '
!
! ****** Photospheric diffusion profile.
!
      real(r_typ), dimension(:,:), allocatable :: eta_phot_prof
!
! ****** Current photospheric diffusion magnitude.
!
      real(r_typ) :: eta_phot_mag
!
! ****** Photospheric diffusion time-profile factor.
!
      real(r_typ) :: eta_phot_factor
!
end module
!#######################################################################
module array_tp_def
!
!-----------------------------------------------------------------------
! ****** Definition of a data structure that can hold a 2D
! ****** (t,p) array, with information about the type of scales
! ****** the array is on.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** The type of BCs to be set at the poles are defined by
! ****** variable POLE_BC as follows:
! ******    1: scalar
! ******    2: theta component of a vector
! ******    3: phi component of a vector
      type :: array_tp
        logical :: main_mesh_t
        logical :: main_mesh_p
        integer :: pole_bc
        real(r_typ), dimension(:,:), pointer, contiguous :: f
      end type
!
end module
!#######################################################################
module eflux_types
!
!-----------------------------------------------------------------------
! ****** Definition of emerging flux structures.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      type :: eflux_struct
        logical :: phi_driven
        logical :: psi_driven
        logical :: e_driven
        character(256) :: phi_file
        character(256) :: psi_file
        logical :: normalize_phi
        logical :: normalize_psi
        logical :: vr_set
        character(256) :: vr_file
      end type
!
      type :: ef_component_struct
        logical :: active
        real(r_typ) :: e0
        real(r_typ), dimension(:,:), allocatable :: er
        real(r_typ), dimension(:,:), allocatable :: et
        real(r_typ), dimension(:,:), allocatable :: ep
        real(r_typ), dimension(:,:), allocatable :: vr
        real(r_typ), dimension(:,:), allocatable :: vt
        real(r_typ), dimension(:,:), allocatable :: vp
      end type
!
      type :: ef_struct
        type(ef_component_struct) :: phi
        type(ef_component_struct) :: psi
        type(ef_component_struct) :: edrive
        logical :: vr_set
        real(r_typ) :: vr_v0
        real(r_typ), dimension(:,:), allocatable :: vr
        real(r_typ), dimension(:,:), allocatable :: vt
        real(r_typ), dimension(:,:), allocatable :: vp
      end type
!
end module
!#######################################################################
module emerging_flux_params
!
!-----------------------------------------------------------------------
! ****** Parameters that control emerging flux.
!-----------------------------------------------------------------------
!
      use number_types
      use eflux_types
!
      implicit none
!
! ****** Flag to emerge transverse field (which is misnamed!).
!
      logical :: emerging_flux=.false.
!
! ****** Flag to evolve the flux.
!
      logical :: evolve_flux=.false.
!
! ****** Flags for time-dependent coronal boundary driving.
!
      logical :: time_dependent_corona=.false.
      logical :: time_dependent_corona_from_files=.false.
      logical :: tdc_edb_correction_trunc=.false.
      logical :: tdc_edb_correction_etmod=.false.
      logical :: debug_tdc=.false.
      real(r_typ) :: tdc_edb_br_eps=0.05_r_typ
      real(r_typ) :: tdc_edb_btp_a=.16666666666666666666_r_typ
      real(r_typ) :: tdc_edb_btp_d=10._r_typ
      real(r_typ) :: tdc_edb_correction_etmod_eta=2.0e-7_r_typ
!
! ****** Differential rotation flag.
!
      logical :: rotation_flux=.false.
!
! ****** Emerging flux parameters.
!
      type(eflux_struct) :: eflux
!
      data eflux%phi_driven/.false./
      data eflux%psi_driven/.false./
      data eflux%e_driven/.false./
      data eflux%phi_file/'NO_DEFAULT'/
      data eflux%psi_file/'NO_DEFAULT'/
      data eflux%normalize_phi/.true./
      data eflux%normalize_psi/.true./
      data eflux%vr_set/.false./
      data eflux%vr_file/'NO_DEFAULT'/
!
! ****** Emerging flux electric field.
!
      real(r_typ), dimension(:,:), allocatable :: eflux_er
      real(r_typ), dimension(:,:), allocatable :: eflux_et
      real(r_typ), dimension(:,:), allocatable :: eflux_ep
      real(r_typ), dimension(:,:), allocatable :: eflux_vr
      real(r_typ), dimension(:,:), allocatable :: eflux_vt
      real(r_typ), dimension(:,:), allocatable :: eflux_vp
      real(r_typ), dimension(:,:), allocatable :: vxbbr0r
      real(r_typ), dimension(:,:), allocatable :: vxbbr0t
      real(r_typ), dimension(:,:), allocatable :: vxbbr0p
      real(r_typ), dimension(:,:), allocatable :: curl_et
      real(r_typ), dimension(:,:), allocatable :: div_et
!
! ****** Effective photospheric resistivity.
!
      real(r_typ), dimension(:,:), allocatable :: eflux_eta
!
! ****** Emerging flux electric field.
!
      type(ef_struct) :: ef
!
! ****** Arrays to hold the magnetic field at r=R0 that is read
! ****** in during the evolution of the magnetic flux, and
! ****** indices to their contents.
!
      integer :: ifile0_contents
      integer :: ifile1_contents
      real(r_typ), dimension(:,:), allocatable :: br_ef0,br_ef1
      real(r_typ), dimension(:,:,:), allocatable :: br_ef,dbr_ef, &
       vt_ef,dvt_ef,vp_ef,dvp_ef,phi_ef,dphi_ef
!
! ****** Flag to specify if evolving flux is ON for the
! ****** present time step.
!
      logical :: ef_is_on=.false.
!
end module
!#######################################################################
module drive_profile
!
      use number_types
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** Drive velocity.
!-----------------------------------------------------------------------
!
      real(r_typ) :: v_drive=0.
      real(r_typ) :: v_flow_norm=0.
      real(r_typ) :: v_flow_trans=0.
!
! ****** Current drive velocity magnitude.
!
      real(r_typ) :: v_drive_mag
      real(r_typ) :: v_flow_norm_mag
      real(r_typ) :: v_flow_trans_mag
!
! ****** Drive velocity time-profile factor.
!
      real(r_typ) :: v_drive_factor
      real(r_typ) :: v_flow_norm_factor
      real(r_typ) :: v_flow_trans_factor
!
end module
!#######################################################################
module fluxrope_parameters
!
!-----------------------------------------------------------------------
! ****** General parameters for handling flux-rope insertion in MAS.
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY: avec
!
      implicit none
!
! ****** The maximum number flux ropes for a single type.
!
      integer, parameter :: n_fr_max=10
!
! ****** Vector potential for the sum of all ropes.
!
      type(avec) :: a_fr
!
! ****** When this is set, the Br from the flux ropes at r=R0 is
! ****** subtracted from the Br read in before calculating the
! ****** potential field.
!
      logical :: fluxrope_preserve_br0=.false.
!
! ****** Flag to indicate that flux ropes have been added.
!
      logical :: fluxropes_added=.false.
!
end module
!#######################################################################
module fluxrope_file_structure_def
!
!-----------------------------------------------------------------------
! ****** Definition of the structure that contains parameters for adding
! ****** flux-ropes or other fields from vector potential files.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      type :: rope_file_def
        logical :: add
        character(256) :: ar_file
        character(256) :: at_file
        character(256) :: ap_file
        real(r_typ) :: a_factor
        real(r_typ) :: insertion_time
      end type
!
! ****** Flux rope file parameters:
!
!          ADD:
!            A logical flag to specify that a set of vector potential
!            files will be added at the beginning of the run.
!
!          AR_FILE:
!            Name of the file from which Ar is read in.
!
!          AT_FILE:
!            Name of the file from which At is read in.
!
!          AP_FILE:
!            Name of the file from which Ap is read in.
!
!          A_FACTOR:
!            Multiplication factor for Ar,At,Ap [default 1].
!
end module
!#######################################################################
module fluxrope_file_parameters
!
!-----------------------------------------------------------------------
! ****** Parameters for the modified RBSL flux rope model.
!-----------------------------------------------------------------------
!
      use number_types
      use fluxrope_file_structure_def
      use fluxrope_parameters
!
      implicit none
!
! ****** Structure containing the required parameters.
!
      type(rope_file_def), dimension(n_fr_max) :: rope_from_file
!
! ****** Set the default values.
!
      integer, private :: i
!
      data (rope_from_file(i)%add,i=1,n_fr_max) &
           /n_fr_max*.false./
      data (rope_from_file(i)%ar_file,i=1,n_fr_max) &
           /n_fr_max*'NO_DEFAULT'/
      data (rope_from_file(i)%at_file,i=1,n_fr_max) &
           /n_fr_max*'NO_DEFAULT'/
      data (rope_from_file(i)%ap_file,i=1,n_fr_max) &
           /n_fr_max*'NO_DEFAULT'/
      data (rope_from_file(i)%a_factor,i=1,n_fr_max) &
           /n_fr_max*1._r_typ/
      data (rope_from_file(i)%insertion_time,i=1,n_fr_max) &
           /n_fr_max*0._r_typ/
!
end module
!#######################################################################
module rbsl_structure_def
!
!-----------------------------------------------------------------------
! ****** Definition of the structure that defines the parameters needed
! ****** to use RBSL flux-ropes in MAS.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      type :: rbsl_def
        logical :: add
        character(256) :: path_file
        real(r_typ) :: axial_current
        real(r_typ) :: minor_radius
        integer :: handedness
        logical :: mirror_poloidal
        real(r_typ) :: insertion_time
      end type
!
! ****** This implementation is based on the fortran program APATH,
! ****** written by Viacheslav Titov. It was adapted for MAS by CD.
!
! ****** The approach and formulation is described in Titov et al. 2018:
! ****** Regularized Biot-Savart Laws for Modeling Magnetic Flux Ropes.
!
! ****** Definitions of the RBSL flux rope parameters are:
!
!          ADD:
!            A logical flag to specify that the RBSL rope is to
!            be added at the beginning of the run.
!
!          PATHFILE:
!            The name of the hdf file that defines the axis path
!            of the RBSL rope.
!            - The coordinate system is SPHERICAL (r,t,p).
!            - The dimensions of the file must be (N,3). Where the
!              3 indicates the three r,t,p coordinates.
!
!          AXIAL_CURRENT:
!            The magnitude of the axial current (in MAS units).
!            A positive value implies that the current is aligned
!            with the path direction. A negative value implies the
!            current is anti-parallel.
!
!          MINOR_RADIUS:
!            The minor radius of the flux rope [solar radii].
!
!          HANDEDNESS:
!            The helicity of the flux rope, specified as an
!            integer value [-1 => left-handed, +1 => right-handed].
!
!          MIRROR_POLOIDAL:
!            A logical flag to indicate if you wish to mirror
!            (reverse) the poloidal current below the surface.
!            This is a convenient trick for (mostly) eliminating
!            the axial flux at the surface if the geometry of
!            the path is mirrored above/below the corona.
!            - The default is [False]
!
end module
!#######################################################################
module rbsl_parameters
!
!-----------------------------------------------------------------------
! ****** Parameters for the modified RBSL flux rope model.
!-----------------------------------------------------------------------
!
      use number_types
      use rbsl_structure_def
      use fluxrope_parameters
!
      implicit none
!
! ****** Structure containing the RBSL parameters.
!
      type(rbsl_def), dimension(n_fr_max) :: rbsl_fluxrope
!
! ****** Set the default values.
!
      integer, private :: i
!
      data (rbsl_fluxrope(i)%add,i=1,n_fr_max) &
           /n_fr_max*.false./
      data (rbsl_fluxrope(i)%path_file,i=1,n_fr_max) &
           /n_fr_max*'NO_DEFAULT'/
      data (rbsl_fluxrope(i)%axial_current,i=1,n_fr_max) &
           /n_fr_max*1._r_typ/
      data (rbsl_fluxrope(i)%minor_radius,i=1,n_fr_max) &
           /n_fr_max*.025_r_typ/
      data (rbsl_fluxrope(i)%handedness,i=1,n_fr_max) &
           /n_fr_max*1/
      data (rbsl_fluxrope(i)%mirror_poloidal,i=1,n_fr_max) &
           /n_fr_max*.false./
      data (rbsl_fluxrope(i)%insertion_time,i=1,n_fr_max) &
           /n_fr_max*0._r_typ/
!
end module
!#######################################################################
module rbsl_parameters_internal
!
!-----------------------------------------------------------------------
! ****** Internal parameters for the modified Titov-Demoulin
! ****** flux rope model.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      integer :: npts
!
      real(r_typ) :: a
      real(r_typ) :: AIU, AFU
!
      real(r_typ), dimension(:,:), allocatable :: Rvc
      real(r_typ), dimension(:,:), allocatable :: Rvca
      real(r_typ), dimension(:,:), allocatable :: dRvc
      real(r_typ), dimension(:), allocatable :: smult
!
end module
!#######################################################################
module tdm_structure_def
!
!-----------------------------------------------------------------------
! ****** Definition of the structure that contains the parameters
! ****** for the modified Titov-Demoulin flux rope model.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      type :: tdm_def
        logical :: add
        character(256) :: rope_type
        real(r_typ) :: origin_r
        real(r_typ) :: origin_t
        real(r_typ) :: origin_p
        real(r_typ) :: normal_t
        real(r_typ) :: normal_p
        real(r_typ) :: tilt_from_vertical
        real(r_typ) :: apex_height
        real(r_typ) :: footpoint_halfdistance
        real(r_typ) :: minor_radius
        real(r_typ) :: delta
        real(r_typ) :: b_poloidal
        integer :: handedness
        logical :: add_charges
        real(r_typ) :: charge_magnitude
        real(r_typ) :: charge_halflength
        logical :: get_bp_from_charge
        real(r_typ) :: charge_to_bp_factor
        logical :: use_major_radius
        real(r_typ) :: major_radius
        real(r_typ) :: insertion_time
      end type
!
! ****** The location of the coordinate origin of the local
! ****** Cartesian coordinate system (X',Y',Z') in the modified
! ****** Titov-Demoulin model is given by (ORIGIN_T,ORIGIN_P)
! ****** in spherical coordinates (in the photosphere).  This
! ****** is the location of the flux rope "center".
!
! ****** The normal vector to the plane that cuts through the
! ****** middle of the flux rope (lengthwise), passing through the
! ****** point (ORIGIN_T,ORIGIN_P), is specified by its spherical
! ****** vector components (NORMAL_T,NORMAL_P).  These specify
! ****** a plane that is perpendicular to the photosphere.
! ****** By definition, the normal is directed from the negative
! ****** polarity of the strapping field toward the positive
! ****** polarity of the strapping field.  This plane can be
! ****** additionally tilted away from the vertical by the angle
! ****** TILT_FROM_VERTICAL, specified in degrees.  A positive
! ****** TILT_FROM_VERTICAL tilts the plane toward the positive
! ****** polarity.  [TILT_FROM_VERTICAL is thus a right-handed
! ****** rotation about the Y' axis.]
!
! ****** Additional flux rope parameters:
!
!          ADD:
!            A logical flag to specify that the flux rope is to
!            be added at the beginning of the run.
!
!          ROPE_TYPE:
!            Name of the type of TDM tope you wish to add.
!             valid names are:
!            'hollow_nonff': The original TDm model in MAS.
!                            It has a hollow core current
!                            distribution that is NOT quite
!                            force free.
!            'hollow': The rope with a "hollow-core" current
!                      profile, discussed in Titov et al. 2014.
!            'parabolic': The rope with a parabolic current
!                         profile, discussed in Titov et al. 2014.
!
!          APEX_HEIGHT:
!            Height of the flux rope apex above the photosphere
!            [solar radii].
!
!          FOOTPOINT_HALFDISTANCE:
!            Half the distance between the flux rope footpoints
!            in the photosphere [solar radii].
!
!          MINOR_RADIUS:
!            The minor radius of the flux rope [solar radii].
!
!          DELTA:
!            The fractional width of the surface transition layer in
!            which the current is concentrated (unitless ratio).
!
!          B_POLOIDAL:
!            The strength of the external poloidal field at the
!            flux rope axis, specified as a positive value.
!            [normalized MAS units].
!
!          HANDEDNESS:
!            The magnetic helicity of the flux rope, specified as an
!            integer value [-1 => left-handed, +1 => right-handed].
!            To be clear:
!              -1: Axial J antiparallel to axial B, Dextral chirality.
!              +1: Axial J parallel to axial B, Sinestral chirality.
!
!          ADD_CHARGES:
!            Logical to add in the external field of two magnetic
!            charges perpendicular to the rope axis. The depth
!            is set automatically to match the rope depth.
!
!          CHARGE_MAGNITUDE:
!            The strength of the magnetic charge in MAS units.
!            A positive value will set the polarity of the spots
!            to match with the definition of normal_t/normal_p
!            and imply a downward (strapping) JxB force. A negative
!            value reverses these spot polarities only (upward force).
!
!          CHARGE_HALFLENGTH:
!            The charge separation half length [solar radii].
!
!          GET_BP_FROM_CHARGE:
!            Logical to set bp based on the charge_magnitude. Bp is
!            set by determining the charge field at the FR axis.
!            This will override the setting for B_POLOIDAL.
!
!          CHARGE_TO_BP_FACTOR:
!            Dimensionless factor the multiplies the equilibrium
!            bp determined when GET_BP_FROM_CHARGE=.true.
!
!          USE_MAJOR_RADIUS:
!            Logical to use the major_radius parameter instead of
!            the footpoint_halfdistance in setting the geometry
!            of the flux_rope.
!
!          MAJOR_RADIUS:
!            Desired value of the major radius [solar radii]. This
!            value is used only if USE_MAJOR_RADIUS is true.
!
!
end module
!#######################################################################
module tdm_parameters
!
!-----------------------------------------------------------------------
! ****** Parameters for the modified Titov-Demoulin flux rope model.
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_structure_def
      use fluxrope_parameters
      use types, ONLY : avec
!
      implicit none
!
! ****** Structure containing the TDM parameters.
!
      type(tdm_def), dimension(n_fr_max) :: tdm_fluxrope
!
! ****** Set the default values.
!
      integer, private :: i
      real(r_typ), parameter, private :: halfpi=.5_r_typ*pi
!
      data (tdm_fluxrope(i)%add,i=1,n_fr_max) &
           /n_fr_max*.false./
      data (tdm_fluxrope(i)%rope_type,i=1,n_fr_max) &
           /n_fr_max*'PARABOLIC'/
      data (tdm_fluxrope(i)%origin_r,i=1,n_fr_max) &
           /n_fr_max*1._r_typ/
      data (tdm_fluxrope(i)%origin_t,i=1,n_fr_max) &
           /n_fr_max*halfpi/
      data (tdm_fluxrope(i)%origin_p,i=1,n_fr_max) &
           /n_fr_max*0./
      data (tdm_fluxrope(i)%normal_t,i=1,n_fr_max) &
           /n_fr_max*1._r_typ/
      data (tdm_fluxrope(i)%normal_p,i=1,n_fr_max) &
           /n_fr_max*0./
      data (tdm_fluxrope(i)%tilt_from_vertical,i=1,n_fr_max) &
           /n_fr_max*0./
      data (tdm_fluxrope(i)%apex_height,i=1,n_fr_max) &
           /n_fr_max*.05_r_typ/
      data (tdm_fluxrope(i)%footpoint_halfdistance,i=1,n_fr_max) &
           /n_fr_max*.15_r_typ/
      data (tdm_fluxrope(i)%minor_radius,i=1,n_fr_max) &
           /n_fr_max*.025_r_typ/
      data (tdm_fluxrope(i)%delta,i=1,n_fr_max) &
           /n_fr_max*.2_r_typ/
      data (tdm_fluxrope(i)%b_poloidal,i=1,n_fr_max) &
           /n_fr_max*10._r_typ/
      data (tdm_fluxrope(i)%handedness,i=1,n_fr_max) &
           /n_fr_max*1/
      data (tdm_fluxrope(i)%add_charges,i=1,n_fr_max) &
           /n_fr_max*.false./
      data (tdm_fluxrope(i)%charge_magnitude,i=1,n_fr_max) &
           /n_fr_max*0._r_typ/
      data (tdm_fluxrope(i)%charge_halflength,i=1,n_fr_max) &
           /n_fr_max*0.02_r_typ/
      data (tdm_fluxrope(i)%get_bp_from_charge,i=1,n_fr_max) &
           /n_fr_max*.false./
      data (tdm_fluxrope(i)%charge_to_bp_factor,i=1,n_fr_max) &
           /n_fr_max*1._r_typ/
      data (tdm_fluxrope(i)%use_major_radius,i=1,n_fr_max) &
           /n_fr_max*.false./
      data (tdm_fluxrope(i)%major_radius,i=1,n_fr_max) &
           /n_fr_max*.20_r_typ/
      data (tdm_fluxrope(i)%insertion_time,i=1,n_fr_max) &
           /n_fr_max*0._r_typ/
!
end module
!#######################################################################
module tdm_parameters_internal
!
!-----------------------------------------------------------------------
! ****** Internal parameters for the modified Titov-Demoulin
! ****** flux rope model.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ) :: R,a,d,II,FF,delta
      real(r_typ) :: L,q0
!
! ****** Cartesian coordinates of the local coordinate system origin.
!
      real(r_typ) :: tdm_origin_x
      real(r_typ) :: tdm_origin_y
      real(r_typ) :: tdm_origin_z
!
! ****** Rotation matrices that transform between coordinate
! ****** systems.
!
      real(r_typ), dimension(3,3) :: rm1,rm2,rm3
!
end module
!#######################################################################
module field_table
!
!-----------------------------------------------------------------------
! ****** Table describing the properties of all the main fields.
!-----------------------------------------------------------------------
!
      use number_types
      use decomposition
!
      implicit none
!
!-----------------------------------------------------------------------
! ****** Definition of a field descriptor structure.
!-----------------------------------------------------------------------
!
      type :: field_def
        character(8) :: name=''
        logical :: input_enabled=.false.
        real(r_typ), dimension(:,:,:), pointer, contiguous :: f
        logical :: rm  ! .true. ==> field on main r mesh
        logical :: tm  ! .true. ==> field on main t mesh
        logical :: pm  ! .true. ==> field on main p mesh
        integer :: n1_g
        integer :: n2_g
        integer :: n3_g
        real(r_typ), dimension(:), pointer, contiguous :: r_g
        real(r_typ), dimension(:), pointer, contiguous :: t_g
        real(r_typ), dimension(:), pointer, contiguous :: p_g
        type(map_struct), dimension(:), pointer :: map_r
        type(map_struct), dimension(:), pointer :: map_t
        type(map_struct), dimension(:), pointer :: map_p
        type(map_struct), dimension(:), pointer :: maptp_t
        type(map_struct), dimension(:), pointer :: maptp_p
        integer, dimension(:), pointer, contiguous :: n1
        !r-dim(0:nproc-1)
        integer, dimension(:), pointer, contiguous :: n2
        !t-dim(0:nproc-1)
        integer, dimension(:), pointer, contiguous :: n3
        !p-dim(0:nproc-1)
      end type
!
! ****** Definition of field identifiers.
!
      integer, parameter :: IFLD_AR    = 1
      integer, parameter :: IFLD_AT    = 2
      integer, parameter :: IFLD_AP    = 3
      integer, parameter :: IFLD_VR    = 4
      integer, parameter :: IFLD_VT    = 5
      integer, parameter :: IFLD_VP    = 6
      integer, parameter :: IFLD_RHO   = 7
      integer, parameter :: IFLD_P     = 8
      integer, parameter :: IFLD_PRES  = 9
      integer, parameter :: IFLD_BR    =10
      integer, parameter :: IFLD_BT    =11
      integer, parameter :: IFLD_BP    =12
      integer, parameter :: IFLD_JR    =13
      integer, parameter :: IFLD_JT    =14
      integer, parameter :: IFLD_JP    =15
      integer, parameter :: IFLD_ETA   =16
      integer, parameter :: IFLD_VIS   =17
      integer, parameter :: IFLD_VR_OLD=18
      integer, parameter :: IFLD_VT_OLD=19
      integer, parameter :: IFLD_VP_OLD=20
      integer, parameter :: IFLD_SIFAC =21
      integer, parameter :: IFLD_T_E   =22
      integer, parameter :: IFLD_T_P   =23
      integer, parameter :: IFLD_T     =24
      integer, parameter :: IFLD_HEAT  =25
      integer, parameter :: IFLD_EP    =26
      integer, parameter :: IFLD_EM    =27
      integer, parameter :: IFLD_ETA_UW=28
      integer, parameter :: IFLD_EFR   =29
      integer, parameter :: IFLD_EFT   =30
      integer, parameter :: IFLD_EFP   =31
      integer, parameter :: IFLD_V_PAR =32
      integer, parameter :: IFLD_ZP    =33
      integer, parameter :: IFLD_ZM    =34
!
! ****** Number of field definitions.
!
      integer, parameter :: nfields=34
!
! ****** Table of field definitions.
!
      type(field_def), dimension(nfields) :: fldtab
!
! ****** Structure for specifying initial/added fields from file.
!
      type :: fields_from_file
        character(12) :: field=''
        character(12) :: action='initial'
        character(512) :: fname=''
      end type
!
      type(fields_from_file),dimension(nfields) :: load_fields
!
end module
!#######################################################################
module diagnostics
!
      use number_types
      use field_table
!
      implicit none
!
      integer, private :: i,j
!
! ****** The last time when diagnostic intervals were checked.
!
      real(r_typ) :: t_last_check=0.
!
!-----------------------------------------------------------------------
! ****** Plotting diagnostics (i.e., HDF dumps).
!-----------------------------------------------------------------------
!
! ****** Maximum number of fields to plot.
!
      integer, parameter :: mxplot=nfields
!
! ****** Number of fields to plot.
!
      integer :: nplot=0
!
! ****** Indices of fields to plot (in FLDTAB).
!
      integer, dimension(mxplot) :: plot_index=0
!
! ****** Input list of fields to plot.
!
      character(8), dimension(mxplot) :: plotlist=' '
!
! ****** Plotting intervals for 3D fields.
!
      integer :: ipltxint=0
      real(r_typ) :: tpltxint=0.
!
! ****** Flag to indicate a 3D plotting step.
!
      logical :: plotting_step=.false.
!
!-----------------------------------------------------------------------
! ****** Time histories.
!-----------------------------------------------------------------------
!
! ****** Maximum number of time histories to buffer.
!
      integer, parameter :: nhistmax=101
!
! ****** Definition of a time history buffer structure.
!
      type :: thist_def
        real(r_typ), dimension(nhistmax) :: v
        integer :: gop      ! Type of global reduction operation.
        character(8) :: lab
      end type
!
! ****** Definition of global reduction operations.
!
      integer, parameter :: GOP_NONE=1
      integer, parameter :: GOP_MIN =2
      integer, parameter :: GOP_MAX =3
      integer, parameter :: GOP_SUM =4
!
! ****** Number of time histories to track.
!
      integer, parameter :: nhistq=23
!
! ****** Buffer for time histories.
!
      type(thist_def), dimension(nhistq) :: thist
!
      data (thist(i)%lab,i=1,nhistq)/'Time    ', &
                                     'Wr      ', &
                                     'Wt      ', &
                                     'Wp      ', &
                                     'Kr      ', &
                                     'Kt      ', &
                                     'Kp      ', &
                                     'E       ', &
                                     '|JxB|   ', &
                                     '|J.B|   ', &
                                     'K_par_r ', &
                                     'K_par_t ', &
                                     'K_par_p ', &
                                     'K_perp_r', &
                                     'K_perp_t', &
                                     'K_perp_p', &
                                     'R       ', &
                                     'V       ', &
                                     'P       ', &
                                     'E_cons  ', &
                                     'dt      ', &
                                     'Flow_CFL', &
                                     'Wave_CFL'/
!
      data (thist(i)%gop,i=1,nhistq)/GOP_NONE,19*GOP_SUM,3*GOP_NONE/
!
! ****** Time history collection intervals.
!
      integer :: ihistint=1
      real(r_typ) :: thistint=0.
!
! ****** Flag to indicate a history collection step.
!
      logical :: history_step=.false.
!
! ****** Number of time histories collected.
!
      integer :: ihist=0
!
!-----------------------------------------------------------------------
! ****** Restart file dump intervals.
!-----------------------------------------------------------------------
!
      integer :: irsdump=0
      real(r_typ) :: trsdump=0.
!
! ****** Flag to indicate a restart file dump.
!
      logical :: restart_step=.false.
!
!-----------------------------------------------------------------------
! ****** Diagnostic points.
!-----------------------------------------------------------------------
!
! ****** Maximum number of diagnostic quantities (fields).
!
      integer, parameter :: mxdiagq=nfields
!
! ****** Definition of a diagnostic point input specification
! ****** structure.
!
      type :: diag_spec
        character(8) :: type
        character(8), dimension(mxdiagq) :: fields
        real(r_typ) :: r
        real(r_typ) :: t
        real(r_typ) :: p
      end type
!
! ****** Definition of a diagnostic quantity structure.
!
      type :: diagq
        character(8) :: name
        real(r_typ), dimension(:,:,:), pointer, contiguous :: fld
        logical :: rm
        logical :: tm
        logical :: pm
        integer :: i
        integer :: ip1
        real(r_typ) :: ar
        integer :: j
        integer :: jp1
        real(r_typ) :: at
        integer :: k
        integer :: kp1
        real(r_typ) :: ap
        real(r_typ), dimension(:), pointer, contiguous :: v
      end type
!
! ****** Definition of a diagnostic point structure.
!
      type :: diagp
        character(8) :: type
        real(r_typ) :: r
        real(r_typ) :: t
        real(r_typ) :: p
        integer :: iproc
        integer :: nq
        type(diagq), dimension(:), pointer :: q
      end type
!
! ****** Maximum number of diagnostic points.
!
      integer, parameter :: mxdiagp=30
!
! ****** Number of diagnostic points.
!
      integer :: ndiagp=0
!
! ****** Storage for diagnostic points.
!
      type(diagp), dimension(:), pointer :: diagpt
!
! ****** Input structure for specifying diagnostic points.
!
      type(diag_spec), dimension(mxdiagp) :: diag
!
      real(r_typ), parameter :: NULL_VALUE=-1.e20_r_typ
!
      integer, parameter, private :: nd=mxdiagp*mxdiagq
!
      data (diag(i)%type,i=1,mxdiagp)/mxdiagp*'VALUE'/
      data (diag(i)%r,i=1,mxdiagp)/mxdiagp*NULL_VALUE/
      data (diag(i)%t,i=1,mxdiagp)/mxdiagp*NULL_VALUE/
      data (diag(i)%p,i=1,mxdiagp)/mxdiagp*NULL_VALUE/
      data ((diag(i)%fields(j),j=1,mxdiagq),i=1,mxdiagp)/nd*' '/
!
!-----------------------------------------------------------------------
! ****** Tracer Particles.
!-----------------------------------------------------------------------
!
! ****** Activate particle tracing.
!
      logical :: trace_particles=.false.
!
! ****** Tracer particle dump frequency.
!
      integer ::     trace_ixint=0
      real(r_typ) :: trace_txint=0.
!
! ****** Flag to indicate a tracer particles dump step.
!
      logical :: trace_step=.false.
!
! ****** Select quantities to outpu in addition to position.
!
      logical :: trace_track_ds=.false.
!cc      logical :: trace_track_rho=.false.
!
! ****** Filename of seed particles.
!
      character(64) :: trace_seed_file=' '
!
! ****** Tracer particles structure.
!
      type :: tracer_particles
        real(r_typ), dimension(:), allocatable :: r
        real(r_typ), dimension(:), allocatable :: t
        real(r_typ), dimension(:), allocatable :: p
        integer :: n
        real(r_typ), dimension(:), allocatable :: ds
      end type
!
      type(tracer_particles), target :: tracers
!
      integer :: trace_reseed_index=1
      character(64) :: trace_reseed_type='none'
      real(r_typ) :: trace_reseed_r0=1._r_typ
!
      integer, parameter :: n_trace_reseed_types=2
!
      integer, parameter :: TRACER_RESEED_NONE       =1
      integer, parameter :: TRACER_RESEED_R_PERIODIC =2
      character(64), dimension(n_trace_reseed_types) :: tr_name
!
      data tr_name(TRACER_RESEED_NONE)/'none'/
      data tr_name(TRACER_RESEED_R_PERIODIC)/'r_periodic'/
!
!-----------------------------------------------------------------------
! ****** Slice output.
!-----------------------------------------------------------------------
!
! ****** Number of fields to plot.
!
      integer :: nplot_slices=0
!
! ****** Input list of fields to plot rslices.
!
      character(8), dimension(mxplot) :: slice_plotlist=' '
!
! ****** Indices of fields to plot (in FLDTAB).
!
      integer, dimension(mxplot) :: slice_plot_index=0
!
! ****** Maximum number of tpslices.
!
      integer, parameter :: max_tpslices=100
!
! ****** Input array of radii to take slices of.
!
      real(r_typ), dimension(max_tpslices) :: slice_tp_radii=0.
!
! ****** Number of slice radii to plot.
!
      integer :: n_tpslice_radii=0
!
! ****** Inputs for plotting intervals for slices.
!
      integer ::     slice_ixint=0
      real(r_typ) :: slice_txint=0.
!
! ****** Flag to indicate a slice dump step.
!
      logical :: slice_step=.false.
!
!-----------------------------------------------------------------------
! ****** fcs output.
!-----------------------------------------------------------------------
!
       logical :: plot_dump_fcs=.true.
       logical :: slice_dump_fcs=.true.
!
end module
!#######################################################################
module restart
!
!-----------------------------------------------------------------------
! ****** Definition of structures to help in reading and writing
! ****** restart files.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      integer, parameter, private :: LENNAME=16
      integer, parameter, private :: LENVALUE=64
!
      type :: cvar
        character(LENNAME) :: name
        character(LENVALUE) :: value
      end type
!
      type :: ivar
        character(LENNAME) :: name
        integer :: value
      end type
!
      type :: rvar
        character(LENNAME) :: name
        real(r_typ) :: value
      end type
!
      type :: rsi_struc
        integer :: index
        character(256) :: fname
        logical :: required
        logical :: read
      end type
!
      type :: rso_struc
        integer :: nfields
        integer, dimension(:), allocatable :: index
        logical, dimension(:), allocatable :: write
        character(8) :: fname_root
      end type
!
! ****** Flag to signal a restart run.
!
      logical :: restart_run=.false.
!
! ****** Restart file mesh dimensions.
!
      integer :: nr_rs,nt_rs,np_rs
!
! ****** Restart file time and date.
!
      character(10) :: restart_file_date
      character(8) :: restart_file_time
!
! ****** Buffer containing the total energies.
!
      real(r_typ), dimension(3) :: energy_buf
!
! ****** Number of restart file fields.
!
      integer, parameter :: n_rs_fields=18
!
! ****** Definition of the input restart file configuration.
!
      integer :: n_rs_i_files
!
      type(rsi_struc), dimension(n_rs_fields) :: rs_i
!
! ****** Definition of the output restart file configuration.
!
      logical :: output_rs_file_config_defined=.false.
!
      type(rso_struc), dimension(:), allocatable :: rs_o
!
end module
!#######################################################################
module coef_storage
!
!-----------------------------------------------------------------------
! ****** Storage for the COEF array used in the v solve.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      real(r_typ), dimension(:,:,:), allocatable :: coef !(nrm,ntm,npm)
!
end module
!#######################################################################
module dtinfo
!
!-----------------------------------------------------------------------
! ****** Information about time step limits and maximum speeds.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Maximum CFL numbers.
!
      real(r_typ) :: flow_cfl,wave_cfl
!
! ****** Maximum time step based on CFL limit.
!
      real(r_typ) :: dtcfl
!
! ****** Maximum speeds.
!
      real(r_typ) :: v_max,va_max,cs_max
!
! ****** Maximum size of semi-implicit coefficient.
!
      real(r_typ) :: si_max
!
end module
!#######################################################################
module energy_diagnostic
!
!-----------------------------------------------------------------------
! ****** Variables relating to the total energy diagnostic.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Magnetic energy.
!
      real(r_typ) :: wr,wt,wp,ww
!
! ****** Kinetic energy.
!
      real(r_typ) :: kr,kt,kp,kk
      real(r_typ) :: kparr,kpart,kparp
      real(r_typ) :: kperpr,kperpt,kperpp
!
! ****** Thermal energy.
!
      real(r_typ) :: etherm
!
! ****** Rate of resistive dissipation.
!
      real(r_typ) :: rr=0.
      real(r_typ) :: rr_old=0.
!
! ****** Rate of viscous dissipation.
!
      real(r_typ) :: vv=0.
      real(r_typ) :: vv_old=0.
!
! ****** Poynting flux across the boundaries into the domain.
!
      real(r_typ) :: poynt=0.
!
! ****** Accumulated energy that has been dissipated.
!
      real(r_typ) :: e_dissipated=0.
!
! ******  Accumulated energy that has flowed into the domain.
!
      real(r_typ) :: e_poynt=0.
!
! ****** Estimate of the conserved energy.
!
      real(r_typ) :: e_conserved
!
end module
!#######################################################################
module alfven_wave_params
!
!-----------------------------------------------------------------------
! ****** Parameters to find the Alfven wave test frequency.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      integer :: l_taw
      real(r_typ) :: x0_taw,x1_taw
!
end module
!#######################################################################
module hdf_defs
!
!-----------------------------------------------------------------------
! ****** Definition of constants for the HDF5 interface.
!-----------------------------------------------------------------------
!
      use hdf5, ONLY : HID_T
!
      implicit none
!
! ****** Status and name of the currently open file.
!
      logical :: hdf_sd_file_open_for_read=.false.
      logical :: hdf_sd_file_open_for_write=.false.
      character(256) :: hdf_sd_currently_open_file
!
! ****** HDF5 globals for restarts
!
      integer(HID_T) :: rsfile_id ! File identifier for restart file
!
end module
!#######################################################################
module io_units
!
!-----------------------------------------------------------------------
! ****** Set the unit numbers for various IO files.
!-----------------------------------------------------------------------
!
      implicit none
!
      integer, parameter :: IO_SCRATCH_T=1
      integer, parameter :: IO_INPUT=8
      integer, parameter :: IO_OUT=9
      integer, parameter :: IO_HIST_DIAG=11
      integer, parameter :: IO_WARN=13
      integer, parameter :: IO_DUMP_3D=25
      integer, parameter :: IO_DUMP_TRACERS=26
      integer, parameter :: IO_DUMP_SLICE=27
      integer, parameter :: IO_DUMP_RS=28
      integer, parameter :: IO_TEMP=20
      integer, parameter :: IO_TEMP2=21
!
end module
!#######################################################################
module alfven_wave_pressure
!
!-----------------------------------------------------------------------
! ****** Alfven wave pressure parameters.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
      integer :: nsaw=0
      real(r_typ) :: dtawav=0.,pw0=0.,rho_aw=1._r_typ, &
       awthprof_th=0.7_r_typ, &
       awthprof_dth=0.08_r_typ, &
       awthprof2_th=2.44159265358979323844_r_typ, &
       dbob_aw=0., &
       wdbob_aw=1._r_typ, &
       tau_aw=1._r_typ
      logical :: dissipate_aw=.false.
      logical :: modulate_pw0=.false.
      logical :: use_pw_theta_profile=.false.
!
      real(r_typ), dimension(:), allocatable, target  :: awthprof
!
! ****** Put in a "safety factor" when estimating the maximum time
! ****** step that is used for the Alfven wave advance.
! ****** Experience shows that this factor needs to be there, but
! ****** it is presently not understood why.
!        (Maybe make this an input parameter? - RMC)
!
      real(r_typ), parameter :: safety_factor_aw=.5_r_typ
!
end module
!#######################################################################
module wtd
!$acc routine(wtd_rho_factor) seq
!
!-----------------------------------------------------------------------
! ****** Storage and parameters for the WTD model.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** Parameters for zp,zm
!
      real(r_typ) :: wtd_z0=0.
      real(r_typ) :: wtd_b0=1.0_r_typ
      real(r_typ) :: wtd_lambda0=0.02_r_typ
!
! ****** Factor to prevent negative VA in BC ghost cells.
!
      real(r_typ) :: wtd_bc_extrap_fac_r1=-HUGE(1.0_r_typ)
!
! ****** Option to activate reflecting BCs:
! ****** 'NONE' => Let the waves pass through (preferred).
! ****** 'CONS' => Outward poynting flux maintained.
! ****** 'AMPL' => Reflect the wave amplitude.
!
      character(32) :: wtd_reflect_bc='NONE'
      integer :: IRBC_TYPE=-1
      integer, parameter :: IRBC_NONE=1
      integer, parameter :: IRBC_CONS=2
      integer, parameter :: IRBC_AMPL=3
!
! ****** Initial condition option for ZP/ZM.
!
! ****** Options are:
! ******   'CONSTANT'     =>
! ******   'FROM_INIT_3D' =>
! ******   'WKB'          =>
! ******   'WKB_BR'       =>
! ******   'EPEM'         =>
! ******   'FROM_FILE'    =>
! ****** The wtd_icfac sets the value when using `CONSTANT`, and otherwise
! ****** multiplies the IC.  Be sure to set to a non-zero value when using
! ****** the other IC options!
!
      character(32) :: wtd_icond='CONSTANT'
      real(r_typ) :: wtd_icfac=0.
      character(256) :: wtd_ic1dfile=' '
!
! ****** WTD model flags.
!
      logical :: zw_dissp=.true.
      logical :: zw_reflection=.true.
!
! ****** Use zw heating in energy equation.
!
      logical :: wtd_add_zw_heating=.true.
      real(r_typ) :: zw_heat_factor
!
! ****** Use zw pressure in momentum equation.
!
      logical :: wtd_add_zw_pressure=.false.
      real(r_typ) :: zw_pressure_factor
!
! ****** Use limiter for z amplitude.
! ****** Can be constant (zw_limit_amplitude) or a
! ****** radial profile (zw_limit_radial_file)
!
      logical :: wtd_use_zw_limit=.false.
      real(r_typ) :: zw_limit_amplitude=HUGE(1.0_r_typ)
      character(256) :: zw_limit_radial_file=' '
!
! ****** Upwind coefficients for zp/zm equations.
! ****** s: source terms.
! ****** z: terms involving gradients of zp/zm.
!
      real(r_typ) :: zw_uwc_s=0.
      real(r_typ) :: zw_uwc_z=1._r_typ
!
! ******* Average DT used for ZP/ZM advance.
!
      real(r_typ) :: dtzwav=0.
      integer :: nszw=0
!
! ******* CFL for ZP/ZM advance.
!
      real(r_typ) :: zw_cfl=.9_r_typ
!
! ****** ZP/ZM flux limiters.
!
      logical :: wtd_use_flux_limiter_gradzw=.true.
      logical :: wtd_use_flux_limiter_gradsrc=.false.
      character(32) :: zw_flux_limiter_type='OSPRE'
      integer :: IFLUX=-1
      integer, parameter :: IFLUX_ospre  =1
      integer, parameter :: IFLUX_minmod =2
!
! ****** Flags for the effective rho limit.
!
      logical :: wtd_use_zw_effective_rho_limit=.false.
      real(r_typ) :: zw_effective_rho_limit_lr=log10(160._r_typ)
      real(r_typ) :: zw_effective_rho_limit_lw=0.3_r_typ
!$acc declare create (wtd_use_zw_effective_rho_limit, &
!$acc                 zw_effective_rho_limit_lr, &
!$acc                 zw_effective_rho_limit_lw)
!
! ****** zw advance has a separate rho_aw (zw_rho_aw).
! ****** This will slow down the zw advance by this factor.
! ****** (cuts timescale to reduces number of subcycles - sus...)
!
      real(r_typ) :: zw_rho_aw=1.0_r_typ
!
! ****** Manual Heat over rho limit
!
      logical :: wtd_use_zw_horho_limit=.false.
      real(r_typ) :: zw_horho_limit_rlim=8.0_r_typ
      real(r_typ) :: zw_horho_limit_value=5.e-2_r_typ
!
! ****** Optional 2D mask file for multiplying z0 BC at the surface.
!
      logical :: wtd_use_zw_flux_mask=.false.
      character(256) :: z0_flux_mask_tp_file='NO_DEFAULT'
      real(r_typ), dimension(:,:), allocatable :: z0_flux_mask
!
! ****** Optional limiter for the Poynting flux supplied to an open
! ****** field line. This requires that ep and em are also advanced.
! ****** The value of the maxflux limit is in cgs units:
! ****** (e.g. 1e6 erg cm-2 s-1).
! ****** The value of the equilibration time is in seconds
! ****** (e.g. 180 s).
!
      logical :: wtd_use_open_field_cutoff=.false.
      real(r_typ) :: wtd_open_cutoff_maxflux=1.e6_r_typ
      real(r_typ) :: wtd_open_cutoff_dt_eq_s=180._r_typ
      real(r_typ), dimension(:,:), allocatable :: wtd_open_flux_zmult
      real(r_typ), dimension(:,:), allocatable :: wtd_net_pflux
      real(r_typ), dimension(:,:), allocatable :: wtd_mask_open
!
      logical :: debug_wtd=.false.
      logical :: debug_wtd_open_field_cutoff=.false.
!
      interface
        pure function wtd_rho_factor(rhoval)
        use number_types
        implicit none
        real(r_typ), intent(in) :: rhoval
        real(r_typ) :: wtd_rho_factor
        end function wtd_rho_factor
      end interface
!
end module
!#######################################################################
module heating_parameters
!
!-----------------------------------------------------------------------
! ****** Storage and parameters for the heating specification.
!-----------------------------------------------------------------------
!
      use number_types
      use profile_def
!
      implicit none
!
! ****** Definition of a heat source structure.
!
      type :: heat_source
        logical :: active=.false.
        character(64) :: name=' '
        character(64) :: type='no_default'
        real(r_typ) :: h0=0.
        real(r_typ) :: lambda=.2_r_typ
        real(r_typ) :: power=1.2_r_typ
        real(r_typ) :: brmax=.25_r_typ
        real(r_typ) :: center_gaussian(3)=(/1.25_r_typ,0._r_typ, &
        0._r_typ/)
        type(profile) :: r_profile
        type(profile) :: t_profile
        type(profile) :: b_profile
        type(profile) :: time_profile
        logical :: b_attenuation=.false.
        real(r_typ) :: b_cutoff=226.563_r_typ
        real(r_typ) :: q0=.02_r_typ
        real(r_typ) :: q1=.005_r_typ
        real(r_typ) :: lambda0=.03_r_typ
        real(r_typ) :: lambda1=.15_r_typ
        logical :: use_mask=.false.
        logical :: nl_mask=.false.
      end type
!
! ****** Storage and parameters for heat sources.
!
      integer, parameter :: max_heat_sources=10
!
      type(heat_source), dimension(max_heat_sources) :: heatsource
!
      integer, dimension(max_heat_sources) :: hs_type
!
! ****** Parameters to flat-top the heating to a maximum value.
!
      logical :: heating_flat_topped=.false.
      real(r_typ) :: heat_max=1.e20_r_typ
!
! ****** Variables to add a heating source from a file.
!
      character(256) :: heat_file=' '
      logical :: add_heat_from_file
      real(r_typ), dimension(:,:,:), allocatable :: heat_from_file
!
! ****** Flag to add ohmic heating.
!
      logical :: add_ohmic_heating=.false.
      real(r_typ) :: ohmic_heating_factor=1.0_r_typ
!
! ****** Variables to read a heat mask from a file.
!
      character(256) :: heat_mask_file=' '
      logical :: have_heat_mask
      real(r_typ), dimension(:,:,:), allocatable :: heat_mask
!
!-----------------------------------------------------------------------
! ****** Definition of valid heat source types.
!-----------------------------------------------------------------------
!
! ****** Number of defined heat source types.
!
      integer, parameter :: n_heat_source_types=7
!
! ****** Identifiers for the defined heat source types.
! ****** These identifiers must match the names specified in
! ****** HS_NAME(:) below in their order.
!
      integer, parameter :: HS_DEF_EXP       =1
      integer, parameter :: HS_DEF_2EXP      =2
      integer, parameter :: HS_DEF_EXP_BPHOTO=3
      integer, parameter :: HS_DEF_B_DEP     =4
      integer, parameter :: HS_DEF_BR_DEP    =5
      integer, parameter :: HS_DEF_GAUSSIAN  =6
      integer, parameter :: HS_ZW_EXPONENTIAL=7
!
! ****** Storage for defined heat source type names.
!
      character(64), dimension(n_heat_source_types) :: hs_name
!
! ****** Types of defined heat sources.
!
      data hs_name(HS_DEF_EXP       )/'exponential'/
      data hs_name(HS_DEF_2EXP      )/'two-exponential'/
      data hs_name(HS_DEF_EXP_BPHOTO)/'exponential-b-photo-dependent'/
      data hs_name(HS_DEF_B_DEP     )/'b-dependent'/
      data hs_name(HS_DEF_BR_DEP    )/'br-dependent'/
      data hs_name(HS_DEF_GAUSSIAN  )/'gaussian'/
      data hs_name(HS_ZW_EXPONENTIAL)/'zw-exponential'/
!
! ****** Chromospheric Heating Parameters.
!
      logical :: use_chromo_heat=.false.
      real(r_typ) :: chromo_heat_t_zqc_0=10000.0_r_typ
      real(r_typ) :: chromo_heat_t_zqc_1=40000.0_r_typ
      real(r_typ), dimension(:,:,:), allocatable :: heat_chromo
!
end module
!#######################################################################
module radiative_loss_parameters
!
!-----------------------------------------------------------------------
! ****** Radiative loss law parameters.
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Define the radiative loss law types.
!
      integer, parameter :: n_rad_law=6
!
! ****** Radiative loss law index definitions.
! ****** This list must start at index 1 and must end with index
! ****** value N_RAD_LAW.
!
      integer, parameter :: RAD_LAW_ATHAY             =1
      integer, parameter :: RAD_LAW_ROSNER            =2
      integer, parameter :: RAD_LAW_RTV               =3
      integer, parameter :: RAD_LAW_CHIANTI_v71_CORONA=4
      integer, parameter :: RAD_LAW_CHIANTI_v71_PHOTO =5
      integer, parameter :: RAD_LAW_CHIANTI_v713_HYBRID=6
!
! ****** Radiative loss law name definitions.
! ****** The order must correspond to the above declarations.
!
      character(32), dimension(n_rad_law) :: rad_law_name
!
      data rad_law_name(RAD_LAW_ATHAY) &
                              /'ATHAY'/
      data rad_law_name(RAD_LAW_ROSNER) &
                              /'ROSNER'/
      data rad_law_name(RAD_LAW_RTV) &
                              /'RTV'/
      data rad_law_name(RAD_LAW_CHIANTI_v71_CORONA) &
                              /'CHIANTI_v71_CORONA'/
      data rad_law_name(RAD_LAW_CHIANTI_v71_PHOTO ) &
                              /'CHIANTI_v71_PHOTO'/
      data rad_law_name(RAD_LAW_CHIANTI_v713_HYBRID) &
                              /'CHIANTI_v713_HYBRID'/
!
! ****** The index of the radiative loss law selected.
!
      integer :: rad_law_index=0
!
! ****** Flag to indicate that the radiative loss law has been
! ****** initialized.
!
      logical :: rad_law_initialized=.false.
!
! ****** Temperatures that define the region where Q is modified
! ****** to go to zero (if requested), and the constants used
! ****** in the transition.
!
      real(r_typ) :: t_zqc_0
      real(r_typ) :: t_zqc_1
      real(r_typ) :: a_zqc
      real(r_typ) :: b_zqc
!
end module
!#######################################################################
module chianti_v71_rad_loss_corona
!
!-----------------------------------------------------------------------
! ****** Parameters for the CHIANTI radiative loss function with
! ****** coronal abundances.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** This radiative loss law was obtained from CHIANTI
! ****** version 7.1 using SolarSoft routine RAD_LOSS.PRO.
!
! ****** Abundance model: coronal abundances
! ******   (Feldman et al. 1992, ApJSS, 81, 387;
! ******    Landi, Feldman, & Dere 2002, ApJ, 139, 281;
! ******    Grevesse & Sauval 1998, Space Sci. Rev., 85, 161)
! ****** Abundance file: sun_coronal_ext.abund
!
! ****** Ionization equilibrium model: CHIANTI
! ****** Ionization equilibrium file: chianti.ioneq
!
! ****** Evaluated at a constant pressure of 0.5 [dyn/cm^2/s].
!
! ****** Version of CHIANTI used.
!
      character(8), parameter :: chianti_version='7.1'
!
! ****** Number of values in the table.
!
      integer, parameter :: n_elem=101
!
! ****** The table assumes that the radiative loss function
! ****** Q(T) is expressed in terms of uniform increments in
! ****** log10(T), with T in [K], and Q in [erg-cm^3/s].
!
      real(r_typ), parameter :: log10_T_min=4._r_typ
      real(r_typ), parameter :: log10_T_max=9._r_typ
!
! ****** Inverse of the (uniform) increment in log10(T).
!
      real(r_typ), parameter :: log10_dt_inv=(n_elem-1) &
                                             /( log10_T_max &
                                               -log10_T_min)
!
! ****** Table that has the values of log10(Q[erg-cm^3/s]).
!
      real(r_typ), dimension(n_elem) :: log10_Q_table
!
      data log10_Q_table/ &
       -23.053720,-22.608917,-22.201519,-21.869802,-21.684013, &
       -21.659719,-21.730042,-21.830411,-21.910629,-21.940114, &
       -21.925158,-21.882720,-21.819293,-21.739567,-21.645444, &
       -21.541707,-21.437104,-21.347542,-21.293833,-21.269791, &
       -21.258449,-21.270308,-21.287414,-21.279126,-21.253218, &
       -21.230150,-21.219972,-21.216386,-21.224706,-21.276223, &
       -21.380011,-21.472548,-21.504925,-21.493113,-21.466189, &
       -21.443690,-21.430127,-21.415454,-21.394676,-21.374235, &
       -21.363539,-21.366170,-21.376353,-21.391410,-21.417227, &
       -21.465230,-21.550128,-21.673484,-21.807932,-21.926742, &
       -22.018263,-22.077592,-22.106909,-22.112793,-22.103273, &
       -22.085571,-22.065103,-22.046422,-22.034324,-22.033451, &
       -22.048419,-22.083934,-22.144429,-22.226347,-22.315033, &
       -22.394977,-22.458936,-22.506446,-22.539409,-22.560491, &
       -22.572118,-22.576383,-22.575024,-22.569357,-22.560548, &
       -22.549457,-22.536845,-22.523306,-22.509245,-22.494902, &
       -22.480377,-22.465586,-22.450447,-22.434802,-22.418578, &
       -22.401694,-22.384121,-22.365890,-22.347013,-22.327555, &
       -22.307556,-22.287064,-22.266142,-22.244831,-22.223163, &
       -22.201198,-22.178951,-22.156461,-22.133751,-22.110846, &
       -22.087767/
!$acc declare copyin(log10_Q_table)
!
end module
!#######################################################################
module chianti_v71_rad_loss_photo
!
!-----------------------------------------------------------------------
! ****** Parameters for the CHIANTI radiative loss function with
! ****** photospheric abundances.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** This radiative loss law was obtained from CHIANTI
! ****** version 7.1 using SolarSoft routine RAD_LOSS.PRO.
!
! ****** Abundance model: photospheric abundances
! ******   (Grevesse, Asplund, & Sauval 2007,
! ******    Space Sci. Rev., 130, 105)
! ****** Abundance file: sun_photospheric_2007_grevesse.abund
!
! ****** Ionization equilibrium model: CHIANTI
! ****** Ionization equilibrium file: chianti.ioneq
!
! ****** Evaluated at a constant pressure of 0.5 [dyn/cm^2/s].
!
! ****** Version of CHIANTI used.
!
      character(8), parameter :: chianti_version='7.1'
!
! ****** Number of values in the table.
!
      integer, parameter :: n_elem=101
!
! ****** The table assumes that the radiative loss function
! ****** Q(T) is expressed in terms of uniform increments in
! ****** log10(T), with T in [K], and Q in [erg-cm^3/s].
!
      real(r_typ), parameter :: log10_T_min=4._r_typ
      real(r_typ), parameter :: log10_T_max=9._r_typ
!
! ****** Inverse of the (uniform) increment in log10(T).
!
      real(r_typ), parameter :: log10_dt_inv=(n_elem-1) &
                                             /( log10_T_max &
                                               -log10_T_min)
!
! ****** Table that has the values of log10(Q[erg-cm^3/s]).
!
      real(r_typ), dimension(n_elem) :: log10_Q_table
!
      data log10_Q_table/ &
       -23.278543,-22.760442,-22.301559,-21.942126,-21.751012, &
       -21.738208,-21.823982,-21.936337,-22.031817,-22.085563, &
       -22.104446,-22.101736,-22.072176,-22.012507,-21.925388, &
       -21.817613,-21.699178,-21.588129,-21.509493,-21.467012, &
       -21.450323,-21.464954,-21.488495,-21.487622,-21.468062, &
       -21.450199,-21.445180,-21.447295,-21.462569,-21.526248, &
       -21.656325,-21.794838,-21.879875,-21.912466,-21.921077, &
       -21.932902,-21.956533,-21.973765,-21.972744,-21.962177, &
       -21.955532,-21.958838,-21.967740,-21.980043,-22.001315, &
       -22.041697,-22.112266,-22.211626,-22.317631,-22.413759, &
       -22.492288,-22.547303,-22.578962,-22.591815,-22.591543, &
       -22.583270,-22.570960,-22.558138,-22.548678,-22.546376, &
       -22.554703,-22.576570,-22.613490,-22.660351,-22.705494, &
       -22.739902,-22.761695,-22.772821,-22.775718,-22.772496, &
       -22.764719,-22.753542,-22.739824,-22.724179,-22.707109, &
       -22.688972,-22.670071,-22.650633,-22.630814,-22.610714, &
       -22.590384,-22.569815,-22.549002,-22.527913,-22.506544, &
       -22.484888,-22.462946,-22.440742,-22.418286,-22.395607, &
       -22.372720,-22.349648,-22.326410,-22.303024,-22.279501, &
       -22.255861,-22.232111,-22.208263,-22.184328,-22.160312, &
       -22.136225/
!$acc declare copyin(log10_Q_table)
!
end module
!#######################################################################
module chianti_v713_rad_loss_hybrid
!
!-----------------------------------------------------------------------
! ****** Parameters for the CHIANTI radiative loss function with
! ****** hybrid abundances.
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
!
! ****** This radiative loss law was obtained from CHIANTI
! ****** version 7.1.3 using SolarSoft routine RAD_LOSS.PRO.
!
! ****** Abundance model: hybrid abundances
! ******   (Schmelz, J.T., Reames, D.V., von Steiger, R.,
!           & Basu, S. 2012, ApJ, 755, 33
! ****** Abundance file: abundance/sun_coronal_2012_schmelz.abund
!
! ****** Ionization equilibrium model: CHIANTI
! ****** Ionization equilibrium file: chianti.ioneq
!
! ****** Evaluated at a constant pressure of 0.5 [dyn/cm^2/s].
!
! ****** Version of CHIANTI used.
!
      character(8), parameter :: chianti_version='7.1.3'
!
! ****** Number of values in the table.
!
      integer, parameter :: n_elem=101
!
! ****** The table assumes that the radiative loss function
! ****** Q(T) is expressed in terms of uniform increments in
! ****** log10(T), with T in [K], and Q in [erg-cm^3/s].
!
      real(r_typ), parameter :: log10_T_min=4._r_typ
      real(r_typ), parameter :: log10_T_max=9._r_typ
!
! ****** Inverse of the (uniform) increment in log10(T).
!
      real(r_typ), parameter :: log10_dt_inv=(n_elem-1) &
                                             /( log10_T_max &
                                               -log10_T_min)
!
! ****** Table that has the values of log10(Q[erg-cm^3/s]).
!
      real(r_typ), dimension(n_elem) :: log10_Q_table
!
      data log10_Q_table/ &
       -23.173405,-22.693628,-22.259687,-21.913499,-21.726534, &
       -21.712934,-21.796067,-21.904196,-21.995410,-22.046955, &
       -22.061490,-22.047052,-22.006913,-21.943809,-21.859823, &
       -21.761927,-21.660436,-21.574684,-21.526706,-21.504842, &
       -21.494666,-21.509326,-21.530231,-21.524690,-21.498276, &
       -21.471054,-21.454857,-21.445585,-21.450557,-21.502869, &
       -21.610191,-21.705010,-21.738200,-21.727392,-21.702443, &
       -21.683368,-21.674188,-21.662965,-21.643790,-21.623632, &
       -21.612265,-21.613308,-21.621704,-21.635247,-21.659802, &
       -21.706597,-21.789538,-21.909865,-22.040647,-22.156947, &
       -22.247128,-22.305767,-22.334703,-22.340561,-22.331272, &
       -22.313839,-22.293549,-22.274858,-22.262343,-22.260413, &
       -22.273314,-22.305224,-22.359730,-22.432529,-22.509241, &
       -22.575680,-22.626061,-22.660962,-22.682807,-22.694341, &
       -22.697901,-22.695365,-22.688236,-22.677635,-22.664557, &
       -22.649756,-22.633864,-22.617414,-22.600796,-22.584035, &
       -22.567166,-22.550116,-22.532777,-22.515005,-22.496732, &
       -22.477898,-22.458492,-22.438548,-22.418087,-22.397170, &
       -22.375836,-22.354127,-22.332095,-22.309774,-22.287191, &
       -22.264389,-22.241384,-22.218202,-22.194863,-22.171383, &
       -22.147777/
!$acc declare copyin(log10_Q_table)
!
end module
!#######################################################################
module interplanetary_vars
!
!-----------------------------------------------------------------------
! ****** Variables need to drive the code in interplanetary mode
!-----------------------------------------------------------------------
!
      use number_types
      use types
!
      implicit none
      integer, private :: i
!
      character(128) :: ip_path=' '
      character(64) :: boundary_frame='FAKE_COROTATING'
      logical :: fake_corotation=.false.
      logical :: interplanetary_run=.false.
      logical :: ip_bc_use_pot_solves=.true.
      integer :: ip_bc_interp_order=1
      logical :: ip_bc_shift_phi_guess=.true.
      logical :: ip_bc_shift_psi_guess=.false.
!
      integer, parameter :: mx_ip_seq=5000
      integer :: n_ip_seq, ip_sequence(mx_ip_seq)
      character(64) :: brfile=' '
      character(64) :: btfile=' '
      character(64) :: bpfile=' '
      character(64) :: vrfile=' '
      character(64) :: vtfile=' '
      character(64) :: vpfile=' '
      character(64) :: rhofile=' '
      character(64) :: tfile=' '
      character(64) :: fcsfile=' '
      character(64) :: epfile=' '
      character(64) :: emfile=' '
      character(64) :: zpfile=' '
      character(64) :: zmfile=' '
!
      real(r_typ) :: ip_node(mx_ip_seq)
!
      real(r_typ) :: helper_ip(mx_ip_seq)
!
      data (ip_node(i),i=1,mx_ip_seq) &
           /mx_ip_seq*-1._r_typ/
!
      integer, parameter :: NULL_VALUE_IP_SEQUENCE=-1
!
      data (ip_sequence(i),i=1,mx_ip_seq) &
           /mx_ip_seq*NULL_VALUE_IP_SEQUENCE/
!
      integer :: ifile0_contents
      integer :: ifile1_contents
!
      real(r_typ), dimension(:,:), allocatable,target ::br_ip,bt_ip, &
      bp_ip,rho_ip,t_ip,vr_ip,vt_ip,vp_ip
      real(r_typ), dimension(:,:), allocatable,target ::br_ip_g,bt_ip_g, &
      bp_ip_g,rho_ip_g,t_ip_g,vr_ip_g,vt_ip_g,vp_ip_g,ep_ip_g,em_ip_g, &
      zp_ip_g,zm_ip_g
!
      real(r_typ), dimension(:,:), allocatable,target :: &
      br_ip0_g,br_ip1_g,bt_ip0_g,bt_ip1_g,bp_ip0_g,bp_ip1_g, &
      rho_ip0_g,rho_ip1_g,t_ip0_g,t_ip1_g,vr_ip0_g,vr_ip1_g,vt_ip0_g, &
      vt_ip1_g,vp_ip0_g,vp_ip1_g,ep_ip0_g,ep_ip1_g,em_ip0_g,em_ip1_g, &
      zp_ip0_g,zp_ip1_g,zm_ip0_g,zm_ip1_g
!
      real(r_typ) :: deltat_ip=0.
      real(r_typ) :: corotating_relaxation_time=0.
!
end module
!#######################################################################
module prescribe_b_v_at_r0_vars
!
!-----------------------------------------------------------------------
! ****** Variables need to prescribe B and V at R0
!-----------------------------------------------------------------------
!
      use number_types
      use types
!
      implicit none
      integer, private :: i
!
      logical :: prescribe_bv=.false.
      character(128) :: pbv_path=' '
      integer, parameter :: mx_pbv_seq=5000
      integer :: n_pbv_seq, pbv_sequence(mx_pbv_seq)
      character(64) :: br_pbv_file=' '
      character(64) :: bt_pbv_file=' '
      character(64) :: bp_pbv_file=' '
      character(64) :: vr_pbv_file=' '
      character(64) :: vt_pbv_file=' '
      character(64) :: vp_pbv_file=' '
!
      real(r_typ) :: pbv_node(mx_pbv_seq)
      real(r_typ) :: pbv_bcvfac=1._r_typ
!
      data (pbv_node(i),i=1,mx_pbv_seq) &
           /mx_pbv_seq*-1._r_typ/
!
      integer, parameter :: NULL_VALUE_PBV_SEQUENCE=-1
!
      data (pbv_sequence(i),i=1,mx_pbv_seq) &
           /mx_pbv_seq*NULL_VALUE_PBV_SEQUENCE/
!
      integer :: i_pbv_file0_contents
      integer :: i_pbv_file1_contents
      real(r_typ), dimension(:,:), allocatable ::br_pbv,bt_pbv, &
      bp_pbv,vr_pbv,vt_pbv,vp_pbv
      real(r_typ), dimension(:,:), allocatable ::br_pbv_g, &
      bt_pbv_g,bp_pbv_g,vr_pbv_g,vt_pbv_g,vp_pbv_g
!
      real(r_typ), dimension(:,:), pointer :: &
      br_pbv0_g,br_pbv1_g,bt_pbv0_g,bt_pbv1_g,bp_pbv0_g,bp_pbv1_g, &
      vr_pbv0_g,vr_pbv1_g,vt_pbv0_g, &
      vt_pbv1_g,vp_pbv0_g,vp_pbv1_g
      real(r_typ) :: deltat_pbv=0.
!
end module
!#######################################################################
module prescribe_tdc_from_file_r0
!
!-----------------------------------------------------------------------
! ****** Variables needed to prescribe Br and Vt, Vp, and Phi at R0
!-----------------------------------------------------------------------
!
      use number_types
      use types
!
      implicit none
      integer, private :: i
!
      character(128) :: tdcff_path=' '
      integer, parameter :: mx_tdcff_seq=5000
      integer :: n_tdcff_seq, tdcff_sequence(mx_tdcff_seq)
      character(64) :: br_tdcff_file=' '
      character(64) :: vt_tdcff_file=' '
      character(64) :: vp_tdcff_file=' '
      character(64) :: phi_tdcff_file=' '
!
      real(r_typ) :: tdcff_node(mx_tdcff_seq)
!
      data (tdcff_node(i),i=1,mx_tdcff_seq) &
           /mx_tdcff_seq*-1._r_typ/
!
      integer, parameter :: NULL_VALUE_TDCFF_SEQUENCE=-1
!
      data (tdcff_sequence(i),i=1,mx_tdcff_seq) &
           /mx_tdcff_seq*NULL_VALUE_TDCFF_SEQUENCE/
!
      real(r_typ), dimension(:,:), allocatable ::phi_tdc
!
      real(r_typ) :: deltat_tdcff=0.
!
      real(r_typ) :: tdc_phi
!
end module
!#######################################################################
module seam_3d_interface
      interface
        subroutine seam_3d (seam1,seam2,seam3,a)
        use number_types
        implicit none
        logical :: seam1,seam2,seam3
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_2d_interface
      interface
        subroutine seam_2d (seam1,seam2,a)
        use number_types
        implicit none
        logical :: seam1,seam2
        real(r_typ), dimension(:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_interface
      interface
        subroutine seam (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_rp_interface
      interface
        subroutine seam_rp (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_tp_interface
      interface
        subroutine seam_tp (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_rt_interface
      interface
        subroutine seam_rt (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_r_interface
      interface
        subroutine seam_r (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_t_interface
      interface
        subroutine seam_t (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_p_interface
      interface
        subroutine seam_p (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_t_2d_interface
      interface
        subroutine seam_t_2d (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_tp_2d_interface
      interface
        subroutine seam_tp_2d (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module seam_p_2d_interface
      interface
        subroutine seam_p_2d (a)
        use number_types
        implicit none
        real(r_typ), dimension(:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module global_to_local_interface
      interface
        subroutine global_to_local (f_g,f)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:) :: f_g,f
        end subroutine
      end interface
end module
!#######################################################################
module global_to_local_tp_interface
      interface
        subroutine global_to_local_tp (f_g,f)
        use number_types
        implicit none
        real(r_typ), dimension(:,:) :: f_g,f
        end subroutine
      end interface
end module
!#######################################################################
module write_field_interface
      interface
        subroutine write_field (fname,ix,a)
        use number_types
        implicit none
        character(*) :: fname
        integer :: ix
        real(r_typ), dimension(:,:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module write_field_tp_interface
      interface
        subroutine write_field_tp (fname,ix,a,iproc_r2use)
        use number_types
        implicit none
        character(*) :: fname
        integer :: ix,iproc_r2use
        real(r_typ), dimension(:,:) :: a
        end subroutine
      end interface
end module
!#######################################################################
module assemble_array_interface
      interface
        subroutine assemble_array (map_r,map_t,map_p,a,a_g)
        use number_types
        use decomposition
        use mpidefs
        implicit none
        type(map_struct), dimension(0:nproc-1) :: map_r,map_t,map_p
        real(r_typ), dimension(:,:,:) :: a,a_g
        end subroutine
      end interface
end module
!#######################################################################
module assemble_array_tp_interface
      interface
        subroutine assemble_array_tp (map_t,map_p,a,a_g)
        use number_types
        use decomposition
        use mpidefs
        implicit none
        type(map_struct), dimension(0:nproc_tp-1) :: map_t,map_p
        real(r_typ), dimension(:,:) :: a,a_g
        end subroutine
      end interface
end module
!#######################################################################
module distribute_array_interface
      interface
        subroutine distribute_array (n1,n2,n3,a_g,a)
        use number_types
        use mpidefs
        implicit none
        integer, dimension(0:nproc-1) :: n1,n2,n3
        real(r_typ), dimension(:,:,:) :: a_g,a
        end subroutine
      end interface
end module
!#######################################################################
module vnorm_interface
      interface
        function vnorm (rm,tm,pm,f)
        use number_types
        implicit none
        logical :: rm,tm,pm
        real(r_typ), dimension(:,:,:) :: f
        real(r_typ) :: vnorm
        end function
      end interface
end module
!#######################################################################
module get_cl_args_interface
      interface
        subroutine get_cl_args (narg,arg)
        implicit none
        integer :: narg
        character(*), dimension(:), pointer ::arg
        end subroutine
      end interface
end module
!#######################################################################
module parse_cl_interface
      interface
        subroutine parse_cl (narg,arg,ierr)
        implicit none
        integer :: narg,ierr
        character(*), dimension(:), pointer ::arg
        end subroutine
      end interface
end module
!#######################################################################
module hdfname_interface
      interface
        function hdfname (root,seq)
        implicit none
        character(*) :: root
        integer :: seq
        character(256) :: hdfname
        end function
      end interface
end module
!#######################################################################
module hdf_tpslice_name_interface
      interface
        function hdf_tpslice_name (root,seq1,seq2)
        implicit none
        character(*) :: root
        integer :: seq1,seq2
        character(512) :: hdf_tpslice_name
        end function
      end interface
end module
!#######################################################################
module rdhdf_2d_interface
      interface
        subroutine rdhdf_2d (fname,scale,nx,ny,f,x,y,ierr)
        use number_types
        implicit none
        character(*), intent(in) :: fname
        logical, intent(out) :: scale
        integer, intent(out) :: nx,ny
        real(r_typ), dimension(:,:), pointer, contiguous ::f
        real(r_typ), dimension(:), pointer, contiguous ::x,y
        integer, intent(out) :: ierr
        end subroutine
      end interface
end module
!#######################################################################
module rdhdf_3d_interface
      interface
        subroutine rdhdf_3d (fname,scale,nx,ny,nz,f,x,y,z,ierr)
        use number_types
        implicit none
        character(*), intent(in) :: fname
        logical, intent(out) :: scale
        integer, intent(out) :: nx,ny,nz
        real(r_typ), dimension(:,:,:), pointer, contiguous ::f
        real(r_typ), dimension(:), pointer, contiguous ::x,y,z
        integer, intent(out) :: ierr
        end subroutine
      end interface
end module
!#######################################################################
module assign_ptr_1d_interface
      interface
        subroutine assign_ptr_1d (from,to)
        use number_types
        implicit none
        real(r_typ), dimension(:), target :: from
        real(r_typ), dimension(:), pointer :: to
        end subroutine
      end interface
end module
!#######################################################################
module assign_ptr_3d_interface
      interface
        subroutine assign_ptr_3d (from,to)
        use number_types
        implicit none
        real(r_typ), dimension(:,:,:), target :: from
        real(r_typ), dimension(:,:,:), pointer :: to
        end subroutine
      end interface
end module
!#######################################################################
module ucase_interface
      interface
        function ucase (s)
        character(*), intent(in) :: s
        character(len(s)) :: ucase
        end function
      end interface
end module
!#######################################################################
module lcase_interface
      interface
        function lcase (s)
        character(*), intent(in) :: s
        character(len(s)) :: lcase
        end function
      end interface
end module
!#######################################################################
module flint_interface
      interface
        function flint (check,x,n,xn,fn,ierr,silent)
        use number_types
        logical :: check
        real(r_typ) :: x
        integer :: n
        real(r_typ), dimension(n) :: xn,fn
        integer :: ierr
        logical, optional :: silent
        real(r_typ) :: flint
        end function
      end interface
end module
!#######################################################################
module sum_p_interface
      interface
      function sum_p (npts_r,npts_p,f,w)
        use number_types
        use mesh
        implicit none
        integer :: npts_r
        integer :: npts_p
        real(r_typ),    dimension(npts_r,npts_p) :: f
        real(r_typ),    dimension(npts_p)        :: w
        real(r_typ),    dimension(npts_r)        :: sum_p
        end function
      end interface
end module
!#######################################################################
module outside_interval_interface
      interface
      function outside_interval (x0,x1,x,eps)
        use number_types
        implicit none
        real(r_typ), intent(in) :: x0,x1
        real(r_typ), intent(inout) :: x
        real(r_typ), optional :: eps
        logical :: outside_interval
        end function
      end interface
end module
!#######################################################################
module boost_interface
!$acc routine(boost) seq
      interface
        pure function boost (tempk)
          use number_types
          implicit none
          real(r_typ), intent(in) :: tempk
          real(r_typ) :: boost
        end function boost
      end interface
end module
!#######################################################################
module interp_interface
!$acc routine(interp) seq
      interface
        pure subroutine interp (n,x,xv,i,ip1,a,ierr)
          use number_types
          implicit none
          integer, intent(in) :: n
          real(r_typ), dimension(n), intent(in) :: x
          real(r_typ), intent(in) :: xv
          integer, intent(out) :: i,ip1
          real(r_typ), intent(out) :: a
          integer, intent(out) :: ierr
        end subroutine interp
      end interface
end module
!#######################################################################
module sv2cv_interface
!$acc routine(sv2cv) seq
      interface
        pure subroutine sv2cv (ar,at,ap,t,p,ax,ay,az)
          use number_types
          implicit none
          real(r_typ), intent(in) :: ar,at,ap,t,p
          real(r_typ), intent(out) :: ax,ay,az
        end subroutine sv2cv
      end interface
end module
!#######################################################################
module c2s_interface
!$acc routine(c2s) seq
      interface
        pure subroutine c2s (x,y,z,r,t,p)
          use number_types
          implicit none
          real(r_typ), intent(in) :: x,y,z
          real(r_typ), intent(out) :: r,t,p
        end subroutine c2s
      end interface
end module
!#######################################################################
module s2c_interface
!$acc routine(s2c) seq
      interface
        pure subroutine s2c (r,t,p,x,y,z)
          use number_types
          implicit none
          real(r_typ), intent(in) :: r,t,p
          real(r_typ), intent(out) :: x,y,z
        end subroutine s2c
      end interface
end module
!#######################################################################
module profile_value_interface
!$acc routine(profile_value) seq
      interface
        pure function profile_value (prof,x)
          use number_types
          use profile_def
          implicit none
          type(profile), intent(in) :: prof
          real(r_typ), intent(in) :: x
          real(r_typ) :: profile_value
        end function profile_value
      end interface
end module
!#######################################################################
module mod_input_parameter
!
!-----------------------------------------------------------------------
! ****** Atom list for calculation
!-----------------------------------------------------------------------
!
      integer :: nelem=0
      integer, parameter :: mxelem=15
      integer :: natom_list(mxelem)=0
!
!-----------------------------------------------------------------------
! ****** Data path
!-----------------------------------------------------------------------
!
      character(512) :: path_eigen=' '
end module
!#######################################################################
module mod_eigen_matrix
!
!-----------------------------------------------------------------------
! ****** err_ratetable is the accuracy of temperature in ionization
! ****** and recombination rate tables. The unit is log10(Te).
!-----------------------------------------------------------------------
!
      use number_types
!
      implicit none
      real (r_typ) , parameter :: err_ratetable=1.0e-03_r_typ
!
!-----------------------------------------------------------------------
! ****** n_element is the number of chemical elements computed in this
! ****** program.
!-----------------------------------------------------------------------
!
      integer, parameter :: n_element=15
      integer, parameter :: max_atom=30
!
!-----------------------------------------------------------------------
! ****** char_element and index_element are name and atom index for
! ****** these chemical elements.
!-----------------------------------------------------------------------
!
      character(2):: char_element(n_element)
      integer :: index_element(n_element)
      data index_element /1,2,6,7,8,10,11,12,13,14,16,18,20,26,28/
      data char_element /'H','He','C','N','O','Ne','Na','Mg','Al', &
      'Si','S','Ar','Ca','Fe','Ni'/
!
!-----------------------------------------------------------------------
! ******  nte is the total number of temperature sample points in the
! ******  ionization rate table and eigenmatrix tables. The Te ranges
! ******  from 10^4 K to 10^9 K.
!-----------------------------------------------------------------------
!
      integer, parameter :: nte=501
      real (r_typ), parameter :: dlogte=5.0_r_typ/float(nte-1)
!
!-----------------------------------------------------------------------
! ******  eigen_type is used to save eigen values and eigen vectors
! ******  for each chemical element. c is ionization rate, and r is
! ******  recombination rate. eqis saved ion fractions for equilibrium
! ******  assumption.
!-----------------------------------------------------------------------
!
      type eigen_type
        real(r_typ),pointer,contiguous:: eqis(:,:),evalues(:,:), &
                                         evector(:,:,:), &
                                         evector_invers(:,:,:), &
                                         c(:,:),r(:,:)
      end type eigen_type
!
!-----------------------------------------------------------------------
! ****** eigen includs all chemical elements.
!-----------------------------------------------------------------------
!
      type(eigen_type),dimension(n_element):: eigen
      save eigen
!$acc declare create(eigen)
!
end module
!#######################################################################
module func_solveionization_eigen_interface
!$acc routine(func_solveionization_eigen) seq
      interface
        pure subroutine func_solveionization_eigen (ichemi,natom,te, &
                                                    rho,f0,dt,ft)
          use number_types
          implicit none
          integer, intent(in) :: ichemi,natom
          real(r_typ), intent(in) :: te,rho,dt
          real(r_typ), intent(in) :: f0(natom+1)
          real(r_typ), intent(out) :: ft(natom+1)
          real(r_typ) :: f1(natom+1),f2(natom+1)
          real(r_typ) :: ene
          integer :: i,j,index_te
        end subroutine func_solveionization_eigen
      end interface
end module
!#######################################################################
module sub_solve_ionic_onestep_interface
!$acc routine(sub_solve_ionic_onestep) seq
      interface
        pure subroutine sub_solve_ionic_onestep (nelem,natom_array, &
              i_chemi_eigen,te_arr, ne_arr,dt_input,conce_ini,conce_nei)
          use number_types
          use mod_eigen_matrix
          use func_solveionization_eigen_interface
          integer, parameter:: ntime=2
          integer, intent(in) :: nelem
          integer, intent(in) :: natom_array(nelem),i_chemi_eigen(nelem)
          real(r_typ),intent(in) :: dt_input
          real(r_typ),intent(in) :: te_arr(ntime),ne_arr(ntime)
          real(r_typ),intent(in) :: conce_ini(max_atom,max_atom)
          real(r_typ),intent(out) :: conce_nei(max_atom,max_atom)
          real(r_typ) :: conce_temp_ini(max_atom,max_atom)
          real(r_typ) :: eval_arr(max_atom),dt_est_elem(nelem)
          integer:: i, n_inter, jelem
          integer:: natom
          real(r_typ):: te_sta,te_end,te_now,dd_te,ne_now, &
                        ne_s,ne_e,dt_sub
        end subroutine sub_solve_ionic_onestep
      end interface
end module
!#######################################################################
program MAS
!
!-----------------------------------------------------------------------
!
      use mpidefs
      use vars
      use time_limit
      use diagnostics
      use interplanetary_vars
      use emerging_flux_params
      use io_units
      use fluxrope_parameters
      use iso_fortran_env,  ONLY : OUTPUT_UNIT
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Set up the run and initialize fields.
!
      call setup
!
! ****** Exit the code if doing a dryrun.
!
      if (dryrun) then
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from START:'
          write (IO_OUT,*) 'DRYRUN was requested.  Ending MAS.'
          write (*,*)
          write (*,*) '### COMMENT from START:'
          write (*,*) 'DRYRUN was requested.  Ending MAS.'
        end if
        call endrun (.true.)
      end if
!
      call start
!
      if (iamp0) then
        write (*,*)
        write (*,*) '>running'
        write (*,*)
      end if
!
! ****** Timestep loop.
!
      do
!
        ntime=ntime+1
        time=time+dtime
!
        if (iamp0) then
          write (*,'(a,i8,2(a,f12.6),a)') 'NTIME = ',ntime, &
                                        ', TIME = ',time, &
                                        ', DTIME = ',dtime, &
                                      dtime_set_reason
          FLUSH (OUTPUT_UNIT)
        end if
!
! ****** Keep track of the average time step.
!
        dtime_avg=(dtime_avg*(ntime-1)+dtime)/ntime
!
! ****** Set the variables that control collection of histories.
!
        call history_check
!
! ****** Set the time profiles.
!
        call evaluate_time_profiles (time)
        call set_time_profile_variables
!
! ****** Set the cell resistivity.
!
        call celleta
!
! ****** Add flux ropes.
!
        call fluxrope_setup
        if (fluxropes_added) call fluxrope_add
!
! ****** Helicity Pumping (optional)
!
        if (helicity_pumping) call helicity_pump
!
! ****** Find the electric field boundary due to an
! ****** emerging flux or a prescribe_bv run.  Also used for
! ****** evolve_flux and rotation_flux.
!
        call newflux
!
! ****** Set time-dependent hydrostatic equilibrium boundary
! ****** conditions.
!
        call set_r0_bc
!
! ****** Get interplanetary boundary conditions
!
        if (interplanetary_run) call get_ip_boundaries
!
! ****** Set time-dependent electric field boundary conditions
! ****** at r=R0 (when using E to drive a simulation).
!
        if (ef%edrive%active) then
          call set_edrive_bc_r0
        end if
!
! ****** Advance the fields to the new time level.
!
        if (advance_a)       call adva
        if (advance_zw)      call advzw
        if (advance_t)       call advt
        if (advance_rho)     call advrho
        call setpt
        if (advance_pw)      call advpw
        if (trace_particles) call advparticles
        if (advance_fcs)     call advfcs
        if (advance_v) then
          if (freeze_b) then
            call advv_par
          else
            call advv
          end if
        end if
!
! ****** Calculate energy diagnostics.
!
        call energy
        call energy_diag
!
! ****** Set the time step for the next step.
!
        call setdt
!
! ****** Collect and plot diagnostics.
!
        call diags
!
! ****** Check if finished.
!
! ****** Set logical flag IFEND=.true. when the run is over.
!
        if (ntime.ge.ntmax.or.time.ge.tmax) ifend=.true.
!
! ****** Check if the user has requested to stop the run
! ****** prematurely.
!
        call check_if_stoprun
!
! ****** Check if the wall-clock time limit has been exceeded.
!
        if (use_wallclock_limit) then
          call check_if_wallclock_exceeded
        end if
!
! ****** End the run on a recoverable abort (IFABORT=.true.).
!
        if (ifabort.or.ifend) exit
!
! ****** Flush the output files.
!
        if (iamp0) then
          FLUSH (IO_OUT)
          FLUSH (IO_WARN)
        end if
!
      enddo
!
! ****** Write spatial diagnostics, time histories, and exit.
!
      call final_diags
!
end program
!#######################################################################
subroutine read_and_check_input_file
!
!-----------------------------------------------------------------------
!
! ****** Read the input file and check inputs.
!
! ****** The input file is read on all ranks.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh
      use meshdef
      use decomposition_params
      use diagnostics
      use cgcom
      use vars
      use dissipation_profiles
      use mpidefs
      use shear_profile
      use drive_profile
      use time_profiles
      use emerging_flux_params
      use potential_field
      use alfven_wave_pressure
      use wtd
      use flow_profile
      use heating_parameters
      use eta_photosphere
      use fluxrope_parameters
      use tdm_parameters
      use rbsl_parameters
      use fluxrope_file_parameters
      use radiative_loss_parameters
      use interplanetary_vars
      use prescribe_b_v_at_r0_vars
      use sts
      use hdf_defs
      use mod_input_parameter
      use vmod_fcs
      use io_units
      use helicity_pumping_params
      use prescribe_tdc_from_file_r0
      use ident
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Values for the global mesh size.
! ****** These are only used to input the global mesh size when
! ****** the AUTO_DECOMPOSE=.true. option is being used.
! ****** Since these names conflict with those in GLOBALS, it is
! ****** important not to use module GLOBALS here.
!
      integer :: nr=0
      integer :: nt=0
      integer :: np=0
!
!-----------------------------------------------------------------------
!
! **********************************
! ****** MAS INPUT PARAMETERS ******
! **********************************
!
      namelist /topology/          &
!
! ****** Grid resolution.
!
        nr,                        & ! Number of radial grid points.
        nt,                        & ! Number of co-latitude grid points.
        np,                        & ! Number of longitude grid points.
!
! ****** MPI decomposition options.
!
        nprocs,                    & ! MPI process topology expressed in
                                     ! a comma-separated triple of the number
                                     ! of MPI processes/ranks in the r, t, and p
                                     ! directions, (e.g. 4,5,7).  The product
                                     ! must equal the total number of MPI ranks.
                                     ! If not set, an automatic topology will be
                                     ! applied.
        auto_decompose,            & ! (Logical) Toggle of automatic grid point
                                     ! distribution across MPI ranks.
        mp_r,                      & ! Array of number of grid points per radial
                                     ! MPI rank (length is nprocs(1)), must add
                                     ! up to nr.
        mp_t,                      & ! Array of number of grid points per colat
                                     ! MPI rank (length is nprocs(2)), must add
                                     ! up to nt.
        mp_p                         ! Array of number of grid points per long
                                     ! MPI rank (length is nprocs(3)), must add
                                     ! up to np.
!
      namelist /data/ &
!
! ****** Spatial domain (ignored for restart runs).
!
        r0,                        & ! Position of the inner radial boundary
                                     ! in units of solar radii (6.96e10cm)
        r1,                        & ! Position of the outer radial boundary
                                     ! in units of solar radii
!
! ****** Time domain.
!
        time_at_start,             & ! Start time of run in mas time units.
                                     ! This will overwrite the time in restart runs.
        tmax,                      & ! End time of run in mas time units.
        ntmax,                     & ! Maximum number of time steps allowed in the run.
!
! ****** Initial condition options for the magnetic field.
!
        initial_field,             & ! Set the initial filed to one of these options:
                                     !   POTENTIAL_FIELD      : Potential field based on input map.
                                     !   DIPOLE               : Global and subsurface dipoles.
                                     !   ALFVEN_WAVE1         : Analytic Alfven wave in theta.
                                     !   ALFVEN_WAVE2         : Analytic Alfven wave in phi.
                                     !   ALFVEN_WAVE2_ROTATED : Same as ALFVEN_WAVE2 but tilted.
                                     !   A_FILE               : Read in initial vector potential from file.
                                     ! The field is alternatively set through a restart file,
                                     ! using load_fields, etc.
! ****** DIPOLE(S).
        b0_dipole,                 & ! Magnetic field strength of Sun-centered dipole.
        dipangle,                  & ! Angle (in degrees) by which the Sun-centered dipole is tilted.
        n_ssdip,                   & ! Number of subsurface dipoles to add.
        r_ssdip,                   & ! Array of subsurface dipoles radial.
        t_ssdip,                   & ! Array of subsurface dipoles theta.
        p_ssdip,                   & ! Array of subsurface dipoles phi.
        alpha_ssdip,               & ! Array of subsurface dipole moment rotations wrt N pole [deg]
        b0_ssdip,                  & ! Array of subsurface dipoles strengths.
! ****** ALFVEN_WAVES.
        wave_mode_r,               & ! Radial wave mode number for Alfven wave tests.
        wave_mode_t,               & ! Theta wave mode number for Alfven wave tests.
        wave_amplitude,            & ! Wave amplitude for Alfven wave tests.
        wave_rotation_t,           & ! Rotation/tilt in theta for ALFVEN_WAVE2_ROTATED.
! ****** POTENTIAL_FIELD.
        bnfile,                    & ! Lower boundary radial magnetic field file (hdf5).
        b_in_gauss,                & ! (Logical) toggle to indicate that the input lower
                                     ! boundary radial magnetic field file is in units of
                                     ! Gauss (.true.) or mas code units (.false.).
        b0,                        & ! If set, input Br field will be scaled so that the maximum
                                     ! normal field magnitude is b0.
        potential_field_bc,        & ! Upper boundary condition for potential field.  Options:
                                     !   CLOSED_WALL     :
                                     !   SOURCE_SURFACE  :
                                     !   MHDSS           : Specific use case, do not use.
        r_ss,                      & ! Source-surface radius for PFSS initial field.
        allow_unbalanced_flux,     & ! (Logical) toggle to add back the unbalanced flux
                                     ! to the input magnetogram.  Only works with source
                                     ! surface potential field.
! ****** A_FILE.
        afile,                     & ! Filename for text file containing 2D r-theta vector potential.
! ****** Monopole Options.
        br00,                      & ! Add artificial monopole radial field (mas magnetic field units).
        fmaxef,                    & ! Maximum expansion factor of the radial monopole specified with br00.
        r1ef,                      & ! Radius where super-radial expansion ceases.
        sigmaef,                   & ! Interval over which the expansion switches
                                     ! from super-radial to radial.
!
! ****** Initial condition options for the plasma.
!
        initial_plasma,            & ! Initial plasma.  Choices are:
                                     !   ZERO-BETA   : Zero-beta equilibrium.  Use "zb" structure
                                     !                 to set parameters, or use zb_rho_file.
                                     !   HYDROSTATIC : Hydrostatic equilibrium.  Use "hs" structure
                                     !                 to set parameters.
                                     !   STREAMER    : Same as HYDROSTATIC but with a modification to Vr
                                     !                 to force an outflowing radial solar wind (hard-wired).
                                     !   1DFILE      : Use "onedfile" text file to describe
                                     !               : spherically symmetric initial plasma
                                     !   2DFILE      : Use 2D file (in r-theta) for axisymmetric initial plasma.
                                     !   NONE
! ****** ZERO-BETA.
        zb_rho_profile,            & ! Zero-beta density profile type.  Options are:
                                     !   GENERATE_INTERNALLY : Use zb input structure to generate rho internally.
                                     !   READ_FROM_FILE      : Read the hdf5 file "zb_rho_file" to set rho.
        zb_rho_file,               & ! Filename (hdf5) for zero-beta initial density.
        zb,                        & ! Zero-beta parameters structure:
                                     !   rho0
                                     !   rho1
                                     !   rho00
                                     !   rhoexp
                                     !   b0
                                     !   b1
                                     !   lam_r0
                                     !   lam_r1
                                     !   lam_l0
                                     !   lam_l1
! ****** HYDROSTATIC.
        hs,                        & ! Hydrostatic equilibrium parameters structure:
                                     !   rho0i
                                     !   rho0f
                                     !   rho1i
                                     !   rho1f
                                     !   b0
                                     !   b1
                                     !   t0i
                                     !   t0f
                                     !   t1i
                                     !   t1f
                                     !   time0
                                     !   time1
! ****** 1DFILE.
        onedfile,                  & ! Name of text file describing the 1D initial plasma.
                                     !   Must be of the form:
                                     !   r	vr	ne	p	 pw
! ****** 2DFILE.
        twodfile_vr,               & ! Filename (hdf5) of theta-phi Vr in code units to use as initial plasma
                                     ! at lower radial boundary.  It is then used to fill in the full 3D domain.
        twodfile_rho,              & ! Filename (hdf5) of theta-phi density in code units to use as initial plasma
                                     ! at lower radial boundary.  It is then used to fill in the full 3D domain.
        twodfile_t,                & ! Filename (hdf5) of theta-phi electron temperature in code units to use as initial plasma
                                     ! at lower radial boundary.  It is then used to fill in the full 3D domain.
        const_t_rho,               & ! (Logical) toggle to either keep lower boundary 2D specified
                                     ! plasma constant when filling in the 3D domain along r (.true.) or
                                     ! use a polytropic radial scaling (.false.).
! ****** Field adding/replacing from file.
        load_fields,               & ! Structure to specify a 3D initial condition field:
                                     !   field  : Field type.
                                     !   action : Either "add" or "initial".
                                     !            "initial" replaces the current initial field, while
                                     !            "add" adds the field to the current field (B only).
                                     !   fname  : Filename (hdf5) of 3D field.
        loaded_b_clean_method,     & ! Method to clean loaded B field before afromb solves:
                                     !   0 : B is used as-is.
                                     !   1 : B is divergence-cleaned with a 3D solve.
                                     !   2 : Each r-slice of Br is flux balanced.
                                     !   3 : Applies (1) and then (2).
        long_sequence_numbers_input, & ! (Logical) toggle to indicate that input time-dept boundary files
                                     ! have a 6 (.true.) or 3 (.false.) digit number sequence.
        trace_seed_file,           & ! Filename (hdf5) that contains the initial tracer positions.
! ****** Flux ropes.
        fluxrope_preserve_br0,     & ! (Logical) If .true., the Br from the flux ropes at r=R0 is
                                     ! subtracted from the Br read in before calculating the potential field.
        tdm_fluxrope,              & ! Structure specifying a TdM flux rope.  Contains:
                                     !   add
                                     !   rope_type
                                     !   origin_r
                                     !   origin_t
                                     !   origin_p
                                     !   normal_t
                                     !   normal_p
                                     !   tilt_from_vertical
                                     !   apex_height
                                     !   footpoint_halfdistance
                                     !   minor_radius
                                     !   delta
                                     !   b_poloidal
                                     !   handedness
                                     !   add_charges
                                     !   charge_magnitude
                                     !   charge_halflength
                                     !   get_bp_from_charge
                                     !   charge_to_bp_factor
                                     !   use_major_radius
                                     !   major_radius
                                     !   insertion_time
        rbsl_fluxrope,             & ! Structure specifying an RBSL flux rope.  Contains:
                                     !   add
                                     !   path_file
                                     !   axial_current
                                     !   minor_radius
                                     !   handedness
                                     !   mirror_poloidal
                                     !   insertion_time
        rope_from_file,            & ! Structure specifying adding a flux rope from file.  Contains:
                                     !   add
                                     !   ar_file
                                     !   at_file
                                     !   ap_file
                                     !   a_factor
                                     !   insertion_time
!
! ****** Restart run options.
!
        rsifile,                   & ! Activate a restart run by setting this to a restart file filename.
        restart_calculation_frame, & ! Indicate whether the restart file was computed in the inertial
                                     ! or corotating frame (allows restarting from one frame to another).
                                     ! Options:
                                     !   INERTIAL
                                     !   COROTATING
        fname_restart_fcs,         & ! Charge state restart filename for restart runs.
        n_rs_input_file_parts,     & !   LEGACY:  Specify number of parts of an old-style multi-file restart.
        rsifile_prefix,            & !   LEGACY:  Filename prefix (path) for multi-part restart.
        rsifile_root,              & !   LEGACY:  Filename root for multi-part restart.
        rsifile_parts,             & !   LEGACY:  Explicitly list filenames of multi-part restart.
!
! ****** Output options.
!
        legacy_output_filenames,   & ! (Logical) toggle to use new output file names (.false.) or
                                     ! use the legacy file output conventions (.true.).
        hdf32,                     & ! Output fields in single (.true.) or double (.false.) precision.
        long_sequence_numbers,     & ! (Logical) toggle to set output hdf5 files to have
                                     ! a 6 (.true.) or 3 (.false.) digit number sequence.
        plotlist,                  & ! Comma-separated list of fields to plot.  Available fields are:
                                     !   vr, vt, vp, br, bt, bp, rho, t, p, pres, jr, jt, jp, ar, at, ap,
                                     !   sifac, heat, ep, em, vr_old, vt_old, vp_old, eta, visc,
                                     !   zp, zm, te, tp, efr, eft, efp, v_par
                                     ! Not all fields are valid for all runs; p and pres are the same.
        ipltxint,                  & ! Iteration cadence to write out field data (hdf5).
        tpltxint,                  & ! Time cadence to write out field data (mas time units).
        slice_plotlist,            & ! Comma-separated list of fields to plot slices of.
                                     ! Choices are the same as those of plotlist.
        slice_ixint,               & ! Iteration cadence to write out field data slices (hdf5).
        slice_txint,               & ! Time cadence to write out field data slices (mas time units).
        slice_tp_radii,            & ! Comma-separated list of radial points
                                     ! to take theta-phi slices at (in solar radii).
        trace_ixint,               & ! Iteration cadence to write out tracer data.
        trace_txint,               & ! Time cadence to write out tracer data (mas time units).
        plot_dump_fcs,             & ! (Logical) to activate charge state 3D hdf5 oputput.
                                     ! Cadence same as field 3D plots ([i|t]pltxint).
        slice_dump_fcs,            & ! (Logical) to activate charge state 2D theta-phi slice hdf5 output.
                                     ! Cadence same as slice plots (slice_[i|t]xint).
        irsdump,                   & ! Iteration cadence to write out restart files (hdf5).
        trsdump,                   & ! Time cadence to write out restart files (mas time units).
        rs_final,                  & ! (Logical) toggle to write a restart file at the end of a run.
        ihistint,                  & ! Iteration cadence to write out histories into text file.
        thistint,                  & ! Time cadence to write out histories into text file (mas time units).
        diag,                      & ! Diagnostic (in-situ) point structure.  Contains:
                                     !   type
                                     !   fields
                                     !   r
                                     !   t
                                     !   p
!
! ****** Grid specification (ignored for restart runs).
!
        rfrac,                     & ! Normalized positions of radial grid
                                     ! segment boundaries (as a fraction of
                                     ! domain size)
        drratio,                   & ! Ratio of radial grid spacing at the end
                                     ! of each segment to its beginning
                                     ! [ length(drratio) = length(rfrac)-1 ].
        nfrmesh,                   & ! Number of times to filter colatitude grid
                                     ! spacing.
        tfrac,                     & ! Normalized positions of colatitude grid
                                     ! segment boundaries (as a fraction of
                                     ! domain size)
        dtratio,                   & ! Ratio of colat grid spacing at the end
                                     ! of each segment to its beginning
                                     ! [ length(drratio) = length(rfrac)-1 ].
        nftmesh,                   & ! Number of times to filter colatitude grid
                                     ! spacing.
        pfrac,                     & ! Normalized positions of longitude grid
                                     ! segment boundaries (as a fraction of
                                     ! domain size)
        dpratio,                   & ! Ratio of long grid spacing at the end
                                     ! of each segment to its beginning
                                     ! [ length(drratio) = length(rfrac)-1 ].
        nfpmesh,                   & ! Number of times to filter longitude grid
                                     ! spacing.
        phishift,                  & ! Apply longitude shift (radians) to the
                                     ! longitude grid.
!
! ****** Time step options.
!
        dtmax,                     & ! Maximum allowed time step in mas time units.
        dtmin,                     & ! Minimum allowed time step in mas time units.
                                     ! If the time step drops below this, the run stops.
        dt_init,                   & ! Initial time step to try. If not set, dtmax will be used.
                                     ! By default, this is not used for restart runs.
        use_dt_init_on_restart,    & ! (Logical) toggle to use the dt_init for a restart run (.true.)
                                     ! of not (.false.).
        dt_max_wave_cfl,           & ! Maximum allowed wave CFL (implicitness).  If wave CFL
                                     ! exceeds this limit, the time step is reduced accordingly.
        cfl,                       & ! Fraction of the CFL time step limit to use.
        dt_max_increase_fac,       & ! Fraction the time step is allowed to increase per step.
!
! ****** General model options.
!
        calculation_frame,         & ! String indicating the frame of reference of the calculation.
                                     ! These also effect how boundary driving is performed.
                                     !   INERTIAL   : Inertial frame.
                                     !   COROTATING : Corotating frame (adds Coriolis and centrifugal forces).
        g0,                        & ! Gravity at the solar surface (code units).
        omega_corotate,            & ! Solar rotation rate in mas units.
        he_frac,                   & ! Helium fraction.
        char_bc0,                  & ! Activate lower characteristic radial boundary condition.
        char_bc1,                  & ! Activate upper characteristic radial boundary condition.
        nfiltub,                   & ! Number of times to filter parallel velocity in
                                     ! lower characteristic boundary condition (default 2).
        ubzero,                    & ! Set flow at inner boundary to zero if it is negative.
        tbc0,                      & ! Temperature in K of the lower radial boundary.
        tchromo,                   & ! Temperature in K of the lower radial boundary used for radiative loss function.
        rho0,                      & ! Density of the lower radial boundary.
!
! ****** Time profiles for various quantities.
!
        tprofile,                  & ! Add a time profile structure.  Contains:
                                     !   t
                                     !   f
                                     !   filename
                                     !   vars
                                     !   on
                                     !   nodes
                                     !   nvars
                                     !   value
                                     ! Available "vars":
                                     !   eta
                                     !   visc
                                     !   v0
                                     !   eflux_psi_e0
                                     !   eflux_phi_e0
                                     !   flow_norm_factor
                                     !   flow_trans_factor
                                     !   eta_photosphere
                                     !   pw0_factor
                                     !   eflux_vr
                                     !   eflux_br
                                     !   edrive_e0
                                     !   edrive_er
                                     !   edrive_et
                                     !   edrive_ep
                                     !   edrive_vr
                                     !   edrive_vt
                                     !   edrive_vp
                                     !   rho_limit
                                     !   io_dump_3d
                                     !   io_dump_tracers
                                     !   io_dump_slices
                                     !   helicity_pumping
                                     !   ohmic_heating_factor
                                     !   zw_heat_factor
                                     !   zw_pressure_factor
                                     !   tdc_phi
!
! ****** Induction equation and resistivity.
!
        advance_a,                 & ! (Logical) toggle to activate vector potential advance (induction equation).
        experimental_a_advance,    & ! (Logical) to activate experimental algorithm for advancing A. DO NOT USE.
        bt_photo_in,               & ! Specifies amount (code units) of transverse field (theta) to
                                     ! advect into the corona from the lower boundary.
        bp_photo_in,               & ! Specifies amount (code units) of transverse field (phi) to
                                     ! advect into the corona from the lower boundary.
        slund,                     & ! Inverse uniform resistivity (1/eta) in code units.
        ifeta_phot,                & ! (Logical) toggle to activate photospheric resistivity.
        eta_phot,                  & ! Photospheric diffusion coefficient.
        eta_phot_file,             & ! Filename (hdf5) to read a photospheric diffusion profile.
        eta_profile,               & ! Type of eta profile.  Options:
                                     !   UNIFORM
                                     !   RADIALLY_DEPENDENT
                                     !   HIGH_SLUND_REGION
                                     !   CUSTOM_TP+R_PROFILE
                                     !   CUSTOM_PROFILE
        eta_profile_r,             & ! Radial eta profile structure.  Contains:
                                     !   active
                                     !   f(3)
                                     !   x(2)
                                     !   w(2)
        eta_profile_tp_file,       & ! Filename (hdf5) of theta-phi eta profile.
        eta_profile_file,          & ! Filename (hdf5) of 3D eta profile.
        eta_fac_0,                 & ! Radial-dept eta profile parameter.
        eta_fac_1,                 & ! Radial-dept eta profile parameter.
        r_eta_crit,                & ! Radial-dept eta profile parameter.
        dr_eta_crit,               & ! Radial-dept eta profile parameter.
        slund_low,                 & ! High_Slund_Region parameter.
        slund_high,                & ! High_Slund_Region parameter.
        dynamic_eta,               & ! (Logical) toggle to activate cell-based eta
                                     ! based on upwind diffusion.
        rmcell,                    & ! Specify the cell magnetic Reynolds number
                                     ! for dynamic eta.
        rmcell_etamax,             & ! Specify the maximum allowed value for eta
                                     ! for dynamic eta.
        eta_bg,                    & ! Background uniform resistivity to add to standard
                                     ! eta.  Useful when using custom eta profiles with
                                     ! time profile control.
        phi_0,                     & ! Used for both eta and visc for high
                                     ! slund or low visc region modes.  Sets the region
                                     ! for the high and low.
        phi_1,                     & ! Used for both eta and visc for high
                                     ! slund or low visc region modes.  Sets the region
                                     ! for the high and low.
        theta_0,                   & ! Used for both eta and visc for high
                                     ! slund or low visc region modes.  Sets the region
                                     ! for the high and low.
        theta_1,                   & ! Used for both eta and visc for high
                                     ! slund or low visc region modes.  Sets the region
                                     ! for the high and low.
        eta_uw_mult,               & ! LEGACY: Scales the upwind resistivity in
                                     ! experimental A advance.
!
! ****** Momentum equation and viscosity.
!
        advance_v,                 & ! (Logical) toggle to activate velocity advance (momentum equation).
        zero_v_parallel,           & ! Zero-out parallel flow.  Useful for zero-beta runs.
        visc,                      & ! Uniform viscosity coefficient (nu) in code units.
        visc_bg,                   & ! Uniform viscosity coefficient to add as
                                     ! background when using custom visc profile runs.
        visc_profile,              & ! Type of viscosity profile.  Options:
                                     !   UNIFORM
                                     !   RADIALLY_DEPENDENT
                                     !   LOW_VISC_REGION
                                     !   CUSTOM_TP+R_PROFILE
                                     !   CUSTOM_PROFILE
        visc_profile_r,            & ! Radial viscosity profile structure.  Contains:
                                     !   active
                                     !   f(3)
                                     !   x(2)
                                     !   w(2)
        visc_profile_tp_file,      & ! Filename (hdf5) of theta-phi viscosity profile.
        visc_profile_file,         & ! Filename (hdf5) of 3D viscosity profile.
        visc_fac_0,                & ! Radial-dept viscosity profile parameter.
        visc_fac_1,                & ! Radial-dept viscosity profile parameter.
        r_visc_crit,               & ! Radial-dept viscosity profile parameter.
        dr_visc_crit,              & ! Radial-dept viscosity profile parameter.
        visc_low,                  & ! LOW_VISC_REGION parameter.
        visc_high,                 & ! LOW_VISC_REGION parameter.
        visc_rho_outside,          & ! (Logical) toggle to compute viscosity as rho*Div(nu-Grad-V) (.true.)
                                     ! or Div(nu-rho-Grad-V) (.false.).
!
! ****** Energy equation, thermal conduction, radiative loss, and heating.
!
        advance_t,                 & ! (Logical) toggle to activate temperature advance (energy equation).
        gamma,                     & ! Ratio of specific heats (e.g. 5/3 for corona, 3/2 for heliosphere).
        advance_tp,                & ! (Logical) toggle to activate the proton temperature advance,
                                     ! along with coupling with electron density.
        iftfloor,                  & ! (Logical) to activate temperature flooring.
        tfloor,                    & ! Value in Kelvin for the temperature floor.
        ifcheck0temp,              & ! (Logical) to activate check of negative temperature.
! ****** Thermal conduction (Collisional).
        advance_tc,                & ! (Logical) toggle to activate Spitzer thermal conduction.
        t_cutoff1,                 & ! Cut-off temperature (in K) for modifying Spitzer thermal conduction.
        tcond,                     & ! Multiplier for electron thermal conduction term.  Must be set >0
                                     ! for thermal conduction to work (e.g. tcond=1.0).
        tcondp,                    & ! Multiplier for proton thermal conduction term.  Must be set >0
                                     ! for proton thermal conduction to work (e.g. tcond=1.0).
        tc_r,                      & ! Thermal conduction radial taper function parameter.
        tc_dr,                     & ! Thermal conduction radial taper function parameter.
        tc_fac0,                   & ! Thermal conduction radial taper function parameter.
        tc_fac1,                   & ! Thermal conduction radial taper function parameter.
        nfilt_kappa,               & ! Number of times to apply a filter to kappa.
        kappa_mask_file,           & ! Filename (hdf5) of [0,1] 3D mask to transition
                                     ! from field-aligned kappa to isotropic.
! ****** Collisionless thermal conduction (CTC).
        use_radial_nocoll,         & ! LEGACY: (Logical) to use old radial-only CTC.
        alpha_nocoll,              & ! CTC multiplicative factor.  If >0, activates CTC.
        alpha_nocoll_p,            & ! CTC multiplicative factor for protons. If >0, activates CTC.
        tc_nocoll_r,               & ! CTC radial increase function parameter.
        tc_nocoll_dr,              & ! CTC radial increase function parameter.
! ****** Radiative loss.
        radloss,                   & ! Factor to multiply by radiative loss.
                                     ! Set to 0 to deactivate radloss, 1.0 to use it fully.
        ifimplrad,                 & ! Set to 1.0 to use implicit radiative loss algorithm.
        rad_law,                   & ! Set radiative loss function.  Choices are:
                                     !   ATHAY
                                     !   ROSNER
                                     !   RTV
                                     !   CHIANTI_v71_CORONA
                                     !   CHIANTI_v71_PHOTO
                                     !   CHIANTI_v713_HYBRID
        legacy_q_chromo_reduction, & ! LEGACY: (Logical) toggle to use the old-style
                                     ! way to taper radiative loss towards zero.
! ****** Coronal heating.
        heatsource,                & ! Structure to specify a heating source.
                                     ! Options:
                                     !   active
                                     !   name
                                     !   type
                                     !   h0
                                     !   lambda
                                     !   power
                                     !   brmax
                                     !   center_gaussian
                                     !   r_profile
                                     !   t_profile
                                     !   b_profile
                                     !   time_profile
                                     !   b_attenuation
                                     !   b_cutoff
                                     !   q0
                                     !   q1
                                     !   lambda0
                                     !   lambda1
                                     !   use_mask.
                                     !   nl_mask
                                     ! Options for "type":
                                     !   exponential
                                     !   two-exponential
                                     !   exponential-b-photo-dependent
                                     !   b-dependent
                                     !   br-dependent
                                     !   gaussian
                                     !   zw-exponential
        heating_flat_topped,       & ! (Logical) to toggle flat-topping the heating with "heat_max".
                                     ! (NOT including ohmic heating).
        heat_max,                  & ! Maximum heating amount (in code units) if "heating_flat_topped" is set.
                                     ! Note that ohmic heating is applied AFTER the flat-top.
        heat_mask_file,            & ! Filename (hdf5) of 3D heat mask [0,1] to use.
        add_ohmic_heating,         & ! (Logical) toggle to add Ohmic heating to heating function.
        heat_file,                 & ! Filename (hdf5) of 3D heating (mas units) to add.
        f_heating,                 & ! Percentage [0,1] of heating that goes to electrons vs.
                                     ! protons in the two-temp model.
        use_chromo_heat,           & ! (Logical) toggle to activate chromospheric heating.
                                     ! NOTE! This modifies the radiative loss function!
        chromo_heat_t_zqc_0,       & ! Minimum temperature (mas units) of radloss cutoff.
                                     ! This is where the radloss -> zero exactly.
        chromo_heat_t_zqc_1,       & ! Upper temperature (mas units) of the chromo heating
                                     ! modification polynomial.
!
! ****** Density advance.
!
        advance_rho,               & ! (Logical) toggle to activate density advance.
        ifcheck0rho,               & ! (Logical) toggle to check for negative density and quit if found.
        ifcheck0pres,              & ! (Logical) toggle to check for negative presure and quit if found.
        ifrholimit,                & ! (Logical) toggle to activate rho limiter.
        rho_limit_file,            & ! Filename (hdf5) of 3D rho limit (floor).
        rho_limit_factor,          & ! Scalar factor to multiply rho_limit loaded from file.
        max_alfven_speed_rho_mod,  & ! If set >0, this activates a modification that
                                     ! changes rho such that the Alfven speed is less than the
                                     ! maximum specified here (code units).
        rhobc_maxfac_r1,           & ! Setting this dimensionless constant will limit the
                                     ! values of rho as it is extrapolated beyond the half
                                     ! mesh boundaries. This can prevent the extrapolated
                                     ! rho from ever going negative.
!
! ****** WKB pressure waves.
!
        advance_pw,                & ! (Logical) toggle to activate WKB pressure waves.
        pw0,                       & ! Amplitude of pressure waves.
        rho_aw,                    & ! Slow down the time scale of WKB evolution by this
                                     ! factor to speed up the PW advance but
                                     ! can be suspect if ep/m has comparable dynamic
                                     ! timescales to the MHD evolution.
        use_pw_theta_profile,      & ! (Logical) to turn on a theta profile for PW.
        awthprof_th,               & ! Lower limit parameter for PW theta profile.
        awthprof2_th,              & ! Upper limit parameter for PW theta profile.
        awthprof_dth,              & ! Width parameter for PW theta profile.
        ifcheck0pw,                & ! (Logical) toggle to check for negative pw and quit if found.
        dissipate_aw,              & ! Dissipate the PW advance.
        modulate_pw0,              & ! Modulate the PW advance.
        dbob_aw,                   & ! PW dissipation parameter.
        wdbob_aw,                  & ! PW dissipation parameter.
        tau_aw,                    & ! PW dissipation parameter.
        use_pw_rcut,               & ! (Logical) Set to manually cutoff the wave pressure
                                     ! force below a certain height.
                                     ! NOTE: This also applies to WTD.
        pw_rcut_r0,                & ! Center radius for the tanh cutoff function.
        pw_rcut_width,             & ! Width of the tanh cutoff function.

!
! ****** WTD heating and pressure waves.
!
        advance_zw,                & ! (Logical) toggle to activate WTD turbulence waves.
        wtd_z0,                    & ! Amplitude of outgoing waves at the inner boundary.
        wtd_b0,                    & ! Reference value of B in the dissipation constant.
        wtd_lambda0,               & ! Reference length scale in dissipation constant.
        wtd_reflect_bc,            & ! The BC for the wave leaving the domain at r0. Options:
                                     !   NONE : Let the wave pass through (default).
                                     !   CONS : Reflect the wave such that the net Poynting flux
                                     !          is ALWAYS matching the outward Poynting flux.
                                     !   AMPL : Reflect the amplitude, adding it to the outgoing wave.
        wtd_add_zw_heating,        & ! (Logical) toggle to add WTD heating to temperature advance.
        wtd_add_zw_pressure,       & ! (Logical) toggle to add WTD pressure term to the velocity
!                                      advance. This refers to zp,zm ONLY, which are seperate
!                                      pressures from the ep,em advance.
        wtd_icond,                 & ! Sets the 3D initial condition of zp,zm. Options:
                                     !   CONSTANT  : Set zp/zm to a constant value.
                                     !   WKB       : Use 3D rho and WKB approx w/ v=0 set+zp and -zm.
                                     !   WKB_BR    : Like WKB but check Br to assign zp or zm only.
                                     !   EPEM      : Use the wave energies in ep and em to get zp and zm.
                                     !   FROM_FILE : Set the radial zp, zm profiles from a 1D file.
        wtd_ic1dfile,              & ! Filename (hdf5) for 1D initial WTD "FROM_FILE".
        wtd_icfac,                 & ! This constant multiplies all the initial
                                     ! conditions except 'constant' where instead the
                                     ! value is set directly.
        zw_dissp,                  & ! (Logical) toggle to turn the dissipation term.
        zw_reflection,             & ! (Logical) toggle to turn the reflection term.
        zw_uwc_s,                  & ! Upwind coefficient when computing the gradients
                                     ! in the propagation and Dissipation terms.
        zw_uwc_z,                  & ! Upwind coefficient when computing the gradients
                                     ! in v dot grad z term
        zw_cfl,                    & ! CFL factor for the ZW advance.
        wtd_use_zw_limit,          & ! (Logical) toggle to impose limits to the maxium
                                     ! absolute values of zp and zm. This can be done as a constant
                                     ! and/or as a radial profile.
        zw_limit_amplitude,        & ! Maximum value for zp & zm (mas units).
        zw_limit_radial_file,      & ! Filename (hdf5) of 1D radial profile for the
                                     ! maximum absolute value of wave amplitude.
        zw_flux_limiter_type,      & ! Flux limiting function to use for ZW.  Options:
                                     !   OSPRE
                                     !   MINMOD
        wtd_use_flux_limiter_gradzw,  & ! (Logical) toggle to use 2nd order flux-limiting
                                          ! scheme for the v dot grad z term.
        wtd_use_flux_limiter_gradsrc, & ! (Logical) toggle to use 2nd order flux-limiting
                                          ! scheme for the propagation and reflection terms
        wtd_use_zw_effective_rho_limit, & ! Create a "fake" base density for the corona as
                                          ! seen by zw. This works by turning off reflection
                                          ! and dissipation smoothy above a certain density
                                          ! value to avoid over-reflection w/ smooth Br0.
        zw_effective_rho_limit_lr, & ! Set to log(rho0) for the center of the smooth tanh profile.
        zw_effective_rho_limit_lw, & ! Set to log(rho_width) for the width of the tanh profile in log-space.
        zw_rho_aw,                 & ! Slow down the time scale of WTD evolution by this
                                     ! factor to speed up the ZW advance but
                                     ! can be suspect if zp/m has comparable dynamic
                                     ! timescales to the MHD evolution.
        wtd_bc_extrap_fac_r1,      & ! Dimensionless constant to limit the extrapolation
                                     ! of va in getva_zw past the radial boundaries.
                                     ! This works by making va_outside no less than va_inside and
                                     ! it can be used to prevent negative extrapolated values.
        wtd_use_zw_horho_limit,    & ! (Logical) toggle to limit the heating per mass density
                                     ! to avoid blowing up in the solar wind when something
                                     ! is suspect with zp,zm evolution at these heights (e.g. CME).
        zw_horho_limit_rlim,       & ! Radius above which to apply the limiter.
        zw_horho_limit_value,      & ! Maximum value of heat/rho (mas units).
        wtd_use_zw_flux_mask,      & ! (Logical) toggle to read a 2D profile that specifies
                                     ! a fractional reduction to the outward Poynting flux.
                                     ! This will hit the outward z0 amplitude by sqrt of the
                                     ! profile.
        z0_flux_mask_tp_file,      & ! Filename (hdf5) for theta-phi zw flux mask.
        wtd_use_open_field_cutoff, & ! (Logical) toggle to activate a Poynting flux limiter that
                                     ! limits the amount of heat dumped into open field lines.
        wtd_open_cutoff_maxflux,   & ! Flux limit set in CGS units (erg s-1 cm-2).
        wtd_open_cutoff_dt_eq_s,   & ! "Equilibrate" the limiter slowly at a timescale specified in
                                     ! seconds (updates a moving average).
!
! ****** Charge states (see also the charge states parameter namelist below).
!
        advance_fcs,               & ! (Logical) toggle to activate charge state model.
        if_vmod,                   & ! Slow down the ions in the lower corona and
                                     ! increase their ionization level.
        r_vmod,                    & ! Specifies the radius below which the ion
                                     ! velocity is switched off.
        dr_vmod,                   & ! Sets the radial interval over which the mod occurs.
        tmod1,                     & ! Modify the temperature in calculating charge states.
        tmod0,                     & ! Modify the temperature in calculating charge states.
!
! ****** Boundary driving of corona.
!
        evolve_flux,               & ! Must set this to .true. to use time_dependent_corona
!
! ****** Boundary driving of coronal flux.
!
        rotation_flux,             & ! (Logical) Set to .false. to use VxB boundaries.
                                     ! If .true., some form of driving must be activated.
        emerging_flux,             & ! (Logical) to activate emerging flux.
        eflux,                     & ! Structure specifying flux driving. Contains:
                                     !   phi_driven
                                     !   psi_driven
                                     !   e_driven
                                     !   phi_file
                                     !   psi_file
                                     !   normalize_phi
                                     !   normalize_psi
                                     !   vr_set
                                     !   vr_file
!
! ****** Boundary driving of corona with B and V (PBV).
!
        prescribe_bv,              & ! (Logical) to activate B and V driving.
        pbv_path,                  & ! System path to where the PBV files are located.
        pbv_sequence,              & ! Comma-seperated list of times for
                                     ! sequence of boundary files (mas units).
        pbv_node,                  & ! Comma-separated list of file indices for
                                     ! sequence of boundary files.
        deltat_pbv,                & ! Time offset (mas units) to apply to pbv_sequence list.
        br_pbv_file,               & ! Base filename of Br boundary files.
                                     ! E.g. if files are "PATH/br_test001.h5", set
                                     ! br_pbv_file='br_test'
        bt_pbv_file,               & ! Base filename of Bt boundary files.
        bp_pbv_file,               & ! Base filename of Bp boundary files.
        vr_pbv_file,               & ! Base filename of Vr boundary files.
        vt_pbv_file,               & ! Base filename of Vt boundary files.
        vp_pbv_file,               & ! Base filename of Vp boundary files.
        pbv_bcvfac,                & ! Factor to multiply boundary velocity values.
        if_pchip,                  & ! (Logical) toggle to activate pchip interpolation for PBV.
                                     ! Set to .false. if using "time_dependent_corona_from_files"
                                     ! (pchip is still used)
!
! ****** Time-dependent corona driving (B, V, and Phi).
!
        time_dependent_corona,     & ! (Logical) toggle to activate TDC driving.
        tdc_edb_correction_trunc,  & ! Apply correction to preserve Br evolution but
                                     ! truncate at neutral lines.
        tdc_edb_correction_etmod,  & ! Apply correction to E-tangential at neutral lines
                                     ! to better enforce E.B~0.  This will not
                                     ! strictly preserve Br evolution at neutral lines.
        tdc_edb_correction_etmod_eta, & ! Apply photospheric resistivity of this amplitude.
                                        ! Can help preserve Br evolution at neutral lines.
        tdc_edb_br_eps,            & ! Limiing Br value for above two corrections.
        tdc_edb_btp_a,             & ! Limit the size of E_r/E_t at the neutral line.
        tdc_edb_btp_d,             & ! Limit the perpendicular velocity as a
                                     ! fraction of the sound speed.
        time_dependent_corona_from_files, & ! (Logical) toggle to activate TDC driving from files.
        tdcff_path,                & ! System path to where the boundary files are located.
        br_tdcff_file,             & ! Base filename of Br boundary files (see br_pbv_file).
        vt_tdcff_file,             & ! Base filename of Vt boundary files.
        vp_tdcff_file,             & ! Base filename of Vp boundary files.
        phi_tdcff_file,            & ! Base filename of PHI boundary files.
        tdcff_sequence,            & ! Comma-seperated list of times for
                                     ! sequence of boundary files (mas units).
        tdcff_node,                & ! Comma-separated list of file indices for
                                     ! sequence of boundary files.
        deltat_tdcff,              & ! Time offset (mas units) to apply to pbv_sequence list.
!
! ****** Surface flows and shear.
!
        flow,                      & ! Flow structure for specifying surface flows.
                                     ! Contains same fields as "shear" structure.
        arotate,                   & ! Differential rotation parameter.
        brotate,                   & ! Differential rotation parameter.
        crotate,                   & ! Differential rotation parameter.
        v_north,                   & ! Meridional flow parameter.
        v_south,                   & ! Meridional flow parameter.
        v_drive,                   & ! Velocity driving speed (mas units).
        v_flow_norm,               & ! Magnitude of normal velocity flow.
        v_flow_trans,              & ! Magnitude of transverse velocity flow.
        shear,                     & ! Shear structure for specifying surface flows.
                                     ! Contains:
                                     !   active
                                     !   type
                                     !   mask_t0
                                     !   mask_p0
                                     !   mask_width_t
                                     !   mask_width_p
                                     !   mask_angle
                                     !   dthmax
                                     !   th0
                                     !   power
                                     !   file_r
                                     !   file_t
                                     !   file_p
                                     !   normalize_vtrans
                                     !   normalize_vnorm
!
! ****** Helicity pumping.
!
        helicity_pumping,          & ! (Logical) toggle to activate helicity pumping.
        hpump_cadence,             & ! Cadence (mas time units) for helicity pumps.
        hpump_time_offset,         & ! Offset time (mas units) for cadence.
        hpump_constant,            & ! Overall multiplier.
        hpump_profile,             & ! Type of helicity pumping profile.  Options:
                                     !   UNIFORM
                                     !   RADIALLY_DEPENDENT
                                     !   CUSTOM_TP+R_PROFILE
                                     !   CUSTOM_PROFILE
        r_hpump_crit,              & ! Radial-dept helicity pumping profile parameter.
        dr_hpump_crit,             & ! Radial-dept helicity pumping profile parameter.
        hpump_fac_0,               & ! Radial-dept helicity pumping profile parameter.
        hpump_fac_1,               & ! Radial-dept helicity pumping profile parameter.
        hpump_profile_r,           & ! Radial helicity pumping profile structure.  Contains:
                                     !   active
                                     !   f(3)
                                     !   x(2)
                                     !   w(2)
        hpump_profile_tp_file,     & ! Filename (hdf5) of theta-phi helicity pumping profile.
        hpump_profile_file,        & ! Filename (hdf5) of 3D  helicity pumping profile.
!
! ****** Tracer particles.
!
        trace_particles,           & ! (Logical) toggle to activate tracer particles.
        trace_reseed_type,         & ! String to indicate what to do when tracers leave the outer
                                     ! radial domain.  Choices are:
                                     !   NONE       : Do nothing (positions are "stuck" on boundary.
                                     !   R_PERIODIC : Re-seed the tracers at a specified radius.
        trace_reseed_r0,           & ! Radius (in Rs) to reseed tracer particles when they leave the domain.
        trace_track_ds,            & ! (Logical) toggle to activate tracking total distance for
                                     ! tracer particles.
!
! ****** Semi-implicit operator options.
!
        isitype,                   & ! Toggle semi-implicit term 1: on  0: off (explicit).
        simult,                    & ! Factor to multiply the semi-implicit term.
        si_aggressive,             & ! (Logical) toggle to use non-uniform SI factor (.true.)
                                     ! or a uniform max value (.false.).
        si_local_kv,               & ! (Logical) toggle to use non-uniform SI flow term (.true.)
                                     ! of a uniform max CFL value (.false.).
        fac_cflv,                  & ! Semi-implicit term CFL factor.
!
! ****** "Freeze-B" mode.  Freeze the field and allow flow along field lines.
!
        freeze_b,                  & ! (Logical) toggle to activate the "freeze-B" mode.
        bhat_mask_file,            & ! Filename (hdf5) of 3D mask [0,1] that
                                     ! transitions b-hat from being aligned along B
                                     ! to being aligned along the radial direction.
!
! ****** Field line mode.
!
        fl_compute,                & ! (Logical) toggle to activate field line computation.
        fl_file,                   & ! Filename (hdf5) containing 1D field line.
!
! ****** Numerical algorithm options.
!
        use_old_jxb,               & ! Use legacy JxB calculation (.true.) or not (.false.).
        use_old_vdgv,              & ! Use older V-dot-Grad-V calculation (.true.)
                                     ! or use experimental one (.false.).
                                     ! Only use the old one.
        upwind_a,                  & ! Upwind factor for all components of vector potential
                                     ! advection (real value [0,1]).
                                     !   0: Central difference
                                     !   1: Full upwind
        upwind_ar,                 & ! Upwind factor for radial component of vector potential.
        upwind_at,                 & ! Upwind factor for theta component of vector potential.
        upwind_ap,                 & ! Upwind factor for phi component of vector potential.
        upwind_v,                  & ! Upwind factor for velocity advection (see upwind_a).
        upwind_t,                  & ! Upwind factor for temperature advection (see upwind_a).
                                     ! This is for both TE and TP.
        upwind_rho,                & ! Upwind factor for density advection (see upwind_a).
        pred_v,                    & ! (Logical) toggle to use predictor in momentum equation.
        pred_a,                    & ! (Logical) toggle to use predictor in induction equation.
        pred_t,                    & ! (Logical) toggle to use predictor in energy equation.
        pred_rho,                  & ! (Logical) toggle to use predictor in density advance.
        betapc_v_flow,             & ! Factor to multiply advection term in momentum predictor.
        betapc_v_wave,             & ! Factor to multiply wave term in momentum predictor.
        betapc_t_flow,             & ! Factor to multiply advection term in energy predictor.
        betapc_t_wave,             & ! Factor to multiply wave term in energy predictor.
        betapc_rho_flow,           & ! Factor to multiply advection term in density predictor.
        betapc_rho_wave,           & ! Factor to multiply wave term in density predictor.
        betapc_si,                 & ! Factor for semi-implicit term in predictor (real, [0,1]).
        betapc_a,                  & ! Factor for VxB (vector potential) advection predictor.
! ****** Super time stepping (ESRK) and PTL options.
        use_sts_visc,              & ! (Logical) Set to .true. to use a STS method for viscosity
                                     ! instead of PCG. (By default also activates PTL).
        use_sts_tc,                & ! (Logical) Set to .true. to use a STS method for thermal
                                     ! conduction instead of PCG. (By default also activates PTL).
        sts_type,                  & ! Select which STS method to use:
                                     !   1: RKL1
                                     !   2: RKL2
                                     !   3: RKG2
        visc_auto_subcycle,        & ! Use PTL time-step subcycling for viscosity.
        visc_subcycles_max,        & ! Maximum allowed subcycles for PTL for viscosity.
        visc_subcycles,            & ! Set fixed number of subcycles for viscosity.
        tc_auto_subcycle,          & ! Use PTL time-step subcycling for thermal conduction.
        tc_subcycles_max,          & ! Maximum allowed subcycles for PTL for thermal conduction.
        tc_subcycles,              & ! Set fixed number of subcycles for thermal conduction.
! ****** Preconditioned Conjugate Gradient solver options.
        ncghist,                   & ! Write solver iteration residuals every ncghist iterations.
                                     ! Note that initial potential field solvers use ncghist=100
                                     ! unless ncghist is set greater than 0.
        ncgmax,                    & ! Maximum allowed number of solver iterations (all solvers).
                                     ! If exceeded, the run stops.
        ifprec_t,                  & ! Set preconditioner (PC) type for thermal conduction solver:
                                     !   0: None
                                     !   1: Diagonal scaling
                                     !   2: SGS
                                     !   3: ILU0
                                     ! Note this setting can be overridden when running on GPUs.
        ifprec_a,                  & ! PC type for resistivity solver (see ifprec_t).
        ifprec_v,                  & ! PC type for momentum and viscosity solvers (see ifprec_t)
        ifprec_divb,               & ! PC type for remesh divB cleaner solver (see ifprec_t)
        ifprec_pot2d,              & ! PC type for 2D potential field solvers (see ifprec_t)
        ifprec_pot3d,              & ! PC type for 3D potential field solver:
                                     !   0: None
                                     !   1: Diagonal scaling
        ifprec_32,                 & ! Logical toggle to use single-precision (.true.)
                                     ! or double precision (.false.) solver preconditioners.
        epscg_a,                   & ! Convergence tolerance for resistivity solve.
        epscg_v,                   & ! Convergence tolerance for semi-implicit and viscosity solves.
        epscg_t,                   & ! Convergence tolerance for thermal conduction solves.
        epscg_potfld,              & ! Convergence tolerance for initial potential solves.
        epscg_newflux,             & ! Convergence tolerance for boundary driving potential solves.
        epscg_divb,                & ! Convergence tolerance for remesh divB cleaner solve.
! ****** Stabilizing options.
        filter_poles,              & ! (Logical) toggle to activate all polar filter options.
        pole_filter_t,             & ! (Logical) toggle to activate polar filter for temperature.
        pole_filter_rho,           & ! (Logical) toggle to activate polar filter for density.
        pole_filter_pw,            & ! (Logical) toggle to activate polar filter for pressure waves.
        pole_filter_vr,            & ! (Logical) toggle to activate polar filter for radial velocity.
        pole_filter_z,             & ! (Logical) toggle to activate polar filter for WTD z+/z-.
        expert_user_override,      & ! Type that only currently contains "limit_supersonic_inflow"
                                     ! logical, which sets the velocity to the sound speed
                                     ! if there is supersonic inflow.
!
! ****** Debugging.
!
        print_matrix_pot2d,        & ! Write out dense matrix for 2D potential field solve.
        print_matrix_pot3d,        & ! Write out dense matrix for 3D potential field solve.
        print_matrix_adva,         & ! Write out dense matrix for resistivity solve.
        print_matrix_advv,         & ! Write out dense matrix for semi-implicit and viscosity solves.
        print_matrix_t,            & ! Write out dense matrix for thermal conduction solve.
        debug_wtd,                 & ! (Logical) toggle to activate debugging of WTD.
        debug_wtd_open_field_cutoff, & ! Dump the boundary slices for the WTD Poynting flux and the
                                       ! limiter fields.
        debug_tdc,                 & ! (Logical) toggle to activate debugging of TDC.
                                     ! It outputs electric fields (and other quantities)
                                     ! at the R0 boundary at the slice cadence.
        ifvdgv,                    & ! (Logical) toggle to use (.true.) advection terms in momentum equation
                                     ! or not (.false.).  For testing purposes only.
        use_exp_visc,              & ! Set to (.true.) to use explicit Euler for viscosity.
        use_exp_tc                   ! Set to (.true.) to use explicit Euler for thermal conduction.
!
! ****** Interplanetary run (heliosphere).
!
      namelist /interplanetary/    &
        interplanetary_run,        & ! (Logical) Set .true. to activate interplanetary boundary driving.
        boundary_frame,            & ! Frame of reference of the boundary files. Options:
                                     !   FAKE_COROTATING : Corotating but without v-phi C-forces.
                                     !   COROTATING
                                     !   INERTIAL
        ip_path,                   & ! Directory where boundary files reside.
        ip_sequence,               & ! Comma-seperated list of times for
                                     ! sequence of boundary files (mas units).
        ip_node,                   & ! Comma-separated list of file indices for
                                     ! sequence of boundary files.
        deltat_ip,                 & ! Time offset (mas units) to apply to ip_sequence list.
        corotating_relaxation_time,& ! Time offset (mas units) for boundary phi-shift.
                                     ! Use this when you have a simulation that was
                                     ! initially relaxed in a corotating frame, and subsequent
                                     ! restarts are to be computed in the inertial frame.
                                     ! Also useful for various other use-cases.
        brfile,                    & ! Base filename of Br boundary files (see br_pbv_file).
        btfile,                    & ! Base filename of Bt boundary files.
        bpfile,                    & ! Base filename of Bp boundary files.
        vrfile,                    & ! Base filename of Vr boundary files.
        vtfile,                    & ! Base filename of Vt boundary files.
        vpfile,                    & ! Base filename of Vp boundary files.
        rhofile,                   & ! Base filename of RHO boundary files.
        tfile,                     & ! Base filename of T boundary files.
        epfile,                    & ! Base filename of Ep boundary files.
        emfile,                    & ! Base filename of Em boundary files.
        fcsfile,                   & ! Base filename of FCS boundary files.
        zpfile,                    & ! Base filename of Zp boundary files.
        zmfile,                    & ! Base filename of Zm boundary files.
        ip_bc_interp_order,        & ! Order for bc file rotation interpolation.
        ip_bc_use_pot_solves,      & ! (Logical) toggle to use potential field solves for the boundaries
                                     ! or not.  Should always be .true. unless using zero transverse
                                     ! fields/velocities.
        ip_bc_shift_phi_guess,     & ! Use the old phi solution rotated as initial solver guess.
        ip_bc_shift_psi_guess        ! Use the old psi solution rotated as initial solver guess.
!
! ****** Charge states model options.
!
      namelist /fcs_nl/            &
        nelem,                     & ! Number of elements.
        natom_list,                & ! Array of atomic numbers of elements.
        path_eigen                   ! Directory where the Chianti ionization
                                     ! files are stored.
!
!-----------------------------------------------------------------------
!
! ****** Buffer to hold an input file line.
!
      character(1024) :: line
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Open the input file (all MPI ranks).
!
      call ffopen (IO_INPUT,infile,'r',ierr)
      call check_error_on_any_proc (ierr)
!
! ****** Now read the namelist sections one by one on all ranks.
!
      read (IO_INPUT,topology,iostat=ierr)
      if (ierr.ne.0) then
        if (iamp0) then
          backspace (IO_INPUT)
          read (IO_INPUT,fmt='(A)') line
          write (*,*)
          write (*,*) '### ERROR from READ_INPUT_FILE [TOPOLOGY]:'
          write (*,*) '### The following line has a problem:'
          write (*,*)
          write (*,*) trim(line)
          write (*,*)
          write (*,*) '###'
        end if
      end if
      call check_error_on_any_proc (ierr)
!
      read (IO_INPUT,data,iostat=ierr)
      if (ierr.ne.0) then
        if (iamp0) then
          backspace (IO_INPUT)
          read (IO_INPUT,fmt='(A)') line
          write (*,*)
          write (*,*) '### ERROR from READ_INPUT_FILE [DATA]:'
          write (*,*) '### The following line has a problem:'
          write (*,*)
          write (*,*) trim(line)
          write (*,*)
          write (*,*) '###'
        end if
      end if
      call check_error_on_any_proc (ierr)
!
      read (IO_INPUT,interplanetary,iostat=ierr)
      if (ierr.ne.0.and.ierr.ne.-1) then
        if (iamp0) then
          backspace (IO_INPUT)
          read (IO_INPUT,fmt='(A)') line
          write (*,*)
          write (*,*) '### ERROR from READ_INPUT_FILE [INTERPLANETARY]:'
          write (*,*) '### The following line has a problem:'
          write (*,*)
          write (*,*) trim(line)
          write (*,*)
          write (*,*) '###'
        end if
      end if
      if (ierr.eq.-1) ierr=0
      call check_error_on_any_proc (ierr)
!
      read (IO_INPUT,fcs_nl,iostat=ierr)
      if (ierr.ne.0.and.ierr.ne.-1) then
        if (iamp0) then
          backspace (IO_INPUT)
          read (IO_INPUT,fmt='(A)') line
          write (*,*)
          write (*,*) '### ERROR from READ_INPUT_FILE [FCS_NL]:'
          write (*,*) '### The following line has a problem:'
          write (*,*)
          write (*,*) trim(line)
          write (*,*)
          write (*,*) '###'
        end if
      end if
      if (ierr.eq.-1) ierr=0
      call check_error_on_any_proc (ierr)
!
! ****** Save the mesh size if the automatic decomposition option
! ****** is being used.
!
      if (auto_decompose) then
        nr_auto=nr
        nt_auto=nt
        np_auto=np
      end if
!
! ****** Create the output file.  This needs to be here due to the new
! ****** legacy mode option.
!
      if (legacy_output_filenames) then
        outfile='o'//runid
      else
        outfile='mas.out'
      end if
!
      if (iamp0) then
        call ffopen (IO_OUT,trim(outfile),'rw',ierr)
      end if
      call check_error_on_p0 (ierr)
!
! ****** Read and write out the raw input file (only on processor IPROC0).
!
      if (iamp0) then
        rewind(IO_INPUT)
        write (*,*)
        write (*,*) '### Input file contents:'
        write (*,*)
        write (IO_OUT,*)
        write (IO_OUT,*) '### Input file contents:'
        write (IO_OUT,*)
        do
          read (IO_INPUT,'(a)',err=100,end=100) line
          write (*,'(a)') trim(line)
          write (IO_OUT,'(a)') trim(line)
        enddo
  100   continue
        write (*,*)
        write (IO_OUT,*)
      end if
!
! ****** Close the input file on all ranks.
!
      close(IO_INPUT,iostat=ierr)
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### WARNING from READ_INPUT_FILE:'
        write (*,*) '### Could not close the input file.'
      end if
!
! ****** Check the input parameters.
! ****** NOTE: This routine can change input parameters so we call it
! ******       here before writing the namelist.
!
      call check_inputs
!
! ****** Write the NAMELIST parameter values used (after checking).
!
      if (iamp0) then
        if (legacy_output_filenames) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### Parameter values:'
          write (IO_OUT,*)
          write (IO_OUT,topology)
          write (IO_OUT,data)
          write (IO_OUT,interplanetary)
          write (IO_OUT,fcs_nl)
          write (IO_OUT,*)
        else
          call ffopen (IO_TEMP,'mas_run_parameters_used.out','rw',ierr)
          write (IO_TEMP,topology)
          write (IO_TEMP,data)
          write (IO_TEMP,interplanetary)
          write (IO_TEMP,fcs_nl)
          close (IO_TEMP)
        end if
      end if
      call check_error_on_p0 (ierr)
!
end subroutine
!#######################################################################
subroutine check_if_wallclock_exceeded
!
!-----------------------------------------------------------------------
!
! ****** Check if the wall-clock time limit has been exceeded.
!
! ****** If so, set the stop run flag IFEND=.true. and return.
!
!-----------------------------------------------------------------------
!
      use mpidefs
      use timing
      use time_limit
      use vars
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Processor IPROC0 keeps track of the elapsed wall-clock time.
!
      if (iamp0) then
        t_wc_elapsed=MPI_Wtime()-time_at_start_of_program
        if (t_wc_elapsed.ge.(t_wc_limit-t_wc_reserved)) then
          write (*,*)
          write (*,*) '### WARNING from MAS:'
          write (*,*) '### The run was stopped because the'// &
                      ' wall-clock time limit'
          write (*,*) '### has been exceeded.'
          write (*,*) 'NTIME = ',ntime
          write (*,*) 'TIME = ',time
          write (IO_OUT,*)
          write (IO_OUT,*) '### WARNING from MAS:'
          write (IO_OUT,*) '### The run was stopped because the'// &
                      ' wall-clock time limit'
          write (IO_OUT,*) '### has been exceeded.'
          write (IO_OUT,*) 'NTIME = ',ntime
          write (IO_OUT,*) 'TIME = ',time
          ifend=.true.
        end if
      end if
!
! ****** Broadcast IFEND to all the processors.
!
      call MPI_Bcast (ifend,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
!
end subroutine
!#######################################################################
subroutine check_if_stoprun
!
!-----------------------------------------------------------------------
!
! ****** Stop the present run if a file named "STOPRUN" exists in
! ****** the run directory.
!
! ****** If it does, set the abort flag IFABORT=.true. and return.
!
!-----------------------------------------------------------------------
!
      use mpidefs
      use vars
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: exists
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Check if the user has requested to stop the run
! ****** prematurely.
!
      if (iamp0) then
        inquire (file='STOPRUN',exist=exists)
        if (exists) then
          write (*,*)
          write (*,*) '### WARNING from MAS:'
          write (*,*) '### The run was stopped prematurely' &
                      //' via STOPRUN ...'
          write (*,*) 'NTIME = ',ntime
          write (*,*) 'TIME = ',time
          write (IO_OUT,*)
          write (IO_OUT,*) '### WARNING from MAS:'
          write (IO_OUT,*) '### The run was stopped prematurely' &
                      //' via STOPRUN ...'
          write (IO_OUT,*) 'NTIME = ',ntime
          write (IO_OUT,*) 'TIME = ',time
          ifabort=.true.
        end if
      end if
!
! ****** Broadcast IFABORT to all the processors.
!
      call MPI_Bcast (ifabort,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
!
end subroutine
!#######################################################################
subroutine setup
!
!-----------------------------------------------------------------------
!
! ****** Set up the run, input/output, etc.
!
!-----------------------------------------------------------------------
!
      use ident
      use vars
      use timing
      use mpidefs
      use get_cl_args_interface
      use parse_cl_interface
      use io_units
      use diagnostics
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Command-line arguments.
!
      integer :: narg
      character(512), dimension(:), pointer :: arg
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: i,lr
!
      character(10) :: chdate
      character(8) :: chtime
!
!-----------------------------------------------------------------------
!
      logical, external :: valid_character,letter
!
!-----------------------------------------------------------------------
!
! ****** Initialize MPI.
!
      call init_mpi
!
      if (iamp0) then
        write (*,*) ' '
        write (*,*) '_|      _|     _|_|       _|_|_|'
        write (*,*) '_|_|  _|_|   _|    _|   _|'
        write (*,*) '_|  _|  _|   _|_|_|_|     _|_|'
        write (*,*) '_|      _|   _|    _|         _|'
        write (*,*) '_|      _|   _|    _|   _|_|_|'
        write (*,*) ' '
        write (*,*) 'Magnetohydrodynamic Algorithm outside a Sphere'
        write (*,*) '                        Predictive Science Inc.'
      end if
!
! ****** Get system information.
!
      call get_system_info
!
! ****** Get the command-line arguments (allocates arg).
!
      call get_cl_args (narg,arg)
!
! ****** Parse the command line (deallocates arg).
!
      call parse_cl (narg,arg,ierr)
!
! ****** Start the timer to get the total CPU time used.
!
      call timer (TIME_TOTAL)
!
! ****** Start the timer that measures start-up time.
!
      if (use_timer) call timer (TIME_STARTUP)
!
! ****** Check the validity of RUNID.
!
      lr=len_trim(runid)
!
      ierr=0
      if (lr.le.0.or.lr.gt.64.or..not.letter(runid(1:1))) ierr=1
      do i=1,lr
        if (.not.valid_character(runid(i:i))) ierr=1
      enddo
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in SETUP:'
          write (*,*) '### Run ID is invalid.'
          write (*,*) 'RUNID = ',runid
        end if
        call endrun (.true.)
      end if
!
! ****** Create input file name based on RUNID if it is not specified.
!
      if (infile.eq.' ') infile='i'//runid
!
! ****** Read the input file (this also creates the output file).
!
      call read_and_check_input_file
!
! ****** Create output text file names.
!
      if (legacy_output_filenames) then
        warnfile='w'//runid
      else
        warnfile='mas_warnings.out'
        dump3dfile     ='mas_output_list_3d.out'
        dumpslicefile  ='mas_output_list_slices.out'
        dumptracerfile ='mas_output_list_tracers.out'
        dumprsfile     ='mas_output_list_restarts.out'
      end if
!
      if (iamp0) then
        call ffopen (IO_WARN,trim(warnfile),'rw',ierr)
      end if
      call check_error_on_p0 (ierr)
!
! ****** Write out the identification information.
!
      call datetime (chdate,chtime)
!
      if (iamp0) then
        write (*,300) 'Code: ',idcode, &
                      'Version: ',vers//branch_vers, &
                      'Updated on: ',update, &
                      'Source file: ',source, &
                      'Run ID: ',trim(runid), &
                      'Run started on: ',chdate, &
                      'Run started at: ',chtime, &
                      'Ran on machine: ',trim(machname), &
                      'Machine type: ',trim(machtype), &
                      'Compiler: ',trim(compiler), &
                      'Compiler Flags: ',trim(compiler_flags)
        write (IO_OUT,300) 'Code: ',idcode, &
                      'Version: ',vers//branch_vers, &
                      'Updated on: ',update, &
                      'Source file: ',source, &
                      'Run ID: ',trim(runid), &
                      'Run started on: ',chdate, &
                      'Run started at: ',chtime, &
                      'Ran on machine: ',trim(machname), &
                      'Machine type: ',trim(machtype), &
                      'Compiler: ',trim(compiler), &
                      'Compiler Flags: ',trim(compiler_flags)
  300   format (11(/,a,a),/)
      end if
!
! ****** Create the file dump output files.
!
      if (iamp0) then
        call ffopen (IO_DUMP_3D,dump3dfile,'rw',ierr)
        if (trace_particles) then
          call ffopen (IO_DUMP_TRACERS,dumptracerfile,'rw',ierr)
        end if
        if (n_tpslice_radii.gt.0) then
          call ffopen (IO_DUMP_SLICE,dumpslicefile,'rw',ierr)
        end if
        if (irsdump.gt.0.or.trsdump.gt.0) then
          call ffopen (IO_DUMP_RS,dumprsfile,'rw',ierr)
        end if
      end if
      call check_error_on_p0 (ierr)
!
end subroutine
!#######################################################################
subroutine get_system_info
!
!-----------------------------------------------------------------------
!
! ****** Get information about the system MAS is running on.
!
!-----------------------------------------------------------------------
!
      use number_types
      use ident
      use mpidefs
      use iso_fortran_env
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr,ierrc
      character(512) :: errmsg
!
!-----------------------------------------------------------------------
!
      if (iamp0) then
!
! ****** Get system hostname (machname).
!
        call EXECUTE_COMMAND_LINE('uname -n > tmp.txt',wait=.true., &
                                  exitstat=ierr,cmdstat=ierrc, &
                                  cmdmsg=errmsg)
        if (ierr==0) then
          open(unit=10,file="tmp.txt",status="old")
          read(10, '(A)') machname
          close(10, status="delete")
        else
          write(*,*) "WARNING:  Failed to retrieve machine name"
          write(*,*) " ERRMSG:  "//trim(errmsg)
          machname = 'Unknown'
          if (ierrc==0) then
            open(unit=10,file="tmp.txt",status='old')
            close(10, status="delete")
          end if
        end if
!
! ****** Get system type (machtype).
!
        call EXECUTE_COMMAND_LINE('uname -m > tmp.txt',wait=.true., &
                                  exitstat=ierr,cmdstat=ierrc, &
                                  cmdmsg=errmsg)
        if (ierr==0) then
          open(unit=10,file="tmp.txt",status="old")
          read(10, '(A)') machtype
          close(10, status="delete")
        else
          write(*,*) "WARNING:  Failed to retrieve machine type"
          write(*,*) " ERRMSG:  "//trim(errmsg)
          machtype = 'Unknown'
          if (ierrc==0) then
            open(unit=10,file="tmp.txt",status='old')
            close(10, status="delete")
          end if
        end if
!
! ****** Get compiler and compiler flags.
!
        compiler=compiler_version()
        compiler_flags=compiler_options()
!
      end if
!
! ****** Broadcast to all other ranks.
!
      call MPI_Bcast(machname,len(machname),MPI_CHARACTER, &
                     0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(machtype,len(machtype),MPI_CHARACTER, &
                     0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(compiler,len(compiler),MPI_CHARACTER, &
                     0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(compiler_flags,len(compiler_flags),MPI_CHARACTER, &
                     0,MPI_COMM_WORLD,ierr)
!
end subroutine
!#######################################################################
subroutine final_diags
!
!-----------------------------------------------------------------------
!
! ****** Write out final diagnostics and finish up the run.
!
!-----------------------------------------------------------------------
!
      use diagnostics
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical, save :: final_diags_has_been_called=.false.
!
!-----------------------------------------------------------------------
!
      if (final_diags_has_been_called) then
        call finish
        return
      end if
!
      final_diags_has_been_called=.true.
!
! ****** Write spatial diagnostics (unless just written).
!
      if (ipltxint.gt.0.or.tpltxint.gt.0.) then
        if (ifabort) then
          call plot_dump
        else
          if (.not.plotting_step) call plot_dump
        end if
      end if
!
! ****** Write tracer particles (unless just written).
!
      if (trace_particles) then
        if (trace_ixint.gt.0.or.trace_txint.gt.0.) then
          if (ifabort) then
            call particle_dump
          else
            if (.not.trace_step) call particle_dump
          end if
        end if
      end if
!
! ****** Write slices  (unless just written).
!
      if (slice_ixint.gt.0.or.slice_txint.gt.0.) then
        if (ifabort) then
          call slice_dump
        else
          if (.not.slice_step) call slice_dump
        end if
      end if
!
! ****** Write the time histories.
!
      call dumphist
!
! ****** Write a restart file if appropriate.
!
      if (ifabort.or.rs_final) then
        call write_restart (0)
      end if
!
      call finish
!
end subroutine
!#######################################################################
subroutine finish
!
!-----------------------------------------------------------------------
!
! ****** Finish up the run.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use ident
      use vars
      use cgcom
      use timing
      use mpidefs
      use alfven_wave_pressure
      use wtd
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(10) :: chdate
      character(8) :: chtime
!
      integer :: n_a,n_si_p,n_si_c,n_visc,n_pot2d,n_pot2d_newflux, &
                 n_pot2dh,n_pot3d,n_divb,n_te,n_tp
!
!-----------------------------------------------------------------------
!
      call datetime (chdate,chtime)
!
      if (iamp0) then
        write (*,100) 'Code: ',idcode, &
                      'Version: ',vers//branch_vers, &
                      'Updated on: ',update, &
                      'Source file: ',source, &
                      'Run ID: ',trim(runid), &
                      'Run ended on: ',chdate, &
                      'Run ended at: ',chtime, &
                      'Ran on machine: ',trim(machname), &
                      'Machine type: ',trim(machtype), &
                      'Compiler: ',trim(compiler), &
                      'Compiler Flags: ',trim(compiler_flags)
        write (9,100) 'Code: ',idcode, &
                      'Version: ',vers//branch_vers, &
                      'Updated on: ',update, &
                      'Source file: ',source, &
                      'Run ID: ',trim(runid), &
                      'Run ended on: ',chdate, &
                      'Run ended at: ',chtime, &
                      'Ran on machine: ',trim(machname), &
                      'Machine type: ',trim(machtype), &
                      'Compiler: ',trim(compiler), &
                      'Compiler Flags: ',trim(compiler_flags)
  100   format (11(/,a,a),/)
      end if
!
      if (iamp0) then
        write (*,200) '### End of run ...', &
                      'NTIME = ',ntime, &
                      'TIME = ',time
        write (9,200) '### End of run ...', &
                      'NTIME = ',ntime, &
                      'TIME = ',time
  200   format (/,tr1,a,//,tr1,a,i10,/,tr1,a,1pe17.10)
      end if
!
! ****** Write out the average time step used.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### Time advance information:'
        write (9,*) 'Average time step used = ',dtime_avg
        if (advance_pw) then
          write (9,*)
          write (9,*) '### Alfven wave advance information:'
          write (9,*) 'Average time step for ep/em advance = ',dtawav
        end if
        if (advance_zw) then
          write (9,*)
          write (9,*) '### WTD advance information:'
          write (9,*) 'Average time step for zp,zm advance = ',dtzwav
        end if
      end if
!
! ****** Write out the field solver convergence information.
!
      n_a=0
      if (nsolves_a.ne.0) n_a=ntotal_a/nsolves_a
!
      n_te=0
      if (nsolves_te.ne.0) n_te=ntotal_te/nsolves_te
!
      n_tp=0
      if (nsolves_tp.ne.0) n_tp=ntotal_tp/nsolves_tp
!
      n_si_p=0
      if (nsolves_si_p.ne.0) n_si_p=ntotal_si_p/nsolves_si_p
!
      n_si_c=0
      if (nsolves_si_c.ne.0) n_si_c=ntotal_si_c/nsolves_si_c
!
      n_visc=0
      if (nsolves_visc.ne.0) n_visc=ntotal_visc/nsolves_visc
!
      n_pot2d=0
      if (nsolves_pot2d.ne.0) n_pot2d=ntotal_pot2d/nsolves_pot2d
!
      n_pot2d_newflux=0
      if (nsolves_pot2d_newflux.ne.0) n_pot2d_newflux= &
          ntotal_pot2d_newflux/nsolves_pot2d_newflux
!
      n_pot2dh=0
      if (nsolves_pot2dh.ne.0) n_pot2dh=ntotal_pot2dh/nsolves_pot2dh
!
      n_pot3d=0
      if (nsolves_pot3d.ne.0) n_pot3d=ntotal_pot3d/nsolves_pot3d
!
      n_divb=0
      if (nsolves_divb.ne.0) n_divb=ntotal_divb/nsolves_divb
!
      if (iamp0) then
        write (9,*)
        write (9,*) '-----------------------------------------'
        write (9,*) '### Field solver convergence information:'
        write (9,*) '-----------------------------------------'
!
        write (9,*)
        write (9,*) '### Implicit resistivity advance:'
        write (9,*) 'Total number of solves = ',nsolves_a
        write (9,*) 'Total number of iterations = ',ntotal_a
        write (9,*) 'Average number of iterations per solve = ',n_a
!
        write (9,*)
        write (9,*) '### Thermal conduction (e) advance:'
        if (use_sts_tc) then
          write (9,*) 'Total number of solves = ',nsolves_te
          write (9,*) 'Total number of STS steps  = ',ntotal_te
          write (9,*) 'Average number of STS steps per solve  = ',n_te
        elseif (use_exp_tc) then
          write (9,*) 'Total number of advances = ',nsolves_te
          write (9,*) 'Total number of EXP steps  = ',ntotal_te
          write (9,*) 'Average number of EXP steps per advance= ',n_te
        else
          write (9,*) 'Total number of solves = ',nsolves_te
          write (9,*) 'Total number of iterations = ',ntotal_te
          write (9,*) 'Average number of iterations per solve = ',n_te
        end if
!
        write (9,*)
        write (9,*) '### Thermal conduction (p) advance:'
        if (use_sts_tc) then
          write (9,*) 'Total number of solves = ',nsolves_tp
          write (9,*) 'Total number of STS steps  = ',ntotal_tp
          write (9,*) 'Average number of STS steps per solve  = ',n_tp
        elseif (use_exp_tc) then
          write (9,*) 'Total number of advances = ',nsolves_tp
          write (9,*) 'Total number of EXP steps  = ',ntotal_tp
          write (9,*) 'Average number of EXP steps per advance= ',n_tp
        else
          write (9,*) 'Total number of solves = ',nsolves_tp
          write (9,*) 'Total number of iterations = ',ntotal_tp
          write (9,*) 'Average number of iterations per solve = ',n_tp
        end if
!
        write (9,*)
        write (9,*) '### Semi-implicit advance (predictor):'
        write (9,*) 'Total number of solves = ',nsolves_si_p
        write (9,*) 'Total number of iterations = ',ntotal_si_p
        write (9,*) 'Average number of iterations per solve = ',n_si_p
!
        write (9,*)
        write (9,*) '### Semi-implicit advance (corrector):'
        write (9,*) 'Total number of solves = ',nsolves_si_c
        write (9,*) 'Total number of iterations = ',ntotal_si_c
        write (9,*) 'Average number of iterations per solve = ',n_si_c
!
        write (9,*)
        write (9,*) '### Viscosity advance:'
        if (use_sts_visc) then
          write (9,*) 'Total number of solves = ',nsolves_visc
          write (9,*) 'Total number of STS steps  = ',ntotal_visc
          write (9,*) 'Average number of STS steps per solve  = ',n_visc
        elseif (use_exp_visc) then
          write (9,*) 'Total number of advances = ',nsolves_visc
          write (9,*) 'Total number of EXP steps  = ',ntotal_visc
          write (9,*) 'Average number of EXP steps per advance= ',n_visc
        else
          write (9,*) 'Total number of solves = ',nsolves_visc
          write (9,*) 'Total number of iterations = ',ntotal_visc
          write (9,*) 'Average number of iterations per solve = ',n_visc
        end if
!
        write (9,*)
        write (9,*) '### Initial boundary potential field (2D):'
        write (9,*) 'Total number of solves = ',nsolves_pot2d
        write (9,*) 'Total number of iterations = ',ntotal_pot2d
        write (9,*) 'Average number of iterations per solve = ',n_pot2d
!
        write (9,*)
        write (9,*) '### Initial potential field (3D):'
        write (9,*) 'Total number of solves = ',nsolves_pot3d
        write (9,*) 'Total number of iterations = ',ntotal_pot3d
        write (9,*) 'Average number of iterations per solve = ',n_pot3d
!
        write (9,*)
        write (9,*) '### Boundary potential field (2D psi evolve):'
        write (9,*) 'Total number of solves = ',nsolves_pot2d_newflux
        write (9,*) 'Total number of iterations = ',ntotal_pot2d_newflux
        write (9,*) 'Average number of iterations per solve = ', &
                                                         n_pot2d_newflux
!
        write (9,*)
        write (9,*) '### Boundary potential field (2D phi evolve):'
        write (9,*) 'Total number of solves = ',nsolves_pot2dh
        write (9,*) 'Total number of iterations = ',ntotal_pot2dh
        write (9,*) 'Average number of iterations per solve = ',n_pot2dh
!
        write (9,*)
        write (9,*) '### Divergence cleaning:'
        write (9,*) 'Total number of solves = ',nsolves_divb
        write (9,*) 'Total number of iterations = ',ntotal_divb
        write (9,*) 'Average number of iterations per solve = ',n_divb
!
      end if
!
! ****** Write out the timing information.
!
      call write_timing
!
! ****** Write out the total CPU time used.
!
      if (iamp0) then
        write (*,300) '### CPU time used (on IPROC0): ',total_cpu_time
        write (9,300) '### CPU time used (on IPROC0): ',total_cpu_time
  300   format (/,tr1,a,f12.2,' seconds',/)
      end if
!
! ****** Exit.
!
      if (ifabort) then
        call endrun (.true.)
      else
        call endrun (.false.)
      end if
!
end subroutine
!#######################################################################
subroutine start
!
!-----------------------------------------------------------------------
!
! ****** Initialization of the run.
!
!-----------------------------------------------------------------------
!
      use number_types
      use ident
      use fields
      use vars
      use io_units
      use restart
      use timing
      use mpidefs
      use characteristics
      use emerging_flux_params
      use ucase_interface
      use globals
      use mesh
      use time_limit
      use eta_photosphere
      use flow_profile
      use shear_profile
      use radiative_loss_parameters
      use interplanetary_vars
      use coef_storage
      use upwind_resistivity
      use fluxrope_parameters
      use prescribe_b_v_at_r0_vars
      use alfven_wave_pressure
      use bhat_storage
      use prescribe_tdc_from_file_r0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Define the output restart file configuration.
!
      call define_output_rs_params
!
! ****** Check if this is a restart run, and if so, define the
! ****** restart file configuration and set restart_run to true.
!
      call define_input_rs_params
!
! ****** If this is a restart, read the restart header.
! ****** This needs to be done here in order to get the
! ****** mesh dimensions needed for the auto-topology feature
! ****** in check_proc_topology.
!
      if (restart_run) then
        call read_restart_header
      end if
!
! ****** Check/set the processor topology.
!
      call check_proc_topology
!
! ****** Decompose the domain.
!
      call decompose_domain
!
! ****** Log the type of timer being used to the output file.
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) repeat ('-',72)
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from START:'
        if (use_timer) then
          write (IO_OUT,*) '### Timing has been turned ON for this run.'
        else
          write (IO_OUT,*) '### Timing has been turned OFF for this run.'
        end if
      end if
!
! ****** If a wall-clock time limit has been specified,
! ****** write it to the output file.
!
      if (use_wallclock_limit) then
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from START:'
          write (IO_OUT,*) '### A wall-clock time limit has been'// &
                      ' specified.'
          write (IO_OUT,*)
          write (IO_OUT,*) 'Time limit [seconds] = ',int(t_wc_limit)
          write (IO_OUT,*) 'Time reserved for final diagnostics'// &
                      ' [seconds] = ',int(t_wc_reserved)
        end if
      end if
!
! ****** Decompose the mesh.
!
      call decompose_mesh
!
! ****** Check the mesh topology.
!
      call check_mesh_topology
!
! ****** Allocate the main arrays.
!
      call allocate_arrays
!
! ****** Define the normalization constants.
!
      call get_normalization_params
!
! ****** Load the field table.
!
      call set_field_table
!
! ****** Read the restart file fields.
!
      if (restart_run) then
        call read_restart_mesh
        call read_restart_fields
! ****** Kluge to fix rho and p boundary conditions in restarts.
        call fix_restart_bc
      end if
!
! ****** Set up the mesh.
!
      call set_mesh
!$acc enter data copyin(r,dr,rh,drh,t,dt,th,dth,p,dp,ph,dph,st,ct, &
!$acc              sth,cth,sp,cp,sph,cph,r_i,dr_i,rh_i,drh_i,dt_i, &
!$acc              dth_i,dp_i,dph_i,st_i,sth_i, &
!$acc              fl_one,fl_oneh,fl_fac,fl_fach,fl_fac_i,fl_fach_i, &
!$acc              r_true,rh_true,r_true_i,rh_true_i)
!
! ****** Print decomposition diagnostics.
!
      call decomp_diags
!
! ****** Set up the monopole profile.
!
      call set_brmono
!$acc enter data copyin(br_mono,grav)
!
! ****** Write a diagnostic message that the parallel flow model
! ****** is being used.
!
      if (iamp0.and.freeze_b) then
        write (*,*)
        write (*,*) '### COMMENT from START:'
        write (*,*) '### The parallel flow model has been'// &
                    ' requested (FREEZE_B=.true.).'
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from START:'
        write (IO_OUT,*) '### The parallel flow model has been'// &
                    ' requested (FREEZE_B=.true.).'
      end if
!
! ****** Set switches for plotting.
!
      call set_diagnostics
!
! ****** Set the upwind coefficients for A.
!
      if (upwind_a.gt.0.) then
        upwind_ar=upwind_a
        upwind_at=upwind_a
        upwind_ap=upwind_a
      end if
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from START:'
        write (IO_OUT,*) '### Upwind coefficients for the A equation:'
        write (IO_OUT,*) 'UPWIND_AR = ',upwind_ar
        write (IO_OUT,*) 'UPWIND_AT = ',upwind_at
        write (IO_OUT,*) 'UPWIND_AP = ',upwind_ap
      end if
!
! ****** Normalize the "floor" temperature.
!
      tfloor=tfloor/fn_t
!
! ****** Initialize the time.
!
      ntime=0
!
      if (.not.restart_run) then
        if (time_at_start.lt.0) then
          time=0.
        else
          time=time_at_start
        end if
      end if
!
      time_at_start=time
!
! ****** Initialize tracer particles.
!
      call initialize_tracers
!
! ****** Initialize pot2d and pot2dh solvers.
!
      call load_pot2d_solve
      call load_pot2dh_solve
!
! ****** Initialize the flux ropes (if any).
!
      call fluxrope_setup
!
      if (interplanetary_run) then
        call setup_ip_boundaries
!$acc enter data copyin(br_ip,bt_ip,bp_ip,vr_ip,vt_ip,vp_ip,t_ip,rho_ip)
!$acc enter data copyin(boundary_frame)
      end if
!
! ****** Set up the initial state.
!
      if (.not.restart_run) then
!
! ****** Develop the initial state.
! ****** First initialize the magnetic field.
!
        if (ucase(initial_field).eq.'DIPOLE') then
          call initialize_magnetic_field_from_dipoles
        else if (ucase(initial_field).eq.'POTENTIAL_FIELD') then
          call potfld_from_bnfile
        else if (ucase(initial_field).eq.'ALFVEN_WAVE1') then
          call init_alfven_wave1
        else if (ucase(initial_field).eq.'ALFVEN_WAVE2') then
          call init_alfven_wave2
        else if (ucase(initial_field).eq.'ALFVEN_WAVE2_ROTATED') then
          call init_alfven_wave2_rotated
        else if (ucase(initial_field).eq.'A_FILE') then
          call read_a_file (afile)
        else
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in START:'
            write (*,*) '### Invalid initial field requested:'
            write (*,*) 'INITIAL_FIELD = ',trim(initial_field)
            write (*,*)
            write (*,*) '### The allowed options are:'
            write (*,*) '''DIPOLE'''
            write (*,*) '''POTENTIAL_FIELD'''
            write (*,*) '''ALFVEN_WAVE1'''
            write (*,*) '''ALFVEN_WAVE2'''
            write (*,*) '''ALFVEN_WAVE2_ROTATED'''
            write (*,*) '''A_FILE'''
          end if
          call endrun (.true.)
        end if
      endif
!
! ****** Add flux ropes (if any).
!
      if (fluxropes_added) then
!$acc update device(a%r,a%t,a%p)
        call fluxrope_add
!$acc update self(a%r,a%t,a%p,b%r,b%t,b%p,fj%r,fj%t,fj%p)
      end if
!
! ****** Setup Helicity Pumping.
!
      if (helicity_pumping) call setup_helicity_pumping
!$acc enter data copyin(hpump_prof)
!$acc update device(a_hpump%r,a_hpump%t,a_hpump%p)
!
! ****** Initialize the plasma.
!
      if (.not.restart_run) then
        if (ucase(initial_field).eq.'ALFVEN_WAVE1') then
        else if (ucase(initial_field).eq.'ALFVEN_WAVE2') then
        else if (ucase(initial_field).eq.'ALFVEN_WAVE2_ROTATED') then
        else if (ucase(initial_plasma).eq.'ZERO-BETA') then
          call initialize_zb_equilibrium
          call initialize_no_flow
        else if (ucase(initial_plasma).eq.'STREAMER') then
          call initialize_hs_equilibrium
          call initialize_solar_wind
        else if (ucase(initial_plasma).eq.'HYDROSTATIC') then
          call initialize_hs_equilibrium
          call initialize_no_flow
        else if (ucase(initial_plasma).eq.'1DFILE') then
          call initialize_from_file (onedfile)
        else if (ucase(initial_plasma).eq.'2DFILE') then
          call initialize_from_file_2d
        else if (ucase(initial_plasma).eq.'NONE') then
        else
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in START:'
            write (*,*) '### Invalid initial plasma requested:'
            write (*,*) 'INITIAL_PLASMA = ',trim(initial_plasma)
            write (*,*)
            write (*,*) '### The allowed options are:'
            write (*,*) '''ZERO-BETA'''
            write (*,*) '''STREAMER'''
            write (*,*) '''HYDROSTATIC'''
            write (*,*) '''1DFILE'''
            write (*,*) '''2DFILE'''
          end if
          call endrun (.true.)
        end if
!
      else
!
! ****** For zero beta runs, if the density profile is being
! ****** loaded from a file, load it even for restart cases.
! ****** This allows a change in the density profile at a restart.
!
        if (ucase(initial_plasma).eq.'ZERO-BETA'.and. &
            ucase(zb_rho_profile).eq.'READ_FROM_FILE') then
          call load_rho_from_file (zb_rho_file)
        end if
!
      end if
!
! ****** Initialize the temperature.
!
      temp(:,:,:)=(he_rho/he_p)*pres(:,:,:)/rho(:,:,:)
!
      if (restart_run) then
        if (advance_tp) then
          temp_p(:,:,:)=(he_rho*pres(:,:,:)/rho(:,:,:)- &
                            he_p_e*temp_e(:,:,:))/he_p_p
!$acc update device(temp_p)
        end if
      else
        temp_e(:,:,:)=temp(:,:,:)
        if (advance_tp) then
          temp_p(:,:,:)=temp_e(:,:,:)
          temp(:,:,:)=(he_p_e*temp_e(:,:,:)+he_p_p*temp_p(:,:,:))/he_p
!$acc update device(temp_p)
        end if
      end if
!$acc update device(temp)
!
! ****** Replace or add fields from file.
!
      call load_fields_from_file
!
! ****** Setup the rho limiter profile if selected:
! ****** (rho_temp is used in order to be able to reuse the
! ******  load_rho_from_file routine)
!
      if (ifrholimit) then
         allocate(rho_temp(nr,nt,np))
         rho_temp(:,:,:)=rho(:,:,:)
         call load_rho_from_file (rho_limit_file)
         rho_limit(:,:,:)=rho(:,:,:)
         rho(:,:,:)=rho_temp(:,:,:)
         deallocate(rho_temp)
!$acc update device(rho_limit)
      end if
!
! ****** Set the resistivity profile.
!
      call load_resistivity
!$acc update device(eta_prof)
!
! ****** Set the viscosity profile.
!
      call load_viscosity
!$acc update device(vis_prof)
!
! ****** Load the kappa mask.
!
      call load_kappa_mask
!$acc enter data copyin(kappa_mask)
!
! ****** Set up temperature advance.
!
      call load_temp_e_advance
!
! ****** Set up velocity advance.
!
      if (freeze_b) then
        call load_v_par_advance
      else
        call load_v_advance
      end if
!
! ****** Set up A advance.
!
      call load_a_advance
!
! ****** Check the specified time profiles.
!
      call check_time_profiles
!
! ****** Evaluate the initial time profiles.
!
      call evaluate_time_profiles (time)
!
! ****** Set the initial values of variables driven by time profiles.
!
      call set_time_profile_variables
!$acc update self(vis,eta)
!
! ****** Initialize B and J.
!
!$acc update device(a%r,a%t,a%p)
      call bfroma (a,b,one)
      call jfromb (b,fj)
!$acc update self(b%r,b%t,b%p,fj%r,fj%t,fj%p)
!
      if (freeze_b) then
!
! ****** If the parallel flow algorithm is being used, get b-hat.
!
        call get_bhat
!$acc enter data copyin(bhat_r,bhat_t,bhat_p)
!
! ****** If the parallel flow model is being used, project the
! ****** vector velocity to the parallel velocity, to define it.
! ****** Also, project the parallel flow back to v, to remove any
! ****** perpendicular part of the flow. vb needs to be set here
! ****** to ensure v_par_to_v sets v correctly at the boundaries.
!
!$acc update device(v%r,v%t,v%p)
        if (rb0) then
          vb%r0%r(:,:)=AVG(v%r,1,:,:)
          vb%r0%t(:,:)=AVGR(v%t,2,:,:)
          vb%r0%p(:,:)=AVGR(v%p,2,:,:)
!$acc update device(vb%r0%r,vb%r0%t,vb%r0%p)
        end if
        if (rb1) then
          vb%r1%r(:,:)=AVG(v%r,nrm,:,:)
          vb%r1%t(:,:)=AVGR(v%t,nr,:,:)
          vb%r1%p(:,:)=AVGR(v%p,nr,:,:)
!$acc update device(vb%r1%r,vb%r1%t,vb%r1%p)
        end if
!$acc update device(v_par)
        call project_v_to_v_par (v,v_par)
        call project_v_par_to_v (v_par,v)
!$acc update self(v%r,v%t,v%p,v_par)
        if (restart_run) then
!$acc update device(v_old%r,v_old%t,v_old%p,v_par_old)
          call project_v_to_v_par (v_old,v_par_old)
          call project_v_par_to_v (v_par_old,v_old)
!$acc update self(v_old%r,v_old%t,v_old%p,v_par_old)
        end if
      end if
!
! ****** Initialize the shear profile.
!
      call initialize_shear
!$acc enter data copyin(shear,v_shear_t,v_shear_p)
!
! ****** Initialize the flow profile.
!
      call initialize_flow
!$acc enter data copyin(flow,v_flow_r,v_flow_t,v_flow_p)
!
! ****** Initialize the photospheric resistivity profile.
!
      if (ifeta_phot.or.tdc_edb_correction_etmod) then
        if (ifeta_phot) then
          call load_eta_phot
        else
          allocate (eta_phot_prof(ntm,npm))
          eta_phot_prof(:,:)=0.
        endif
        allocate (eflux_eta(ntm,npm))
        eflux_eta(:,:)=0.
!$acc enter data copyin(eta_phot_prof,eflux_eta)
      end if
!
! ****** Allocate eflux arrays.  these are needed here due to
!        debug_tdc slice writes.  The rest are
!        allocated in NEWFLUX.
!
      if (evolve_flux.or.prescribe_bv) then
        allocate (eflux_er(nt,np))
        allocate (eflux_et(ntm1,np))
        allocate (eflux_ep(nt,npm1))
        allocate (eflux_vr(nt,np))
        allocate (eflux_vt(ntm,np))
        allocate (eflux_vp(nt,npm))
        allocate (br_pbv (ntm,npm))
        allocate (phi_tdc(nt,np))
        br_pbv(:,:)=0.
        eflux_er(:,:)=0.
        eflux_et(:,:)=0.
        eflux_ep(:,:)=0.
        eflux_vr(:,:)=0.
        eflux_vt(:,:)=0.
        eflux_vp(:,:)=0.
        phi_tdc(:,:)=0.
!$acc enter data copyin(eflux_er,eflux_et,eflux_ep,phi_tdc, &
!$acc                   eflux_vr,eflux_vt,eflux_vp,br_pbv)
        if (debug_tdc) then
          allocate (vxbbr0r(nt,np))
          allocate (vxbbr0t(ntm1,np))
          allocate (vxbbr0p(nt,npm1))
          allocate (curl_et(ntm,npm))
          allocate (div_et(nt,np))
          vxbbr0r(:,:)=0.
          vxbbr0t(:,:)=0.
          vxbbr0p(:,:)=0.
          div_et(:,:)=0.
          curl_et(:,:)=0.
!$acc enter data copyin(vxbbr0r,vxbbr0t,vxbbr0p,div_et,curl_et)
        end if
      end if
!
! ****** Initialize the emerging flux profile.
!
      if (emerging_flux) then
        call initialize_emerging_flux
!$acc enter data copyin(ef,ef%phi,ef%psi,ef%edrive,ef%vr,ef%vt,ef%vp, &
!$acc                   ef%phi%er,ef%phi%et,ef%phi%ep,ef%vr_set, &
!$acc                   ef%psi%er,ef%psi%et,ef%psi%ep,ef%vr_v0, &
!$acc                   ef%edrive%er,ef%edrive%et,ef%edrive%ep, &
!$acc                   ef%edrive%vr,ef%edrive%vt,ef%edrive%vp, &
!$acc                   ef%edrive%e0,ef%phi%e0,ef%psi%e0)
      end if
!
! ****** Initialize the characteristics.
!
      call initialize_characteristics
!
! ****** Initialize the velocity at the previous time step.
!
      if (.not.restart_run) then
        v_old%r(:,:,:)=v%r(:,:,:)
        v_old%t(:,:,:)=v%t(:,:,:)
        v_old%p(:,:,:)=v%p(:,:,:)
        if (freeze_b) then
          v_par_old(:,:,:)=v_par(:,:,:)
        end if
      end if
!
! ****** Correct vp if changing the frame of reference
!
      if (restart_run) then
        if(restart_calculation_frame.eq.'COROTATING'.and. &
           calculation_frame.eq.'INERTIAL') then
          call transform_vp (omega_corotate)
        elseif(restart_calculation_frame.eq.'INERTIAL'.and. &
           calculation_frame.eq.'COROTATING') then
          call transform_vp (-omega_corotate)
        end if
      end if
!
! ****** Load wave turbulence models.
!
! ****** Set radial cut profiles for wave pressures.
      if (advance_pw) then
        call load_awthprof
!$acc enter data copyin(awthprof)
      end if
      if (advance_zw) then
        call init_zw
!$acc update device(zp,zm)
      end if
      if ((advance_pw.or.advance_zw).and.use_pw_rcut) then
        pw_rcut_main(:)=half*(one+ &
                        tanh((r(:)-pw_rcut_r0)/pw_rcut_width))
        pw_rcut_half(:)=half*(one+ &
                        tanh((rh(:)-pw_rcut_r0)/pw_rcut_width))
       end if
!$acc update device(pw_rcut_main,pw_rcut_half)
!
! ****** Set up charge states arrays.
!
      if (advance_fcs) then
        call setup_fcs
      end if
!
! ****** Initialize the radiative loss parameters.
!
      if (radloss.gt.0.) then
        call initialize_radiative_loss
      end if
!
! ****** Turn off the advancement of the magnetic field
! ****** if the model with parallel dynamics (i.e., frozen B)
! ****** was requested.
!
      if (freeze_b) then
        advance_a=.false.
!$acc update device(v_par,v_par_old)
      end if
!$acc update device(rho,pres,temp,temp_e,em,ep,a%r,a%t,a%p, &
!$acc               b%r,b%t,b%p,e%r,e%t,e%p,fj%r,fj%t,fj%p, &
!$acc               v%r,v%t,v%p,v_old%r,v_old%t,v_old%p, &
!$acc               rho0i,rho0f,rho0v, &
!$acc               vb%r0%r,vb%r0%t,vb%r0%p,vb%r1%r,vb%r1%t,vb%r1%p, &
!$acc               ab%r0%t,ab%r1%t,ab%r0%p,ab%r1%p)
!
! ****** Set the initial time step.
!
      call setdt
!
! ****** Compute the initial energies and initialize the energy
! ****** diagnostic.
!
      call energy
      call energy_diag_init
!
! ***** Set dump/history switches.
!
      call history_check
!
! ****** Initialize the coronal heating parameters.
!
      call initialize_heating
!
! ****** Filter poles if requested.
!
      if (advance_zw.and.pole_filter_z) then
        call smooth_poles_scalars (zm)
        call smooth_poles_scalars (zp)
      end if
!
      if (advance_pw.and.pole_filter_pw) then
        call smooth_poles_scalars (em)
        call smooth_poles_scalars (ep)
      end if
!
      if (pole_filter_t) then
        call smooth_poles_scalars (temp_e)
        call smooth_poles_scalars (temp)
        if (advance_tp) then
          call smooth_poles_scalars (temp_p)
        end if
      end if
!
      if (pole_filter_rho) then
        call smooth_poles_scalars (rho)
      end if
!
      if (pole_filter_vr) then
        call smooth_poles_vr (v%r)
      end if
!
! ****** Collect and write diagnostics.
!
      call diags
!
      if (iamp0) FLUSH (IO_OUT)
!
! ****** Stop the start-up timer.
!
      if (use_timer) call timer (TIME_STARTUP)
!
end subroutine
!#######################################################################
subroutine afromb (b,a)
!
!-----------------------------------------------------------------------
!
! ****** Derive A from a given B.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types
      use cgcom
      use mesh
      use mpidefs
      use vars
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
      type(bvec) :: b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      type(avec) :: jtmp
      type(avec_bc) :: abtmp
      real(r_typ), dimension(nr,ntm,npm) :: psi_br
      real(r_typ), dimension(nt,np), target :: ar_slice,rhs1
      real(r_typ), dimension(ntm,npm), target :: br_slice,rhs2
!
      integer :: i,j,k
      integer :: ierr=0
      real(r_typ) :: r2
!
!-----------------------------------------------------------------------
!
!$acc enter data create(psi_br,ar_slice,rhs1,br_slice,rhs2)
!
! ****** Get temporary J from input B.
!
      call alloc_avec (jtmp)
      call jfromb (b,jtmp)
!
! ****** Solve for ar from jr.
!
      equation_solved=EQ_POT2DH
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from AFROMB:'
        write (IO_OUT,*) '### Starting Jr=Lap(Ar) slice solves.'
        write (IO_OUT,*) '### '
        FLUSH (IO_OUT)
      end if
!
      do i=1,nrm1
!
        r2=r(i)*r(i)
!
        do concurrent (k=1:np, j=1:nt)
          ar_slice(j,k)=zero
        enddo
!
        do concurrent (k=1:np, j=1:nt)
          rhs1(j,k)=0.
        enddo
!
        do concurrent (k=2:npm1, j=2:ntm1)
          rhs1(j,k)=r2*sth(j)*dth(j)*dph(k)*jtmp%r(i,j,k)
        enddo
!
        call pot2dh_solver (ar_slice,rhs1,ierr)
!
        do concurrent (k=1:np, j=1:nt)
          a%r(i,j,k)=ar_slice(j,k)
        enddo
!
        if (iamp0) then
          write (IO_OUT,*) '### Solved Ar i=',i,'/',nrm1
          FLUSH (IO_OUT)
        end if
      enddo
!
      call check_error_on_any_proc (ierr)
!
      call dealloc_avec (jtmp)
!
! ****** Now do 2D psi solve slices.
!
      equation_solved=EQ_POT2D
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nr)
        psi_br(i,j,k)=zero
      enddo
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from AFROMB:'
        write (IO_OUT,*) '### Starting Br=Lap(PSI) slice solves.'
        write (IO_OUT,*) '### '
        FLUSH (IO_OUT)
      end if
!
      do i=1,nr
!
        r2=rh(i)*rh(i)
!
        do concurrent (k=1:npm, j=1:ntm)
          br_slice(j,k)=zero
          rhs2(j,k)=zero
        enddo
!
        do concurrent (k=2:npm-1, j=2:ntm-1)
          rhs2(j,k)=r2*dt(j)*st(j)*dp(k)*b%r(i,j,k)
        enddo
!
        if (tb0) then
          do concurrent (k=2:npm-1)
            rhs2(   1,k)=quarter*r2*dt(1)*sth(2)*dp(k)*b%r(i,1,k)
          enddo
        end if
!
        if (tb1) then
          do concurrent (k=2:npm-1)
            rhs2(ntm1,k)= &
                    quarter*r2*dt(ntm1)*sth(ntm1)*dp(k)*b%r(i,ntm1,k)
          enddo
        end if
!
        call pot2d_solver (br_slice,rhs2,ierr)
!
        do concurrent (k=1:npm, j=1:ntm)
          psi_br(i,j,k)=br_slice(j,k)
        enddo
!
        if (iamp0) then
          write (IO_OUT,*) '### Solved PSI i=',i,'/',nr
          FLUSH (IO_OUT)
        end if
!
      enddo
!
      call check_error_on_any_proc (ierr)
!
! ****** Now compute other A components:
!
      do concurrent (k=2:npm1, j=jm0:jm1, i=1:nr)
        a%t(i,j,k)=rh_i(i)*st_i(j)* &
                   dph_i(k)*(psi_br(i,j,k)-psi_br(i,j,k-1))
      enddo
!
      do concurrent (k=1:npm1, j=2:ntm1, i=1:nr)
        a%p(i,j,k)=-rh_i(i)* &
                   dth_i(j)*(psi_br(i,j,k)-psi_br(i,j-1,k))
      enddo
!
! ****** Seam and set boundary conditions.
!
      call set_pole_bc_avec (a)
      call seam_avec (a)
!
! ****** The following is really only needed if
! ****** potential_field_bc.eq.'MHDSS'.
!
      call alloc_avec_bc (abtmp)
      call get_at_b (a,abtmp)
      call set_bc_a (abtmp,a,one)
      call seam_avec (a)
      call dealloc_avec_bc (abtmp)
!
!$acc exit data delete(psi_br,ar_slice,rhs1,br_slice,rhs2)
end subroutine
!#######################################################################
subroutine div_clean_b (b)
!
!-----------------------------------------------------------------------
!
! ****** Divergence clean B.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types
      use cgcom
      use mesh
      use mpidefs
      use decomposition
      use write_field_interface
      use field_table
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Array for the potential and the RHS for the 3D potential
! ****** solve.
!
      real(r_typ), dimension(nrm,ntm,npm) :: divb,rhs,phi
      type(bvec) :: gradphi
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ierr
      real(r_typ) :: dv
!
!-----------------------------------------------------------------------
!
! ****** Set up div cleaning solve parameters.
!
!$acc enter data create(divb,rhs,phi)
      call load_divb_solver
!
      call alloc_bvec (gradphi)
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
        divb(i,j,k)=0.
        rhs(i,j,k)=0.
        phi(i,j,k)=0.
      enddo
!
! ****** Get current Div B.
!
      call get_divb (b,divb)
      call write_mmm_diag (divb,'DIVB_INIT','DIV_CLEAN_B')
!     call write_field ('divb_init.h5',IFLD_VIS,divb)
!
! ****** Set up rhs for phi solve.
! ****** Note that only internal points will be used in the solve.
!
      do concurrent (k=2:npm-1, j=2:ntm-1, i=i0:nrm1)
        dv=r(i)**2*dr(i)*st(j)*dt(j)*dp(k)
        rhs(i,j,k)=dv*divb(i,j,k)
      enddo
!
      call seam_scalar (rhs,nrm,ntm,npm)
!
      call divb_solver (phi,rhs)
!     call write_mmm_diag (phi,'PHI_SOLVED','DIV_CLEAN_B')
!     call write_field ('phi_solved.h5',IFLD_VIS,phi)
!
! ****** Get correction from gradient of phi.
!
      call get_grad_phi (phi,gradphi)
!
      call get_divb (gradphi,divb)
      call write_mmm_diag (divb,'DIV-GRAD-PHI','DIV_CLEAN_B')
!     call write_field ('gradphi_r.h5',IFLD_BR,gradphi%r)
!     call write_field ('div_grad_phi.h5',IFLD_VIS,divb)
!
! ****** Apply correction and set bounderies.
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nr)
        b%r(i,j,k)=b%r(i,j,k)-gradphi%r(i,j,k)
      enddo
      do concurrent (k=1:npm, j=1:nt, i=1:nrm)
        b%t(i,j,k)=b%t(i,j,k)-gradphi%t(i,j,k)
      enddo
      do concurrent (k=1:np, j=1:ntm, i=1:nrm)
        b%p(i,j,k)=b%p(i,j,k)-gradphi%p(i,j,k)
      enddo
!
      call set_pole_bc_bvec (b)
!
      call seam_scalar (b%r,nr,ntm,npm)
      call seam_scalar (b%t,nrm,nt,npm)
      call seam_scalar (b%p,nrm,ntm,np)
!     call write_field ('bclean_r.h5',IFLD_BR,b%r)
!
! ****** Get new Div B.
!
      call get_divb (b,divb)
      call write_mmm_diag (divb,'DIVB_FINAL','DIV_CLEAN_B')
!     call write_field ('divb_final.h5',IFLD_VIS,divb)
!
      call dealloc_bvec (gradphi)
!$acc exit data delete(divb,rhs,phi)
!
end subroutine
!#######################################################################
subroutine write_mmm_diag (f,capt,capt2)
!
!-----------------------------------------------------------------------
!
! ****** Write out some diagnostics of a mmm 3D field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types
      use cgcom
      use mesh
      use mpidefs
      use decomposition
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: f
      character(*) :: capt,capt2
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ierr
      real(r_typ) :: total_abs_f,max_abs_f,min_abs_f
!
!-----------------------------------------------------------------------
!
      total_abs_f=zero
      max_abs_f=zero
      min_abs_f=huge(zero)
!
!$acc parallel loop collapse(3) default(present) &
!$acc  reduction(+:total_abs_f) &
!$acc  reduction(max:max_abs_f) &
!$acc  reduction(min:min_abs_f)
!$omp parallel do collapse(3) default(shared) &
!$omp reduction(+:total_abs_f) &
!$omp reduction(max:max_abs_f) &
!$omp reduction(min:min_abs_f) &
      do k=map_pm(iproc)%i0,map_pm(iproc)%i1
        do j=map_tm(iproc)%i0,map_tm(iproc)%i1
          do i=map_rm(iproc)%i0,map_rm(iproc)%i1
            total_abs_f=total_abs_f+abs(f(i,j,k))
            max_abs_f=max(max_abs_f,abs(f(i,j,k)))
            min_abs_f=min(min_abs_f,abs(f(i,j,k)))
          enddo
        enddo
      enddo
!$omp end parallel do
      call global_sum (total_abs_f)
      call global_max (max_abs_f)
      call global_min (min_abs_f)
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from ',capt2,':'
        write (9,*) '### Sum |',capt,'|:',total_abs_f
        write (9,*) '### Avg |',capt,'|:', &
                                      total_abs_f/(npm1_g*ntm1_g*nrm1_g)
        write (9,*) '### Min |',capt,'|:',min_abs_f
        write (9,*) '### Max |',capt,'|:',max_abs_f
      end if
!
end subroutine
!#######################################################################
subroutine load_a_advance
!
!-----------------------------------------------------------------------
!
! ****** Set up unchanging values used in the vector-potential advance
!
!-----------------------------------------------------------------------
!
      use globals
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Get number of rows for each component and all components:
!
      N_ar=nrm1*ntm2*npm2
      N_at=nrm2*(jm1-jm0+1)*npm2
      N_ap=nrm2*ntm2*npm1
!
      N_cgvec=N_ar+N_at+N_ap
!
end subroutine
!#######################################################################
subroutine load_temp_e_advance
!
!-----------------------------------------------------------------------
!
! ****** Set up unchanging values used in temperature advance
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh
      use globals
      use vars
      use fields, ONLY : prof_coll, prof_nocoll
      use cgcom, ONLY : ifprec_t
      use mpidefs
      use matrix_storage_t_solve
      use sts, ONLY : use_sts_tc,use_exp_tc
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i
!
      if ((use_sts_tc.or.use_exp_tc).and.ifimplrad.ne.0) then
        ifimplrad=0
        if (iamp0) then
          write (*,*) ' '
          write (*,*) '### WARNING from LOAD_TEMP_E_ADVANCE:'
          write (*,*) '### Implicit radiation loss not yet'
          write (*,*) '### implemented for use with STS.'
          write (*,*) '### Switching to ifimplrad=0.'
        end if
      end if
!
! ****** Set the radial selection profiles for collionless and
! ****** collisional thermal conduction.
!
      if (alpha_nocoll.ne.0..or.alpha_nocoll_p.ne.0.) then
        do concurrent (i=1:nr)
          prof_nocoll(i)=.5_r_typ* &
                    (1._r_typ+tanh((rh_true(i)-tc_nocoll_r)/tc_nocoll_dr))
        enddo
      end if
!
      if (advance_tc) then
        do concurrent (i=1:nr)
          prof_coll(i)=tc_fac0+(tc_fac1-tc_fac0)*.5_r_typ* &
                       (1._r_typ+tanh((rh_true(i)-tc_r)/tc_dr))
        enddo
      end if
!
! ****** Setup matrix parameters and offsets for
! ****** thermal conduction solve.
!
      N_cgvec=nrm2*ntm2*npm2
!
      if (ifprec_t.ge.2.and.advance_tc.and..not.use_sts_tc) then
!
! ***** Set a_dia_offsets array for DIA sparse matrix storage format
!
        a_dia_offsets( 1)=  -(nrm2)-(nrm2)*(ntm2) !    j-1,k-1
        a_dia_offsets( 2)=-1       -(nrm2)*(ntm2) !i-1,    k-1
        a_dia_offsets( 3)=         -(nrm2)*(ntm2) !        k-1
        a_dia_offsets( 4)= 1       -(nrm2)*(ntm2) !i+1,    k-1
        a_dia_offsets( 5)=   (nrm2)-(nrm2)*(ntm2) !    j+1,k-1
        a_dia_offsets( 6)=-1-(nrm2)               !i-1.j-1
        a_dia_offsets( 7)=  -(nrm2)               !    j-1
        a_dia_offsets( 8)= 1-(nrm2)               !i+1,j-1
        a_dia_offsets( 9)=-1                      !i-1
        a_dia_offsets(10)= 0                      !diagonal (i,j,k)
        a_dia_offsets(11)= 1                      !i+1
        a_dia_offsets(12)=-1+(nrm2)               !i-1.j+1
        a_dia_offsets(13)=   (nrm2)               !    j+1
        a_dia_offsets(14)= 1+(nrm2)               !i+1,j+1
        a_dia_offsets(15)=  -(nrm2)+(nrm2)*(ntm2) !    j-1,k+1
        a_dia_offsets(16)=-1       +(nrm2)*(ntm2) !i-1,    k+1
        a_dia_offsets(17)=          (nrm2)*(ntm2) !        k+1
        a_dia_offsets(18)= 1       +(nrm2)*(ntm2) !i+1,    k+1
        a_dia_offsets(19)=   (nrm2)+(nrm2)*(ntm2) !    j+1,k+1
!
! ****** Note: The following a_dia_offsets should be ignored at
! ******       each respective boundary (phi ignored only if nproc_p>1):
!       i-1:  2, 6, 9,12,16
!       i+1:  4, 8,11,14,18
!       j-1:  1, 6, 7, 8,15
!       j+1:  5,12,13,14,19
!       k-1:  1, 2, 3, 4, 5
!       k+1: 15,16,17,18,19
!
! ****** Get number of non-zeros in A_dia and compute IA:
!
!$acc enter data copyin(a_dia_offsets)
        allocate (a_csr_ia(1+N_cgvec))
        call getM_nnz_tc (N_cgvec,a_dia_offsets,M_nnz,1,a_csr_ia)
!$acc enter data copyin(a_csr_ia)
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_TEMP_ADVANCE:'
          write (9,*) '### Thermal conduction preconditioner activated.'
          write (9,'(A,I17)') ' Matrix size per node (NxN) N: ',N_cgvec
         write (9,'(A,I13)') ' Matrix # of non-zeros per node M: ',M_nnz
          write (9,'(A,F8.2,A)') ' Estimated memory usage per node: ', &
          (8*(2*M_nnz+22*N_cgvec)+ &
           4*(2*M_nnz+4*N_cgvec+1))/1024./1024.,' MB'
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine load_v_advance
!
!-----------------------------------------------------------------------
!
! ****** Set up unchanging values used in velocity advance.
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
      use cgcom, ONLY : ifprec_v
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Setup matrix parameters and offsets for
! ****** thermal conduction solve.
!
! ****** Get number of rows for each component and all components:
!
      N_vr=(nrm-2)*ntm2*npm2
      N_vt=nrm2*(ntm-2)*npm2
      N_vp=nrm2*ntm2*(npm-2)
!
      N_cgvec=N_vr+N_vt+N_vp
!
      if (ifprec_v.ge.2) then
!
! ***** Set a_dia_offsets array for DIA sparse matrix storage format
!
        a_vr_offsets( 1)=                -(nrm-2)*(ntm2)!R         k-1
        a_vr_offsets( 2)=        -(nrm-2)               !R     j-1
        a_vr_offsets( 3)=-1                             !R i-1
        a_vr_offsets( 4)= 0                             !R diag(i,j,k)
        a_vr_offsets( 5)= 1                             !R i+1
        a_vr_offsets( 6)=         (nrm-2)               !R     j+1
        a_vr_offsets( 7)=                 (nrm-2)*(ntm2)!R         k+1
        a_vr_offsets( 8)=N_vr     -(nrm2)               !T     j-1
        a_vr_offsets( 9)=N_vr+1   -(nrm2)               !T i+1,j-1
        a_vr_offsets(10)=N_vr                           !T diag(i,j,k)
        a_vr_offsets(11)=N_vr+1                         !T i+1
        a_vr_offsets(12)=N_vr+N_vt       -(nrm2)*(ntm2) !P         k-1
        a_vr_offsets(13)=N_vr+N_vt+1     -(nrm2)*(ntm2) !P i+1,    k-1
        a_vr_offsets(14)=N_vr+N_vt                      !P diag(i,j,k)
        a_vr_offsets(15)=N_vr+N_vt+1                    !P i+1
!
! ****** Indidices that should not be added to CSR matrix at bounderies:
!
!       i-1: 3
!       j-1: 2,8,9
!       k-1: 1,12,13
!       i+1: R:5    T:9,11   P:13,15
!       j+1: R:6
!       k+1: R:7
!
        a_vt_offsets( 1)=-1                             !R i-1
        a_vt_offsets( 2)= 0                             !R diag(i,j,k)
        a_vt_offsets( 3)=-1      +(nrm-2)               !R i-1,j+1
        a_vt_offsets( 4)=         (nrm-2)               !R     j+1
        a_vt_offsets( 5)=N_vr            -(nrm2)*(ntm-2)!T         k-1
        a_vt_offsets( 6)=N_vr     -(nrm2)               !T     j-1
        a_vt_offsets( 7)=N_vr   -1                      !T i-1
        a_vt_offsets( 8)=N_vr                           !T diag(i,j,k)
        a_vt_offsets( 9)=N_vr   +1                      !T i+1
        a_vt_offsets(10)=N_vr     +(nrm2)               !T     j+1
        a_vt_offsets(11)=N_vr            +(nrm2)*(ntm-2)!T         k+1
        a_vt_offsets(12)=N_vr+N_vt       -(nrm2)*(ntm2) !P         k-1
        a_vt_offsets(13)=N_vr+N_vt+(nrm2)-(nrm2)*(ntm2) !P   j+1 k-1
        a_vt_offsets(14)=N_vr+N_vt                      !P diag(i,j,k)
        a_vt_offsets(15)=N_vr+N_vt+(nrm2)               !P     j+1
!
! ****** Indidices that should not be added to CSR matrix at bounderies:
!
!       i-1: 1,3,7
!       j-1: 6
!       k-1: 5,12,13
!       i+1:        T:9
!       j+1: R:3,4  T:10  P:13,15
!       k+1:        T:11
!
        a_vp_offsets( 1)=-1                             !R i-1
        a_vp_offsets( 2)= 0                             !R diag(i,j,k)
        a_vp_offsets( 3)=-1              +(nrm-2)*(ntm2)!R i-1     k+1
        a_vp_offsets( 4)=                 (nrm-2)*(ntm2)!R         k+1
        a_vp_offsets( 5)=N_vr     -(nrm2)               !T     j-1
        a_vp_offsets( 6)=N_vr                           !T diag(i,j,k)
        a_vp_offsets( 7)=N_vr     -(nrm2)+(nrm2)*(ntm-2)!T     j-1,k+1
        a_vp_offsets( 8)=N_vr            +(nrm2)*(ntm-2)!T         k+1
        a_vp_offsets( 9)=N_vr+N_vt       -(nrm2)*(ntm2) !P         k-1
        a_vp_offsets(10)=N_vr+N_vt-(nrm2)               !P     j-1
        a_vp_offsets(11)=N_vr+N_vt-1                    !P i-1
        a_vp_offsets(12)=N_vr+N_vt                      !P diag(i,j,k)
        a_vp_offsets(13)=N_vr+N_vt+1                    !P i+1
        a_vp_offsets(14)=N_vr+N_vt+(nrm2)               !P     j+1
        a_vp_offsets(15)=N_vr+N_vt       +(nrm2)*(ntm2) !P         k+1
!
! ****** Indidices that should not be added to CSR matrix at bounderies:
!
!       i-1: 1,3,11
!       j-1: 5,7,10
!       k-1: 9
!       i+1:               P:13
!       j+1:               P:14
!       k+1: R:3,4  T:7,8  P:15
!
! ****** Get number of non-zeros in matrix and compute IA.
!
!$acc enter data copyin(a_vr_offsets,a_vt_offsets,a_vp_offsets)
        allocate (a_csr_ia(1+N_cgvec))
        call getM_nzz_v (N_cgvec,N_vr,N_vt,a_vr_offsets, &
                         a_vt_offsets,a_vp_offsets,M_nzz,a_csr_ia)
!$acc enter data copyin(a_csr_ia)
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_V_ADVANCE:'
          write (9,*) '### Velocity preconditioner activated.'
          write (9,'(A,I17)') ' Matrix size per node (NxN) N: ',N_cgvec
         write (9,'(A,I13)') ' Matrix # of non-zeros per node M: ',M_nzz
          write (9,'(A,F8.2,A)') ' Estimated memory usage per node: ', &
          (8*(2*M_nzz+22*N_cgvec) &
           +4*(2*M_nzz+4*N_cgvec+1))/1024./1024.,' MB'
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine load_v_par_advance
!
!-----------------------------------------------------------------------
!
! ****** Set up unchanging values used in parallel flow advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh
      use globals
      use vars
      use cgcom, ONLY : ifprec_v
      use mpidefs
      use matrix_storage_v_par_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Setup matrix parameters and offsets for
! ****** parallel flow solve.
!
      N_cgvec=nrm2*ntm2*npm2
!
      if (ifprec_v.ge.2) then
!
! ***** Set a_dia_offsets array for DIA sparse matrix storage format
!
        a_dia_offsets(1)=         -(nrm2)*(ntm2) !        k-1
        a_dia_offsets(2)=  -(nrm2)               !    j-1
        a_dia_offsets(3)=-1                      !i-1
        a_dia_offsets(4)= 0                      !diagonal (i,j,k)
        a_dia_offsets(5)= 1                      !i+1
        a_dia_offsets(6)=   (nrm2)               !    j+1
        a_dia_offsets(7)=          (nrm2)*(ntm2) !        k+1
!
! ****** Note: The following a_dia_offsets should be ignored at
! ******       each respective boundary (phi ignored only if nproc_p>1):
!       i-1:  3
!       i+1:  5
!       j-1:  2
!       j+1:  6
!       k-1:  1
!       k+1:  7
!
! ****** Get number of non-zeros in A:
!
!$acc enter data copyin(a_dia_offsets)
        allocate (a_csr_ia(1+N_cgvec))
        call getM_nnz_v_par (N_cgvec,a_dia_offsets,M_nnz,1,a_csr_ia)
!$acc enter data copyin(a_csr_ia)
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_V_PAR_ADVANCE:'
          write (9,*) '### Parallel flow preconditioner activated.'
          write (9,'(A,I17)') ' Matrix size per node (NxN) N: ',N_cgvec
         write (9,'(A,I13)') ' Matrix # of non-zeros per node M: ',M_nnz
          write (9,'(A,F8.2,A)') ' Estimated memory usage per node: ', &
          (8*(2*M_nnz+22*N_cgvec)+ &
           4*(2*M_nnz+4*N_cgvec+1))/1024./1024.,' MB'
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine load_divb_solver
!
!-----------------------------------------------------------------------
!
! ****** Set up unchanging values used in divb solver.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh
      use globals
      use vars
      use cgcom, ONLY : ifprec_divb
      use mpidefs
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Setup matrix parameters and offsets for
! ****** divergence cleaning solve.
!
      if (rb0) then
        i0=1
      else
        i0=2
      end if
!
      N_cgvec=(nrm1-i0+1)*(ntm-2)*(npm-2)
!
      if (ifprec_divb.ge.2) then
!
! ***** Set a_dia_offsets array for DIA sparse matrix storage format
!
        a_dia_offsets(1)=              -(nrm1-i0+1)*(ntm-2) !      k-1
        a_dia_offsets(2)=  -(nrm1-i0+1)                     !   j-1
        a_dia_offsets(3)=-1                                 !i-1
        a_dia_offsets(4)= 0                                 !diag(i,j,k)
        a_dia_offsets(5)= 1                                 !i+1
        a_dia_offsets(6)=   (nrm1-i0+1)                     !   j+1
        a_dia_offsets(7)=               (nrm1-i0+1)*(ntm-2) !      k+1
!
! ****** Note: The following a_dia_offsets should be ignored at
! ******       each respective boundary (phi ignored only if nproc_p>1):
!       i-1:  3
!       i+1:  5
!       j-1:  2
!       j+1:  6
!       k-1:  1
!       k+1:  7
!
! ****** Get number of non-zeros in A and compute IA:
!
!$acc enter data copyin(a_dia_offsets)
        allocate (a_csr_ia(1+N_cgvec))
        call getM_nnz_divb (N_cgvec,a_dia_offsets,M_nnz,1,a_csr_ia)
!$acc enter data copyin(a_csr_ia)
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_V_PAR_ADVANCE:'
          write (9,*) '### Parallel flow preconditioner activated.'
          write (9,'(A,I17)') ' Matrix size per node (NxN) N: ',N_cgvec
         write (9,'(A,I13)') ' Matrix # of non-zeros per node M: ',M_nnz
          write (9,'(A,F8.2,A)') ' Estimated memory usage per node: ', &
          (8*(2*M_nnz+22*N_cgvec)+ &
           4*(2*M_nnz+4*N_cgvec+1))/1024./1024.,' MB'
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine fix_restart_bc
!
!-----------------------------------------------------------------------
!
! ****** Fix boundary conditions for restarts.  This is a kluge!
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use characteristics
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      if (rb0) then
        do k=1,np
          do j=1,nt
            rho0v(j,k)=half*(rho(1,j,k)+rho(2,j,k))
            rho0i(j,k)=rho0v(j,k)
            rho0f(j,k)=rho0v(j,k)
            pr0v(j,k)=half*(pres(1,j,k)+pres(2,j,k))
            pr0i(j,k)=pr0v(j,k)
            pr0f(j,k)=pr0v(j,k)
          enddo
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine fix_loaded_fields
!
!-----------------------------------------------------------------------
!
! ****** Fix boundary conditions and other things for loaded fields.
! ****** The behavior is that the namelist/defaults overwrite
! ****** BCs derived from the loaded fields.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use characteristics
      use vars
      use field_table
      use lcase_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      logical :: logbak
      character(512) :: curr_field=''
!
!-----------------------------------------------------------------------
!
      do i=1,nfields
!
        curr_field=trim(lcase(load_fields(i)%field))
!
        if (curr_field.eq.'') then
          continue
        elseif (curr_field.eq.'rho') then
!$acc update device(rho)
          do concurrent(k=1:np,j=1:nt)
            rho0i(j,k)=rho0
            rho0f(j,k)=rho0i(j,k)
            rho0v(j,k)=rho0i(j,k)
          enddo
          logbak=char_bc1
          char_bc1=.false.
          call set_bc_rho (rho,rho0v)
          char_bc1=logbak
          call seam_scalar (rho,nr,nt,np)
!$acc update self(rho,rho0i,rho0f,rho0v)
        elseif (curr_field.eq.'tp') then
!$acc update device(temp_p)
          logbak=char_bc1
          char_bc1=.false.
          call load_bc_temp_p
          call set_bc_temp_p (temp_p,one)
          char_bc1=logbak
          if (iftfloor) then
            call floor_field (temp_p,nr,nt,np,'P-TEMPERATURE', &
                          'FIX_LOADED_FIELDS',tfloor)
          end if
          call seam_scalar (temp_p,nr,nt,np)
!$acc update self(temp_p)
        elseif ((curr_field.eq.'t').or.(curr_field.eq.'te')) then
          if (curr_field.eq.'t') then
            temp_e(:,:,:)=temp(:,:,:)
          end if
          logbak=char_bc1
          char_bc1=.false.
!$acc update device(temp_e)
          call load_bc_temp_e
          call set_bc_temp_e (temp_e,one)
          char_bc1=logbak
          if (iftfloor) then
            call floor_field (temp_e,nr,nt,np,'E-TEMPERATURE', &
                          'FIX_LOADED_FIELDS',tfloor)
          end if
          call seam_scalar (temp_e,nr,nt,np)
!$acc update self(temp_e)
        elseif (curr_field.eq.'vr'.or. &
               curr_field.eq.'vt'.or. &
               curr_field.eq.'vp') then
          call set_pole_bc_vvec_cpu (v)
        elseif (curr_field.eq.'ep') then
          call set_pole_bc_scalar_hhh_cpu (ep)
        elseif (curr_field.eq.'em') then
          call set_pole_bc_scalar_hhh_cpu (em)
        elseif (curr_field.eq.'zp') then
          call set_pole_bc_scalar_hhh_cpu (zp)
        elseif (curr_field.eq.'zm') then
          call set_pole_bc_scalar_hhh_cpu (zm)
        end if
!
      enddo
!
end subroutine
!#######################################################################
subroutine datetime (date,time)
!
!-----------------------------------------------------------------------
!
! ****** Return the real date and time as character strings
! ****** in the following format:
!
!        DATE: MM/DD/YYYY
!        TIME: HH:MM:SS
!
! ****** To get the full date and time, DATE should be declared as
! ****** CHARACTER(10), and TIME should be declared as CHARACTER(8).
!
! ****** Uses the FORTRAN90 intrinsic DATE_AND_TIME.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*), intent(out) :: date,time
!
!-----------------------------------------------------------------------
!
      character, parameter :: slash='/'
      character, parameter :: colon=':'
!
      character(8) :: date_ccyymodd
      character(10) :: time_hhmmsspsss
!
!-----------------------------------------------------------------------
!
! ****** Get the date and time from the FORTRAN90 intrinsic.
!
      call date_and_time (date_ccyymodd,time_hhmmsspsss)
!
! ****** Reformat the result.
!
      date=date_ccyymodd(5:6)//slash// &
           date_ccyymodd(7:8)//slash// &
           date_ccyymodd(1:4)
!
      time=time_hhmmsspsss(1:2)//colon// &
           time_hhmmsspsss(3:4)//colon// &
           time_hhmmsspsss(5:6)
!
end subroutine
!#######################################################################
function letter (ch)
!
!-----------------------------------------------------------------------
!
! ****** Check if character CH is a letter.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: letter
      character :: ch
!
!-----------------------------------------------------------------------
!
      if ((iachar(ch).ge.65.and.iachar(ch).le. 90).or. &
          (iachar(ch).ge.97.and.iachar(ch).le.122)) then
        letter=.true.
      else
        letter=.false.
      end if
!
      return
end function
!#######################################################################
function digit (ch)
!
!-----------------------------------------------------------------------
!
! ****** Check if character CH is a digit.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: digit
      character :: ch
!
!-----------------------------------------------------------------------
!
      if (iachar(ch).ge.48.and.iachar(ch).le.57) then
        digit=.true.
      else
        digit=.false.
      end if
!
      return
end function
!#######################################################################
function alphanumeric (ch)
!
!-----------------------------------------------------------------------
!
! ****** Check if character CH is an allowed alphanumeric character.
!
! ****** Allowed characters include an underscore, a plus/minus sign,
! ****** the # sign, and the % sign.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: alphanumeric
      character :: ch
!
!-----------------------------------------------------------------------
!
! ****** ASCII codes.
!
      integer, parameter :: PLUS=43
      integer, parameter :: MINUS=45
      integer, parameter :: POUND=35
      integer, parameter :: PERCENT=37
      integer, parameter :: UNDERSCORE=95
!
!-----------------------------------------------------------------------
!
      select case (iachar(ch))
      case (UNDERSCORE,PLUS,MINUS,POUND,PERCENT)
        alphanumeric=.true.
      case default
        alphanumeric=.false.
      end select
!
      return
end function
!#######################################################################
function valid_character (ch)
!
!-----------------------------------------------------------------------
!
! ****** Check if CH is an allowed character.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: valid_character
      character :: ch
!
!-----------------------------------------------------------------------
!
      logical, external :: letter,digit,alphanumeric
!
!-----------------------------------------------------------------------
!
      if (letter(ch).or.digit(ch).or.alphanumeric(ch)) then
        valid_character=.true.
      else
        valid_character=.false.
      end if
!
      return
end function
!#######################################################################
function ucase (s)
!
!-----------------------------------------------------------------------
!
! ****** Convert the string S into uppercase letters and return it as
! ****** the function result.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*), intent(in) :: s
      character(len(s)) :: ucase
!
!-----------------------------------------------------------------------
!
      integer :: i,ic
!
!-----------------------------------------------------------------------
!
      ucase=' '
!
      do i=1,len_trim(s)
        ic=iachar(s(i:i))
        if (ic.ge.97.and.ic.le.122) then
          ic=ic-32
        end if
        ucase(i:i)=achar(ic)
      end do
!
      return
end function
!#######################################################################
function lcase (s)
!
!-----------------------------------------------------------------------
!
! ****** Convert the string S into lowercase letters and return it as
! ****** the function result.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*), intent(in) :: s
      character(len(s)) :: lcase
!
!-----------------------------------------------------------------------
!
      integer :: i,ic
!
!-----------------------------------------------------------------------
!
      lcase=' '
!
      do i=1,len_trim(s)
        ic=iachar(s(i:i))
        if (ic.ge.65.and.ic.le.90) then
          ic=ic+32
        end if
        lcase(i:i)=achar(ic)
      end do
!
      return
end function
!#######################################################################
function match (keyword,n,table,withcase)
!
!-----------------------------------------------------------------------
!
! ****** Match KEYWORD to the list of N words in TABLE.
!
! ****** A successful match returns the index of the first matched
! ****** entry in TABLE; an unsuccessful match returns 0.
!
! ****** If WITHCASE=.true., a successful match requires an
! ****** exact match of upper/lower case letters.  Otherwise,
! ****** the case is not required to match.
!
!-----------------------------------------------------------------------
!
      use ucase_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*), intent(in) :: keyword
      integer, intent(in) :: n
      character(*), dimension(n), intent(in) :: table
      logical, intent(in) :: withcase
      integer :: match
!
!-----------------------------------------------------------------------
!
      integer :: i
!
!-----------------------------------------------------------------------
!
      match=0
!
      do i=1,n
        if (withcase) then
          if (keyword.eq.table(i)) then
            match=i
            return
          end if
        else
          if (ucase(keyword).eq.ucase(table(i))) then
            match=i
            return
          end if
        end if
      end do
!
      return
end function
!#######################################################################
subroutine get_cl_args (narg,arg)
!
!-----------------------------------------------------------------------
!
! ****** Get the command-line arguments.
!
!-----------------------------------------------------------------------
!
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: narg
      character(*), dimension(:), pointer :: arg
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,nc
!
!-----------------------------------------------------------------------
!
! ****** Get the number of command-line arguments
! ****** (only on processor IPROC0).
!
      if (iamp0) then
        narg=COMMAND_ARGUMENT_COUNT()
      end if
!
! ****** Broadcast the number of arguments to all processors.
!
      call MPI_Bcast (narg,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
!
! ****** Allocate storage for the arguments.
!
      allocate (arg(narg))
!
! ****** Get the arguments (only on processor IPROC0).
!
      if (iamp0) then
        do i=1,narg
          call GET_COMMAND_ARGUMENT (i,arg(i))
        enddo
      end if
!
! ****** Broadcast the arguments to all processors.
!
      nc=len(arg)*narg
!
      call MPI_Bcast (arg,nc,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
!
end subroutine
!#######################################################################
subroutine parse_cl (narg,arg,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Parse the command-line arguments.
!
!-----------------------------------------------------------------------
!
! ****** Syntax is:
!
!     <executable> [<options>] <runid> [<infile>]
!
! ****** Return IERR=0 if the command-line parameters are
! ****** valid.
!
!-----------------------------------------------------------------------
!
      use number_types
      use ident
      use debug
      use vars
      use timing
      use mpidefs
      use ucase_interface
      use time_limit
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: narg
      character(*), dimension(:), pointer :: arg
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      integer :: iarg
      logical :: runid_set=.false.
      logical :: infile_set=.false.
      integer :: nsec
!
!-----------------------------------------------------------------------
!
      ierr=0
!
      if (narg.eq.0) go to 900
!
! ****** Parse arguments.
!
! ****** Syntax: [<options>] <runid> [<infile>]
!
! ****** Note that the arguments to the P4 system that are used
! ****** to run MPI jobs on Linux are thrown away.  These are:
! ****** "-p4pg <file>" and "-p4wd <file>".
!
      iarg=1
!
      do
        if (iarg.gt.narg) exit
        select case (trim(arg(iarg)))
        case ('-v')
          idebug=idebug+1
          iarg=iarg+1
        case ('-dryrun')
          dryrun=.true.
          iarg=iarg+1
        case ('-timer')
          if (iarg+1.le.narg) then
            iarg=iarg+1
            select case (ucase(trim(arg(iarg))))
            case ('NONE')
              use_timer=.false.
            case ('MPI')
              use_mpi_timer=.true.
            case default
              go to 900
            end select
            iarg=iarg+1
          else
            go to 900
          end if
        case ('-timerlog')
          timer_log=.true.
          iarg=iarg+1
        case ('-wc_limit')
          if (iarg+1.le.narg) then
            iarg=iarg+1
            call parse_time (trim(arg(iarg)),nsec)
            if (nsec.eq.-1) then
              if (iamp0) then
                write (*,*)
                write (*,*) '### ERROR in MAS:'
                write (*,*) '### Command-line argument error.'
                write (*,*)
                write (*,*) '### Invalid time specification:'
                write (*,*) trim(arg(iarg))
                write (*,*) 'while setting -wc_limit.'
              end if
              ierr=1
              return
            else
              use_wallclock_limit=.true.
              t_wc_limit=nsec
            end if
            iarg=iarg+1
          else
            go to 900
          end if
        case ('-wc_res')
          if (iarg+1.le.narg) then
            iarg=iarg+1
            call parse_time (trim(arg(iarg)),nsec)
            if (nsec.eq.-1) then
              if (iamp0) then
                write (*,*)
                write (*,*) '### ERROR in MAS:'
                write (*,*) '### Command-line argument error.'
                write (*,*)
                write (*,*) '### Invalid time specification:'
                write (*,*) trim(arg(iarg))
                write (*,*) 'while setting -wc_res.'
              end if
              ierr=1
              return
            else
              t_wc_reserved=nsec
            end if
            iarg=iarg+1
          else
            go to 900
          end if
        case default
          if (.not.runid_set) then
            runid=trim(arg(iarg))
            runid_set=.true.
            iarg=iarg+1
          else if (.not.infile_set) then
            infile=trim(arg(iarg))
            infile_set=.true.
            iarg=iarg+1
          else
            go to 900
          end if
        end select
      enddo
!
! ****** Deallocate the command-line argument array.
!
      deallocate (arg)
!
! ****** Check that the run ID has been specified.
!
      if (.not.runid_set) go to 900
!
      return
!
  900 continue
!
! ****** Error exit.
!
      ierr=1
!
      if (iamp0) then
        write (*,*)
        write (*,*) 'Code: ',idcode
        write (*,*) 'Version: ',vers//branch_vers
        write (*,*) 'Updated on: ',update
        write (*,*) 'Source file: ',source
        write (*,*) 'Machine name: ',trim(machname)
        write (*,*) 'Machine type: ',trim(machtype)
        write (*,*) 'Compiler: ',trim(compiler)
        write (*,*) 'Compiler Flags: ',trim(compiler_flags)
        write (*,*)
        write (*,*) '### ERROR in MAS:'
        write (*,*) '### Command-line syntax error.'
        write (*,*)
        write (*,*) 'The command-line syntax is:'
        write (*,*)
        write (*,*) '<executable> [<options>] <runid> [<infile>]'
        write (*,*)
        write (*,*) 'If <infile> is not specified, it defaults'// &
                    ' to i<runid>.'
        write (*,*)
        write (*,*) 'The allowed options are:'
        write (*,*)
        write (*,*) '-v                       Use (repeatedly) to'// &
                    ' get detailed diagnostics;'
        write (*,*) '-timer none|mpi   Use to select the'// &
                    ' timer (default=mpi);'
        write (*,*) '-timerlog                Use to log'// &
                    ' detailed timing diagnostics;'
        write (*,*) '-wc_limit [[HH:]MM:]SS   The maximum'// &
                    ' wall-clock time to run for'
        write (*,*) '                         (default=infinite);'
        write (*,*) '-wc_res [[HH:]MM:]SS     The time'// &
                    ' to reserve for writing final diagnostics'
        write (*,*) '                         and the restart'// &
                    ' file (default=10:00).'
      end if
!
      call endrun (.true.)
!
end subroutine
!#######################################################################
subroutine parse_time (s,sec)
!
!-----------------------------------------------------------------------
!
! ****** Convert the time specification in string S of the form:
!
!          [[HH:]MM:]SS
!
! ****** into seconds, and return it in the integer SEC.
!
! ****** The leading component specified can have one or more digits;
! ****** any following components must have 2 digits, and must be
! ****** between 0 and 59 inclusive.
!
! ****** If the string S is invalid, SEC=-1 is returned.
!
! ****** The following are examples of valid specifications:
!
!              3654   converts to 3654 seconds
!              5:05   converts to 5 minutes and 5 seconds
!                 5   converts to 5 seconds
!                 0   converts to 0 seconds
!            300:10   converts to 300 minutes and 10 seconds
!         110:09:04   converts to 110 hours, 9 minutes, and 4 seconds
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: s
      integer :: sec
!
!-----------------------------------------------------------------------
!
      logical, external :: digit
!
!-----------------------------------------------------------------------
!
      integer :: ss,mm,hh,i,i0,i1,ic
      logical :: done
!
!-----------------------------------------------------------------------
!
      sec=-1
      done=.false.
      mm=0
      hh=0
!
! ****** Parse the seconds.
!
      i0=1
      i1=len_trim(s)
      ic=index(s(i0:i1),':',.true.)
      if (ic.eq.0) done=.true.
      i0=ic+1
!
      if (.not.done.and.(i1-i0+1).ne.2) return
      do i=i0,i1
        if (.not.digit(s(i:i))) return
      enddo
!
      read (s(i0:i1),*,err=900,end=900) ss
      if (.not.done.and.ss.gt.59) return
      if (done) go to 100
!
! ****** Parse the minutes.
!
      i0=1
      i1=ic-1
      ic=index(s(i0:i1),':',.true.)
      if (ic.eq.0) done=.true.
      i0=ic+1
!
      if (.not.done.and.(i1-i0+1).ne.2) return
      do i=i0,i1
        if (.not.digit(s(i:i))) return
      enddo
!
      read (s(i0:i1),*,err=900,end=900) mm
      if (.not.done.and.mm.gt.59) return
      if (done) go to 100
!
! ****** Parse the hours.
!
      i0=1
      i1=ic-1
!
      do i=i0,i1
        if (.not.digit(s(i:i))) return
      enddo
!
      read (s(i0:i1),*,err=900,end=900) hh
!
  100 continue
!
! ****** Convert to seconds.
!
      sec=(hh*60+mm)*60+ss
!
      return
!
  900 continue
!
! ****** Error return.
!
end subroutine
!#######################################################################
pure function is_substring (main_string,sub_string)
!
!-----------------------------------------------------------------------
!
! ****** Check if one string contains another.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: is_substring
      character(*), intent(in) :: main_string
      character(*), intent(in) :: sub_string
!
!-----------------------------------------------------------------------
!
      is_substring=.false.
!
! ****** Check for empty string.
!
      if (len_trim(sub_string)==0) then
        is_substring=.true.
        return
      end if
!
! ****** Check if string is shorter than substring.
!
      if (len_trim(main_string) < len_trim(sub_string)) return
!
! ****** Check for substring.
!
      if (INDEX(main_string,sub_string)>0) is_substring = .true.
!
      return
end function
!#######################################################################
subroutine check_inputs
!
!-----------------------------------------------------------------------
!
! ****** Check the input parameters for conflicts.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh
      use meshdef
      use decomposition_params
      use diagnostics
      use cgcom
      use vars
      use dissipation_profiles
      use mpidefs
      use shear_profile
      use drive_profile
      use time_profiles
      use emerging_flux_params
      use potential_field
      use alfven_wave_pressure
      use flow_profile
      use heating_parameters
      use eta_photosphere
      use tdm_parameters
      use radiative_loss_parameters
      use interplanetary_vars
      use prescribe_b_v_at_r0_vars
      use fluxrope_parameters
      use hdf_defs
      use ucase_interface
      use restart
      use wtd
      use mod_input_parameter
      use sts
      use ident
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i
      logical :: is_substring
!
!-----------------------------------------------------------------------
!
      ierr=0
!
!-----------------------------------------------------------------------
! ****** Check for correctable input problems.
!-----------------------------------------------------------------------
!
! ****** Prevent crash if tcut is 0.
!
      if (t_cutoff1.le.0) then
        t_cutoff1=2.0_r_typ*tiny(1.0_r_typ)
        if (iamp0) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### ''t_cutoff1'' was 0 or negative.'
          write (*,*) '### It has been set to a tiny value'
          write (*,*) '### to avoid a NaN.'
        end if
      end if
!
! ****** Check for input errors & warnings that are not correctable.
!
      if (iamp0) then
!
        if (advance_t.and.alpha_nocoll.eq.0.and.advance_tc) then
          write (*,*)
          write (*,*) '### WARNING from CHECK_INPUTS:'
          write (*,*) '### You are advancing thermal conduction'
          write (*,*) '### with collionless thermal conduction off.'
          write (*,*) '### By default, thermal conduction is still'
          write (*,*) '### being multiplied by a radial profile.'
          write (*,*) '### (variables TC_R, TC_DR, TC_FAC0, TC_FAC1)'
        end if
!
! ****** Check for conflicting input parameters and exit code if found.
!
        if (interplanetary_run.and.ucase(initial_plasma).ne.'2DFILE') &
          then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### Invalid initial plasma requested:'
          write (*,*) 'INITIAL_PLASMA = ',trim(initial_plasma)
          write (*,*) '### The only allowed option for IP runs is:'
          write (*,*) '''2DFILE'''
        end if
!
! ****** Check time-dependent coronal boundary driving conflicts.
!
        if (.not.time_dependent_corona.and.(tdc_edb_correction_trunc &
           .or.tdc_edb_correction_etmod)) then
          write (*,*)
          write (*,*) '### WARNING in CHECK_INPUTS:'
          write (*,*) '### You set either ''tdc_edb_correction_trunc'''
          write (*,*) '### or ''tdc_edb_correction_etmod'' without'
          write (*,*) '### setting ''time_dependent_corona''.'
          write (*,*) '### This feature is turned off!'
        end if
!
        if (time_dependent_corona.and.tdc_edb_correction_trunc &
           .and.tdc_edb_correction_etmod) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### Setting ''tdc_edb_correction_trunc'' and '
          write (*,*) '### ''tdc_edb_correction_etmod'' not allowed.'
        end if
!
        if (time_dependent_corona.and.(.not.evolve_flux)) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### ''time_dependent_corona'' is set but '
          write (*,*) '### ''evolve_flux'' is not set.'
        end if
!
! ****** Check prescribe_bv conflicts.
!
        if (prescribe_bv.and.flow%active) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### Setting ''prescribe_bv'' and '
          write (*,*) '### ''flow%active'' not allowed.'
        end if
!
        if (prescribe_bv.and..not.evolve_flux) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### ''evolve_flux'' must be set to .true.'
          write (*,*) '### for ''prescribe_bv'' runs.'
        end if
!
        if (prescribe_bv.and..not.rotation_flux) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### ''rotation_flux'' must be set to .true.'
          write (*,*) '### for ''prescribe_bv'' runs.'
        end if
!
! ****** Check the sanity of the proton temperature flag.
!
        if (advance_tp.and..not.advance_t) then
          ierr=1
          write (*,*) ' '
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### You are advancing Tp but not Te!'
        end if
!
! ****** Check thermal conduction flags.
!
        if (advance_t) then
          if (advance_tc.and.tcond.le.0.) then
            ierr=1
            write (*,*)
            write (*,*) '### ERROR in CHECK_INPUTS:'
            write (*,*) '### You are advancing tc but tcond<=0!'
          end if
!
          if (.not.advance_tc.and.tcond.gt.0.) then
            write (*,*)
            write (*,*) '### WARNING in CHECK_INPUTS:'
            write (*,*) '### You are not advancing tc but tcond>0!'
          end if
        end if
!
! ****** Check that the user did not request to run the parallel
! ****** model (i.e, frozen B with flow along B only), and also
! ****** requested to zero out the parallel flow.  This combination
! ****** does not make sense.
!
        if (freeze_b.and.zero_v_parallel) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### You requested FREEZE_B=.true.'// &
                      ' and ZERO_V_PARALLEL=.true..'
          write (*,*) '### This combination does not make sense.'
        end if
!
! ****** Check that the user did not request to run the parallel
! ****** model in conjunction with an interplanetary run.
! ****** This combination is not allowed.
!
        if (freeze_b.and.interplanetary_run) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### You requested FREEZE_B=.true.'// &
                      ' for an interplanetary run.'
          write (*,*) '### This combination is not allowed.'
        end if
!
! ****** Computation along a field line checks.
!
        if (fl_compute.and.fl_file.eq.' ') then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### You requested FL_COMPUTE=.true. for'// &
                      ' computation along a field line but did not'// &
                      ' provide a field line file name, FL_FILE'
          write (*,*) '### This combination is not allowed.'
        end if
!
        if (fl_compute.and.advance_a) then
          ierr=1
          write (*,*)
          write (*,*) '### ERROR in CHECK_INPUTS:'
          write (*,*) '### You requested FL_COMPUTE=.true. for'// &
                      ' computation along a field line but set'// &
                      ' ADVANCE_A=.true.  This is not allowed.'
          write (*,*) '### Please set ADVANCE_A=.false.'
        end if
!
        if (.not.fl_compute.and.fl_file.ne.' ') then
          write (*,*)
          write (*,*) '### WARNING in CHECK_INPUTS:'
          write (*,*) '### You set FL_COMPUTE=.false.'// &
                      ' for computation along a field line but'// &
                      ' provided a field line file name, FL_FILE'
          write (*,*) '### You must set FL_COMPUTE=.true. to use'// &
                      ' computation along a field line.'
        end if
      end if
!
      call check_error_on_p0 (ierr)
!
!-----------------------------------------------------------------------
! ****** Input parameter processing.
!-----------------------------------------------------------------------
!
! ****** Set auto cycling when using STS methods.
!
      if (use_sts_visc.and..not.visc_auto_subcycle) then
        visc_auto_subcycle=.true.
        if (iamp0) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### Activating viscosity auto'
          write (*,*) '### subcycling due to use of STS.'
          write (*,*) '### Set visc_subcycles_max=1 to override.'
        end if
      end if
!
      if (use_sts_tc.and..not.tc_auto_subcycle) then
        tc_auto_subcycle=.true.
        if (iamp0) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### Activating thermal conduction auto'
          write (*,*) '### subcycling due to use of STS.'
          write (*,*) '### Set tc_subcycles_max=1 to override.'
        end if
      end if
!
! ****** Set pole filter paramaters.
!
      if (filter_poles) then
        pole_filter_t=.true.
        pole_filter_rho=.true.
        pole_filter_pw=.true.
        pole_filter_vr=.true.
        pole_filter_z=.true.
        if (iamp0) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### ''filter_poles'' is ACTIVE.'
          write (*,*) '### Auto-setting pole filter for all quantities.'
        end if
      end if
!
! ****** Find number of TP slice radii from input.
!
      n_tpslice_radii=0
      do i=1,max_tpslices
        if (slice_tp_radii(i).ne.0) then
          n_tpslice_radii=n_tpslice_radii+1
        else
          exit
        end if
      enddo
!
! ****** Make some options uppercase.
!
      calculation_frame=ucase(calculation_frame)
!
      if (interplanetary_run) then
        boundary_frame=ucase(boundary_frame)
      end if
!
      if (restart_run) then
        restart_calculation_frame=ucase(restart_calculation_frame)
!
! ****** Set default restart calculation frame if not
! ****** specified by the user.                        .
!
        if (restart_calculation_frame.eq.'FLAG') then
          restart_calculation_frame=calculation_frame
        end if
      end if
!
! ****** Check for NVIDIA GPU run. If yes, set if_prec parameters correctly.
!
      if (is_substring(compiler,'nvfortran') .and. &
          is_substring(compiler_flags,'stdpar=gpu')) then
!
        if (ifprec_v.ne.1) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### Preconditioner choice for velocity solve was'
          write (*,*) '### not compatible with GPU run.'
          write (*,*) '### Changing to diagonal scaling.'
          ifprec_v=1
        end if
!
        if (advance_tc.and.ifprec_t.ne.1) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### Preconditioner choice for thermal conduction'
          write (*,*) '### solve was not compatible with GPU run.'
          write (*,*) '### Changing to diagonal scaling.'
          ifprec_t=1
        end if
!
        if (ifprec_pot2d.ne.1) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### Preconditioner choice for boundary potential'
          write (*,*) '### field solves was not compatible with GPU run.'
          write (*,*) '### Changing to diagonal scaling.'
          ifprec_pot2d=1
        end if
!
        if (ifprec_divb.ne.1) then
          write (*,*)
          write (*,*) '### NOTE from CHECK_INPUTS:'
          write (*,*) '### Preconditioner choice for divergence cleaning'
          write (*,*) '### of re-meshed field solve was not compatible with'
          write (*,*) '### GPU run. Changing to diagonal scaling.'
          ifprec_divb=1
        end if
!
      end if
!
! ****** Update GPU versions of inputs that are "declared".
!
!$acc update device(t_cutoff1, &
!$acc               wtd_use_zw_effective_rho_limit, &
!$acc               zw_effective_rho_limit_lr, &
!$acc               zw_effective_rho_limit_lw)
!$acc enter data copyin(expert_user_override,natom_list)
!
end subroutine
!#######################################################################
subroutine initialize_magnetic_field_from_dipoles
!
!-----------------------------------------------------------------------
!
! ****** Load the initial magnetic field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x0,y0,z0,mx,my,mz
      real(r_typ) :: ar,at,ap
      integer :: i,j,k,n
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Initialize A.
!
      a%r=0.
      a%t=0.
      a%p=0.
!
! ****** Add a large-scale axisymmetric dipole.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from'// &
                    ' INITIALIZE_MAGNETIC_FIELD_FROM_DIPOLES:'
        write (9,*) '### Adding a sun-centered dipole:'
        write (9,*)
        write (9,*) 'B0_DIPOLE = ',b0_dipole
        write (9,*) 'DIPANGLE [deg] = ',dipangle
      end if
!
      call add_dipole (a)
!
! ****** Add N_SSDIP sub-surface dipoles.
!
      do n=1,n_ssdip
!
! ****** Get the parameters for the sub-surface dipole.
!
        call dipole_params (r_ssdip(n),t_ssdip(n),p_ssdip(n), &
                            alpha_ssdip(n),b0_ssdip(n), &
                            x0,y0,z0,mx,my,mz)
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from'// &
                      ' INITIALIZE_MAGNETIC_FIELD_FROM_DIPOLES:'
          write (9,*) '### Adding a sub-surface dipole:'
          write (9,*)
          write (9,*) 'Dipole number: ',n
          write (9,*) 'Location: r           = ',r_ssdip(n)
          write (9,*) 'Location: theta [deg] = ',t_ssdip(n)
          write (9,*) 'Location: phi [deg]   = ',p_ssdip(n)
          write (9,*) 'Dipole moment rotation wrt N pole [deg] = ', &
                      alpha_ssdip(n)
          write (9,*) 'Strength = ',b0_ssdip(n)
        end if
!
! ****** Add the vector potential due to the sub-surface dipole.
!
        do k=1,np
          do j=1,nt
            do i=1,nrm1
              call a_dipole (x0,y0,z0,mx,my,mz, &
                             r(i),th(j),ph(k),ar,at,ap)
              a%r(i,j,k)=a%r(i,j,k)+ar
            enddo
          enddo
        enddo
!
        do k=1,np
          do j=1,ntm1
            do i=1,nr
              call a_dipole (x0,y0,z0,mx,my,mz, &
                             rh(i),t(j),ph(k),ar,at,ap)
              a%t(i,j,k)=a%t(i,j,k)+at
            enddo
          enddo
        enddo
!
        do k=1,npm1
          do j=1,nt
            do i=1,nr
              call a_dipole (x0,y0,z0,mx,my,mz, &
                             rh(i),th(j),p(k),ar,at,ap)
              a%p(i,j,k)=a%p(i,j,k)+ap
            enddo
          enddo
        enddo
!
      enddo
!
! ****** Seam A.
!
!$acc update device(a%r,a%t,a%p)
      call seam_avec (a)
!
! ****** Set the BCs at the poles.
!
      call set_pole_bc_avec (a)
!
! ****** Get the magnetic field.
!
      call bfroma (a,b,one)
!$acc update self(a%r,a%t,a%p,b%r,b%t,b%p)
!
end subroutine
!#######################################################################
subroutine add_dipole (a)
!
!-----------------------------------------------------------------------
!
! ****** Add the magnetic field due a large-scale dipole to the
! ****** vector potential A.
!
! ****** The dipole is tilted DIPANGLE degrees, with a magnetic
! ****** field strength B0_DIPOLE.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
      use constants
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: deg_to_rad=pi/180._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sd,cd
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      if (b0_dipole.eq.0.) return
!
      sd=sin(dipangle*deg_to_rad)
      cd=cos(dipangle*deg_to_rad)
!
      do k=1,np
        do j=1,ntm1
          do i=1,nr
            a%t(i,j,k)=a%t(i,j,k)-b0_dipole*sin(ph(k))*sd/rh(i)**2
          enddo
        enddo
      enddo
!
      do k=1,npm1
        do j=1,nt
          do i=1,nr
            a%p(i,j,k)=a%p(i,j,k)+b0_dipole*( sin(th(j))*cd &
                                             -cos(th(j))*cos(p(k))*sd &
                                            )/rh(i)**2
          enddo
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine dipole_params (rd,td,pd,alpha,b0,x0,y0,z0,mx,my,mz)
!
!-----------------------------------------------------------------------
!
! ****** Get the Cartesian parameters for a dipole located at
! ****** spherical location (RD,TD,PD), with a dipole moment that
! ****** lies in a plane that is tangent to the solar surface.
! ****** The dipole moment is tilted an angle ALPHA with respect to
! ****** the North pole in the theta-phi plane; positive ALPHA
! ****** causes the moment to rotate clock-wise in this plane.
! ****** The strength of the dipole is B0.
!
! ****** This routine returns the location of the dipole (X0,Y0,Z0)
! ****** in Cartesian coordinates, as well as the dipole moment
! ****** (MX,MY,MZ).  These parameters can be used to get the vector
! ****** potential due to the dipole by calling routine A_DIPOLE.
!
! ****** Note that TD, PD, and ALPHA should be specified in degrees.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: rd,td,pd,alpha,b0
      real(r_typ), intent(out) :: x0,y0,z0,mx,my,mz
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: td_rad,pd_rad,alpha_rad
      real(r_typ) :: st,ct,sp,cp
      real(r_typ) :: th_x,th_y,th_z
      real(r_typ) :: ph_x,ph_y,ph_z
      real(r_typ) :: sa,ca
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: deg_to_rad=pi/180._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Convert input angles to radians.
!
      td_rad=td*deg_to_rad
      pd_rad=pd*deg_to_rad
      alpha_rad=alpha*deg_to_rad
!
! ****** Find the location of the dipole in Cartesian coordinates.
!
      call s2c (rd,td_rad,pd_rad,x0,y0,z0)
!
! ****** Find the theta-hat unit vector at (X0,Y0,Z0).
!
      st=sin(td_rad)
      ct=cos(td_rad)
      sp=sin(pd_rad)
      cp=cos(pd_rad)
!
      th_x= ct*cp
      th_y= ct*sp
      th_z=-st
!
! ****** Find the phi-hat unit vector at (X0,Y0,Z0).
!
      ph_x=-sp
      ph_y= cp
      ph_z=0.
!
! ****** Set the dipole moment vector (rotated clock-wise by
! ****** ALPHA degrees about the North pole).
!
      sa=sin(alpha_rad)
      ca=cos(alpha_rad)
!
      mx=b0*(-ca*th_x+sa*ph_x)
      my=b0*(-ca*th_y+sa*ph_y)
      mz=b0*(-ca*th_z+sa*ph_z)
!
end subroutine
!#######################################################################
subroutine a_dipole (x0,y0,z0,mx,my,mz,r,t,p,ar,at,ap)
!
!-----------------------------------------------------------------------
!
! ****** Get the spherical components of the vector potential
! ****** (AR,AT,AP) at spherical location (R,T,P), for a dipole
! ****** located at (X0,Y0,Z0), with a dipole moment (MX,MY,MZ).
!
! ****** This routine should not be called with (R,T,P) coincident
! ****** with (X0,Y0,Z0), due to the singularity of the vector
! ****** potential there.
!
! ****** Note that T and P should be specified in radians.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: x0,y0,z0,mx,my,mz
      real(r_typ), intent(in) :: r,t,p
      real(r_typ), intent(out) :: ar,at,ap
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x,y,z
      real(r_typ) :: r3i
      real(r_typ) :: ax,ay,az
      real(r_typ) :: st,ct,sp,cp
!
!-----------------------------------------------------------------------
!
! ****** Get the evaluation point in Cartesian coordinates.
!
      call s2c (r,t,p,x,y,z)
!
! ****** Get the vector potential in Cartesian coordinates.
!
      x=x-x0
      y=y-y0
      z=z-z0
!
      r3i=one/sqrt(x**2+y**2+z**2)**3
!
      ax=(my*z-mz*y)*r3i
      ay=(mz*x-mx*z)*r3i
      az=(mx*y-my*x)*r3i
!
! ****** Transform the vector potential to spherical coordinates.
!
      st=sin(t)
      ct=cos(t)
      sp=sin(p)
      cp=cos(p)
!
      ar= ax*st*cp+ay*st*sp+az*ct
      at= ax*ct*cp+ay*ct*sp-az*st
      ap=-ax*sp   +ay*cp
!
end subroutine
!#######################################################################
pure subroutine c2s (x,y,z,r,t,p)
!$acc routine(c2s) seq
!
!-----------------------------------------------------------------------
!
! ****** Convert from Cartesian coordinates (X,Y,Z)
! ****** to spherical coordinates (R,T,P).
!
! ****** This routine returns T and P in radians, in the
! ****** following range:
!
!          0. .le. t .le. pi
!          0. .le. p .lt. 2.*pi
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: x,y,z
      real(r_typ), intent(out) :: r,t,p
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: pid2=.5_r_typ*pi
      real(r_typ), parameter :: pi2=2._r_typ*pi
!
!-----------------------------------------------------------------------
!
      r=sqrt(x**2+y**2+z**2)
!
      if (r.eq.0.) then
        t=0.
      else
        t=acos(z/r)
      end if
!
      if (x.eq.0.) then
        if (y.ge.0.) then
          p=pid2
        else
          p=-pid2
        end if
      else
        p=atan2(y,x)
      end if
      if (p.lt.0.) p=p+pi2
!
end subroutine
!#######################################################################
pure subroutine s2c (r,t,p,x,y,z)
!$acc routine(s2c) seq
!
!-----------------------------------------------------------------------
!
! ****** Convert from spherical coordinates (R,T,P)
! ****** to Cartesian coordinates (X,Y,Z).
!
! ****** This routine assumes that T and P are in radians.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: r,t,p
      real(r_typ), intent(out) :: x,y,z
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: st
!
!-----------------------------------------------------------------------
!
      st=sin(t)
      x=r*st*cos(p)
      y=r*st*sin(p)
      z=r*cos(t)
!
end subroutine
!#######################################################################
subroutine cv2sv (ax,ay,az,t,p,ar,at,ap)
!
!-----------------------------------------------------------------------
!
! ****** Convert vector (AX,AY,AZ), expressed in Cartesian
! ****** coordinates, to vector (AR,AT,AP), expressed in spherical
! ****** coordinates at position (T,P).
!
! ****** This routine assumes that T and P are in radians.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: ax,ay,az
      real(r_typ) :: t,p
      real(r_typ) :: ar,at,ap
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: st,ct,sp,cp
!
!-----------------------------------------------------------------------
!
      st=sin(t)
      ct=cos(t)
      sp=sin(p)
      cp=cos(p)
!
      ar= ax*st*cp+ay*st*sp+az*ct
      at= ax*ct*cp+ay*ct*sp-az*st
      ap=-ax*sp   +ay*cp
!
end subroutine
!#######################################################################
pure subroutine sv2cv (ar,at,ap,t,p,ax,ay,az)
!$acc routine(sv2cv) seq
!
!-----------------------------------------------------------------------
!
! ****** Convert vector (AR,AT,AP), expressed in spherical
! ****** coordinates at position (T,P), to vector (AX,AY,AZ),
! ****** expressed in Cartesian coordinates.
!
! ****** This routine assumes that T and P are in radians.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: ar,at,ap,t,p
      real(r_typ), intent(out) :: ax,ay,az
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: st,ct,sp,cp
!
!-----------------------------------------------------------------------
!
      st=sin(t)
      ct=cos(t)
      sp=sin(p)
      cp=cos(p)
!
      ax= ar*st*cp+at*ct*cp-ap*sp
      ay= ar*st*sp+at*ct*sp+ap*cp
      az= ar*ct   -at*st
!
end subroutine
!#######################################################################
subroutine setup_helicity_pumping
!
!-----------------------------------------------------------------------
!
! ****** Setup the helicity pumping functionality.
!
! ****** Here we compute the Background vector potential and a static
! ****** pumping profile.
!
! ****** If this is a restart run OR fluxrope_preserve_br0 was true,
! ****** then we need to re-compute a potential/background field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use globals
      use vars
      use types
      use fields
      use mpidefs
      use restart
      use ucase_interface
      use fluxrope_parameters
      use helicity_pumping_params
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec),target :: a_save
!
!-----------------------------------------------------------------------
!
! ****** Set the helicity pumping profile.
!
      allocate (hpump_prof(nrm,ntm,npm)); hpump_prof(:,:,:)=0.
!
      call load_helicity_pumping_profile
!
      call alloc_avec (a_hpump)
!
! ****** If its not a restart, no fluxropes added, and you've
! ****** initialized with just a dipole or potential field then
! ****** just use the initial field you already computed.
!
      if (.not.(restart_run.or.fluxropes_added).and. &
         ((ucase(initial_field).eq.'DIPOLE').or. &
          (ucase(initial_field).eq.'POTENTIAL_FIELD'))) then
!
        a_hpump%r(:,:,:)=a%r(:,:,:)
        a_hpump%t(:,:,:)=a%t(:,:,:)
        a_hpump%p(:,:,:)=a%p(:,:,:)
!
! ****** If it is a restart, flux-ropes have been added, or the field
! ****** might have currents, then we need to recalculate the
! ****** background potential field based on the current flux
! ****** distribution in MAS.
!
      else
        call alloc_avec (a_save)
        a_save%r(:,:,:)=a%r(:,:,:)
        a_save%t(:,:,:)=a%t(:,:,:)
        a_save%p(:,:,:)=a%p(:,:,:)
!
! ****** If the configuration was set up by preserving br0, then
! ****** we need to also turn it off for this calculation.
!
        if (fluxrope_preserve_br0) then
          fluxrope_preserve_br0=.false.
          call potfld_from_mas_br0
          fluxrope_preserve_br0=.true.
        else
          call potfld_from_mas_br0
        endif
!
! ****** Save the background field and put back the current field.
!
        a_hpump%r(:,:,:)=a%r(:,:,:)
        a_hpump%t(:,:,:)=a%t(:,:,:)
        a_hpump%p(:,:,:)=a%p(:,:,:)
!
        a%r(:,:,:)=a_save%r(:,:,:)
        a%t(:,:,:)=a_save%t(:,:,:)
        a%p(:,:,:)=a_save%p(:,:,:)
!
        call dealloc_avec (a_save)
      endif
!
end subroutine
!#######################################################################
subroutine helicity_pump
!
!-----------------------------------------------------------------------
!
! ****** Pump the helicity by adding in a fraction of the energized
! ****** part of the vector potential.
!
! ****** This will only happen if we are on a pumping step.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars
      use types
      use globals
      use fields
      use mpidefs
      use time_profiles
      use io_units
      use helicity_pumping_params
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i, j, k
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: hpump_factor
      real(r_typ) :: ci
!
!-----------------------------------------------------------------------
!
! ****** Leave if we are not a pumping step.
!
      if (.not.hpump_step) return
!
! ****** Get the fractional multiplier based on the time profile.
!
      hpump_factor=tp_vars(TP_INDEX_HELICITY_PUMPING)%value
!
! ****** Print a diagnostic message.
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from HELICITY_PUMP:'
        write (IO_OUT,*) '### APPLYING FRACTIONAL BOOST!'
        write (IO_OUT,*) 'spatial profile type = ',hpump_profile
        write (IO_OUT,*) 'hpump_constant = ',hpump_constant
        write (IO_OUT,*) 'time profile value = ',hpump_factor
        write (IO_OUT,*) 'NTIME = ',ntime
        write (IO_OUT,*) 'TIME = ',time
      end if
!
! ****** Ar component update (includes R Boundary).
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        ci=AVGTP(hpump_prof,i,j,k)*hpump_factor
        a%r(i,j,k)=(one+ci)*a%r(i,j,k) - a_hpump%r(i,j,k)*ci
      enddo
!
! ****** At component update (not including R Boundary).
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        ci=AVGRP(hpump_prof,i,j,k)*hpump_factor
        a%t(i,j,k)=(one+ci)*a%t(i,j,k) - a_hpump%t(i,j,k)*ci
      enddo
!
! ****** Ap component update (not including R Boundary).
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        ci=AVGRT(hpump_prof,i,j,k)*hpump_factor
        a%p(i,j,k)=(one+ci)*a%p(i,j,k) - a_hpump%p(i,j,k)*ci
      enddo
!
! ****** Update At at the R boundaries, don't extrapolate ci in r.
!
      if (rb0) then
        i=1
        do concurrent (k=2:npm1, j=1:ntm1)
          ci=AVGP(hpump_prof,i,j,k)*hpump_factor
          a%t(i,j,k)=(one+ci)*a%t(i,j,k) - a_hpump%t(i,j,k)*ci
        enddo
      end if
!
      if (rb1) then
        i=nr
        do concurrent (k=2:npm1, j=1:ntm1)
          ci=AVGP(hpump_prof,i,j,k)*hpump_factor
          a%t(i,j,k)=(one+ci)*a%t(i,j,k) - a_hpump%t(i,j,k)*ci
        enddo
      end if
!
! ****** Update Ap at the R boundaries, don't extrapolate ci in r.
!
      if (rb0) then
        i=1
        do concurrent (k=1:npm1, j=2:ntm1)
          ci=AVGT(hpump_prof,i,j,k)*hpump_factor
          a%p(i,j,k)=(one+ci)*a%p(i,j,k) - a_hpump%p(i,j,k)*ci
        enddo
      end if
!
      if (rb1) then
        i=nr
        do concurrent (k=1:npm1, j=2:ntm1)
          ci=AVGT(hpump_prof,i,j,k)*hpump_factor
          a%p(i,j,k)=(one+ci)*a%p(i,j,k) - a_hpump%p(i,j,k)*ci
        enddo
      end if
!
! ****** Seam the final vector potential and set the BCs.
!
      call seam_avec (a)
      call set_pole_bc_avec (a)
!
! ****** Get B and J.
!
      call bfroma (a,b,one)
      call jfromb (b,fj)
!
end subroutine
!#######################################################################
subroutine fluxrope_setup
!
!-----------------------------------------------------------------------
!
! ****** Setup the flux ropes.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use mpidefs
      use fluxrope_parameters
      use tdm_parameters
      use rbsl_parameters
      use fluxrope_file_parameters
      use vars, ONLY : time,time_at_start
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i
      logical, save :: first=.true.
!
!-----------------------------------------------------------------------
!
! ****** Reset flag.
!
      fluxropes_added=.false.
!
! ****** Check if we are still adding any ropes.
!
      do i=1, n_fr_max
!
        if (tdm_fluxrope(i)%add.or. &
            rbsl_fluxrope(i)%add.or. &
            rope_from_file(i)%add) then
!
          fluxropes_added=.true.
!
          if (first) then
            call alloc_avec (a_fr)
            first=.false.
          end if
          a_fr%r(:,:,:)=0.0
          a_fr%t(:,:,:)=0.0
          a_fr%p(:,:,:)=0.0
!
          exit
!
        end if
      enddo
!
      if (fluxropes_added) then
!
! ****** Calculate the flux rope vector potentials. Don't share the
! ****** loops so that the ofile output is organized.
!
! ****** TDm.
!
      do i=1,n_fr_max
        if (tdm_fluxrope(i)%add.and. &
           (time-time_at_start).ge.tdm_fluxrope(i)%insertion_time) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### Adding the TDM flux rope with index = ',i
          end if
          call tdm_add_a (tdm_fluxrope(i),a_fr)
          tdm_fluxrope(i)%add=.false.
        end if
      enddo
!
! ****** RBSL.
!
      do i=1,n_fr_max
        if (rbsl_fluxrope(i)%add.and. &
           (time-time_at_start).ge.rbsl_fluxrope(i)%insertion_time) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### Adding the RBSL flux rope with index = ',i
          end if
          call rbsl_add_a (rbsl_fluxrope(i),a_fr)
          rbsl_fluxrope(i)%add=.false.
        end if
      enddo
!
! ****** Fluxrope (or arbitrary vector potential) from a file.
!
      do i=1,n_fr_max
        if (rope_from_file(i)%add.and. &
          (time-time_at_start).ge.rope_from_file(i)%insertion_time) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### Adding the vector potential files '// &
                        ' defined with index = ',i
          end if
          call fluxrope_add_a_from_file (rope_from_file(i),a_fr)
          rope_from_file(i)%add=.false.
        end if
      enddo
!
      end if
!
end subroutine
!#######################################################################
subroutine fluxrope_add
!
!-----------------------------------------------------------------------
!
! ****** Add the flux ropes (if any) calculated by fluxrope_setup.
!
!-----------------------------------------------------------------------
!
      use number_types
      use fluxrope_parameters
      use fields, ONLY :  a, b, fj
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ierr
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Add in the fluxrope vector potential
!
!$acc update device(a_fr%r,a_fr%t,a_fr%p)
      do concurrent (k=1:np, j=1:nt, i=1:nrm1)
        a%r(i,j,k)=a%r(i,j,k)+a_fr%r(i,j,k)
      enddo
!
      do concurrent (k=1:np, j=1:ntm1, i=1:nr)
        a%t(i,j,k)=a%t(i,j,k)+a_fr%t(i,j,k)
      enddo
!
      do concurrent (k=1:npm1, j=1:nt, i=1:nr)
        a%p(i,j,k)=a%p(i,j,k)+a_fr%p(i,j,k)
      enddo
!
! ****** Initialize B and J (might be used elsewhere in startup).
!
      call bfroma (a,b,one)
!
      call jfromb (b,fj)
!
end subroutine
!#######################################################################
subroutine rbsl_add_a (rbsl_fr,a_fr)
!
!-----------------------------------------------------------------------
!
! ****** Add the vector potential of an RBSL flux rope to A_FR.
! ****** The parameters are in structure RBSL_FR.
!
! ****** This implementation is based on the fortran program APATH,
! ****** written by Viacheslav Titov. It was adapted for MAS by CD.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use mpidefs
      use rbsl_structure_def
      use rbsl_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(rbsl_def) :: rbsl_fr
      type(avec) :: a_fr
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: i,j,k
      real(r_typ), dimension(3) :: xp
      real(r_typ), dimension(3) :: avecp
      real(r_typ) :: ar,at,ap
      real(r_typ) :: rc,tc,pc,xy,yz,zc
!
!-----------------------------------------------------------------------
!
! ****** Initialize the RBSL parameters.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from RBSL_ADD_A:'
        write (9,*) '### Calculating A for an RBSL flux rope.'
      end if
!
      call rbsl_init_params (rbsl_fr,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in RBSL_ADD_A:'
          write (*,*) '### An error occurred while determining'// &
                      ' the RBSL model parameters.'
          write (*,*) '### Please check the RBSL input parameters.'
        end if
      end if
      call check_error_on_any_proc (ierr)
!
! ****** Calculate the vector potential corresponding to the TDM
! ****** flux rope.
!
      do k=1,np
        do j=1,nt
          do i=1,nrm1
            call rbsl_get_vector_potential (r(i),th(j),ph(k),ar,at,ap)
            a_fr%r(i,j,k)=a_fr%r(i,j,k)+ar
          enddo
        enddo
      enddo
!
      do k=1,np
        do j=1,ntm1
          do i=1,nr
            call rbsl_get_vector_potential (rh(i),t(j),ph(k),ar,at,ap)
            a_fr%t(i,j,k)=a_fr%t(i,j,k)+at
          enddo
        enddo
      enddo
!
      do k=1,npm1
        do j=1,nt
          do i=1,nr
            call rbsl_get_vector_potential (rh(i),th(j),p(k),ar,at,ap)
            a_fr%p(i,j,k)=a_fr%p(i,j,k)+ap
          enddo
        enddo
      enddo
!
! ****** Deallocate the helper arrays
!
      deallocate (Rvc)
      deallocate (Rvca)
      deallocate (dRvc)
      deallocate (smult)
!
! ****** Seam A_FR.
!
!$acc update device(a_fr%r,a_fr%t,a_fr%p)
      call seam_avec (a_fr)
!
! ****** Set the BCs at the poles.
!
      call set_pole_bc_avec (a_fr)
!$acc update self(a_fr%r,a_fr%t,a_fr%p)
!
end subroutine
!#######################################################################
subroutine rbsl_get_vector_potential (r,t,p,ar,at,ap)
!
!-----------------------------------------------------------------------
!
! ****** Get the RBSL vector potential at a specific point in space.
!
! ****** Parameters needed by this subroutine are initialized by
! ****** calling rbsl_init_params.
!
! ****** This implementation is based on the fortran program APATH,
! ****** written by Viacheslav Titov. It was adapted for MAS by CD.
!
!-----------------------------------------------------------------------
!
      use number_types
      use rbsl_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: r, t, p
      real(r_typ), intent(out) :: ar, at, ap
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x, y, z
      real(r_typ) :: ax, ay, az
      real(r_typ), dimension(3) :: xyz
      real(r_typ), dimension(3) :: AIv, AFv, Av
!
!-----------------------------------------------------------------------
!
! ****** Get the cartesian coordinates of this location.
!
      call s2c(r,t,p,x,y,z)
      xyz(1)=x
      xyz(2)=y
      xyz(3)=z
!
! ****** Compute the Cartesian vector potential.
!
      call AIFv ( npts, Rvca, dRvc, smult, xyz/a, AIv, AFv)
      Av=AIU*AIv+AFU*AFv
!
! ****** Get the vector potential in spherical coordinates.
!
      call cv2sv(Av(1),Av(2),Av(3),t,p,ar,at,ap)
!
end subroutine
!#######################################################################
subroutine AIFv ( n, Rvca, dRvc, smult, rv, AIv, AFv)
!
!-----------------------------------------------------------------------
!
! ****** Line integral to obtain RBSL Vector Potential.
!
! ****** This subroutine was designed, written, and tested by Viacheslav
! ****** Titov as part of the standalone fortran program APATH.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, intent(in) :: n
      real(r_typ), intent(in), dimension(n-1,3) :: Rvca
      real(r_typ), intent(in), dimension(n-1,3) :: dRvc
      real(r_typ), intent(in), dimension(n-1) :: smult
      real(r_typ), intent(in), dimension(3) :: rv
      real(r_typ), intent(out), dimension(3) :: AIv
      real(r_typ), intent(out), dimension(3) :: AFv
!
!-----------------------------------------------------------------------
!
      integer :: i, j, j1, j2
      real(r_typ) :: r,  KIAr, KFAr
      real(r_typ), dimension(3) :: dRxrmR, rmR
!
!-----------------------------------------------------------------------
!
      AIv=0.0
      AFv=0.0
!
! ****** Loop over each axis path segment, calculate its contribution.
!
      do i=1,n-1
        do j=1,3
          rmR(j)=rv(j) - Rvca(i,j)
        enddo
        do j=1,3
          j1= mod(j  , 3)+1
          j2= mod(j+1, 3)+1
          dRxrmR(j)=dRvc(i,j1)*rmR(j2) - dRvc(i,j2)*rmR(j1)
        enddo
        r=sqrt(rmR(1)**2+rmR(2)**2+rmR(3)**2)
        call KIFA(r, KIAr, KFAr)
        do j=1,3
          AIv(j)=AIv(j)+KIAr*dRvc(i,j)
          AFv(j)=AFv(j)+smult(i)*KFAr*dRxrmR(j)
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine KIFA (r, KIA, KFA)
!
!-----------------------------------------------------------------------
!
! ****** Regularized kernals for Bio-Savart vector potentials/fields.
!
! ****** This subroutine was designed, written, and tested by Viacheslav
! ****** Titov as part of the standalone fortran program APATH.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: r
      real(r_typ), intent(out) :: KIA, KFA
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: r2, s, asr, asc
!
!-----------------------------------------------------------------------
!
      r2=r ** 2
      if (r .eq. 0.0D0) then
         KIA=0.169765272631355D1
         KFA=0.195082190781956D1
         return
      else if (r .lt. 0.1D1) then
         s=sqrt(0.1D1 - r2)
         asr=asin(r) / r
         asc=asin((0.1D1+0.2D1 * r2) / (0.5D1 - 0.2D1 * r2))
         KIA=0.636619772367582D0 * (0.1D1 / 0.3D1 * s * &
               (0.5D1 - 0.2D1 * r2)+asr)
         KFA=0.102062072615966D1+0.636619772367582D0 * s &
               - 0.408248290463864D0 * r2 - 0.129949466872280D0 &
               * (0.5D1 - 0.2D1 * r2) * asc - 0.636619772367582D0 &
               * (s - asr) / r2
         return
      else
         KIA=0.1D1 / r
         KFA=KIA / r2
         return
      end if
!
end subroutine
!#######################################################################
subroutine tdm_init_params (tdm_fr,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Initialize the parameters for the modified Titov-Demoulin
! ****** flux rope model whose parameters are in structure TDM_FR.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_structure_def
      use tdm_parameters
      use tdm_parameters_internal
      use mpidefs
      use lcase_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(tdm_def) :: tdm_fr
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: three=3._r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: five=5._r_typ
      real(r_typ), parameter :: eight=8._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: denom
      real(r_typ) :: apex
      real(r_typ) :: foot
      real(r_typ) :: Bp
      integer :: hand
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Check the validity of the parameters.
!
      tdm_fr%rope_type=lcase(tdm_fr%rope_type)
      if (trim(tdm_fr%rope_type).ne.'hollow_nonff'.and. &
          trim(tdm_fr%rope_type).ne.'hollow'.and. &
          trim(tdm_fr%rope_type).ne.'parabolic') then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_INIT_PARAMS:'
          write (*,*) '### Invalid TDm model specified'
          write (*,*) '### Valid models are:'
          write (*,*) '###  hollow_nonff'
          write (*,*) '###  hollow'
          write (*,*) '###  parabolic'
          write (*,*) 'ROPE_TYPE = ',tdm_fr%rope_type
        end if
        ierr=1
        return
      end if
!
      if (tdm_fr%apex_height.le.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_INIT_PARAMS:'
          write (*,*) '### Invalid apex height specified:'
          write (*,*) '### The apex height must be positive:'
          write (*,*) 'APEX_HEIGHT = ',tdm_fr%apex_height
        end if
        ierr=1
        return
      end if
!
      if ((.not.tdm_fr%use_major_radius).and.(tdm_fr%apex_height.gt. &
          tdm_fr%footpoint_halfdistance)) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_INIT_PARAMS:'
          write (*,*) '### Invalid apex height specified:'
          write (*,*) '### The apex height must not exceed'// &
                      ' the footpoint half-distance:'
          write (*,*) 'APEX_HEIGHT = ',tdm_fr%apex_height
          write (*,*) 'FOOTPOINT_HALFDISTANCE = ', &
                      tdm_fr%footpoint_halfdistance
        end if
        ierr=1
        return
      end if
!
      if (tdm_fr%minor_radius.le.0..or. &
          tdm_fr%delta.le.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_INIT_PARAMS:'
          write (*,*) '### Invalid parameters specified:'
          write (*,*) '### The following parameters must be positive:'
          write (*,*) 'MINOR_RADIUS = ',tdm_fr%minor_radius
          write (*,*) 'DELTA = ',tdm_fr%delta
        end if
        ierr=1
        return
      end if
!
      if (.not.(tdm_fr%handedness.eq.1.or. &
                tdm_fr%handedness.eq.-1)) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_INIT_PARAMS:'
          write (*,*) '### Invalid flux rope handedness specified:'
          write (*,*) '### The handedness must be -1 or +1:'
          write (*,*) 'HANDEDNESS = ',tdm_fr%handedness
        end if
        ierr=1
        return
      end if
!
! ****** Definition of the parameters:
!
!          R  = torus major radius
!          a  = torus minor radius
!          d  = depth of torus center below the photosphere
!          II = total axial current
!          FF = total axial flux
!
! ****** Load the local variables.
!
      apex=tdm_fr%apex_height
      hand=tdm_fr%handedness
!
      if (tdm_fr%use_major_radius) then
        R=tdm_fr%major_radius
        foot=sqrt(two*apex*R - apex**2)
      else
        foot=tdm_fr%footpoint_halfdistance
        R=half*(apex**2+foot**2)/apex
      end if
      d=R-apex
      a=tdm_fr%minor_radius
!
! ***** Setup the charges if necessary
! ***** Multiply q0 by -handedness to get jxb downward
!
      if (tdm_fr%add_charges) then
        L=tdm_fr%charge_halflength
        q0=tdm_fr%charge_magnitude
      end if
!
! ****** The poloidal field is specified as a positive value
! ****** for convenience.  Insert a negative sign to indicate
! ****** that the poloidal field points opposite to the direction
! ****** of the normal vector.
!
      if (tdm_fr%get_bp_from_charge.and.tdm_fr%add_charges) then
        denom=sqrt((one+(R/L)**2)**3)
        Bp=-two*abs(q0)/L**2/denom*tdm_fr%charge_to_bp_factor
      else
        Bp=-abs(tdm_fr%b_poloidal)
      end if
!
! ****** Compute the surface current and axial flux.
! ****** The hollow core and parabolic formulas differ slightly
!
      select case(tdm_fr%rope_type)
      case ('hollow_nonff','hollow')
        II=-four*pi*R*Bp/(log(eight*R/a)-1.5_r_typ)
        FF=hand*half*II*a
      case ('parabolic')
        II=-four*pi*R*Bp/(log(eight*R/a)-25._r_typ/24._r_typ)
        FF=hand*three*II*a/(five*sqrt(two))
      end select
!
! ****** Set the thickness of the surface transition layer.
!
      delta=tdm_fr%delta
!
! ****** Write some diagnostics.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from TDM_INIT_PARAMS:'
        write (9,*) '### Parameters for the modified'// &
                    ' Titov-Demoulin flux rope:'
        write (9,*)
        write (9,*) 'Flag to Add: ',tdm_fr%add
        write (9,*) 'Rope Type = ',trim(tdm_fr%rope_type)
        write (9,*) 'Flag to use the user specified major radius:', &
                     tdm_fr%use_major_radius
        write (9,*) 'Major radius = ',R
        write (9,*) 'Minor radius = ',a
        write (9,*) 'Apex height = ',apex
        write (9,*) 'Footpoint separation = ',two*foot
        write (9,*) 'Fractional surface transition layer width = ',delta
        write (9,*) 'Axial current = ',II
        write (9,*) 'Axial flux = ',FF
        write (9,*) 'Axial field = ',FF/(pi*a**2)
        write (9,*) 'Confining poloidal field = ',-Bp
        write (9,*) 'Handedness [-1 => left-handed,'// &
                    ' +1 => right-handed] = ',hand
        write (9,*) 'Flag to add charges: ', tdm_fr%add_charges
        if (tdm_fr%add_charges) then
          write (9,*) 'Charge Magnitude: ', q0
          write (9,*) 'Charge Halfdistance: ', L
          if (tdm_fr%get_bp_from_charge) then
            write (9,*) 'Getting bp from the charge magnitude.'
            write (9,*) 'Charge factor: ', tdm_fr%charge_to_bp_factor
          end if
        end if
      end if
!
end subroutine
!#######################################################################
subroutine tdm_init_transformation (tdm_fr,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Initialize the parameters that define the transformation
! ****** between the modified Titov-Demoulin flux rope coordinates
! ****** and the global coordinates for the flux rope with
! ****** parameters in structure TDM_FR.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_structure_def
      use tdm_parameters_internal
      use s2c_interface
      use sv2cv_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(tdm_def) :: tdm_fr
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: d2r=pi/180._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: tfv
      real(r_typ), dimension(3) :: x_hat,normal,zp_hat,r_hat
      real(r_typ), dimension(3) :: rot
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Get the Cartesian coordinates of the origin of the local
! ****** TDM coordinate system.
!
      call s2c (tdm_fr%origin_r, &
                tdm_fr%origin_t, &
                tdm_fr%origin_p, &
                tdm_origin_x, &
                tdm_origin_y, &
                tdm_origin_z)
!
! ****** Get the Cartesian components of the TDM normal.
!
      call sv2cv (zero, &
                  tdm_fr%normal_t, &
                  tdm_fr%normal_p, &
                  tdm_fr%origin_t, &
                  tdm_fr%origin_p, &
                  normal(1),normal(2),normal(3))
!
! ****** Get the rotation matrix RM1 that rotates by
! ****** TILT_FROM_VERTICAL degrees about the Y' axis.
!
      tfv=d2r*tdm_fr%tilt_from_vertical
      rot(1)=0.
      rot(2)=one
      rot(3)=0.
!
      call get_matrix_from_euler (rot(1),rot(2),rot(3),tfv,rm1,ierr)
!
      if (ierr.ne.0) return
!
! ****** Get the rotation matrix that rotates the X axis into the
! ****** TDM normal.  This defines the X' axis.  This transformation
! ****** has a "twist angle" about the new X' axis that needs to
! ****** be specified (see below).
!
      x_hat(1)=one
      x_hat(2)=0.
      x_hat(3)=0.
!
! ****** Get the matrix RM2 that rotates X_HAT into NORMAL.
!
      call get_matrix_v1_to_v2 (x_hat(1),x_hat(2),x_hat(3), &
                                normal(1),normal(2),normal(3), &
                                rm2,ierr)
!
      if (ierr.ne.0) return
!
! ****** Get the position of the Z' axis in the (X,Y,Z)
! ****** coordinate system.
!
      zp_hat(1)=0.
      zp_hat(2)=0.
      zp_hat(3)=one
!
      call transform_vector_rotate (.false.,rm2,zp_hat)
!
! ****** Get the direction of the r-hat vector in Cartesian
! ****** coordinates at the origin of the local coordinate system.
!
      r_hat(1)=tdm_origin_x
      r_hat(2)=tdm_origin_y
      r_hat(3)=tdm_origin_z
!
! ****** Get the rotation matrix RM3 that rotates Z' into
! ****** R_HAT. This is a twist around the X' axis.
!
      call get_matrix_v1_to_v2 (zp_hat(1),zp_hat(2),zp_hat(3), &
                                r_hat(1),r_hat(2),r_hat(3), &
                                rm3,ierr)
!
      if (ierr.ne.0) return
!
end subroutine
!#######################################################################
subroutine get_matrix_v1_to_v2 (x1,y1,z1,x2,y2,z2,t,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Load the 3 x 3 transformation matrix T that rotates the
! ****** vector V1 = (X1,Y1,Z1) into the vector V2 = (X2,Y2,Z2).
!
!-----------------------------------------------------------------------
!
! ****** The transformation matrix is determined by computing
! ****** the Euler parameters for the rotation.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x1,y1,z1
      real(r_typ) :: x2,y2,z2
      real(r_typ), dimension(3,3) :: t
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: a1,a2,ax,ay,az,phi,a
!
!-----------------------------------------------------------------------
!
      ierr=0
!
      a1=sqrt(x1**2+y1**2+z1**2)
      a2=sqrt(x2**2+y2**2+z2**2)
!
! ****** If either V1 or V2 has zero length, exit with an error.
!
      if (a1.eq.0..or.a2.eq.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in GET_MATRIX_V1_TO_V2:'
          write (*,*) '### A zero-length vector was specified:'
          write (*,*) 'X1 = ',x1,' Y1 = ',y1,' Z1 = ',z1
          write (*,*) 'X2 = ',x2,' Y2 = ',y2,' Z2 = ',z2
        end if
        ierr=1
        return
      end if
!
! ****** The axis about which to rotate is given by V1 x V2.
!
      ax=(y1*z2-z1*y2)
      ay=(z1*x2-x1*z2)
      az=(x1*y2-y1*x2)
!
! ****** Set the rotation angle.
!
      phi=acos((x1*x2+y1*y2+z1*z2)/(a1*a2))
!
! ****** Check for a zero-length cross-product vector.
! ****** In this case, V1 and V2 are either exactly parallel or
! ****** exactly antiparallel.  In this case, use a
! ****** cross-product vector that is perpendicular to V1 and V2
! ****** (with an arbitrary orientation).
! ****** This arbitrariness only affects the "twist" of the
! ****** transformation.
!
      a=sqrt(ax**2+ay**2+az**2)
      if (a.eq.0.) then
        if (z1.eq.0.) then
          ax=0.
          ay=0.
          az=one
        else
          ax=z1
          ay=0.
          az=-x1
        end if
      end if
!
! ****** Set the corresponding 3 x 3 rotation matrix.
!
      call get_matrix_from_euler (ax,ay,az,phi,t,ierr)
!
end subroutine
!#######################################################################
subroutine get_matrix_from_euler (vx,vy,vz,phi,t,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Load the transformation matrix T that corresponds to a
! ****** rotation of PHI radians about the vector (VX,VY,VZ).
!
! ****** The transformation matrix is determined by computing
! ****** the Euler parameters for the rotation.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: vx,vy,vz
      real(r_typ) :: phi
      real(r_typ), dimension(3,3) :: t
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: a,ax,ay,az,sp,cp
!
! ****** Euler vector.
!
      real(r_typ) :: e(4)
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Normalize the vector.
!
      a=sqrt(vx**2+vy**2+vz**2)
!
      if (a.eq.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in GET_MATRIX_FROM_EULER:'
          write (*,*) '### A zero-length rotation vector was'// &
                      ' specified:'
          write (*,*) 'VX = ',vx,' VY = ',vy,' VZ = ',vz
        end if
        ierr=1
        return
      end if
!
      ax=vx/a
      ay=vy/a
      az=vz/a
!
! ****** Set the Euler parameters.
!
      sp=sin(half*phi)
      cp=cos(half*phi)
!
      e(1)=ax*sp
      e(2)=ay*sp
      e(3)=az*sp
      e(4)=cp
!
! ****** Get the 3 x 3 transformation matrix.
!
      call set_rotation_matrix (e,t)
!
end subroutine
!#######################################################################
subroutine set_rotation_matrix (e,a)
!
!-----------------------------------------------------------------------
!
! ****** Set the 3 x 3 rotation matrix from the Euler parameters.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(4) :: e
      real(r_typ), dimension(3,3) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      a(1,1)=one-two*(e(2)*e(2)+e(3)*e(3))
      a(2,1)=two*(e(1)*e(2)+e(3)*e(4))
      a(3,1)=two*(e(3)*e(1)-e(2)*e(4))
!
      a(1,2)=two*(e(1)*e(2)-e(3)*e(4))
      a(2,2)=one-two*(e(3)*e(3)+e(1)*e(1))
      a(3,2)=two*(e(2)*e(3)+e(1)*e(4))
!
      a(1,3)=two*(e(3)*e(1)+e(2)*e(4))
      a(2,3)=two*(e(2)*e(3)-e(1)*e(4))
      a(3,3)=one-two*(e(2)*e(2)+e(1)*e(1))
!
end subroutine
!#######################################################################
subroutine tdm_add_a (tdm_fr,a_tdm)
!
!-----------------------------------------------------------------------
!
! ****** Add the vector potential to structure A_TDM corresponding
! ****** to the modified Titov-Demoulin flux rope whose parameters
! ****** are in structure TDM_FR.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use mpidefs
      use tdm_structure_def
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(tdm_def) :: tdm_fr
      type(avec) :: a_tdm
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: i,j,k
      real(r_typ), dimension(3) :: xp
      real(r_typ), dimension(3) :: avecp
      real(r_typ) :: ar,at,ap
!
!-----------------------------------------------------------------------
!
! ****** Initialize the TDM parameters.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from TDM_ADD_A:'
        write (9,*) '### Calculating A for a modified'// &
                    ' Titov-Demoulin flux rope.'
      end if
!
      call tdm_init_params (tdm_fr,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_ADD_A:'
          write (*,*) '### An error occurred while determining'// &
                      ' the TDM model parameters.'
          write (*,*) '### Please check the TDM input parameters.'
        end if
      end if
      call check_error_on_any_proc (ierr)
!
! ****** Initialize the coordinate transformation.
!
      call tdm_init_transformation (tdm_fr,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_ADD_A:'
          write (*,*) '### An error occurred while determining'// &
                      ' the TDM model coordinate'
          write (*,*) '### transformation.'
          write (*,*) '### Please check the TDM input parameters.'
        end if
      end if
      call check_error_on_any_proc (ierr)
!
! ****** Calculate the vector potential corresponding to the TDM
! ****** flux rope.
!
      do k=1,np
        do j=1,nt
          do i=1,nrm1
            call tdm_transform_position (r(i),th(j),ph(k), &
                                         xp)
            call tdm_get_vector_potential (xp,avecp,tdm_fr)
            call tdm_transform_vector (avecp, &
                                       th(j),ph(k), &
                                       ar,at,ap)
            a_tdm%r(i,j,k)=a_tdm%r(i,j,k)+ar
          enddo
        enddo
      enddo
!
      do k=1,np
        do j=1,ntm1
          do i=1,nr
            call tdm_transform_position (rh(i),t(j),ph(k), &
                                         xp)
            call tdm_get_vector_potential (xp,avecp,tdm_fr)
            call tdm_transform_vector (avecp, &
                                       t(j),ph(k), &
                                       ar,at,ap)
            a_tdm%t(i,j,k)=a_tdm%t(i,j,k)+at
          enddo
        enddo
      enddo
!
      do k=1,npm1
        do j=1,nt
          do i=1,nr
            call tdm_transform_position (rh(i),th(j),p(k), &
                                         xp)
            call tdm_get_vector_potential (xp,avecp,tdm_fr)
            call tdm_transform_vector (avecp, &
                                       th(j),p(k), &
                                       ar,at,ap)
            a_tdm%p(i,j,k)=a_tdm%p(i,j,k)+ap
          enddo
        enddo
      enddo
!
! ****** Seam A_TDM.
!
!$acc update device(a_tdm%r,a_tdm%t,a_tdm%p)
      call seam_avec (a_tdm)
!
! ****** Set the BCs at the poles.
!
      call set_pole_bc_avec (a_tdm)
!$acc update self(a_tdm%r,a_tdm%t,a_tdm%p)
!
end subroutine
!#######################################################################
subroutine fluxrope_add_a_from_file (rope_file,a_fr)
!
!-----------------------------------------------------------------------
!
! ****** Read the vector potential from a set of files specified by
! ****** the rope_from_file structure. Add it to A_FR.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use mpidefs
      use rdhdf_3d_interface
      use field_table
      use distribute_array_interface
      use seam_interface
      use fluxrope_file_structure_def
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(rope_file_def) :: rope_file
      type(avec) :: a_fr
!
!-----------------------------------------------------------------------
!
      character(256) :: fname
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0
      logical :: scale
      integer :: nr_f,nt_f,np_f
      real(r_typ), dimension(:), pointer, contiguous ::r_f,t_f,p_f
      real(r_typ), dimension(:,:,:), pointer, contiguous ::f
      real(r_typ), dimension(:,:,:),pointer, contiguous ::ar_g,at_g,ap_g
      type(avec) :: a_fr_read
!
!-----------------------------------------------------------------------
!
! ****** Allocate the storage for a_fr_READ.
!
      call alloc_avec (a_fr_read)
!
! ****** Read Ar from HDF file FNAME on IPROC0.
!
      if (iamp0) then
        fname=rope_file%ar_file
        write (9,*)
        write (9,*) '### COMMENT from FLUXROPE_ADD_A_FROM_FILE:'
        write (9,*) '### Reading Ar from file: ', &
                    trim(fname)
!
        call rdhdf_3d (fname,scale,nr_f,nt_f,np_f,f, &
                       r_f,t_f,p_f,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### Could not read Ar:'
          write (*,*) 'IERR (from RDHDF_3D) = ',ierr
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array has scales.
!
      if (iamp0) then
        ierr=0
        if (.not.scale) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### The Ar file does not have scales:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array is the correct size
!
      if (iamp0) then
        ierr=0
        if (nr_f .ne. nrm1_g .or. nt_f .ne. nt_g &
                 .or. np_f .ne. np_g) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### The Ar file does not have the correct size:'
          write (*,*) 'File name: ',trim(fname)
          write (*,*) 'File Mesh: ', &
                       'nr_f: ',nr_f,'nt_f: ',nt_f,'np_f: ',np_f
          write (*,*) 'MAS Mesh: ', &
                       'nrm1_g: ',nrm1_g,'nt_g: ',nt_g,'np_g: ',np_g
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the global array on IPROC0.
!
      if (iamp0) then
        allocate (ar_g(nrm1_g,nt_g,np_g))
        ar_g=f*rope_file%a_factor
      else
        allocate (ar_g(1,1,1))
      end if
!
! ****** Distribute the global array from IPROC0 to the local arrays.
!
      call distribute_array (fldtab(IFLD_AR)%n1, &
                             fldtab(IFLD_AR)%n2, &
                             fldtab(IFLD_AR)%n3, &
                             ar_g,a_fr_read%r)
!
! ****** Add Ar to a_fr.
!
      a_fr%r=a_fr%r+a_fr_read%r
!
! ****** Deallocate temporary arrays.
!
      if (iamp0) then
        deallocate (r_f)
        deallocate (t_f)
        deallocate (p_f)
        deallocate (f)
      end if
!
! ****** Read At from HDF file FNAME on IPROC0.
!
      if (iamp0) then
        fname=rope_file%at_file
        write (9,*)
        write (9,*) '### COMMENT from FLUXROPE_ADD_A_FROM_FILE:'
        write (9,*) '### Reading At from file: ', &
                    trim(fname)
!
        call rdhdf_3d (fname,scale,nr_f,nt_f,np_f,f, &
                       r_f,t_f,p_f,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### Could not read At:'
          write (*,*) 'IERR (from RDHDF_3D) = ',ierr
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array has scales.
!
      if (iamp0) then
        ierr=0
        if (.not.scale) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### The At file does not have scales:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array is the correct size
!
      if (iamp0) then
        ierr=0
        if (nr_f .ne. nr_g .or. nt_f .ne. ntm1_g &
                 .or. np_f .ne. np_g) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### The At file does not have the correct size:'
          write (*,*) 'File name: ',trim(fname)
          write (*,*) 'File Mesh:', &
                      'nr_f: ',nr_f,'nt_f: ',nt_f,'np_f: ',np_f
          write (*,*) 'MAS Mesh:', &
                      'nr_g: ',nr_g,'ntm1_g: ',ntm1_g,'np_g: ',np_g
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the global array on IPROC0.
!
      if (iamp0) then
        allocate (at_g(nr_g,ntm1_g,np_g))
        at_g=f*rope_file%a_factor
      else
        allocate (at_g(1,1,1))
      end if
!
! ****** Distribute the global array from IPROC0 to the local arrays.
!
      call distribute_array (fldtab(IFLD_AT)%n1, &
                             fldtab(IFLD_AT)%n2, &
                             fldtab(IFLD_AT)%n3, &
                             at_g,a_fr_read%t)
!
! ****** Add At to a_fr.
!
      a_fr%t=a_fr%t+a_fr_read%t
!
! ****** Deallocate temporary arrays.
!
      if (iamp0) then
        deallocate (r_f)
        deallocate (t_f)
        deallocate (p_f)
        deallocate (f)
      end if
!
! ****** Read Ap from HDF file FNAME on IPROC0.
!
      if (iamp0) then
        fname=rope_file%ap_file
        write (9,*)
        write (9,*) '### COMMENT from FLUXROPE_ADD_A_FROM_FILE:'
        write (9,*) '### Reading Ap from file: ', &
                    trim(fname)
!
        call rdhdf_3d (fname,scale,nr_f,nt_f,np_f,f, &
                       r_f,t_f,p_f,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### Could not read Ap:'
          write (*,*) 'IERR (from RDHDF_3D) = ',ierr
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array has scales.
!
      if (iamp0) then
        ierr=0
        if (.not.scale) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### The Ap file does not have scales:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array is the correct size
!
      if (iamp0) then
        ierr=0
        if (nr_f .ne. nr_g .or. nt_f .ne. nt_g &
                 .or. np_f .ne. npm1_g) then
          write (*,*)
          write (*,*) '### ERROR in FLUXROPE_ADD_A_FROM_FILE:'
          write (*,*) '### The Ap file does not have the correct size:'
          write (*,*) 'File name: ',trim(fname)
          write (*,*) 'File Mesh:', &
                       'nr_f: ',nr_f,'nt_f: ',nt_f,'np_f: ',np_f
          write (*,*) 'MAS Mesh:', &
                       'nr_g: ',nr_g,'nt_g: ',nt_g,'npm1_g: ',npm1_g
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the global array on IPROC0.
!
      if (iamp0) then
        allocate (ap_g(nr_g,nt_g,npm1_g))
        ap_g=f*rope_file%a_factor
      else
        allocate (ap_g(1,1,1))
      end if
!
! ****** Distribute the global array from IPROC0 to the local arrays.
!
      call distribute_array (fldtab(IFLD_AP)%n1, &
                             fldtab(IFLD_AP)%n2, &
                             fldtab(IFLD_AP)%n3, &
                             ap_g,a_fr_read%p)
!
! ****** Add Ap to a_fr.
!
      a_fr%p=a_fr%p+a_fr_read%p
!
! ****** Deallocate temporary arrays.
!
      if (iamp0) then
        deallocate (r_f)
        deallocate (t_f)
        deallocate (p_f)
        deallocate (f)
      end if
!
! ****** Set boundary conditions at the poles.
!
!$acc update device(a_fr%r,a_fr%t,a_fr%p)
      call set_pole_bc_avec (a_fr)
!
! ****** Seam the array.
!
      call seam_avec (a_fr)
!$acc update self(a_fr%r,a_fr%t,a_fr%p)
!
! ****** Deallocate temporary arrays.
!
      deallocate (ar_g)
      deallocate (at_g)
      deallocate (ap_g)
!
      call dealloc_avec (a_fr_read)
!
end subroutine
!#######################################################################
subroutine rbsl_init_params (rbsl_fr,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Initialize the parameters for the RBSL flux rope model
! ****** whose parameters are in structure RBSL_FR.
!
! ****** This implementation is based on the fortran program APATH,
! ****** written by Viacheslav Titov. It was adapted for MAS by CD.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use rbsl_structure_def
      use rbsl_parameters
      use rbsl_parameters_internal
      use mpidefs
      use ucase_interface
      use rdhdf_2d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(rbsl_def) :: rbsl_fr
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: twopi=two*pi
      real(r_typ), parameter :: sqr2=sqrt(two)
      real(r_typ), parameter :: CF=-0.6_r_typ/sqr2
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: ndim
      real(r_typ), dimension(:), pointer, contiguous :: scale_s, scale_d
      real(r_typ), dimension(:,:), pointer, contiguous :: path_rtp
!
!-----------------------------------------------------------------------
!
      integer :: i, j
      integer :: hand
      real(r_typ) :: Ia
      real(r_typ) :: x, y, z, r, t, p
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Check the validity of the parameters.
!
      if (trim(ucase(rbsl_fr%path_file)).eq.'NO_DEFAULT') then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in RBSL_INIT_PARAMS:'
          write (*,*) '### An RBSL Rope is to be added, but'
          write (*,*) '### the path_file is not defined.'
          write (*,*) 'PATH_FILE = ',rbsl_fr%path_file
        end if
        ierr=1
        return
      end if
!
      if (rbsl_fr%minor_radius.le.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in RBSL_INIT_PARAMS:'
          write (*,*) '### Invalid parameters specified:'
          write (*,*) '### The minor radius must be positive:'
          write (*,*) 'MINOR_RADIUS = ',rbsl_fr%minor_radius
        end if
        ierr=1
        return
      end if
!
      if (.not.(rbsl_fr%handedness.eq.1.or. &
                rbsl_fr%handedness.eq.-1)) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in RBSL_INIT_PARAMS:'
          write (*,*) '### Invalid flux rope handedness specified:'
          write (*,*) '### The handedness must be -1 or +1:'
          write (*,*) 'HANDEDNESS = ',rbsl_fr%handedness
        end if
        ierr=1
        return
      end if
!
! ****** Read the path file
!
      call rdhdf_2d (rbsl_fr%path_file, scale, npts, ndim, path_rtp, &
                     scale_s, scale_d, ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in RBSL_INIT_PARAMS:'
        write (9,*) '### Could not read the path file.'
        write (9,*) 'IERR (from RDHDF_2D) = ',ierr
        write (9,*) 'File name: ',trim(rbsl_fr%path_file)
        ierr=1
        return
      end if
!
      if ( ndim.ne.3) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in RBSL_INIT_PARAMS:'
          write (*,*) '### 2nd dim of path file (r,t,p) is not size 3!'
          write (*,*) 'PATH_FILE DIM1: ', npts
          write (*,*) 'PATH_FILE DIM2: ', ndim
        end if
        ierr=1
        return
      end if
!
! ****** Define the computational parameters
! ****** NOTE VT's code apath used chi, which is minus the handedness)
!
!       a: fluxrope minor radius
!      Ia: signed axial current (pos/neg: parallel/anti to axis path)
!    hand: handedness (pos/neg: right/left handed)
!
      a=rbsl_fr%minor_radius
      Ia=rbsl_fr%axial_current
      hand=rbsl_fr%handedness
!
      AIU=Ia/two/twopi
      AFU=-hand*CF*AIU
!
! ****** Compute the path information that you will need.
!
      allocate ( Rvc(npts  , 3))
      allocate (Rvca(npts-1, 3))
      allocate (dRvc(npts-1, 3))
      allocate (smult(npts-1))
!
! ****** Compute helper arrays for the flux rope axis.
!
      do i=1,npts
        r=path_rtp(i,1)
        t=path_rtp(i,2)
        p=path_rtp(i,3)
        call s2c(r,t,p,x,y,z)
        Rvc(i,1)=x / a
        Rvc(i,2)=y / a
        Rvc(i,3)=z / a
      enddo
!
      do i=1,npts-1
        do j=1,3
          Rvca(i,j)=half * (Rvc(i+1,j)+Rvc(i,j))
          dRvc(i,j)=Rvc(i+1,j) - Rvc(i,j)
        enddo
      enddo
!
! ****** If mirroring. Modify the sign factor for the parts of the
! ****** path that are below the surface.
!
      smult=one
      if (rbsl_fr%mirror_poloidal) then
        do i=1,npts-1
          r=sqrt(Rvca(i,1)**2+Rvca(i,2)**2+Rvca(i,3)**2)*a
          if (r.lt.one) then
            smult(i)=-one
          end if
        enddo
      end if
!
! ****** Write some diagnostics.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from RBSL_INIT_PARAMS:'
        write (9,*) '### Parameters for the regularized Biot-'// &
                    'Savart Law (RBSL) flux rope:'
        write (9,*)
        write (9,*) 'Flag to Add: ',rbsl_fr%add
        write (9,*) 'Path File: ',trim(rbsl_fr%path_file)
        write (9,*) 'Minor radius = ',a
        write (9,*) 'Axial current = ',Ia
        write (9,*) 'Handedness [-1 => left-handed,'// &
                    ' +1 => right-handed] = ',hand
        write (9,*) 'Flag to mirror the poloidal current'// &
                    ' below the photosphere = ', rbsl_fr%mirror_poloidal
      end if
!
end subroutine
!#######################################################################
subroutine transform_vector_rotate (inverse,a,v)
!
!-----------------------------------------------------------------------
!
! ****** Transform the vector position V by the matrix A.
!
! ****** When INVERSE=.TRUE., apply the "inverse" rotation that
! ****** corresponds to multiplying V by the inverse of the
! ****** matrix A.  (Since A is assumed to be orthonormal, the
! ****** inverse of A is identical to the transpose of A.)
!
! ****** When INVERSE=.FALSE., multiply V by A.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: inverse
      real(r_typ), dimension(3) :: v
      real(r_typ), dimension(3,3) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: vo
!
!-----------------------------------------------------------------------
!
! ****** Transform the vector according to V := A * V.
!
      vo=v
!
      if (inverse) then
        v(1)=a(1,1)*vo(1)+a(2,1)*vo(2)+a(3,1)*vo(3)
        v(2)=a(1,2)*vo(1)+a(2,2)*vo(2)+a(3,2)*vo(3)
        v(3)=a(1,3)*vo(1)+a(2,3)*vo(2)+a(3,3)*vo(3)
      else
        v(1)=a(1,1)*vo(1)+a(1,2)*vo(2)+a(1,3)*vo(3)
        v(2)=a(2,1)*vo(1)+a(2,2)*vo(2)+a(2,3)*vo(3)
        v(3)=a(3,1)*vo(1)+a(3,2)*vo(2)+a(3,3)*vo(3)
      end if
!
end subroutine
!#######################################################################
subroutine tdm_transform_position (rv,tv,pv,xp)
!
!-----------------------------------------------------------------------
!
! ****** Convert the spherical position (RV,TV,PV) to the Cartesian
! ****** position XP in the local coordinate system (X',Y',Z') of
! ****** the modified Titov-Demoulin flux rope model.
!
!-----------------------------------------------------------------------
!
      use number_types
      use tdm_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: rv,tv,pv
      real(r_typ), dimension(3) :: xp
!
!-----------------------------------------------------------------------
!
! ****** Transform (RV,TV,PV) to Cartesian coordinates.
!
      call s2c (rv,tv,pv,xp(1),xp(2),xp(3))
!
! ****** Translate XP to the local coordinate origin.
!
      xp(1)=xp(1)-tdm_origin_x
      xp(2)=xp(2)-tdm_origin_y
      xp(3)=xp(3)-tdm_origin_z
!
! ****** Apply the inverse of rotation matrix RM3.
!
      call transform_vector_rotate (.true.,rm3,xp)
!
! ****** Apply the inverse of rotation matrix RM2.
!
      call transform_vector_rotate (.true.,rm2,xp)
!
! ****** Apply the inverse of rotation matrix RM1.
!
      call transform_vector_rotate (.true.,rm1,xp)
!
! ****** The resulting vector XP now has the Cartesian position in
! ****** the local coordinate system (X',Y',Z').
!
end subroutine
!#######################################################################
subroutine tdm_transform_vector (avecp,t,p,ar,at,ap)
!
!-----------------------------------------------------------------------
!
! ****** Convert the Cartesian vector AVECP, defined in the local
! ****** coordinate system (X',Y',Z') of the TDM model, to a
! ****** spherical vector (AR,AT,AP), defined at spherical
! ****** position (T,P) in the global spherical coordinate system.
!
!-----------------------------------------------------------------------
!
      use number_types
      use tdm_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: avecp
      real(r_typ) :: t,p
      real(r_typ) :: ar,at,ap
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: v
!
!-----------------------------------------------------------------------
!
! ****** Transform the Cartesian vector AVECP, defined in
! ****** the (X',Y',Z') coordinate system, to a Cartesian vector
! ****** defined in the (X,Y,Z) coordinate system.
!
      v=avecp
!
! ****** Apply rotation matrix RM1.
!
      call transform_vector_rotate (.false.,rm1,v)
!
! ****** Apply rotation matrix RM2.
!
      call transform_vector_rotate (.false.,rm2,v)
!
! ****** Apply rotation matrix RM3.
!
      call transform_vector_rotate (.false.,rm3,v)
!
! ****** Transform Cartesian vector V into spherical vector
! ****** (AR,AT,AP) at spherical position (T,P).
!
      call cv2sv (v(1),v(2),v(3),t,p,ar,at,ap)
!
end subroutine
!#######################################################################
subroutine tdm_get_vector_potential (xp,avecp,tdm_fr)
!
!-----------------------------------------------------------------------
!
! ****** Get the Cartesian components of the vector potential AVECP
! ****** for the modified Titov-Demoulin flux rope at the
! ****** Cartesian position XP in the (X',Y',Z') coordinate system.
!
! ****** This routine calls a specific routine depending on the
! ****** type of TDm rope you wish to use.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_structure_def
      use tdm_parameters_internal
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: xp
      real(r_typ), dimension(3) :: avecp
      type(tdm_def) :: tdm_fr
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Add the flux rope field
!
      select case(tdm_fr%rope_type)
      case ('hollow_nonff')
        call tdm_get_vector_potential_hollow_nonff (xp,avecp)
      case ('hollow')
        call tdm_get_vector_potential_hollow (xp,avecp)
      case ('parabolic')
        call tdm_get_vector_potential_parabolic (xp,avecp)
      case default
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TDM_GET_VECTOR_POTENTIAL:'
          write (*,*) '### case statement on tdm_fr%rope_type'// &
                      ' found no matches!'
          write (*,*) 'ROPE_TYPE = ',tdm_fr%rope_type
        end if
        ierr=1
        call check_error_on_any_proc (ierr)
      end select
!
! ****** Add the charge field if necessary
!
      if (tdm_fr%add_charges) then
        call tdm_add_charge_vector_potential(xp,avecp)
      end if
!
end subroutine
!#######################################################################
subroutine tdm_get_vector_potential_hollow_nonff (xp,avecp)
!
!-----------------------------------------------------------------------
!
! ****** Get the Cartesian components of the vector potential AVECP
! ****** for the old hollow core TDm flux rope at the Cartesian
! ****** position XP in the (X',Y',Z') coordinate system.
! ****** This flux rope is the original non-force free version.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: xp
      real(r_typ), dimension(3) :: avecp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Get rid of this in due time!
!
      real(r_typ), parameter :: limit=5._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x,y,z,rp,RHO
      real(r_typ) :: rhot,k,kt,Ekt,Kkt,A0t
      real(r_typ) :: A1t,A2t,apol(3),ator(3),C
      real(r_typ) :: scaled_rho
      real(r_typ) :: delta_length
!
!-----------------------------------------------------------------------
!
! ****** Elliptic integral functions.
!
      real(r_typ), external :: elliptic_integral_e
      real(r_typ), external :: elliptic_integral_k
!
!-----------------------------------------------------------------------
!
      x=xp(1)
      y=xp(2)
      z=xp(3)
!
! ****** Set the distance from the origin in [y,z] plane.
!
      rp=sqrt(y**2+(z+d)**2)
!
! ****** Set the local radius from the flux rope axis.
!
      RHO=sqrt(x**2+(rp-R)**2)
!
! ****** Titov et al. 2014 defition of delta is fractional but old
! ****** implementation defined it in units of length: dnew=dold/a,
! ****** so multiply it here.
!
      delta_length=a*delta
!
! ****** Adjust RHO to implement a surface transition layer.
!
      scaled_rho=(RHO-a)/delta_length
      if (scaled_rho.le.-limit) then
        rhot=a
      else if (scaled_rho.ge.limit) then
        rhot=RHO
      else
        rhot=half*(RHO+a)+quarter*delta_length* &
             dlog(four*dcosh(scaled_rho)**2)
      end if
!
      kt=two*sqrt(rp*R/(four*rp*R+rhot**2))
      Ekt=elliptic_integral_e(kt)
      Kkt=elliptic_integral_k(kt)
!
      k =two*sqrt(R*rp/(x**2+(rp+R)**2))
!
      A0t=((two-kt**2)*Kkt-two*Ekt)/kt
      A1t=-two*Kkt/kt**2+(-two+kt**2)*Ekt/(-one+kt)/(kt+one)/kt**2
      C=A1t/sqrt(x**2+(rp+R)**2)**3
      A2t=(-four+5._r_typ*kt**2)*Kkt/(-one+kt)/(kt+one)/kt**3- &
          (kt**4-7._r_typ*kt**2+four)*Ekt &
          /(-one+kt)**2/(kt+one)**2/kt**3
!
! ****** Get the toroidal vector potential (produces B poloidal).
!
      ator(1)=0.
      ator(2)=-(z+d)/rp*(II/two/pi)*sqrt(R/rp)*A0t
      ator(3)=y/rp*(II/two/pi)*sqrt(R/rp)*A0t
!
! ****** Get the poloidal vector potential (produces B toroidal).
!
      apol(1)=FF/pi* &
              (R/rp*(R**2+x**2-rp**2)*C+sqrt(R/rp)*A0t/rp/two)/two
      apol(1)=apol(1)+FF/pi*sqrt(R/rp)*(a**2* &
         A2t*(k-kt)/sqrt(four*rp*R+a**2)**3+A1t*(k-kt)/rp/two)/two
      apol(2)=FF/pi*x*R*C*y/rp
      apol(3)=FF/pi*x*R*C*(z+d)/rp
!
! ****** Return the total vector potential.
!
      avecp=ator+apol
!
end subroutine
!#######################################################################
subroutine tdm_get_vector_potential_hollow (xp,avecp)
!
!-----------------------------------------------------------------------
!
! ****** Get the Cartesian components of the vector potential AVECP
! ****** for the hollow core TDm flux rope at the Cartesian
! ****** position XP in the (X',Y',Z') coordinate system.
! ****** This rope is described in Titov et al. 2014.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: xp
      real(r_typ), dimension(3) :: avecp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: three=3._r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: five=5._r_typ
      real(r_typ), parameter :: seven=7._r_typ
      real(r_typ), parameter :: eight=8._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x,y,z,rp,RHO
      real(r_typ) :: rhos,k,ks,Eks,Kks,A0s
      real(r_typ) :: A1s,A2s,apol(3),ator(3),C
      real(r_typ) :: xi, h0, fxi, gxi
!
!-----------------------------------------------------------------------
!
! ****** Elliptic integral functions.
!
      real(r_typ), external :: elliptic_integral_e
      real(r_typ), external :: elliptic_integral_k
      real(r_typ), external :: tdm_hproc
      external :: tdm_fg
!
!-----------------------------------------------------------------------
!
      x=xp(1)
      y=xp(2)
      z=xp(3)
!
! ****** Set the distance from the origin in [y,z] plane.
!
      rp=sqrt(y**2+(z+d)**2)
!
! ****** Set the local radius from the flux rope axis.
!
      RHO=sqrt(x**2+(rp-R)**2)
!
! ****** Get positional params (xi is norm distance to rope edge/delta)
!
      xi=(RHO/a-one)/delta
      h0=tdm_hproc(-one/delta)
      call tdm_fg(xi,delta,h0,fxi,gxi)
!
! ****** Get the toroidal vector potential (produces B poloidal).
!
      rhos=a*(one+delta*fxi)
      ks=sqrt(rp*R/(rp*R+rhos**2/four))
      Eks=elliptic_integral_e(ks)
      Kks=elliptic_integral_k(ks)
      A0s=((two-ks**2)*Kks-two*Eks)/ks
!
      if (rp.eq.0.) then
         C=0.
      else
         C=sqrt(R/rp)/rp*A0s
      end if
      C=(II/two/pi)*C
!
      ator(1)=0.
      ator(2)=-(z+d)*C
      ator(3)=y*C
!
! ****** Get the poloidal vector potential (produces B toroidal).
!
      rhos=a*(one+delta*gxi)
      ks=sqrt(rp*R/(rp*R+rhos**2/four))
      k=sqrt(rp*R/(rp*R+rho**2/four))
      Eks=elliptic_integral_e(ks)
      Kks=elliptic_integral_k(ks)
      A0s=((two-ks**2)*Kks-two*Eks)/ks
      A1s=(two-ks**2)*Eks/(one-ks**2)/ks**2-two*Kks/ks**2
      A2s=(five*ks**2-four)*Kks/(ks**2-one)/ks**3- &
          (ks**4-seven*ks**2+four)*Eks/(ks**2-one)**2/ks**3
!
      if (rp.eq.0.) then
         apol(1)=pi*R**2/four/(rhos**2)*( three/RHO+one/rhos &
            +three*(one+two*a**2/rhos)*(one/RHO-one/rhos))
         C=0.
      else
         apol(1)=sqrt(R/rp)*(A0s+A1s*(k-ks))/(two*rp) &
                +(a**2*ks**3*(k-ks)*A2s+k**3*(R**2-rp**2+x**2)*A1s) &
                /(eight*sqrt(R*rp**5))
         apol(1)=FF/(two*pi)*apol(1)
         C=FF*x*k**3*A1s/(eight*pi*rp**2*sqrt(R*rp))
      end if
!
      apol(2)=C*y
      apol(3)=C*(z+d)
!
! ****** Return the total vector potential.
!
      avecp=ator+apol
!
end subroutine
!#######################################################################
subroutine tdm_get_vector_potential_parabolic (xp,avecp)
!
!-----------------------------------------------------------------------
!
! ****** Get the Cartesian components of the vector potential AVECP
! ****** for the parabolic TDm flux rope at the Cartesian
! ****** position XP in the (X',Y',Z') coordinate system.
! ****** This rope is described in Titov et al. 2014.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: xp
      real(r_typ), dimension(3) :: avecp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: three=3._r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: five=5._r_typ
      real(r_typ), parameter :: seven=7._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x,y,z,rp,RHO
      real(r_typ) :: rhos,k,ks,Eks,Kks,A0s
      real(r_typ) :: A1s,A2s,apol(3),ator(3)
      real(r_typ) :: xi, h0, hxi, Fconst, dkks1, dkks2, pj
      real(r_typ) :: AI, AFr, AFx, Cn
!
!-----------------------------------------------------------------------
!
! ****** Elliptic integral functions.
!
      real(r_typ), external :: elliptic_integral_e
      real(r_typ), external :: elliptic_integral_k
      real(r_typ), external :: tdm_hproc
      real(r_typ), external :: tdm_hsmoo
!
!-----------------------------------------------------------------------
!
      x=xp(1)
      y=xp(2)
      z=xp(3)
!
! ****** Set the distance from the origin in [y,z] plane.
!
      rp=sqrt(y**2+(z+d)**2)
!
! ****** Set the local radius from the flux rope axis.
!
      RHO=sqrt(x**2+(rp-R)**2)
!
! ****** Get positional params (xi is norm distance to rope edge/delta)
!
      xi=(RHO/a-one)/delta
      h0=tdm_hproc(-one/delta)
      hxi=tdm_hsmoo(xi,delta,h0)
      rhos=a*(one+delta*hxi)
      ks=sqrt(rp*R/(rp*R+rhos**2/four))
      k=sqrt(rp*R/(rp*R+rho**2/four))
!
! ****** Most of the terms are common for both components
!
      Fconst=a*0.6_r_typ/sqrt(two)*sign(one,FF)
!
      if (rp .eq. 0._r_typ) then
        AI=0.
        AFr=0.
        AFx=Fconst*pi/two*(R/rhos)**2*(three/RHO-one/rhos &
           +three*(a/rhos)**2*(one/RHO-one/rhos))
      else
        Eks=elliptic_integral_e(ks)
        Kks=elliptic_integral_k(ks)
        A0s=((two-ks**2)*Kks-two*Eks)/ks
        A1s=(two-ks**2)*Eks/(one-ks**2)/ks**2-two*Kks/ks**2
        A2s=(five*ks**2-four)*Kks/(ks**2-one)/ks**3- &
            (ks**4-seven*ks**2+four)*Eks/(ks**2-one)**2/ks**3
        dkks1=k-ks
        dkks2=(k-ks)**2
        AI=sqrt(R)/(rp**1.5_r_typ)*(A0s+A1s*dkks1+A2s*dkks2/two)
!
        pj=three+four*A1s*dkks1
        AFr=Fconst*x*k**3*(pj**1.5_r_typ)*A1s &
            /(12._r_typ*sqrt(three*R)*(rp**2.5_r_typ))
        AFx=Fconst*sqrt(R)/(two*(rp**1.5_r_typ))*( A0s+a**2*ks**3*A1s &
            /(four*R*rp)+(pj**2.5_r_typ)/(30._r_typ*sqrt(three)) &
            -0.3_r_typ &
            +pj**(1.5_r_typ)/(12._r_typ*sqrt(three)*R*rp) &
            *( (k**3*(R**2+x**2-rp**2) &
            -a**2*ks**3)*A1s+a**2*ks**3*A2s*dkks1 ) )
      end if
!
! ****** Get the toroidal vector potential (produces B poloidal).
!
      ator(1)=0.
      ator(2)=-(z+d)*AI
      ator(3)=y*AI
!
! ****** Get the poloidal vector potential (produces B toroidal).
!
      apol(1)=AFx
      apol(2)=AFr*y
      apol(3)=AFr*(z+d)
!
! ****** Return the total vector potential.
!
      Cn=II/(two*pi)
      avecp=(ator+apol)*Cn
!
end subroutine
!#######################################################################
function elliptic_integral_e (k)
!
!-----------------------------------------------------------------------
!
! ****** COMPLETE ELLIPTIC INTEGRAL E(x) OF THE SECOND KIND:
! ****** POLYNOMIAL APPROXIMATION [after Abramowitz & Stegun].
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: k
      real(r_typ) :: elliptic_integral_e
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: elle
      real(r_typ) :: t1,t12,t2,t3,t5
!
!-----------------------------------------------------------------------
!
      t1=k**2
      t2=t1**2
      t3=t2**2
      t5=t2*t1
      t12=log(1.D0/(1.D0-t1))
      elle=(0.526449639D-2*t3-0.6175496082D-1*t5+0.24567970449D0*t2 &
            -0.57713619518D0*t1+0.38794695512D0)*t12 &
            +0.1736506451D-1*t3-0.1170340935D0*t5 &
            +0.30951790564D0*t2-0.78064520345D0*t1+0.15707963268D1
!
      elliptic_integral_e=elle
!
      return
end function
!#######################################################################
function elliptic_integral_k (k)
!
!-----------------------------------------------------------------------
!
! ****** COMPLETE ELLIPTIC INTEGRAL K(x) OF THE FIRST KIND:
! ****** POLYNOMIAL APPROXIMATION WITH AN ERROR <= 2e-8
! ****** [Abramowitz & Stegun].
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: k
      real(r_typ) :: elliptic_integral_k
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: ellk
      real(r_typ) :: t1,t12,t2,t3,t5
!
!-----------------------------------------------------------------------
!
      t1=k**2
      t2=t1**2
      t3=t2**2
      t5=t2*t1
      t12=log(1.D0/(1.D0-t1))
      ellk=(0.441787012D-2*t3-0.5095503394D-1*t5 &
            +0.19516036686D0*t2-0.38011304835D0*t1 &
            +0.73148984531D0)*t12+0.1451196212D-1*t3 &
            -0.9547348561D-1*t5+0.23524960794D0*t2 &
            -0.33879005012D0*t1+0.157079632679D1
!
      elliptic_integral_k=ellk
!
      return
end function
!#######################################################################
function tdm_hproc(xi)
!
!-----------------------------------------------------------------------
!
!     SWITCHING FUNCTION h(xi) FOR BOTH COMPONENTS OF THE VECTOR POTENTIAL:
!     code written by V.S.Titov
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: xi
      real(r_typ) :: tdm_hproc
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: h, ex2
      real(r_typ), parameter :: xilim=5.0_r_typ
      real(r_typ), parameter :: two=2.0_r_typ
      integer :: n=10
      integer, parameter :: nlim=10
!
!-----------------------------------------------------------------------
!
        if (abs(xi).le.xilim) then
           h=(xi+log(two*cosh(xi)))/two
        else
           if (xi.gt.xilim) then
              ex2=exp(-2*xi)
              h=xi
           else
              h=0._r_typ
              ex2=exp(2*xi)
           end if
           do n=1,nlim
              h=h+(-1)**(n+1)*ex2**n
           enddo
        end if
        tdm_hproc=h
        return
end function
!#######################################################################
function tdm_hsmoo(xi,delta,h0)
!
!-----------------------------------------------------------------------
!
!     Smoothing function for h(xi) at rho=0
!     see (Titov et al. 2014 equation A1 for details)
!     code written by V.S.Titov
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: xi,delta,h0
      real(r_typ) :: tdm_hsmoo
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: tdm_hproc
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: hxi
      real(r_typ), parameter :: L0=3.0_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
! ****** h0=hproc(-1/delta) must be determind outside of this function
!
! ****** delta*a*L0 is a smoothing length scale at rho=0.0
!
      hxi=tdm_hproc(xi)
      tdm_hsmoo=h0+(hxi-h0)*tanh((xi+one/delta)/L0)
      return
end function
!#######################################################################
subroutine tdm_fg(xi,delta,h0,f,g)
!
!-----------------------------------------------------------------------
!
!     MATCHING FUNCTIONS f(xi) AND g(xi) FOR TOROITDAL
!     AND POLOIDAL, RESPECTIVELY, VECTOR POTENTIALS:
!     code written by V.S.Titov
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: xi,delta,h0,f,g
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: tdm_hsmoo
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: hxi
!
!-----------------------------------------------------------------------
!
! ****** h0=hproc(-1/delta) must be determind outside of the routine fg
!
      hxi=tdm_hsmoo(xi,delta,h0)
!
      f=hxi-0.406982224701535e0_r_typ &
           *exp(-0.15464309982239e1_r_typ*hxi &
                    -0.249947772314288e0_r_typ*hxi**2)
      g=hxi+0.406982224701535e0_r_typ &
           *exp(-0.238261647628e1_r_typ*hxi)
end subroutine
!#######################################################################
subroutine tdm_add_charge_vector_potential (xp,avecp)
!
!-----------------------------------------------------------------------
!
! ****** Add the Cartesian components of the vector potential
! ****** corresponding to two charges at a fixed depth at a halflength
! ****** L at position XP in the (X',Y',Z') coordinate system to the
! ****** vector AVECP. The charge line is perpendicular to the rope.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use tdm_parameters_internal
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(3) :: xp
      real(r_typ), dimension(3) :: avecp
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x,y,z,rp2,Fac,A0,A1
!
!-----------------------------------------------------------------------
!
      x=xp(1)
      y=xp(2)
      z=xp(3)
!
! ****** Set the distance from the origin in [y,z] plane.
!
      rp2=y**2+(z+d)**2
!
! ****** if rp is zero, the vector potential is zero
!
      if (rp2 .eq. 0._r_typ) then
        return
      end if
!
! ****** factor for left charge
!
      Fac=sqrt((L+x)**2+rp2)
      A0=(L+x)/rp2/Fac
!
! ****** factor for right charge
!
      Fac=sqrt((L-x)**2+rp2)
      A1=(L-x)/rp2/Fac
!
! ***** Now get the components, note the x component is always zero
!
      avecp(2)=avecp(2) -(z+d)*(A0+A1)*q0
      avecp(3)=avecp(3)+   y*(A0+A1)*q0
!
end subroutine
!#######################################################################
subroutine initialize_hs_equilibrium
!
!-----------------------------------------------------------------------
!
! ****** Load an initial hydrostatic equilibrium.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Factor to convert normalized temperature to degrees K.
!
      real(r_typ), parameter :: fnorm_t=2.807067e7_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ierr
      real(r_typ) :: s0,s1,rhov
      real(r_typ) :: br,bt,bp,bmag
      real(r_typ), dimension(nr) :: rho_bg,p_bg,rho_c
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: rho_vs_b
!
!-----------------------------------------------------------------------
!
      rho0i=0.
      rho0f=0.
      pr0i=0.
      pr0f=0.
!
! ****** Check that the variables that control the evolution of the
! ****** boundary conditions at r=R0 are valid.
!
      if (hs%time1.le.hs%time0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INITIALIZE_HS_EQUILIBRIUM:'
          write (*,*) '### Invalid values for the time-profile'// &
                      ' control variables.'
          write (*,*) 'HS%TIME0 must exceed HS%TIME1.'
          write (*,*)
          write (*,*) 'HS%TIME0 = ',hs%time0
          write (*,*) 'HS%TIME1 = ',hs%time1
        end if
        call endrun (.true.)
      end if
!
! ****** Set the initial and final base densities.
!
      if (rb0) then
        do k=2,npm1
          do j=2,ntm1
            br=AVGRTP(b%r,2,j,k)
            bt=AVGP  (b%t,1,j,k)
            bp=AVGT  (b%p,1,j,k)
            bmag=sqrt(br**2+bt**2+bp**2)
            rho0i(j,k)=rho_vs_b(hs%rho0i,hs%rho1i,hs%b0,hs%b1,bmag)
            rho0f(j,k)=rho_vs_b(hs%rho0f,hs%rho1f,hs%b0,hs%b1,bmag)
          enddo
        enddo
      end if
!
! ****** Broadcast the base density to all processors sharing
! ****** this base location.
!
      call MPI_Bcast (rho0i,nt*np,ntype_real,iproc_rb0,comm_r,ierr)
      call MPI_Bcast (rho0f,nt*np,ntype_real,iproc_rb0,comm_r,ierr)
!
! ****** Load a hydrostatic equilibrium.
!
! ****** Get a radially symmetric density in RHO_BG that satisfies
! ****** hydrostatic equilibrium for the base values HS%RHO0I
! ****** and HS%T0I.
!
      call hs_equil (nr,rh,r0,g0,gamma,hs%rho0i,hs%t0i,rho_bg)
!
      s0=two*(hs%t0i/fnorm_t)/hs%rho0i**(gamma-one)
!
      do i=1,nr
        p_bg(i)=s0*rho_bg(i)**gamma
      enddo
!
! ****** Add hydrostatic equilibria to reflect the nonuniform density.
!
      do k=2,npm1
        do j=2,ntm1
          rhov=rho0i(j,k)-hs%rho0i
          if (rhov.gt.0.) then
            call hs_equil (nr,rh,r0,g0,gamma,rhov,hs%t1i,rho_c)
            s1=two*(hs%t1i/fnorm_t)/rhov**(gamma-one)
          else
            rho_c=0.
            s1=0.
          end if
          do i=1,nr
            rho(i,j,k)=rho_bg(i)+rho_c(i)
            pres(i,j,k)=p_bg(i)+s1*rho_c(i)**gamma
          enddo
          pr0i(j,k)=s0*hs%rho0i**gamma+s1*rhov**gamma
        enddo
      enddo
!
! ****** Set the final pressure at r=R0.
!
      s0=two*(hs%t0f/fnorm_t)/hs%rho0f**(gamma-one)
!
      do k=2,npm1
        do j=2,ntm1
          rhov=rho0f(j,k)-hs%rho0f
          if (rhov.gt.0.) then
            s1=two*(hs%t1f/fnorm_t)/rhov**(gamma-one)
          else
            s1=0.
          end if
          pr0f(j,k)=s0*hs%rho0f**gamma+s1*rhov**gamma
        enddo
      enddo
!
! ****** Set the BCs at r=R0 on RHO and PRES.
!
      if (rb0) then
        do k=2,npm1
          do j=2,ntm1
            rho(1,j,k)=two*rho0i(j,k)-rho(2,j,k)
            pres(1,j,k)=two*pr0i(j,k)-pres(2,j,k)
          enddo
        enddo
      end if
!
! ****** Set boundary conditions at the poles.
!
!$acc update device(rho,pres)
      call set_pole_bc_scalar_hhh (rho)
      call set_pole_bc_scalar_hhh (pres)
!
      call seam_scalar (rho,nr,nt,np)
      call seam_scalar (pres,nr,nt,np)
!$acc update self(rho,pres)
!
end subroutine
!#######################################################################
function rho_vs_b (rho0,rho1,b0,b1,b)
!
!-----------------------------------------------------------------------
!
! ****** Mass density at r=R0 as a function of magnetic
! ****** field strength.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: rho0,rho1,b0,b1,b
      real(r_typ) :: rho_vs_b
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: smooth_ramp
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sigma,bv0,bv1
!
!-----------------------------------------------------------------------
!
      sigma=.1*b0
      bv0=b0+3.*sigma
      bv1=b1-3.*sigma
      rho_vs_b=rho0+(rho1-rho0)*smooth_ramp(sigma,bv0,bv1,b)
!
      return
end function
!#######################################################################
function smooth_ramp (sigma,x0,x1,x)
!
!-----------------------------------------------------------------------
!
! ****** Smooth ramp function.
!
!-----------------------------------------------------------------------
!
! ****** SMOOTH_RAMP varies linearly with X from 0 to 1 between
! ****** X0 and X1, with rounded corners (over a distance SIGMA)
! ****** near X=X0 and X=X1.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: sigma
      real(r_typ), intent(in) :: x0
      real(r_typ), intent(in) :: x1
      real(r_typ), intent(in) :: x
      real(r_typ) :: smooth_ramp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: ln_cosh
!
!-----------------------------------------------------------------------
!
      if (sigma.le.0..or.x0.eq.x1) then
        smooth_ramp=0.
        return
      end if
!
      smooth_ramp=half*(one+sigma*( ln_cosh((x-x0)/sigma) &
                                   -ln_cosh((x-x1)/sigma) &
                                  )/(x1-x0) &
                       )
!
      return
end function
!#######################################################################
function ln_cosh (x)
!
!-----------------------------------------------------------------------
!
! ****** Return ln(cosh(x)).
!
! ****** This function is well-behaved for large x.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: x
      real(r_typ) :: ln_cosh
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: ten=10._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: xx
!
!-----------------------------------------------------------------------
!
      xx=abs(x)
!
      if (xx.ge.ten) then
        ln_cosh=xx-log(two)+exp(-xx)
      else
        ln_cosh=log(cosh(xx))
      end if
!
      return
end function
!#######################################################################
subroutine hs_equil (nr,rh,r0,g0,gamma,rho0,t0,rho)
!
!-----------------------------------------------------------------------
!
! ****** Load the mass density for a 1D hydrostatic equilibrium
! ****** with uniform entropy.
!
!-----------------------------------------------------------------------
!
! ****** The following parameters define the equilibrium:
!
!        NR: the number of radial mesh points in arrays RH and RHO
!        RH: an array with the radial mesh points
!        R0: the (normalized) radius of the Sun
!        G0: the (normalized) surface gravity
!        GAMMA: the polytropic index
!        RHO0: the (normalized) mass density at the Sun's surface
!        T0: the temperature [degrees K] at the Sun's surface
!
! ****** The (normalized) mass density is returned in array RHO.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: nr
      real(r_typ), dimension(nr) :: rh
      real(r_typ) :: r0,g0,gamma,rho0,t0
      real(r_typ), dimension(nr) :: rho
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Factor to convert normalized temperature to degrees K.
!
      real(r_typ), parameter :: fnorm_t=2.807067e7_r_typ
!
! ****** Minimum allowed (normalized) mass density.
!
      real(r_typ), parameter :: rho_min=1.e-20_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: power,s,v,eps_v
!
!-----------------------------------------------------------------------
!
! ****** Get a uniform entropy hydrostatic equilibrium
! ****** for the base values RHO0 and T0.
!
      power=one/(gamma-one)
      s=two*(t0/fnorm_t)/rho0**(gamma-one)
!
      eps_v=rho_min**(gamma-one)
!
      do i=1,nr
        v=( ((gamma-one)/(s*gamma))*g0*(r0/rh(i)-one) &
           +rho0**(gamma-one))
        if (v.gt.eps_v) then
          rho(i)=v**power
        else
          rho(i)=rho_min
        end if
      enddo
      rho(1)=two*rho0-rho(2)
!
end subroutine
!#######################################################################
subroutine initialize_zb_equilibrium
!
!-----------------------------------------------------------------------
!
! ****** Load a zero beta equilibrium.
!
!-----------------------------------------------------------------------
!
      use vars
      use fields
      use ucase_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** If option ZB_RHO_PROFILE='READ_FROM_FILE', load an
! ****** equilibrium with a density profile that is read in from a
! ****** file.  Otherwise, load an equilibrium with a density profile
! ****** that is generated internally.
!
      if (ucase(zb_rho_profile).eq.'READ_FROM_FILE') then
        pres=0.
        rho0i=0.
        rho0f=0.
        call load_rho_from_file (zb_rho_file)
      else
        call load_zb_equil_rho_profile
      end if
!
end subroutine
!#######################################################################
subroutine load_fields_from_file
!
!-----------------------------------------------------------------------
!
! ****** Add or replace fields from file if requested.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use mpidefs
      use rdhdf_3d_interface
      use field_table
      use distribute_array_interface
      use seam_interface
      use lcase_interface
      use vars
      use characteristics
      use interplanetary_vars
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(21), parameter :: cname='LOAD_FIELDS_FROM_FILE'
      real(r_typ), parameter :: zero=0._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ifld,ierr,ierr1,ierr2,ierr3
      logical :: loading_b=.false.,adding_b=.false.
      logical :: loading_any_field=.false.
      type(avec) :: abak
      real(r_typ), dimension(:,:,:), allocatable :: field_bak
      real(r_typ), dimension(:,:), allocatable :: brslice
      character(12) :: curr_field,curr_action
      character(12) :: check_field
!
!-----------------------------------------------------------------------
!
! ****** Do some error checking and check for special B case.
!
      ierr=0
      do i=1,nfields
!
        curr_field=trim(lcase(load_fields(i)%field))
        curr_action=trim(lcase(load_fields(i)%action))
!
        if (curr_field.eq.'') then
          continue
        else
          loading_any_field=.true.
          ierr1=1
          ierr2=2
          ierr3=0
          do j=1,nfields
            if (curr_field.eq.lcase(fldtab(j)%name) &
                .and.fldtab(j)%input_enabled) then
              ierr1=0
!
! ****** Check for special case of specifying B.
!
              if (curr_field(1:1).eq.'b') then
                loading_b=.true.
                if (curr_action.eq.'add') then
                  adding_b=.true.
                end if
              end if
!
! ****** TEMP FIX:  Check for zp or zm - if so, set flag so
! ******            init_zw will do nothing.
!
              if (curr_field(1:1).eq.'z') then
                wtd_icond='FROM_INIT_3D'
              end if
!
            end if
            if (curr_action.eq.'add'.or.curr_action.eq.'initial') &
              then
              ierr2=0
            end if
          enddo
!
! ****** Check for invalid combos of t, te, tp
!
          do j=1,nfields
            check_field=trim(lcase(load_fields(j)%field))
            if (curr_field.eq.'t') then
              if (check_field.eq.'te'.or.check_field.eq.'tp') ierr3=1
            end if
            if (curr_field.eq.'te') then
              if (check_field.eq.'t') ierr3=1
            end if
            if (curr_field.eq.'tp') then
              if (check_field.eq.'t') ierr3=1
            end if
          enddo
!
          if (ierr1.eq.1.and.iamp0) then
            write (*,*)
            write (*,*) '### ERROR in ',cname,':'
            write (*,*) '### FIELD NOT VALID.'
            write (*,*) 'Field name: ',curr_field
            write(*,*) "Valid field names:"
            do k=1,nfields
              if (fldtab(k)%input_enabled) then
                write(*,*) fldtab(k)%name
              end if
            enddo
            ierr=1
          end if
!
          if (ierr2.eq.2.and.iamp0) then
            write (*,*)
            write (*,*) '### ERROR in ',cname,':'
            write (*,*) '### ACTION NOT VALID.'
            write (*,*) 'Action name: ',curr_action
            write(*,*) "Valid actions: add,initial"
            ierr=1
          end if
!
          if (ierr3.eq.1.and.iamp0) then
            write (*,*)
            write (*,*) '### ERROR in ',cname,':'
            write (*,*) '### AMBIGUOUS TEMPERATURE SPECIFICATION!'
            write (*,*) 't specified with either te or tp.'
            ierr=1
          end if
        end if
      enddo
      call check_error_on_any_proc (ierr)
!
! ****** If not loading any fields, return so BC fixing below
! ****** does not cause floating point differences.
!
      if (.not.loading_any_field) return
!
! ****** If the user is specifying and adding b, save current A.
!
      if (adding_b) then
        call alloc_avec (abak)
!$acc update device(a%r,a%t,a%p)
        call copy_avec (a,abak)
      end if
!
! ****** Now loop through and add/initialize fields.
!
      do i=1,nfields
!
        curr_field=trim(lcase(load_fields(i)%field))
        curr_action=trim(lcase(load_fields(i)%action))
!
        if (curr_field.eq.'') then
          continue
        else
!
! ****** Find ifld index of requested field.
!
          do j=1,nfields
            if (curr_field.eq.lcase(fldtab(j)%name)) then
              ifld=j
            end if
          enddo
!
! ****** If the field will be added, save a backup of the current field.
!
          if (curr_action.eq.'add'.and.curr_field(1:1).ne.'b') then
            allocate (field_bak(fldtab(ifld)%n1(iproc), &
                                fldtab(ifld)%n2(iproc), &
                                fldtab(ifld)%n3(iproc)))
!$acc enter data create(field_bak)
!$acc update device(fldtab(ifld)%f)
            do concurrent(k=1:fldtab(ifld)%n3(iproc), &
                          j=1:fldtab(ifld)%n2(iproc), &
                          i=1:fldtab(ifld)%n1(iproc))
              field_bak(i,j,k)=fldtab(ifld)%f(i,j,k)
            enddo
          end if
!
! ****** Now read the field and save it into the global field.
!
          call read_3d_field (load_fields(i)%fname,ifld)
!$acc update device(fldtab(ifld)%f)
!
! ****** If adding the field, add in saved original field.
!
          if (curr_action.eq.'add'.and.curr_field(1:1).ne.'b') then
            do concurrent(k=1:fldtab(ifld)%n3(iproc), &
                          j=1:fldtab(ifld)%n2(iproc), &
                          i=1:fldtab(ifld)%n1(iproc))
              fldtab(ifld)%f(i,j,k)=fldtab(ifld)%f(i,j,k) &
                                   +field_bak(i,j,k)
            enddo
!$acc exit data delete(field_bak)
            deallocate (field_bak)
!$acc update self(fldtab(ifld)%f)
          end if
!
        end if
      enddo
!
! ****** If the user loaded a B-field, get A from it.
!
      if (loading_b) then
!
        call set_pole_bc_bvec (b)
        call seam_scalar (b%r,nr,ntm,npm)
        call seam_scalar (b%t,nrm,nt,npm)
        call seam_scalar (b%p,nrm,ntm,np)
!
! ****** Clean interpolated B field by div-cleaning or flux-balancing.
!
        if (loaded_b_clean_method.eq.1) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from ',cname,':'
            write (9,*) '### Divergence-cleaning input B field.'
          end if
          call div_clean_b (b)
        elseif (loaded_b_clean_method.eq.2) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from ',cname,':'
            write (9,*) '### Flux-balancing input B field''s r-slices.'
          end if
          allocate (brslice(ntm,npm))
!$acc update self(b%r,b%t,b%p)
          do i=1,nr
            brslice(:,:)=b%r(i,:,:)
            call balance_flux2 (brslice,ierr)
            b%r(i,:,:)=brslice(:,:)
          enddo
!$acc update device(b%r,b%t,b%p)
          deallocate (brslice)
        elseif (loaded_b_clean_method.eq.3) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from ',cname,':'
            write (9,*) '### Divergence-cleaning input B field.'
            write (9,*) '### AND Flux-balancing B field''s r-slices.'
          end if
          call div_clean_b (b)
!$acc update self(b%r,b%t,b%p)
          allocate (brslice(ntm,npm))
          do i=1,nr
            brslice(:,:)=b%r(i,:,:)
            call balance_flux2 (brslice,ierr)
            b%r(i,:,:)=brslice(:,:)
          enddo
!$acc update device(b%r,b%t,b%p)
          deallocate (brslice)
        elseif (loaded_b_clean_method.eq.0) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from ',cname,':'
            write (9,*) '### Input B field not cleaned.'
          end if
        else
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in ',cname,':'
            write (*,*) '### Invalid LOADED_B_CLEAN_METHOD!'
            ierr=1
          end if
          call check_error_on_p0 (ierr)
        end if
!
! ****** Compute A from B.
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from ',cname,':'
          write (9,*) '### Computing A from B.'
        end if
!
        call afromb (b,a)
!
! ****** If adding B, add in saved A to computed A.
!
        if (adding_b) then
          do concurrent (k=1:np, j=1:nt, i=1:nrm1)
            a%r(i,j,k)=a%r(i,j,k)+abak%r(i,j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm1, i=1:nr)
            a%t(i,j,k)=a%t(i,j,k)+abak%t(i,j,k)
          enddo
!
          do concurrent (k=1:npm1, j=1:nt, i=1:nr)
            a%p(i,j,k)=a%p(i,j,k)+abak%p(i,j,k)
          enddo
          call dealloc_avec (abak)
        end if
!
        call bfroma (a,b,zero)
!
        call jfromb (b,fj)
!$acc update self(a%r,a%t,a%p,b%r,b%t,b%p,fj%r,fj%t,fj%p)
      end if
!
! ****** Fix up loaded fields to conform to input file.
!
      call fix_loaded_fields
!
! ****** Since rho and/or temp could have been modified, set pressure.
! ****** In order to use setpt() here, need to
! ****** set cbc1_pb and/or ip bc arrays.
!
      if (rb1.and.char_bc1) then
        pres(nrm1:nr,:,:)= &
                      (he_p/he_rho)*temp(nrm1:nr,:,:)*rho(nrm1:nr,:,:)
        cbc1_pb(:,:)=half*(pres(nr,:,:)+pres(nrm1,:,:))
!$acc update device(cbc1_pb)
      end if
!
      if (rb0.and.interplanetary_run) then
        rho_ip(:,:)=rho0i(:,:)
        t_ip(:,:)=tr0v(:,:)
!$acc update device(rho_ip,t_ip)
      end if
!
!$acc update device(temp_e,rho)
      call setpt
!$acc update self(pres,temp)
!
! ****** Re-initialize the temperature (rho or pres may have changed).
!
      temp(:,:,:)=(he_rho/he_p)*pres(:,:,:)/rho(:,:,:)
!$acc update device(temp)
!
end subroutine
!#######################################################################
subroutine read_3d_field (fname,ifld)
!
!-----------------------------------------------------------------------
!
! ****** Read the field with field table index IFLD from
! ****** a 3D hdf file specified by fname.  Boundary conditions are
! ****** assumed to alrady be set in the file being loaded.
!
!-----------------------------------------------------------------------
!
      use number_types
      use fields
      use field_table
      use mpidefs
      use rdhdf_3d_interface
      use distribute_array_interface
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: ifld
!
!-----------------------------------------------------------------------
!
      integer :: ierr,n1,n2,n3
      character(13), parameter :: cname='READ_3D_FIELD'
!
!-----------------------------------------------------------------------
!
! ****** Declaration for a global field array.  This array is only
! ****** allocated on IPROC0.
!
      real(r_typ), dimension(:,:,:), allocatable :: a_g
!
!-----------------------------------------------------------------------
!
      logical :: scale,need_to_interp=.false.
      integer :: nx,ny,nz,i
      real(r_typ) :: scl_eps=1e-5_r_typ
      real(r_typ), dimension(:), pointer, contiguous :: x,y,z
      real(r_typ), dimension(:,:,:), pointer, contiguous :: f
!
!-----------------------------------------------------------------------
!
! ****** Read the field from HDF file FNAME on IPROC0.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from ',cname,':'
        write (9,*) '### Reading field ',trim(fldtab(ifld)%name), &
                    ' from file: ', trim(fname)
!
        call rdhdf_3d (fname,scale,nx,ny,nz,f,x,y,z,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in ',cname,':'
          write (*,*) '### Could not read the specified file.'
          write (*,*) 'IERR (from RDHDF_3D) = ',ierr
          write (*,*) 'Field name: ',trim(fldtab(ifld)%name)
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array has scales.
!
      if (iamp0) then
        ierr=0
        if (.not.scale) then
          write (*,*)
          write (*,*) '### ERROR in ',cname,':'
          write (*,*) '### The file does not have scales.'
          write (*,*) 'Field name: ',trim(fldtab(ifld)%name)
          write (*,*) 'File name: ',trim(fname)
          ierr=2
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Load new field.  If it is not on the code mesh, interpolate.
!
      if (iamp0) then
        ierr=0
        allocate (a_g(fldtab(ifld)%n1_g, &
                      fldtab(ifld)%n2_g, &
                      fldtab(ifld)%n3_g))
!
        if ((fldtab(ifld)%n1_g.ne.nx).or. &
            (fldtab(ifld)%n2_g.ne.ny).or. &
            (fldtab(ifld)%n3_g.ne.nz)) then
          need_to_interp=.true.
        else
          do i=1,nx
            if (abs(x(i)-fldtab(ifld)%r_g(i)).gt.scl_eps) then
              need_to_interp=.true.
            end if
          enddo
          do i=1,ny
            if (abs(y(i)-fldtab(ifld)%t_g(i)).gt.scl_eps) then
              need_to_interp=.true.
            end if
          enddo
          do i=1,nz
            if (abs(z(i)-fldtab(ifld)%p_g(i)).gt.scl_eps) then
              need_to_interp=.true.
            end if
          enddo
        end if
!
        if (need_to_interp) then
!
          write (*,*)
          write (*,*) '### COMMENT from ',cname,':'
          write (*,*) '### Interpolating ',trim(fldtab(ifld)%name)
!
          call interp_3d (nx,ny,nz,x,y,z,f, &
                 fldtab(ifld)%n1_g,fldtab(ifld)%n2_g,fldtab(ifld)%n3_g, &
                 fldtab(ifld)%r_g,fldtab(ifld)%t_g,fldtab(ifld)%p_g, &
                 a_g,.false.,ierr)
!
          if (ierr.ne.0) then
            write (*,*)
            write (*,*) '### ERROR in READ_3D_FIELD:'
            write (*,*) '### An error occurred while interpolating'// &
                        ' the field to the code mesh:'
            write (*,*) 'File name: ',trim(fname)
            write (*,*) 'IERR: ',ierr
          end if
        else
          a_g(:,:,:)=f(:,:,:)
        end if
!
      else
        allocate (a_g(1,1,1))
      end if
      call check_error_on_p0 (ierr)
!
      call distribute_array (fldtab(ifld)%n1,fldtab(ifld)%n2, &
                             fldtab(ifld)%n3,a_g,fldtab(ifld)%f)
!
      deallocate (a_g)
!
! ****** Deallocate temporary arrays.
!
      if (iamp0) then
        deallocate (x)
        deallocate (y)
        deallocate (z)
        deallocate (f)
      end if
!
end subroutine
!#######################################################################
subroutine load_rho_from_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Read the density profile from file FNAME and interpolate
! ****** it to the code mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use mpidefs
      use rdhdf_3d_interface
      use field_table
      use distribute_array_interface
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      logical :: scale
      integer :: nr_f,nt_f,np_f
      real(r_typ), dimension(:), pointer, contiguous ::r_f,t_f,p_f
      real(r_typ), dimension(:,:,:), pointer, contiguous ::f
      real(r_typ), dimension(:,:,:), pointer, contiguous ::rho_g
!
!-----------------------------------------------------------------------
!
! ****** Read the density from HDF file FNAME on IPROC0.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from LOAD_RHO_FROM_FILE:'
        write (9,*) '### Reading the density from file: ', &
                    trim(fname)
!
        call rdhdf_3d (fname,scale,nr_f,nt_f,np_f,f, &
                       r_f,t_f,p_f,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_RHO_FROM_FILE:'
          write (*,*) '### Could not read the density:'
          write (*,*) 'IERR (from RDHDF_3D) = ',ierr
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array has scales.
!
      if (iamp0) then
        ierr=0
        if (.not.scale) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_RHO_FROM_FILE:'
          write (*,*) '### The density file does not have scales:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the global array on IPROC0.
!
      if (iamp0) then
        allocate (rho_g(nr_g,nt_g,np_g))
      else
        allocate (rho_g(1,1,1))
      end if
!
! ****** Interpolate the array at the internal points on IPROC0.
!
      if (iamp0) then
        rho_g=0.
        call interp_3d (nr_f,nt_f,np_f,r_f,t_f,p_f,f, &
                        nrm2_g,ntm2_g,npm2_g, &
                        rh_g(2:nrm1_g), &
                        th_g(2:ntm1_g), &
                        ph_g(2:npm1_g), &
                        rho_g(2:nrm1_g,2:ntm1_g,2:npm1_g), &
                        .false.,ierr)
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_RHO_FROM_FILE:'
          write (*,*) '### An error occurred while interpolating'// &
                      ' the density to the code mesh:'
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Set the boundary points at r=R0 and r=R1.
! ****** This uses zero-derivative BCs.
!
      if (iamp0) then
        rho_g(   1,:,:)=rho_g(     2,:,:)
        rho_g(nr_g,:,:)=rho_g(nrm1_g,:,:)
      end if
!
! ****** Set the phi boundary points periodically.
!
      if (iamp0) then
        rho_g(:,:,   1)=rho_g(:,:,npm1_g)
        rho_g(:,:,np_g)=rho_g(:,:,     2)
      end if
!
! ****** Distribute the global array from IPROC0 to the local arrays.
!
      call distribute_array (fldtab(IFLD_RHO)%n1, &
                             fldtab(IFLD_RHO)%n2, &
                             fldtab(IFLD_RHO)%n3, &
                             rho_g,rho)
!
! ****** Set boundary conditions at the poles.
!
      call set_pole_bc_scalar_hhh_cpu (rho)
!
! ****** Seam the array.
!
      call seam (rho)
!
! ****** Deallocate temporary arrays.
!
      if (iamp0) then
        deallocate (r_f)
        deallocate (t_f)
        deallocate (p_f)
        deallocate (f)
      end if
!
      deallocate (rho_g)
!
end subroutine
!#######################################################################
subroutine load_zb_equil_rho_profile
!
!-----------------------------------------------------------------------
!
! ****** Load a zero beta equilibrium with a combination of power-law
! ****** and exponential profiles for the density.
!
!-----------------------------------------------------------------------
!
! ****** A simple power-law fall off can be achieved by
! ****** setting ZB%RHO0=ZB%RHO1=0.  ZB%RHO00 sets the base
! ****** density for the power-law profile.  ZB%RHOEXP sets the
! ****** power (ZB%RHOEXP = 4. => r0/r**4).
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ierr
      real(r_typ) :: br,bt,bp,bmag,rho_e
      real(r_typ), dimension(nr) :: rho_bg,lambda
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: rho_vs_b
!
!-----------------------------------------------------------------------
!
      rho0i=0.
      pres=0.
!
! ****** Set the base density using the magnetic field strength.
!
      if (rb0) then
        do k=2,npm1
          do j=2,ntm1
            br=AVGRTP(b%r,2,j,k)
            bt=AVGP  (b%t,1,j,k)
            bp=AVGT  (b%p,1,j,k)
            bmag=sqrt(br**2+bt**2+bp**2)
            rho0i(j,k)=rho_vs_b(zb%rho0,zb%rho1,zb%b0,zb%b1,bmag)
          enddo
        enddo
      end if
!
! ****** Broadcast the base density to all processors sharing
! ****** this base location.
!
      call MPI_Bcast (rho0i,nt*np,ntype_real,iproc_rb0,comm_r,ierr)
!
! ****** Load a 1d profile for the background power-law density.
!
      do i=1,nr
        rho_bg(i)=zb%rho00*(r0*rh_i(i))**zb%rhoexp
      enddo
!
! ****** Load the scale length profile for the exponential density.
!
      do i=1,nr
        if (rh(i).le.zb%lam_r0) then
          lambda(i)=zb%lam_l0
        else if (rh(i).ge.zb%lam_r1) then
          lambda(i)=zb%lam_l1
        else
          lambda(i)=zb%lam_l0+(zb%lam_l1-zb%lam_l0)*(rh(i)-zb%lam_r0) &
                       /(zb%lam_r1-zb%lam_r0)
        end if
      enddo
!
! ****** Add in the exponential density profile.
!
      do k=2,npm1
        do j=2,ntm1
          do i=1,nr
            rho_e=rho0i(j,k)*exp(-(rh(i)/r0-one)/lambda(i))
            rho(i,j,k)=rho_bg(i)+rho_e
          enddo
        enddo
      enddo
!
! ****** Set the BCs at r=R0 on RHO.
!
      if (rb0) then
        do k=2,npm1
          do j=2,ntm1
            rho(1,j,k)=two*(rho0i(j,k)+zb%rho00)-rho(2,j,k)
          enddo
        enddo
      end if
!
! ****** Set boundary conditions at the poles.
!
      call set_pole_bc_scalar_hhh_cpu (rho)
!
      call seam (rho)
!
end subroutine
!#######################################################################
subroutine initialize_solar_wind
!
!-----------------------------------------------------------------------
!
! ****** Modify a hydrostatic equilibrium to force an outflowing
! ****** radial solar wind.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Hard-wired parameters.
!
      real(r_typ) :: vflow0=.01_r_typ
      real(r_typ) :: vflow1=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Lower the pressure and density at large distances
! ****** to crudely force the solution into a fast wind.
!
      do k=2,npm1
        do j=2,ntm1
          do i=1,nr
            rho(i,j,k)=rho(i,j,k)*exp(-(rh(i)-r0)/(r1-r0))
            pres(i,j,k)=pres(i,j,k)*exp(-(rh(i)-r0)/(r1-r0))
          enddo
        enddo
      enddo
!
! ****** Set the BCs at r=R0.
!
      if (rb0) then
        do k=2,npm1
          do j=2,ntm1
            rho(1,j,k)=two*rho0i(j,k)-rho(2,j,k)
            pres(1,j,k)=two*pr0i(j,k)-pres(2,j,k)
          enddo
        enddo
      end if
!
! ****** Set boundary conditions at the poles.
!
      call set_pole_bc_scalar_hhh_cpu (rho)
      call set_pole_bc_scalar_hhh_cpu (pres)
!
      call seam (rho)
      call seam (pres)
!
! ****** Set an initial out-flowing radial velocity profile.
!
      do i=1,nrm
        v%r(i,:,:)=vflow0+(vflow1-vflow0)*(r(i)-r0)/(r1-r0)
      enddo
!
      v%t=0.
      v%p=0.
!
      vb%r0%r=vflow0
      vb%r1%r=vflow1
      vb%r0%t=0.
      vb%r1%t=0.
      vb%r0%p=0.
      vb%r1%p=0.
!
end subroutine
!#######################################################################
subroutine initialize_no_flow
!
!-----------------------------------------------------------------------
!
! ****** Initialize v to zero.
!
!-----------------------------------------------------------------------
!
      use number_types
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      v%r=0.
      v%t=0.
      v%p=0.
!
      vb%r0%r=0.
      vb%r1%r=0.
      vb%r0%t=0.
      vb%r1%t=0.
      vb%r0%p=0.
      vb%r1%p=0.
!
end subroutine
!#######################################################################
subroutine initialize_characteristics
!
!-----------------------------------------------------------------------
!
! ****** Initialize the characteristic BC arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use characteristics
      use mpidefs
      use vars, ONLY : char_bc1
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      if (rb1.and.char_bc1) then
        cbc1_rhob(:,:)=half*(rho(nr,:,:)+rho(nrm1,:,:))
        cbc1_pb(:,:)=half*(pres(nr,:,:)+pres(nrm1,:,:))
        cbc1_ub(:,:)=0.
!$acc update device(cbc1_rhob,cbc1_pb,cbc1_ub)
      end if
!
end subroutine
!#######################################################################
subroutine initialize_shear
!
!-----------------------------------------------------------------------
!
! ****** Load the shear flow arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use shear_profile
      use constants
      use mpidefs
      use seam_t_2d_interface
      use seam_p_2d_interface
      use ucase_interface
      use field_table
      use write_field_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: three=3._r_typ
      real(r_typ), parameter :: deg_to_rad=pi/180._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: vav_t,vav_p,vmax,omega
      real(r_typ) :: fma,x0,y0,z0,x,y,z,d,alpha,tv,pv,width,thp
      real(r_typ) :: brav,fav,gav
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1,npm1) :: br,f,g
!
!-----------------------------------------------------------------------
!
! ****** Initialize the shear flow arrays.
!
      allocate (v_shear_t(ntm,np))
      allocate (v_shear_p(nt,npm))
!
      v_shear_t(:,:)=0.
      v_shear_p(:,:)=0.
!
      if (.not.shear%active) return
!
      if (ucase(shear%type).eq.'CLASSIC_SHEAR') then
!
! ****** This profile is normalized to 1.
!
        width=half*shear%dthmax
        do k=1,npm1
          do j=2,ntm1
            thp=(th(j)-shear%th0)/width
            v_shear_p(j,k)=thp*exp((one-thp**shear%power)/shear%power)
          enddo
        enddo
        if (tb0) v_shear_p( 1,:)=-v_shear_p(   2,:)
        if (tb1) v_shear_p(nt,:)=-v_shear_p(ntm1,:)
        call seam_t_2d (v_shear_p)
        call seam_p_2d (v_shear_p)
!
      else if (ucase(shear%type).eq.'VORTEX') then
!
        do k=1,npm1
          do j=1,ntm1
            br(j,k)=half*(b%r(1,j,k)+b%r(2,j,k))
          enddo
        enddo
!
! ****** Construct the flow mask.
!
        fma=shear%mask_angle*deg_to_rad
!
        call s2c (r(1),shear%mask_t0,shear%mask_p0,x0,y0,z0)
!
        do k=1,npm1
          do j=1,ntm1
            call s2c (r(1),t(j),p(k),x,y,z)
            d=r(1)*acos((x*x0+y*y0+z*z0)/r(1)**2)
            alpha=atan2(-(t(j)-shear%mask_t0),(p(k)-shear%mask_p0))
            alpha=alpha+fma
            pv=d*cos(alpha)
            tv=d*sin(alpha)
            f(j,k)=exp(-( (tv/shear%mask_width_t)**2 &
                         +(pv/shear%mask_width_p)**2))
          enddo
        enddo
!
        call write_field_tp ('shear_flow_mask.h5',IFLD_BR,f,0)
!
! ****** Set the shear flow.
!
        g=br
!
        do k=2,npm1
          do j=2,ntm-1
            brav=half*(br(j,k)+br(j,k-1))
            fav=half*(f(j,k)+f(j,k-1))
            gav=half*(g(j,k)+g(j,k-1))
            v_shear_t(j,k)=( two*fav*gav*(br(j,k)-br(j,k-1)) &
                            +brav*(f(j,k)*g(j,k)-f(j,k-1)*g(j,k-1)) &
                           )*r_i(1)*st_i(j)*dp_mult*dph_i(k)
          enddo
        enddo
!
        do k=1,npm1
          do j=2,ntm1
            brav=half*(br(j,k)+br(j-1,k))
            fav=half*(f(j,k)+f(j-1,k))
            gav=half*(g(j,k)+g(j-1,k))
            v_shear_p(j,k)=-( two*fav*gav*(br(j,k)-br(j-1,k)) &
                             +brav*(f(j,k)*g(j,k)-f(j-1,k)*g(j-1,k)) &
                            )*r_i(1)*dth_i(j)
          enddo
        enddo
!
! ****** Set the BCs at the poles.
!
        if (tb0) then
          v_shear_t(1,:)=0.
          v_shear_p(1,:)=-v_shear_p(2,:)
        end if
        if (tb1) then
          v_shear_t(ntm1,:)=0.
          v_shear_p(nt,:)=-v_shear_p(ntm1,:)
        end if
!
        call seam_t_2d (v_shear_t)
        call seam_p_2d (v_shear_t)
        call seam_t_2d (v_shear_p)
        call seam_p_2d (v_shear_p)
!
! ****** Normalize the shear velocity to a maximum flow equal
! ****** to 1, if requested.
!
        if (shear%normalize_vtrans) then
!
          vmax=0.
          do k=2,npm1
            do j=2,ntm1
              vav_t=half*(v_shear_t(j,k)+v_shear_t(j-1,k))
              vav_p=half*(v_shear_p(j,k)+v_shear_p(j,k-1))
              vmax=max(vmax,sqrt(vav_t**2+vav_p**2))
            enddo
          enddo
!
          call global_max (vmax)
!
          if (vmax.eq.0.) then
            if (iamp0) then
              write (9,*)
              write (9,*) '### ERROR in INITIALIZE_SHEAR:'
              write (9,*) '### The shear velocity profile is'// &
                          ' identically zero.'
            end if
            call endrun (.true.)
          end if
!
          v_shear_t(:,:)=v_shear_t(:,:)/vmax
          v_shear_p(:,:)=v_shear_p(:,:)/vmax
!
        end if
!
        call write_field_tp ('v_shear_t.h5',IFLD_VT,v_shear_t,0)
        call write_field_tp ('v_shear_p.h5',IFLD_VP,v_shear_p,0)
!
      else if (ucase(shear%type).eq.'DIFFERENTIAL_SHEAR') then
!
! ****** Shear for differential rotation.
!
        do k=1,npm1
          do j=2,ntm1
            thp=-(th(j)-half*pi)
            omega=arotate-brotate*sin(thp)**2 &
                         -crotate*sin(thp)**4
            v_shear_p(j,k)=omega*sth(j)
          enddo
        enddo
        call seam_t_2d (v_shear_p)
        call seam_p_2d (v_shear_p)
        call write_field_tp ('v_shear_t.h5',IFLD_VT,v_shear_t,0)
        call write_field_tp ('v_shear_p.h5',IFLD_VP,v_shear_p,0)
!
      else if (ucase(shear%type).eq.'FLUX_TRANSPORT') then
!
! ****** Shear for differential rotation.
! ****** plus meridional flows          .
!
        do k=1,npm1
          do j=2,ntm1
            thp=-(th(j)-half*pi)
            omega=arotate-brotate*sin(thp)**2 &
                         -crotate*sin(thp)**4
            v_shear_p(j,k)=omega*sth(j)
          enddo
        enddo
!
        do j=2,ntm-1
          omega=(abs(sin(t(j))))**1.8*(abs(cos(t(j))))**0.1
          do k=2,npm1
            if (t(j).le.half*pi) then ! Northern hemisphere
              v_shear_t(j,k)=v_north*omega
            else                      ! Southern hemisphere
              v_shear_t(j,k)=v_south*omega
            end if
          enddo
        enddo
        call seam_t_2d (v_shear_p)
        call seam_p_2d (v_shear_p)
        call seam_t_2d (v_shear_t)
        call seam_p_2d (v_shear_t)
        call write_field_tp ('v_shear_t.h5',IFLD_VT,v_shear_t,0)
        call write_field_tp ('v_shear_p.h5',IFLD_VP,v_shear_p,0)
!
      else if (ucase(shear%type).eq.'FLUX_TRANSPORT2') then
!
! ****** Shear for differential rotation.
! ****** plus meridional flows a la Marc de Rosa.
!
        do k=1,npm1
          do j=2,ntm1
            thp=-(th(j)-half*pi)
            omega=arotate-brotate*sin(thp)**2 &
                         -crotate*sin(thp)**4
            v_shear_p(j,k)=omega*sth(j)
          enddo
        enddo
!
        do j=2,ntm-1
          omega=sin(two*t(j))*(one-exp(-three*    t(j) **3))* &
                              (one-exp(-three*(pi-t(j))**3))
          do k=2,npm1
            v_shear_t(j,k)=v_north*omega
          enddo
        enddo
        call seam_t_2d (v_shear_p)
        call seam_p_2d (v_shear_p)
        call seam_t_2d (v_shear_t)
        call seam_p_2d (v_shear_t)
        call write_field_tp ('v_shear_t.h5',IFLD_VT,v_shear_t,0)
        call write_field_tp ('v_shear_p.h5',IFLD_VP,v_shear_p,0)
      else
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### ERROR in INITIALIZE_SHEAR:'
          write (9,*) '### The requested shear profile is invalid:'
          write (9,*) 'SHEAR%TYPE = ',trim(shear%type)
          write (9,*)
          write (9,*) '### The allowed options are:'
          write (9,*) '''CLASSIC_SHEAR'''
          write (9,*) '''VORTEX'''
        end if
        call endrun (.true.)
!
      end if
!
end subroutine
!#######################################################################
subroutine initialize_flow
!
!-----------------------------------------------------------------------
!
! ****** Load the converging flow arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use flow_profile
      use constants
      use mpidefs
      use seam_t_2d_interface
      use seam_p_2d_interface
      use ucase_interface
      use field_table
      use global_to_local_tp_interface
      use write_field_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: deg_to_rad=pi/180._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: vav_r,vav_t,vav_p,vmax
      real(r_typ) :: fma,x0,y0,z0,x,y,z,d,alpha,tv,pv
      real(r_typ) :: brav,fav
      integer :: j,k,ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt_g  ,np_g  ) :: v_flow_r_g
      real(r_typ), dimension(ntm1_g,np_g  ) :: v_flow_t_g
      real(r_typ), dimension(nt_g  ,npm1_g) :: v_flow_p_g
!
      real(r_typ), dimension(ntm1,npm1) :: br_mm
      real(r_typ), dimension(nt,np) :: br_hh
      real(r_typ), dimension(ntm1,npm1) :: f
!
!-----------------------------------------------------------------------
!
! ****** Initialize the converging flow arrays.
!
      allocate (v_flow_r(nt,np))
      allocate (v_flow_t(ntm,np))
      allocate (v_flow_p(nt,npm))
!
      v_flow_r=0.
      v_flow_t=0.
      v_flow_p=0.
!
      if (.not.flow%active) return
!
      if (ucase(flow%type).eq.'READ_FROM_FILE') then
!
! ****** Read in the r component, and interpolate it to the
! ****** code mesh.
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INITIALIZE_FLOW:'
          write (9,*) '### Reading vr at r=R0 from file: ', &
                      trim(flow%file_r)
          call read_tp_interp_hh (flow%file_r,v_flow_r_g,1,ierr)
        end if
        call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
        call global_to_local_tp (v_flow_r_g,v_flow_r)
!
! ****** Read in the theta component, and interpolate it to the
! ****** code mesh.
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INITIALIZE_FLOW:'
          write (9,*) '### Reading vt at r=R0 from file: ', &
                      trim(flow%file_t)
          call read_tp_interp_mh (flow%file_t,v_flow_t_g,2,ierr)
        end if
        call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
        call global_to_local_tp (v_flow_t_g,v_flow_t)
!
! ****** Read in the phi component, and interpolate it to the
! ****** code mesh.
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INITIALIZE_FLOW:'
          write (9,*) '### Reading vp at r=R0 from file: ', &
                      trim(flow%file_p)
          call read_tp_interp_hm (flow%file_p,v_flow_p_g,3,ierr)
        end if
        call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
        call global_to_local_tp (v_flow_p_g,v_flow_p)
!
      else if (ucase(flow%type).eq.'GENERATE_INTERNALLY') then
!
        do k=1,npm1
          do j=1,ntm1
            br_mm(j,k)=half*(b%r(1,j,k)+b%r(2,j,k))
          enddo
        enddo
!
        br_hh=0.
        do k=2,npm1
          do j=2,ntm1
            br_hh(j,k)=quarter*( br_mm(j,k  )+br_mm(j-1,k  ) &
                                +br_mm(j,k-1)+br_mm(j-1,k-1))
          enddo
        enddo
        call seam_p_2d (br_hh)
!
! ****** Construct the flow mask.
!
        fma=flow%mask_angle*deg_to_rad
!
        call s2c (r(1),flow%mask_t0,flow%mask_p0,x0,y0,z0)
!
        do k=1,npm1
          do j=1,ntm1
            call s2c (r(1),t(j),p(k),x,y,z)
            d=r(1)*acos((x*x0+y*y0+z*z0)/r(1)**2)
            alpha=atan2(-(t(j)-flow%mask_t0),(p(k)-flow%mask_p0))
            alpha=alpha+fma
            pv=d*cos(alpha)
            tv=d*sin(alpha)
            f(j,k)=exp(-( (tv/flow%mask_width_t)**2 &
                         +(pv/flow%mask_width_p)**2))
          enddo
        enddo
!
        call write_field_tp ('converging_flow_mask.h5',IFLD_BR,f,0)
!
! ****** Define the normal flow.
!
        do k=2,npm1
          do j=2,ntm1
            fav=quarter*(f(j,k)+f(j,k-1)+f(j-1,k)+f(j-1,k-1))
            v_flow_r(j,k)=fav
          enddo
        enddo
!
! ****** Define the converging transverse flow.
!
        do k=2,npm1
          do j=2,ntm-1
            brav=half*(br_mm(j,k)+br_mm(j,k-1))
            fav=half*(f(j,k)+f(j,k-1))
            v_flow_t(j,k)=-fav*brav*( br_hh(j+1,k) &
                                     -br_hh(j  ,k)) &
                                   *r_i(1)*dt_i(j)
          enddo
        enddo
!
        do k=1,npm-1
          do j=2,ntm1
            brav=half*(br_mm(j,k)+br_mm(j-1,k))
            fav=half*(f(j,k)+f(j-1,k))
            v_flow_p(j,k)=-fav*brav*( br_hh(j,k+1) &
                                     -br_hh(j,k  )) &
                                   *r_i(1)*sth_i(j)*dp_mult*dp_i(k)
          enddo
        enddo
!
      else
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### ERROR in INITIALIZE_FLOW:'
          write (9,*) '### The requested flow profile is invalid:'
          write (9,*) 'FLOW%TYPE = ',trim(flow%type)
          write (9,*)
          write (9,*) '### The allowed options are:'
          write (9,*) '''READ_FROM_FILE'''
          write (9,*) '''GENERATE_INTERNALLY'''
        end if
        call endrun (.true.)
!
      end if
!
! ****** Set boundary conditions at the poles.
!
      call set_pole_bc_scalar_tp_hh_cpu (v_flow_r)
!
      call set_pole_bc_vvec_tp_cpu (v_flow_t,v_flow_p)
!
! ****** Seam the flow arrays.
!
      call seam_t_2d (v_flow_r)
      call seam_p_2d (v_flow_r)
      call seam_t_2d (v_flow_t)
      call seam_p_2d (v_flow_t)
      call seam_t_2d (v_flow_p)
      call seam_p_2d (v_flow_p)
!
! ****** Normalize the velocity to a maximum equal to 1, if
! ****** requested.
! ****** This is done separately for the normal component (r) and
! ****** for the transverse components (t,p).
!
! ****** Normal component.
!
      if (flow%normalize_vnorm) then
!
        vmax=0.
        do k=2,npm1
          do j=2,ntm1
            vav_r=v_flow_r(j,k)
            vmax=max(vmax,abs(vav_r))
          enddo
        enddo
!
        call global_max (vmax)
!
        if (vmax.ne.0.) then
          v_flow_r=v_flow_r/vmax
        end if
!
      end if
!
! ****** Tangential component.
!
      if (flow%normalize_vtrans) then
!
        vmax=0.
        do k=2,npm1
          do j=2,ntm1
            vav_t=half*(v_flow_t(j,k)+v_flow_t(j-1,k))
            vav_p=half*(v_flow_p(j,k)+v_flow_p(j,k-1))
            vmax=max(vmax,sqrt(vav_t**2+vav_p**2))
          enddo
        enddo
!
        call global_max (vmax)
!
        if (vmax.ne.0.) then
          v_flow_t=v_flow_t/vmax
          v_flow_p=v_flow_p/vmax
        end if
!
      end if
!
! ****** Write the flow to HDF files.
!
      call write_field_tp ('v_flow_r.h5',IFLD_VR,v_flow_r,0)
      call write_field_tp ('v_flow_t.h5',IFLD_VT,v_flow_t,0)
      call write_field_tp ('v_flow_p.h5',IFLD_VP,v_flow_p,0)
!
end subroutine
!#######################################################################
subroutine load_eta_phot
!
!-----------------------------------------------------------------------
!
! ****** Load the photospheric resistivity array.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
      use eta_photosphere
      use field_table
      use global_to_local_tp_interface
      use write_field_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
      real(r_typ), dimension(ntm1_g,npm1_g) :: eta_phot_prof_g
!
!-----------------------------------------------------------------------
!
      allocate (eta_phot_prof(ntm,npm))
!
! ****** Read in the photospheric diffusion, and interpolate
! ****** it to the code mesh.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from LOAD_ETA_PHOT:'
        write (9,*) '### Reading the photospheric diffusion'// &
                    ' from file: ',trim(eta_phot_file)
        call read_tp_interp_mm (eta_phot_file,eta_phot_prof_g,1,ierr)
      end if
      call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
      call global_to_local_tp (eta_phot_prof_g,eta_phot_prof)
!
! ****** Write the photospheric diffusion to an HDF file.
!
      call write_field_tp ('eta_phot_prof.h5',IFLD_ETA,eta_phot_prof,0)
!
end subroutine
!#######################################################################
subroutine initialize_emerging_flux
!
!-----------------------------------------------------------------------
!
! ****** Initialize quantities related to emerging flux.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use emerging_flux_params
      use seam_t_2d_interface
      use seam_p_2d_interface
      use field_table
      use global_to_local_tp_interface
      use write_field_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k,ierr
      real(r_typ) :: eav_t,eav_p,emax
!
      real(r_typ), dimension(nt_g  ,np_g  ) :: phi0_g
      real(r_typ), dimension(ntm1_g,npm1_g) :: psi0_g
      real(r_typ), dimension(nt_g  ,np_g  ) :: vr0_g
!
      real(r_typ), dimension(nt,np) :: phi0
      real(r_typ), dimension(ntm,npm) :: psi0
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays for the directly driven transverse
! ****** electric field at r=R0, if requested.  The actual electric
! ****** field is time-dependent, and is set elsewhere.
!
      if (eflux%e_driven) then
!
        ef%edrive%active=.true.
!
! ****** Allocate the electric field arrays.
!
        allocate (ef%edrive%er(nt,np))
        allocate (ef%edrive%et(ntm1,np))
        allocate (ef%edrive%ep(nt,npm1))
!
        ef%edrive%er=0.
        ef%edrive%et=0.
        ef%edrive%ep=0.
!
! ****** Allocate the velocity arrays.
!
        allocate (ef%edrive%vr(nt,np))
        allocate (ef%edrive%vt(ntm,np))
        allocate (ef%edrive%vp(nt,npm))
!
        ef%edrive%vr=0.
        ef%edrive%vt=0.
        ef%edrive%vp=0.
!
      end if
!
! ****** Add the phi-driven electric field at r=R0, if requested.
!
      if (eflux%phi_driven) then
!
        ef%phi%active=.true.
!
! ****** Allocate the electric field arrays.
!
        allocate (ef%phi%er(nt,np))
        allocate (ef%phi%et(ntm1,np))
        allocate (ef%phi%ep(nt,npm1))
!
        ef%phi%er=0.
        ef%phi%et=0.
        ef%phi%ep=0.
!
! ****** Read the phi potential, and interpolate it to the
! ****** code mesh.
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INITIALIZE_EMERGING_FLUX:'
          write (9,*) '### Reading phi at r=R0 from file: ', &
                      trim(eflux%phi_file)
          call read_tp_interp_hh (eflux%phi_file,phi0_g,1,ierr)
        end if
        call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
        call global_to_local_tp (phi0_g,phi0)
!
! ****** Write the phi potential as a diagnostic.
!
        call write_field_tp ('ef_phi.h5',IFLD_VR,phi0,0)
!
! ****** Add the phi-driven electric field at the r=R0 boundary.
!
        if (rb0) then
          do k=2,npm1
            do j=1,ntm1
              ef%phi%et(j,k)= ef%phi%et(j,k) &
                             +(phi0(j+1,k)-phi0(j,k)) &
                              *dt_i(j)*r_i(1)
            enddo
          enddo
          do k=1,npm1
            do j=2,ntm1
              ef%phi%ep(j,k)= ef%phi%ep(j,k) &
                             +(phi0(j,k+1)-phi0(j,k)) &
                              *dp_mult*dp_i(k)*r_i(1)*sth_i(j)
            enddo
          enddo
        end if
!
! ****** Set boundary conditions at the poles.
!
        call set_pole_bc_avec_tp_cpu (ef%phi%et,ef%phi%ep)
!
! ****** Seam the electric field.
!
        call seam_p_2d (ef%phi%et)
        call seam_t_2d (ef%phi%ep)
!
! ****** If requested, normalize the electric field to have a
! ****** maximum magnitude of 1.
!
        if (eflux%normalize_phi) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from INITIALIZE_EMERGING_FLUX:'
            write (9,*) '### Normalizing the phi-driven electric'// &
                        ' field to unit magnitude.'
          end if
          emax=0.
          do k=1,npm1
            do j=1,ntm1
              eav_t=half*(ef%phi%et(j,k)+ef%phi%et(j,k+1))
              eav_p=half*(ef%phi%ep(j,k)+ef%phi%ep(j+1,k))
              emax=max(emax,eav_t**2+eav_p**2)
            enddo
          enddo
          emax=sqrt(emax)
          call global_max (emax)
          if (emax.eq.0.) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in INITIALIZE_EMERGING_FLUX:'
              write (*,*) '### The emerging flux electric field'// &
                          ' derived from the phi potential'
              write (*,*) '### is identically zero.'
              write (9,*)
              write (9,*) '### ERROR in INITIALIZE_EMERGING_FLUX:'
              write (9,*) '### The emerging flux electric field'// &
                          ' derived from the phi potential'
              write (9,*) '### is identically zero.'
            end if
            call endrun (.true.)
          end if
          ef%phi%et=ef%phi%et/emax
          ef%phi%ep=ef%phi%ep/emax
        end if
!
! ****** Write the electric field to HDF files.
!
        call write_field_tp ('ef_phi_et.h5',IFLD_AT,ef%phi%et,0)
        call write_field_tp ('ef_phi_ep.h5',IFLD_AP,ef%phi%ep,0)
!
      end if
!
! ****** Add the psi-driven electric field at r=R0, if requested.
!
      if (eflux%psi_driven) then
!
        ef%psi%active=.true.
!
! ****** Allocate the electric field arrays.
!
        allocate (ef%psi%er(nt,np))
        allocate (ef%psi%et(ntm1,np))
        allocate (ef%psi%ep(nt,npm1))
!
        ef%psi%er=0.
        ef%psi%et=0.
        ef%psi%ep=0.
!
! ****** Read the psi potential, and interpolate it to the
! ****** code mesh.
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INITIALIZE_EMERGING_FLUX:'
          write (9,*) '### Reading psi at r=R0 from file: ', &
                      trim(eflux%psi_file)
          call read_tp_interp_mm (eflux%psi_file,psi0_g,1,ierr)
        end if
        call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
        call global_to_local_tp (psi0_g,psi0)
!
! ****** Write the psi potential as a diagnostic.
!
        call write_field_tp ('ef_psi.h5',IFLD_BR,psi0,0)
!
! ****** Add the psi-driven electric field at the r=R0 boundary.
!
        if (rb0) then
          do k=2,npm1
            do j=jm0,jm1
              ef%psi%et(j,k)= ef%psi%et(j,k) &
                             +(psi0(j,k)-psi0(j,k-1)) &
                              *dp_mult*dph_i(k)*r_i(1)*st_i(j)
            enddo
          enddo
          do k=1,npm1
            do j=2,ntm1
              ef%psi%ep(j,k)= ef%psi%ep(j,k) &
                             -(psi0(j,k)-psi0(j-1,k)) &
                              *dth_i(j)*r_i(1)
            enddo
          enddo
        end if
!
! ****** Set boundary conditions at the poles.
!
        call set_pole_bc_avec_tp_cpu (ef%psi%et,ef%psi%ep)
!
! ****** Seam the electric field.
!
        call seam_p_2d (ef%psi%et)
        call seam_t_2d (ef%psi%ep)
!
! ****** Normalize the electric field to have a maximum
! ****** magnitude of 1.
!
        if (eflux%normalize_psi) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from INITIALIZE_EMERGING_FLUX:'
            write (9,*) '### Normalizing the psi-driven electric'// &
                        ' field to unit magnitude.'
          end if
          emax=0.
          do k=1,npm1
            do j=1,ntm1
              eav_t=half*(ef%psi%et(j,k)+ef%psi%et(j,k+1))
              eav_p=half*(ef%psi%ep(j,k)+ef%psi%ep(j+1,k))
              emax=max(emax,eav_t**2+eav_p**2)
            enddo
          enddo
          emax=sqrt(emax)
          call global_max (emax)
          if (emax.eq.0.) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in INITIALIZE_EMERGING_FLUX:'
              write (*,*) '### The emerging flux electric field'// &
                          ' derived from the psi potential'
              write (*,*) '### is identically zero.'
              write (9,*)
              write (9,*) '### ERROR in INITIALIZE_EMERGING_FLUX:'
              write (9,*) '### The emerging flux electric field'// &
                          ' derived from the psi potential'
              write (9,*) '### is identically zero.'
            end if
            call endrun (.true.)
          end if
          ef%psi%et=ef%psi%et/emax
          ef%psi%ep=ef%psi%ep/emax
        end if
!
! ****** Write the electric field to HDF files.
!
        call write_field_tp ('ef_psi_et.h5',IFLD_AT,ef%psi%et,0)
        call write_field_tp ('ef_psi_ep.h5',IFLD_AP,ef%psi%ep,0)
!
      end if
!
! ****** Specify the radial velocity at r=R0, if requested.
!
      if (eflux%vr_set) then
!
        ef%vr_set=.true.
!
! ****** Allocate the vr array.
!
        allocate (ef%vr(nt,np))
        allocate (ef%vt(ntm1,np))
        allocate (ef%vp(nt,npm1))
!
        ef%vr=0.
        ef%vt=0.
        ef%vp=0.
!
! ****** Read vr, and interpolate it to the code mesh.
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INITIALIZE_EMERGING_FLUX:'
          write (9,*) '### Reading vr at r=R0 from file: ', &
                      trim(eflux%vr_file)
          call read_tp_interp_hh (eflux%vr_file,vr0_g,1,ierr)
        end if
        call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
        call global_to_local_tp (vr0_g,ef%vr)
!
! ****** Write vr as a diagnostic.
!
        call write_field_tp ('ef_vr.h5',IFLD_VR,ef%vr,0)
!
      end if
!
end subroutine
!#######################################################################
subroutine set_edrive_bc_r0
!
!-----------------------------------------------------------------------
!
! ****** Get the time-dependent electric field and velocity at the
! ****** r=R0 boundary.  These are specified when using E to drive
! ****** a simulation.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use array_tp_def
      use vars
      use time_profiles
      use emerging_flux_params
      use seam_t_2d_interface
      use seam_p_2d_interface
      use seam_tp_2d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical, save :: first=.true.
      logical :: active
      type(array_tp), save :: edrive_er_r0
      type(array_tp), save :: edrive_et_r0
      type(array_tp), save :: edrive_ep_r0
      type(array_tp), save :: edrive_vr_r0
      type(array_tp), save :: edrive_vt_r0
      type(array_tp), save :: edrive_vp_r0
!
!-----------------------------------------------------------------------
!
! ****** On the first time in, define the electric field
! ****** and velocity structures and allocate storage.
!
      if (first) then
!
        edrive_er_r0%main_mesh_t=.false.
        edrive_er_r0%main_mesh_p=.false.
        edrive_er_r0%pole_bc=1
        edrive_et_r0%main_mesh_t=.true.
        edrive_et_r0%main_mesh_p=.false.
        edrive_et_r0%pole_bc=2
        edrive_ep_r0%main_mesh_t=.false.
        edrive_ep_r0%main_mesh_p=.true.
        edrive_ep_r0%pole_bc=3
        allocate (edrive_er_r0%f(nt,np))
        allocate (edrive_et_r0%f(ntm1,np))
        allocate (edrive_ep_r0%f(nt,npm1))
        edrive_er_r0%f=0.
        edrive_et_r0%f=0.
        edrive_ep_r0%f=0.
!
        edrive_vr_r0%main_mesh_t=.false.
        edrive_vr_r0%main_mesh_p=.false.
        edrive_vr_r0%pole_bc=1
        edrive_vt_r0%main_mesh_t=.true.
        edrive_vt_r0%main_mesh_p=.false.
        edrive_vt_r0%pole_bc=2
        edrive_vp_r0%main_mesh_t=.false.
        edrive_vp_r0%main_mesh_p=.true.
        edrive_vp_r0%pole_bc=3
        allocate (edrive_vr_r0%f(nt,np))
        allocate (edrive_vt_r0%f(ntm,np))
        allocate (edrive_vp_r0%f(nt,npm))
        edrive_vr_r0%f=0.
        edrive_vt_r0%f=0.
        edrive_vp_r0%f=0.
!
        first=.false.
!
      end if
!
! ****** Get the components of the electric field at r=R0 at the
! ****** present time, and store them to the arrays that hold the
! ****** electric field boundary conditions at r=R0.
!
      call set_evolving_field_r0 (TP_INDEX_EDRIVE_ER, &
                                  time,edrive_er_r0,active)
!
      if (active) then
        ef%edrive%er=edrive_er_r0%f
      else
        ef%edrive%er=0.
      end if
!
      call set_evolving_field_r0 (TP_INDEX_EDRIVE_ET, &
                                  time,edrive_et_r0,active)
!
      if (active) then
        ef%edrive%et=edrive_et_r0%f
      else
        ef%edrive%et=0.
      end if
!
      call set_evolving_field_r0 (TP_INDEX_EDRIVE_EP, &
                                  time,edrive_ep_r0,active)
!
      if (active) then
        ef%edrive%ep=edrive_ep_r0%f
      else
        ef%edrive%ep=0.
      end if
!
! ****** Set boundary conditions at the poles on the transverse
! ****** electric field.
!
      call set_pole_bc_avec_tp_cpu (ef%edrive%et,ef%edrive%ep)
!
! ****** Seam the electric field.
!
      call seam_tp_2d (ef%edrive%er)
      call seam_p_2d  (ef%edrive%et)
      call seam_t_2d  (ef%edrive%ep)
!
! ****** Get the components of the velocity at r=R0 at the
! ****** present time, and store them to the arrays that hold the
! ****** velocity boundary conditions at r=R0.
!
      call set_evolving_field_r0 (TP_INDEX_EDRIVE_VR, &
                                  time,edrive_vr_r0,active)
!
      if (active) then
        ef%edrive%vr=edrive_vr_r0%f
      else
        ef%edrive%vr=0.
      end if
!
      call set_evolving_field_r0 (TP_INDEX_EDRIVE_VT, &
                                  time,edrive_vt_r0,active)
!
      if (active) then
        ef%edrive%vt=edrive_vt_r0%f
      else
        ef%edrive%vt=0.
      end if
!
      call set_evolving_field_r0 (TP_INDEX_EDRIVE_VP, &
                                  time,edrive_vp_r0,active)
!
      if (active) then
        ef%edrive%vp=edrive_vp_r0%f
      else
        ef%edrive%vp=0.
      end if
!
! ****** Set boundary conditions at the poles on the transverse
! ****** velocity.
!
      call set_pole_bc_avec_tp_cpu (ef%edrive%vt,ef%edrive%vp)
!
! ****** Seam the velocity.
!
      call seam_tp_2d (ef%edrive%vr)
      call seam_p_2d  (ef%edrive%vt)
      call seam_t_2d  (ef%edrive%vp)
!
!$acc update device(ef%edrive%er,ef%edrive%et,ef%edrive%ep)
!$acc update device(ef%edrive%vr,ef%edrive%vt,ef%edrive%vp)
end subroutine
!#######################################################################
subroutine set_evolving_field_r0 (field_index, &
                                        targ, &
                                        fld_r0, &
                                        active)
!
!-----------------------------------------------------------------------
!
! ****** Set the distribution of the time-evolving 2D field
! ****** in the (t,p) surface at r=R0, specified by FIELD_INDEX,
! ****** at time t=TARG, putting the result in structure FLD_R0.
!
! ****** If the field is active at the present time, set
! ****** ACTIVE=.true.; otherwise, set ACTIVE=.false..
!
! ****** When the field is not active (i.e., ACTIVE=.false.), the
! ****** contents of FLD_R0 are not changed.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use array_tp_def
      use vars
      use mpidefs
      use time_profiles
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: field_index
      real(r_typ) :: targ
      type(array_tp) :: fld_r0
      logical :: active
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Structure that holds the interpolation parameters.
! ****** (A separate structure is used for each field.)
!
      type :: t_interp_tp_def
        logical :: first_call
        integer :: ifile0_contents
        integer :: ifile1_contents
        type(array_tp) :: f0
        type(array_tp) :: f1
      end type
!
      type(t_interp_tp_def), dimension(mx_tp_vars), save :: util
!
      data (util(i)%first_call,i=1,mx_tp_vars)/mx_tp_vars*.true./
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: ix,nodes,n1,n2
      logical :: exists
      integer :: i,ip1
      real(r_typ) :: alpha
      character(len(tprofile(1)%filename(1))) :: fname
      character(len(tp_vars(1)%name)) :: name
      integer:: ifile0,ifile1
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Check that the field index is valid.
!
      if (field_index.lt.1.or.field_index.gt.mx_tp_vars) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in SET_EVOLVING_FIELD_R0:'
          write (*,*) '### You have specified an invalid'// &
                      ' field index:'
          write (*,*) 'Field index = ',field_index
          write (*,*) '### [This is an internal error.]'
          ierr=1
        end if
        call check_error_on_p0 (ierr)
      end if
!
! ****** Get the index of the time profile that controls the field
! ****** with index FIELD_INDEX.  If a time profile has not been
! ****** specified to control the field, assume that this field is
! ****** not active.
!
      ix=tp_vars(field_index)%index
!
      if (ix.le.0) then
        active=.false.
        return
      end if
!
      name=tp_vars(field_index)%name
      nodes=tprofile(ix)%nodes
!
! ****** On the first time in, check the parameters and
! ****** initialize the interpolation variables.
!
      if (util(field_index)%first_call) then
!
! ****** Check that every file in the specified sequence exists.
!
        if (iamp0) then
          do i=1,nodes
            fname=tprofile(ix)%filename(i)
            inquire (file=trim(fname),exist=exists)
            if (.not.exists) then
              write (*,*)
              write (*,*) '### ERROR in SET_EVOLVING_FIELD_R0:'
              write (*,*) '### You have specified a file'// &
                          ' that does not exist:'
              write (*,*) 'Field name: ',trim(name)
              write (*,*) 'File name: ',trim(fname)
              ierr=1
              exit
            end if
          enddo
        end if
        call check_error_on_p0 (ierr)
!
! ****** Set up the field interpolation arrays, and allocate memory.
!
        if (fld_r0%main_mesh_t) then
          n1=ntm1
          util(field_index)%f0%main_mesh_t=.true.
          util(field_index)%f1%main_mesh_t=.true.
        else
          n1=nt
          util(field_index)%f0%main_mesh_t=.false.
          util(field_index)%f1%main_mesh_t=.false.
        end if
!
        if (fld_r0%main_mesh_p) then
          n2=npm1
          util(field_index)%f0%main_mesh_p=.true.
          util(field_index)%f1%main_mesh_p=.true.
        else
          n2=np
          util(field_index)%f0%main_mesh_p=.false.
          util(field_index)%f1%main_mesh_p=.false.
        end if
!
        allocate (util(field_index)%f0%f(n1,n2))
        allocate (util(field_index)%f1%f(n1,n2))
        util(field_index)%f0%f=0.
        util(field_index)%f1%f=0.
!
        util(field_index)%f0%pole_bc=fld_r0%pole_bc
        util(field_index)%f1%pole_bc=fld_r0%pole_bc
!
        util(field_index)%ifile0_contents=0
        util(field_index)%ifile1_contents=0
!
        util(field_index)%first_call=.false.
!
      end if
!
! ****** Interpolate to time TARG.
!
      if (targ.le.tprofile(ix)%t(1)) then
        active=tprofile(ix)%on(1)
        ifile0=1
        ifile1=1
        alpha=0.
      else if (targ.ge.tprofile(ix)%t(nodes)) then
        active=tprofile(ix)%on(nodes)
        ifile0=nodes
        ifile1=nodes
        alpha=0.
      else
        call interp (nodes,tprofile(ix)%t,targ,i,ip1,alpha,ierr)
        active=tprofile(ix)%on(i)
        ifile0=i
        ifile1=ip1
      end if
!
! ****** If the field is ON at the present time, read the data
! ****** from the specified files, and interpolate it to the
! ****** required mesh.  If it has been turned OFF, leave the
! ****** contents of FLD_R0 unchanged.
!
      if (.not.active) return
!
! ****** Set up the interpolation arrays F0 and F1 bounding this
! ****** time interval.
!
! ****** First, check to see if the file has changed.
! ****** If it has, check to see if this file has already
! ****** been read in previously; if it has, transfer that
! ****** data, otherwise read in the new file.
!
      if (ifile0.ne.util(field_index)%ifile0_contents) then
        if (ifile0.eq.util(field_index)%ifile1_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from SET_EVOLVING_FIELD_R0:'
            write (9,*) '### Transferring data from FILE1 to FILE0:'
            write (9,*) 'Field name: ',trim(name)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          util(field_index)%f0%f=util(field_index)%f1%f
        else
          fname=tprofile(ix)%filename(ifile0)
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from SET_EVOLVING_FIELD_R0:'
            write (9,*) '### Reading a new data file:'
            write (9,*) 'Field name: ',trim(name)
            write (9,*) 'File name: ',trim(fname)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          call read_file_and_interp_r0 (trim(fname), &
                                        util(field_index)%f0)
        end if
        util(field_index)%ifile0_contents=ifile0
      end if
!
      if (ifile1.ne.util(field_index)%ifile1_contents) then
        if (ifile1.eq.util(field_index)%ifile0_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from SET_EVOLVING_FIELD_R0:'
            write (9,*) '### Transferring data from FILE0 to FILE1:'
            write (9,*) 'Field name: ',trim(name)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          util(field_index)%f1%f=util(field_index)%f0%f
        else
          fname=tprofile(ix)%filename(ifile1)
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from SET_EVOLVING_FIELD_R0:'
            write (9,*) '### Reading a new data file:'
            write (9,*) 'Field name: ',trim(name)
            write (9,*) 'File name: ',trim(fname)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          call read_file_and_interp_r0 (trim(fname), &
                                        util(field_index)%f1)
        end if
        util(field_index)%ifile1_contents=ifile1
      end if
!
! ****** Interpolate the array to time TARG.
!
      fld_r0%f=(one-alpha)*util(field_index)%f0%f &
                   +alpha *util(field_index)%f1%f
!
end subroutine
!#######################################################################
subroutine read_file_and_interp_r0 (fname,fld_r0)
!
!-----------------------------------------------------------------------
!
! ****** Read the field in structure FLD_R0 at r=R0 from file FNAME,
! ****** and interpolate it to a field defined on local arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use array_tp_def
      use mpidefs
      use globals
      use global_to_local_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      type(array_tp) :: fld_r0
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      real(r_typ), dimension(:,:), allocatable :: fld0_g
!
!-----------------------------------------------------------------------
!
! ****** Read the data in the (t,p) surface at r=R0 from the file.
!
      if (iamp0) then
        if (fld_r0%main_mesh_t) then
          if (fld_r0%main_mesh_p) then
            allocate (fld0_g(ntm1_g,npm1_g))
            call read_tp_interp_mm (fname,fld0_g,fld_r0%pole_bc,ierr)
          else
            allocate (fld0_g(ntm1_g,np_g))
            call read_tp_interp_mh (fname,fld0_g,fld_r0%pole_bc,ierr)
          end if
        else
          if (fld_r0%main_mesh_p) then
            allocate (fld0_g(nt_g,npm1_g))
            call read_tp_interp_hm (fname,fld0_g,fld_r0%pole_bc,ierr)
          else
            allocate (fld0_g(nt_g,np_g))
            call read_tp_interp_hh (fname,fld0_g,fld_r0%pole_bc,ierr)
          end if
        end if
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_FILE_AND_INTERP_R0:'
          write (*,*) '### Error while reading the field at r=R0:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_FILE_AND_INTERP_R0:'
          write (9,*) '### Error while reading the field at r=R0:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      else
        allocate (fld0_g(1,1))
      end if
      call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
      call global_to_local_tp (fld0_g,fld_r0%f)
!
! ****** Deallocate temporary storage.
!
      deallocate (fld0_g)
!
end subroutine
!#######################################################################
subroutine potfld_from_bnfile
!
!-----------------------------------------------------------------------
!
! ****** Find the potential field for a flux distribution at the
! ****** lower radial boundary, which is read in from a file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars
      use mpidefs
      use field_table
      use io_units
      use fields, ONLY : b
      use write_field_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Local flux arrays.
!
      real(r_typ), dimension(ntm,npm) :: br0
!
!-----------------------------------------------------------------------
!
! ****** Read Br at r=R0.
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from POTFLD_FROM_BNFILE:'
        write (IO_OUT,*) '### Reading Br at r=R0 from file: ', &
                          trim(bnfile)
        FLUSH (IO_OUT)
      end if
!
      call read_flux (bnfile,br0)
!
! ****** Compute the potential field.
!
      call potfld_compute (br0)
!
! ****** Write out potential field.
!
      call write_field ('potfld_br.h5',IFLD_BR,b%r)
      call write_field ('potfld_bt.h5',IFLD_BT,b%t)
      call write_field ('potfld_bp.h5',IFLD_BP,b%p)
!
end subroutine
!#######################################################################
subroutine potfld_from_mas_br0
!
!-----------------------------------------------------------------------
!
! ****** Find the potential field for the current mas flux distribution
! ****** at the lower radial boundary.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars
      use fields
      use mpidefs
      use field_table
      use io_units
      use write_field_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Local flux arrays.
!
      real(r_typ), dimension(ntm,npm) :: br0
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Get Br0 from the current MAS B.
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from POTFLD_FROM_MAS_BR0:'
        write (IO_OUT,*) '### Getting Br0 from the current MAS B.'
        write (IO_OUT,*) 'NTIME = ',ntime
        write (IO_OUT,*) 'TIME = ',time
        FLUSH (IO_OUT)
      end if
!
!$acc update device(a%r,a%t,a%p)
      call bfroma (a,b,one)
!$acc update self(b%r,b%t,b%p)
!
      br0(:,:)=half*(b%r(1,:,:)+b%r(2,:,:))
!
! ****** Compute the potential field.
!
      call potfld_compute (br0)
!
end subroutine
!#######################################################################
subroutine potfld_compute (br0)
!
!-----------------------------------------------------------------------
!
! ****** Find the potential field for a given surface flux distribution.
! ****** The solution replaces the global vector potential, a.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use debug
      use mpidefs
      use cgcom
      use timing
      use potential_field
      use ucase_interface
      use field_table
      use write_field_tp_interface
      use write_field_interface
      use io_units
      use fluxrope_parameters
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Input surface flux array.
!
      real(r_typ), dimension(ntm,npm) :: br0
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: br0_tmp
!
! ****** Array for the RHS of the 2D potential solve at
! ****** the lower radial boundary.
!
      real(r_typ), dimension(ntm,npm) :: rhs2d
!
! ****** Array for the potential and the RHS for the 3D potential
! ****** solve.
!
      real(r_typ), dimension(nr,ntm,npm) :: psi3d
      real(r_typ), dimension(nr,ntm,npm) :: rhs3d
!
! ****** Magnetic fields of the flux ropes (used if preserving br0).
!
      type(bvec) :: b_fr
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0
      integer :: i,j,k
      real(r_typ) :: dv
      logical :: reset_ncghist=.false.
!
!-----------------------------------------------------------------------
!
! ****** If the unbalanced flux option was requested, make sure that
! ****** a source-surface solution is being done.
!
      if (allow_unbalanced_flux) then
        if (.not.(potential_field_bc.eq.'SOURCE_SURFACE'.or. &
                  potential_field_bc.eq.'MHDSS')) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in POTFLD:'
            write (*,*) '### You have requested to leave the'// &
                        ' flux unbalanced, but have not'
            write (*,*) 'requested a source-surface solution.'// &
                        '  This combination is not allowed.'
            write (*,*) 'ALLOW_UNBALANCED_FLUX = ', &
                        allow_unbalanced_flux
            write (*,*) 'POTENTIAL_FIELD_BC = ', &
                        trim(ucase(potential_field_bc))
          end if
          call endrun (.true.)
        end if
      end if
!
! ****** Set the factors needed to apply the BCs at r=R0 and r=R1.
! ****** The default source-surface radius is equal to R1.
!
      psi_bcfac0_n=-(rh(1)*rh_i(2))**2
      psi_bcfac0_v=two*(rh(1)*r_i(1))**2
!
      potential_field_bc=ucase(potential_field_bc)
!
      if (potential_field_bc.eq.'SOURCE_SURFACE'.or. &
          potential_field_bc.eq.'MHDSS') then
        psi_bcfac1_n=one
        if (r_ss.lt.0.) then
          r_ss=r1
        end if
      else if (potential_field_bc.eq.'CLOSED_WALL') then
        psi_bcfac1_n=-(rh(nr)*rh_i(nrm1))**2
        r_ss=r1
      else
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in POTFLD:'
          write (*,*) '### Invalid boundary condition type'// &
                      ' requested at r=R1:'
          write (*,*) 'POTENTIAL_FIELD_BC = ', &
                      trim(potential_field_bc)
          write (*,*)
          write (*,*) '### The allowed options are:'
          write (*,*) '''CLOSED_WALL'''
          write (*,*) '''SOURCE_SURFACE'''
          write (*,*) '''MHDSS'''
        end if
        call endrun (.true.)
      end if
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from POTFLD:'
        write (IO_OUT,*) '### Boundary condition type used at r=R1:'
        write (IO_OUT,*) 'POTENTIAL_FIELD_BC = ', &
                    trim(ucase(potential_field_bc))
        if (ucase(potential_field_bc).eq.'SOURCE_SURFACE') then
          write (IO_OUT,*) 'Source-surface radius [R_SS] = ',r_ss
        end if
        FLUSH (IO_OUT)
      end if
!
! ****** Write the interpolated boundary flux to file BNFILE_OUT
! ****** (if requested, and before preserve subtraction if any).
!
      if (bnfile_out.ne.' ') then
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from POTFLD:'
          write (IO_OUT,*)
          write (IO_OUT,*) 'Writing BR0 to file: ',trim(bnfile_out)
          FLUSH (IO_OUT)
        end if
        if (br00.ne.0.) then
          br0_tmp(:,:)=br0(:,:)+br00
        else
          br0_tmp(:,:)=br0(:,:)
        end if
        call write_field_tp (bnfile_out,IFLD_BR,br0_tmp,0)
      end if
!
! ****** If flux ropes have been added, and the option to preserve Br
! ****** at r=R0 was set, subtract Br for the flux ropes at r=R0 from
! ****** BR0 before calculating the potential field. This is done so
! ****** that after the flux ropes are added, Br will exactly match
! ****** what is specified by the input Br file.
!
      if (fluxropes_added.and.fluxrope_preserve_br0) then
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from POTFLD:'
          write (IO_OUT,*)
          write (IO_OUT,*) '### Adding flux ropes while'// &
                      ' preserving Br at r=R0.'
          write (IO_OUT,*) '### Thus, Br for the flux ropes is'// &
                      ' being subtracted from the Br'
          write (IO_OUT,*) '### distribution that was at'// &
                      ' r=R0 before calculating'
          write (IO_OUT,*) '### the potential field.'
          FLUSH (IO_OUT)
        end if
!
        call alloc_bvec (b_fr)
!$acc update device(a_fr%r,a_fr%t,a_fr%p)
        call bfroma (a_fr,b_fr,zero)
!$acc update self(b_fr%r,b_fr%t,b_fr%p)
        if (rb0) then
          br0(:,:)=br0(:,:)-half*(b_fr%r(1,:,:)+b_fr%r(2,:,:))
        end if
        call dealloc_bvec (b_fr)
!
      end if
!
!-----------------------------------------------------------------------
! ****** Solve the 2D implicit equations for the boundary potential.
!-----------------------------------------------------------------------
!
! ****** Form the RHS.
!
      rhs2d(:,:)=0.
!
      do k=2,npm-1
        do j=2,ntm-1
          dv=r0**2*dt(j)*st(j)*dp(k)
          rhs2d(j,k)=dv*br0(j,k)
        enddo
        if (tb0) then
          dv=quarter*r0**2*dt(   1)*sth(   2)*dp(k)
          rhs2d(   1,k)=dv*br0(   1,k)
        end if
        if (tb1) then
          dv=quarter*r0**2*dt(ntm1)*sth(ntm1)*dp(k)
          rhs2d(ntm1,k)=dv*br0(ntm1,k)
        end if
      enddo
!$acc enter data copyin(rhs2d)
!
! ****** Solve the 2D implicit equations for the boundary potential.
!
      allocate (psi_r0(ntm,npm))
!
! ****** Use a guess equal to zero.
!
      psi_r0(:,:)=0.
!$acc enter data copyin(psi_r0)
!
! ****** Solve the implicit equations.
!
      equation_solved=EQ_POT2D
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### Starting POT2D solver.'
        FLUSH (IO_OUT)
      end if
!
      if (ncghist.eq.0) then
        ncghist=100
        reset_ncghist=.true.
      end if
!
      call pot2d_solver (psi_r0,rhs2d,ierr)
!$acc exit data delete(rhs2d)
!
      call check_error_on_any_proc (ierr)
!
      if (reset_ncghist) then
        ncghist=0
        reset_ncghist=.false.
      end if
!
      call write_field_tp ('potfld_psi0.h5',IFLD_BR,psi_r0,0)
!
!-----------------------------------------------------------------------
! ****** Solve the 3D implicit equations for the potential.
!-----------------------------------------------------------------------
!
! ****** Form the RHS and use a guess equal to zero.
!
!$acc enter data create(psi3d,rhs3d)
      do concurrent (k=1:npm, j=1:ntm, i=1:nr)
        rhs3d(i,j,k)=0.
        psi3d(i,j,k)=0.
      enddo
!
! ****** Solve the 3D implicit equations for the boundary potential.
!
      equation_solved=EQ_POT3D
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### Starting POT3D solver.'
        FLUSH (IO_OUT)
      end if
!
      if (ncghist.eq.0) then
        ncghist=100
        reset_ncghist=.true.
      end if
!
      call pot3d_solver (psi3d,rhs3d)
!
      if (reset_ncghist) then
        ncghist=0
        reset_ncghist=.false.
      end if
!
      call write_field ('potfld_psi.h5',IFLD_BR,psi3d)
!
! ****** Get the vector potential from PSI.
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm1)
        a%r(i,j,k)=0.
      enddo
!
      do concurrent (k=2:npm1,j=jm0:jm1,i=1:nr)
        a%t(i,j,k)= (psi3d(i,j,k)-psi3d(i,j,k-1)) &
                   *dp_mult*dph_i(k)*rh_i(i)*st_i(j)
      enddo
!
      do concurrent (k=1:npm1,j=2:ntm1,i=1:nr)
        a%p(i,j,k)=-(psi3d(i,j,k)-psi3d(i,j-1,k)) &
                   *dth_i(j)*rh_i(i)
      enddo
!
      call seam_avec (a)
      call set_pole_bc_avec (a)
!
! ****** Get the magnetic field.
!
      call bfroma (a,b,one)
!$acc update self(a%r,a%t,a%p,b%r,b%t,b%p)
!
! ****** The code no longer needs the boundary potential array.
!
!$acc exit data delete(psi_r0)
      deallocate (psi_r0)
!
!$acc exit data delete(psi3d,rhs3d)
end subroutine
!#######################################################################
subroutine read_flux (fname,br0)
!
!-----------------------------------------------------------------------
!
! ****** Read the normal magnetic field Br at r=R0 from file FNAME,
! ****** normalize it, and balance the flux.
!
! ****** The magnetic field is returned in the local array BR0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
      use vars
      use io_units
      use global_to_local_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(ntm,npm) :: br0
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1_g,npm1_g) :: br0_g
      integer :: ierr=0
!
!-----------------------------------------------------------------------
!
! ****** Read the boundary flux file.
!
      if (iamp0) then
!
        call read_tp_interp_mm (fname,br0_g,1,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_FLUX:'
          write (*,*) '### Error while reading the boundary flux:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_FLUX:'
          write (9,*) '### Error while reading the boundary flux:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Balance the flux.
!
      if (iamp0) then
!
        call balance_flux (br0_g,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_FLUX:'
          write (*,*) '### Could not balance the boundary flux'// &
                      ' at r=R0:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_FLUX:'
          write (9,*) '### Could not balance the boundary flux'// &
                      ' at r=R0:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
      call global_to_local_tp (br0_g,br0)
!
! ****** Update BR00 from IPROC0 to all processors.
!
      call MPI_Bcast (br00,1,ntype_real,iproc0,comm_all,ierr)
      call check_error_on_any_proc (ierr)
!
end subroutine
!#######################################################################
subroutine balance_flux (br0_g,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Normalize the normal magnetic field Br at r=R0 and balance
! ****** the flux.
!
!-----------------------------------------------------------------------
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1_g,npm1_g) :: br0_g
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: bnmax,bscale
      real(r_typ) :: surface,fluxp,fluxm,da_t,da_p,br00err
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Find the maximum absolute value of the normal field.
!
      bnmax=maxval(abs(br0_g))
!
      if (bnmax.eq.0.) then
        write (*,*)
        write (*,*) '### ERROR in BALANCE_FLUX:'
        write (*,*) '### Anomaly in the boundary flux at r=R0:'
        write (*,*) 'Br is identically zero.'
        write (9,*)
        write (9,*) '### ERROR in BALANCE_FLUX:'
        write (9,*) '### Anomaly in the boundary flux at r=R0:'
        write (9,*) 'Br is identically zero.'
        ierr=1
        return
      end if
!
! ****** Normalize the field.
!
! ****** When B_IN_GAUSS=.true., then it is assumed that the
! ****** input magnetic field is being specified in Gauss,
! ****** and the value of B0 is ignored.
!
! ****** Otherwise, normalize the magnetic field so that the maximum
! ****** normal field magnitude is B0.
! ****** When B0=0., leave the field unscaled.
!
! ****** BSCALE is the scaling factor for the magnetic field; i.e.,
! ****** the original field is BSCALE times the normalized field.
!
      if (b_in_gauss) then
        bscale=fn_b
      else
        if (b0.eq.0.) then
          bscale=one
        else
          bscale=bnmax/b0
        end if
      end if
!
      br0_g=br0_g/bscale
!
! ****** Write the normalization factor.
!
      write (9,*)
      write (9,*) '### COMMENT from BALANCE_FLUX:'
      write (9,*) '### Normalization factor for the normal magnetic'// &
                  ' field:'
      write (9,*)
      write (9,*) 'Maximum field magnitude before normalization  = ', &
                  bnmax
      write (9,*) 'Maximum field magnitude after normalization   = ', &
                  bnmax/bscale
      write (9,*) 'Scaling factor for the magnetic field, BSCALE = ', &
                  bscale
      write (9,*) '[Original field = BSCALE * normalized field.]'
!
! ****** Calculate the total flux.
!
      surface=0.
      fluxp=0.
      fluxm=0.
      do j=1,ntm1_g
        if (j.eq.1) then
          da_t=quarter*sth_g(2)*dt_g(1)
        else if (j.eq.ntm1_g) then
          da_t=quarter*sth_g(ntm1_g)*dt_g(ntm1_g)
        else
          da_t=st_g(j)*dt_g(j)
        end if
        do k=1,npm1_g
          if (k.eq.1.or.k.eq.npm1_g) then
            da_p=half*dp_g(k)
          else
            da_p=dp_g(k)
          end if
          if (br0_g(j,k).gt.0.) then
            fluxp=fluxp+br0_g(j,k)*da_t*da_p
          else
            fluxm=fluxm+br0_g(j,k)*da_t*da_p
          end if
          surface=surface+da_t*da_p
        enddo
      enddo
!
      write (9,*)
      write (9,*) '### COMMENT from BALANCE_FLUX:'
      write (9,*) '### Computed flux balance:'
      write (9,*)
      write (9,*) 'Positive flux = ',fluxp*r0*r0
      write (9,*) 'Negative flux = ',fluxm*r0*r0
!
! ****** Fix the magnetic field so that the total flux is zero.
!
      br00err=(fluxp+fluxm)/surface
!
      br0_g(:,:)=br0_g(:,:)-br00err
!
      write (9,*)
      write (9,*) '### COMMENT from BALANCE_FLUX:'
      write (9,*) '### Flux balance correction:'
      write (9,*)
      write (9,*) 'Monopole Br field magnitude = ',br00err
!
! ****** If the user requested to leave the flux unbalanced,
! ****** add the unbalanced flux to the monopole field.
!
      if (allow_unbalanced_flux) then
!
! ****** Set the monopole field value to account for the
! ****** unbalanced flux.
!
        br00=br00+br00err
!
        write (9,*)
        write (9,*) '### COMMENT from BALANCE_FLUX:'
        write (9,*) '### The user has requested to leave'// &
                    ' the flux unbalanced.'
        write (9,*) 'Added a monopole field with value BR00 = ',br00err
        write (9,*) 'Total monopole field value is BR00 = ',br00
!
      end if
!
end subroutine
!#######################################################################
subroutine read_tp_interp_hh (fname,f_g,pole_bc,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field in the (t,p) plane from HDF file FNAME
! ****** and interpolate it into global array F_G.
!
! ****** Boundary conditions at the poles are set according to
! ****** POLE_BC (1: scalar, 2: theta component of a vector,
! ****** 3: phi component of a vector).
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use rdhdf_2d_interface
      use ucase_interface
      use sum_p_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(nt_g,np_g) :: f_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: nx,ny
      real(r_typ), dimension(:), pointer, contiguous ::x,y
      real(r_typ), dimension(:,:), pointer, contiguous ::f
!
      real(r_typ), dimension(1) :: sum0,sum1
      real(r_typ), dimension(1) :: sums0,sums1
      real(r_typ), dimension(1) :: sumc0,sumc1
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** When the file name is the special string '<ZERO>',
! ****** the array F_G is set to 0.
!
      if (ucase(fname).eq.'<ZERO>') then
        f_g=0.
        return
      end if
!
! ****** Read the array and its scales.  This call allocates the
! ****** arrays X, Y, and F.
!
      call rdhdf_2d (fname,scale,nx,ny,f,x,y,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_HH:'
        write (9,*) '### Could not read the specified field.'
        write (9,*) 'IERR (from RDHDF_2D) = ',ierr
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Check that the array has scales.
!
      if (.not.scale) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_HH:'
        write (9,*) '### The file does not have scales.'
        write (9,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
! ****** Interpolate the field on the TH_G and PH_G mesh into
! ****** array F_G.
!
! ****** First, interpolate the field on a mesh that does not
! ****** include the points outside the interval [0:pi,0:2*pi],
! ****** and then set these points using boundary conditions.
!
      f_g=0.
!
      call interp_2d (nx,ny,x,y,f,ntm2_g,npm2_g, &
                      th_g(2:ntm1_g), &
                      ph_g(2:npm1_g), &
                      f_g(2:ntm1_g,2:npm1_g), &
                      .false.,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_HH:'
        write (9,*) '### The scales in the file are invalid.'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Set the phi boundary points periodically.
!
      f_g(:,   1)=f_g(:,npm1_g)
      f_g(:,np_g)=f_g(:,     2)
!
! ****** Set boundary conditions at the poles.
!
      if (pole_bc.eq.1) then
!
! ****** A scalar has only an m=0 component.
!
        sum0=sum_p(1,npm2_g,f_g(     2,2:npm1_g),dph_g(2:npm1_g))
        sum1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g),dph_g(2:npm1_g))
!
        f_g(   1,:)=two*sum0(1)-f_g(     2,:)
        f_g(nt_g,:)=two*sum1(1)-f_g(ntm1_g,:)
!
      else
!
! ****** The theta and phi components of a vector have only
! ****** an m=1 component.
!
        if (axisymmetric) then
          sums0=0.
          sumc0=0.
          sums1=0.
          sumc1=0.
        else
          sums0=sum_p(1,npm2_g,f_g(     2,2:npm1_g), &
                         sph_g(2:npm1_g)*dph_g(2:npm1_g))*two
          sumc0=sum_p(1,npm2_g,f_g(     2,2:npm1_g), &
                         cph_g(2:npm1_g)*dph_g(2:npm1_g))*two
          sums1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         sph_g(2:npm1_g)*dph_g(2:npm1_g))*two
          sumc1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         cph_g(2:npm1_g)*dph_g(2:npm1_g))*two
        end if
!
        f_g(   1,1:np_g)= two*( sums0(1)*sph_g(1:np_g) &
                               +sumc0(1)*cph_g(1:np_g)) &
                         -f_g(     2,1:np_g)
        f_g(nt_g,1:np_g)= two*( sums1(1)*sph_g(1:np_g) &
                               +sumc1(1)*cph_g(1:np_g)) &
                         -f_g(ntm1_g,1:np_g)
!
      end if
!
! ****** Deallocate temporary arrays.
!
      deallocate (x)
      deallocate (y)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine read_tp_interp_mh (fname,f_g,pole_bc,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field in the (t,p) plane from HDF file FNAME
! ****** and interpolate it into global array F_G.
!
! ****** Boundary conditions at the poles are set according to
! ****** POLE_BC (1: scalar, 2: theta component of a vector,
! ****** 3: phi component of a vector).
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use rdhdf_2d_interface
      use ucase_interface
      use sum_p_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(ntm1_g,np_g) :: f_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: nx,ny
      real(r_typ), dimension(:), pointer, contiguous ::x,y
      real(r_typ), dimension(:,:), pointer, contiguous ::f
!
      real(r_typ), dimension(1) :: sum0,sum1
      real(r_typ), dimension(1) :: sums0,sums1
      real(r_typ), dimension(1) :: sumc0,sumc1
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** When the file name is the special string '<ZERO>',
! ****** the array F_G is set to 0.
!
      if (ucase(fname).eq.'<ZERO>') then
        f_g=0.
        return
      end if
!
! ****** Read the array and its scales.  This call allocates the
! ****** arrays X, Y, and F.
!
      call rdhdf_2d (fname,scale,nx,ny,f,x,y,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_MH:'
        write (9,*) '### Could not read the specified field.'
        write (9,*) 'IERR (from RDHDF_2D) = ',ierr
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Check that the array has scales.
!
      if (.not.scale) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_MH:'
        write (9,*) '### The file does not have scales.'
        write (9,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
! ****** Interpolate the field on the T_G and PH_G mesh into
! ****** array F_G.
!
! ****** First, interpolate the field on a mesh that does not
! ****** include the points outside the phi interval [0:2*pi],
! ****** and then set these points using boundary conditions.
!
      f_g=0.
!
      call interp_2d (nx,ny,x,y,f,ntm1_g,npm2_g, &
                      t_g, &
                      ph_g(2:npm1_g), &
                      f_g(:,2:npm1_g), &
                      .false.,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_MH:'
        write (9,*) '### The scales in the file are invalid.'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Set the phi boundary points periodically.
!
      f_g(:,   1)=f_g(:,npm1_g)
      f_g(:,np_g)=f_g(:,     2)
!
! ****** Set boundary conditions at the poles.
!
      if (pole_bc.eq.1) then
!
! ****** A scalar has only an m=0 component.
!
        sum0=sum_p(1,npm2_g,f_g(     1,2:npm1_g),dph_g(2:npm1_g))
        sum1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g),dph_g(2:npm1_g))
!
        f_g(     1,:)=sum0(1)
        f_g(ntm1_g,:)=sum1(1)
!
      else
!
! ****** The theta and phi components of a vector have only
! ****** an m=1 component.
!
        if (axisymmetric) then
          sums0=0.
          sumc0=0.
          sums1=0.
          sumc1=0.
        else
          sums0=sum_p(1,npm2_g,f_g(     1,2:npm1_g), &
                         sph_g(2:npm1_g)*dph_g(2:npm1_g))*two
          sumc0=sum_p(1,npm2_g,f_g(     1,2:npm1_g), &
                         cph_g(2:npm1_g)*dph_g(2:npm1_g))*two
          sums1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         sph_g(2:npm1_g)*dph_g(2:npm1_g))*two
          sumc1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         cph_g(2:npm1_g)*dph_g(2:npm1_g))*two
        end if
!
        f_g(     1,1:np_g)= sums0(1)*sph_g(1:np_g) &
                           +sumc0(1)*cph_g(1:np_g)
        f_g(ntm1_g,1:np_g)= sums1(1)*sph_g(1:np_g) &
                           +sumc1(1)*cph_g(1:np_g)
!
      end if
!
! ****** Deallocate temporary arrays.
!
      deallocate (x)
      deallocate (y)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine read_tp_interp_hm (fname,f_g,pole_bc,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field in the (t,p) plane from HDF file FNAME
! ****** and interpolate it into global array F_G.
!
! ****** Boundary conditions at the poles are set according to
! ****** POLE_BC (1: scalar, 2: theta component of a vector,
! ****** 3: phi component of a vector).
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use rdhdf_2d_interface
      use ucase_interface
      use sum_p_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(nt_g,npm1_g) :: f_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: nx,ny
      real(r_typ), dimension(:), pointer, contiguous ::x,y
      real(r_typ), dimension(:,:), pointer, contiguous ::f
!
      real(r_typ), dimension(1) :: sum0,sum1
      real(r_typ), dimension(1) :: sums0,sums1
      real(r_typ), dimension(1) :: sumc0,sumc1
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** When the file name is the special string '<ZERO>',
! ****** the array F_G is set to 0.
!
      if (ucase(fname).eq.'<ZERO>') then
        f_g=0.
        return
      end if
!
! ****** Read the array and its scales.  This call allocates the
! ****** arrays X, Y, and F.
!
      call rdhdf_2d (fname,scale,nx,ny,f,x,y,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_HM:'
        write (9,*) '### Could not read the specified field.'
        write (9,*) 'IERR (from RDHDF_2D) = ',ierr
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Check that the array has scales.
!
      if (.not.scale) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_HM:'
        write (9,*) '### The file does not have scales.'
        write (9,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
! ****** Interpolate the field on the TH_G and P_G mesh into
! ****** array F_G.
!
! ****** First, interpolate the field on a mesh that does not
! ****** include the points outside the theta interval [0:pi],
! ****** and then set these points using boundary conditions.
!
      f_g=0.
!
      call interp_2d (nx,ny,x,y,f,ntm2_g,npm1_g, &
                      th_g(2:ntm1_g), &
                      p_g(1:npm1_g), &
                      f_g(2:ntm1_g,:), &
                      .false.,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_HM:'
        write (9,*) '### The scales in the file are invalid.'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Make sure that the array is periodic.
!
      f_g(:,1)=half*(f_g(:,1)+f_g(:,npm1_g))
      f_g(:,npm1_g)=f_g(:,1)
!
! ****** Set boundary conditions at the poles.
!
      if (pole_bc.eq.1) then
!
! ****** A scalar has only an m=0 component.
!
        sum0=sum_p(1,npm2_g,f_g(     2,2:npm1_g),dp_g(2:npm1_g))
        sum1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g),dp_g(2:npm1_g))
!
        f_g(   1,:)=two*sum0(1)-f_g(     2,:)
        f_g(nt_g,:)=two*sum1(1)-f_g(ntm1_g,:)
!
      else
!
! ****** The theta and phi components of a vector have only
! ****** an m=1 component.
!
        if (axisymmetric) then
          sums0=0.
          sumc0=0.
          sums1=0.
          sumc1=0.
        else
          sums0=sum_p(1,npm2_g,f_g(     2,2:npm1_g), &
                         sp_g(2:npm1_g)*dp_g(2:npm1_g))*two
          sumc0=sum_p(1,npm2_g,f_g(     2,2:npm1_g), &
                         cp_g(2:npm1_g)*dp_g(2:npm1_g))*two
          sums1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         sp_g(2:npm1_g)*dp_g(2:npm1_g))*two
          sumc1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         cp_g(2:npm1_g)*dp_g(2:npm1_g))*two
        end if
!
        f_g(   1,1:npm1_g)= two*( sums0(1)*sp_g(1:npm1_g) &
                                 +sumc0(1)*cp_g(1:npm1_g)) &
                           -f_g(     2,1:npm1_g)
        f_g(nt_g,1:npm1_g)= two*( sums1(1)*sp_g(1:npm1_g) &
                                 +sumc1(1)*cp_g(1:npm1_g)) &
                           -f_g(ntm1_g,1:npm1_g)
!
      end if
!
! ****** Deallocate temporary arrays.
!
      deallocate (x)
      deallocate (y)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine read_tp_interp_mm (fname,f_g,pole_bc,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field in the (t,p) plane from HDF file FNAME
! ****** and interpolate it into global array F_G.
!
! ****** Boundary conditions at the poles are set according to
! ****** POLE_BC (1: scalar, 2: theta component of a vector,
! ****** 3: phi component of a vector).
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use rdhdf_2d_interface
      use ucase_interface
      use sum_p_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(ntm1_g,npm1_g) :: f_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: nx,ny
      real(r_typ), dimension(:), pointer, contiguous ::x,y
      real(r_typ), dimension(:,:), pointer, contiguous ::f
!
      real(r_typ), dimension(1) :: sum0,sum1
      real(r_typ), dimension(1) :: sums0,sums1
      real(r_typ), dimension(1) :: sumc0,sumc1
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** When the file name is the special string '<ZERO>',
! ****** the array F_G is set to 0.
!
      if (ucase(fname).eq.'<ZERO>') then
        f_g=0.
        return
      end if
!
! ****** Read the array and its scales.  This call allocates the
! ****** arrays X, Y, and F.
!
      call rdhdf_2d (fname,scale,nx,ny,f,x,y,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_MM:'
        write (9,*) '### Could not read the specified field.'
        write (9,*) 'IERR (from RDHDF_2D) = ',ierr
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Check that the array has scales.
!
      if (.not.scale) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_MM:'
        write (9,*) '### The file does not have scales.'
        write (9,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
! ****** Interpolate the field on the T_G and P_G mesh into
! ****** array F_G.
!
      f_g=0.
!
      call interp_2d (nx,ny,x,y,f,ntm1_g,npm1_g, &
                      t_g, &
                      p_g(1:npm1_g), &
                      f_g, &
                      .false.,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_TP_INTERP_MM:'
        write (9,*) '### The scales in the file are not valid:'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Make sure that the array is periodic.
!
      f_g(:,1)=half*(f_g(:,1)+f_g(:,npm1_g))
      f_g(:,npm1_g)=f_g(:,1)
!
! ****** Set boundary conditions at the poles.
!
      if (pole_bc.eq.1) then
!
! ****** A scalar has only an m=0 component.
!
        sum0=sum_p(1,npm2_g,f_g(     1,2:npm1_g),dp_g(2:npm1_g))
        sum1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g),dp_g(2:npm1_g))
!
        f_g(     1,:)=sum0(1)
        f_g(ntm1_g,:)=sum1(1)
!
      else
!
! ****** The theta and phi components of a vector have only
! ****** an m=1 component.
!
        if (axisymmetric) then
          sums0=0.
          sumc0=0.
          sums1=0.
          sumc1=0.
        else
          sums0=sum_p(1,npm2_g,f_g(     1,2:npm1_g), &
                         sp_g(2:npm1_g)*dp_g(2:npm1_g))*two
          sumc0=sum_p(1,npm2_g,f_g(     1,2:npm1_g), &
                         cp_g(2:npm1_g)*dp_g(2:npm1_g))*two
          sums1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         sp_g(2:npm1_g)*dp_g(2:npm1_g))*two
          sumc1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g), &
                         cp_g(2:npm1_g)*dp_g(2:npm1_g))*two
        end if
!
        f_g(     1,1:npm1_g)= sums0(1)*sp_g(1:npm1_g) &
                             +sumc0(1)*cp_g(1:npm1_g)
        f_g(ntm1_g,1:npm1_g)= sums1(1)*sp_g(1:npm1_g) &
                             +sumc1(1)*cp_g(1:npm1_g)
!
      end if
!
! ****** Deallocate temporary arrays.
!
      deallocate (x)
      deallocate (y)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine interp_2d (nxi,nyi,xi,yi,fi,nx,ny,x,y,f, &
                            zero_outside,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Interpolate a 2D field from array FI(NXI,NYI), defined
! ****** on the mesh XI(NXI) x YI(NYI), into the array F(NX,NY),
! ****** defined on the mesh X(NX) x Y(NY).
!
! ****** IF ZERO_OUTSIDE=.TRUE., points outside the bounds of
! ****** the XI x YI mesh are set to zero.  Otherwise, if a point
! ****** is outside the bounds of the XI x YI mesh, IERR=2 is
! ****** returned.
!
!-----------------------------------------------------------------------
!
      use number_types
      use flint_interface
      use mpidefs
      use outside_interval_interface
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: nxi,nyi
      real(r_typ), dimension(nxi) :: xi
      real(r_typ), dimension(nyi) :: yi
      real(r_typ), dimension(nxi,nyi) :: fi
      integer :: nx,ny
      real(r_typ), dimension(nx) :: x
      real(r_typ), dimension(ny) :: y
      real(r_typ), dimension(nx,ny) :: f
      logical :: zero_outside
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Precision to within which a mesh point location is
! ****** considered to be subject to round-off.  This takes into
! ****** account small inaccuracies in the domain boundaries.
! ****** The negative value specifies that this a relative error.
!
      real(r_typ), parameter :: eps=-1.e-6_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,ii,jj,iip1,jjp1
      real(r_typ) :: dummy,ax,ay,xv,yv
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Check that the scales XI and YI are monotonic.
!
      dummy=flint(.true.,zero,nxi,xi,xi,ierr)
      if (ierr.ne.0) go to 900
!
      dummy=flint(.true.,zero,nyi,yi,yi,ierr)
      if (ierr.ne.0) go to 900
!
! ****** Interpolate the data.
!
      f=0.
      do j=1,ny
        yv=y(j)
        if (outside_interval(yi(1),yi(nyi),yv,eps)) then
          if (zero_outside) then
            cycle
          else
            go to 910
          end if
        end if
        call interp (nyi,yi,yv,jj,jjp1,ay,ierr)
        if (ierr.ne.0) go to 910
        do i=1,nx
          xv=x(i)
          if (outside_interval(xi(1),xi(nxi),xv,eps)) then
            if (zero_outside) then
              cycle
            else
              go to 910
            end if
          end if
          call interp (nxi,xi,xv,ii,iip1,ax,ierr)
          if (ierr.ne.0) go to 910
          f(i,j)= (one-ax)*((one-ay)*fi(ii  ,jj  )+ay*fi(ii  ,jjp1)) &
                 +     ax *((one-ay)*fi(iip1,jj  )+ay*fi(iip1,jjp1))
        enddo
      enddo
!
      return
!
! ****** Error exit: invalid scales.
!
  900 continue
!
      if (iamp0) then
        write (*,*)
        write (*,*) '### ERROR in INTERP_2D:'
        write (*,*) '### The scales are not monotonically'// &
                    ' increasing.'
        ierr=1
      end if
!
      return
!
! ****** Error exit: data outside range of scales.
!
  910 continue
!
      if (iamp0) then
        write (*,*)
        write (*,*) '### ERROR in INTERP_2D:'
        write (*,*) '### An interpolation was attempted outside'// &
                    ' the range of the defined scales.'
        ierr=2
      end if
!
end subroutine
!#######################################################################
subroutine interp_3d (nxi,nyi,nzi,xi,yi,zi,fi, &
                            nx,ny,nz,x,y,z,f, &
                            zero_outside,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Interpolate a 3D field from array FI(NXI,NYI,NZI), defined
! ****** on the mesh XI(NXI) x YI(NYI) x ZI(NZI), into the array
! ****** F(NX,NY,NZ), defined on the mesh X(NX) x Y(NY) x Z(NZ).
!
! ****** IF ZERO_OUTSIDE=.TRUE., points outside the bounds of
! ****** the XI x YI x ZI mesh are set to zero.  Otherwise, if a
! ****** point is outside the bounds of the XI x YI x ZI mesh,
! ****** IERR=2 is returned.
!
!-----------------------------------------------------------------------
!
      use number_types
      use flint_interface
      use mpidefs
      use outside_interval_interface
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: nxi,nyi,nzi
      real(r_typ), dimension(nxi) :: xi
      real(r_typ), dimension(nyi) :: yi
      real(r_typ), dimension(nzi) :: zi
      real(r_typ), dimension(nxi,nyi,nzi) :: fi
      integer :: nx,ny,nz
      real(r_typ), dimension(nx) :: x
      real(r_typ), dimension(ny) :: y
      real(r_typ), dimension(nz) :: z
      real(r_typ), dimension(nx,ny,nz) :: f
      logical :: zero_outside
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Precision to within which a mesh point location is
! ****** considered to be subject to round-off.  This takes into
! ****** account small inaccuracies in the domain boundaries.
! ****** The negative value specifies that this a relative error.
!
      real(r_typ), parameter :: eps=-1.e-6_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ii,jj,kk,ip1,jp1,kp1
      real(r_typ) :: dummy,ax,ay,az,xv,yv,zv
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Check that the scales XI, YI, ZI are monotonic.
!
      dummy=flint(.true.,zero,nxi,xi,xi,ierr)
      if (ierr.ne.0) go to 900
!
      dummy=flint(.true.,zero,nyi,yi,yi,ierr)
      if (ierr.ne.0) go to 900
!
      dummy=flint(.true.,zero,nzi,zi,zi,ierr)
      if (ierr.ne.0) go to 900
!
! ****** Interpolate the data.
!
      f=0.
      do k=1,nz
        zv=z(k)
        if (outside_interval(zi(1),zi(nzi),zv,eps)) then
          if (zero_outside) then
            cycle
          else
            go to 910
          end if
        end if
        call interp (nzi,zi,zv,kk,kp1,az,ierr)
        if (ierr.ne.0) go to 910
        do j=1,ny
          yv=y(j)
          if (outside_interval(yi(1),yi(nyi),yv,eps)) then
            if (zero_outside) then
              cycle
            else
              go to 910
            end if
          end if
          call interp (nyi,yi,yv,jj,jp1,ay,ierr)
          if (ierr.ne.0) go to 910
          do i=1,nx
            xv=x(i)
            if (outside_interval(xi(1),xi(nxi),xv,eps)) then
              if (zero_outside) then
                cycle
              else
                go to 910
              end if
            end if
            call interp (nxi,xi,xv,ii,ip1,ax,ierr)
            if (ierr.ne.0) go to 910
            f(i,j,k)= (one-ax)*( (one-ay)*( (one-az)*fi(ii ,jj ,kk ) &
                                           +     az *fi(ii ,jj ,kp1) &
                                          ) &
                                +     ay *( (one-az)*fi(ii ,jp1,kk ) &
                                           +     az *fi(ii ,jp1,kp1) &
                                          ) &
                               ) &
                     +     ax *( (one-ay)*( (one-az)*fi(ip1,jj ,kk ) &
                                           +     az *fi(ip1,jj ,kp1) &
                                          ) &
                                +     ay *( (one-az)*fi(ip1,jp1,kk ) &
                                           +     az *fi(ip1,jp1,kp1) &
                                          ) &
                               )
          enddo
        enddo
      enddo
!
      return
!
! ****** Error exit: invalid scales.
!
  900 continue
!
      if (iamp0) then
        write (*,*)
        write (*,*) '### ERROR in INTERP_3D:'
        write (*,*) '### The scales are not monotonically'// &
                    ' increasing.'
        ierr=1
      end if
!
      return
!
! ****** Error exit: data outside range of scales.
!
  910 continue
!
      if (iamp0) then
        write (*,*)
        write (*,*) '### ERROR in INTERP_3D:'
        write (*,*) '### An interpolation was attempted outside'// &
                    ' the range of the defined scales.'
        ierr=2
      end if
!
end subroutine
!#######################################################################
function outside_interval (x0,x1,x,eps)
!
!-----------------------------------------------------------------------
!
! ****** If X is outside the interval [X0,X1], return .TRUE.;
! ****** otherwise, return .FALSE..  It is assumed that X1.ge.X0.
!
!-----------------------------------------------------------------------
!
! ****** The optional argument EPS allows the test of whether
! ****** X is in the interval to specify an inaccuracy.  This
! ****** implements the test in an "elastic" way.   Namely, it
! ****** allows X to be "near" the strict interval and still be
! ****** considered inside the interval.  In this case, X is
! ****** reset to be strictly in the interval; i.e., if X is
! ****** not outside the interval (in this loose sense), it is
! ****** reset to the corresponding interval limit (X0 or X1).
!
! ****** A negative EPS specifies a relative precision in X0
! ****** and X1, whereas a positive EPS specifies an absolute
! ****** precision in X0 and X1.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: x0,x1
      real(r_typ), intent(inout) :: x
      real(r_typ), optional :: eps
      logical :: outside_interval
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x0e,x1e
!
!-----------------------------------------------------------------------
!
      outside_interval=.false.
!
      if (present(eps)) then
        if (eps.lt.0.) then
          x0e=x0*(one-abs(eps))
          x1e=x1*(one+abs(eps))
        else
          x0e=x0-eps
          x1e=x1+eps
        end if
        if (x.lt.x0e) then
          outside_interval=.true.
          return
        end if
        if (x.lt.x0) then
          x=x0
          return
        end if
        if (x.gt.x1e) then
          outside_interval=.true.
          return
        end if
        if (x.gt.x1) then
          x=x1
          return
        end if
      else
        if (x.lt.x0) then
          outside_interval=.true.
          return
        end if
        if (x.gt.x1) then
          outside_interval=.true.
          return
        end if
      end if
!
      return
end function
!#######################################################################
function flint (check,x,n,xn,fn,ierr,silent)
!
!-----------------------------------------------------------------------
!
! ****** Interpolate a function linearly.
!
!-----------------------------------------------------------------------
!
! ****** The funcion is defined at N nodes, with values given by
! ****** FN(N) at positions XN(N).  The function value returned is
! ****** the linear interpolant at X.
!
! ****** Note that if X.lt.XN(1), the function value returned
! ****** is FN(1), and if X.gt.XN(N), the function value returned
! ****** is FN(N).
!
! ****** Call once with CHECK=.true. to check that the values
! ****** in XN(N) are monotonically increasing.  In this mode
! ****** the array XN(N) is checked, and X and FN(N) are not
! ****** accessed.  If the check is passed, IERR=0 is returned.
! ****** Otherwise, IERR=1 is returned.
!
! ****** The optional argument SILENT controls whether error
! ****** messages are written to the TTY (the default).
! ****** Specifying SILENT=.true. suppresses error messages.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: check
      real(r_typ) :: x
      integer :: n
      real(r_typ), dimension(n) :: xn,fn
      integer :: ierr
      logical, optional :: silent
      real(r_typ) :: flint
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: x1,x2,alpha
      logical :: print_error
!
!-----------------------------------------------------------------------
!
      ierr=0
      flint=0.
!
      if (present(silent)) then
        print_error=.not.silent
      else
        print_error=.true.
      end if
!
! ****** If CHECK=.true., check the abscissa table.
!
      if (check) then
        if (n.le.0) then
          if (print_error) then
            if (iamp0) then
              write (9,*)
              write (9,*) '### ERROR in FLINT:'
              write (9,*) '### Invalid abscissa table dimension.'
              write (9,*) 'N = ',n
            end if
          end if
          ierr=1
          return
        end if
        do i=1,n-1
          if (xn(i+1).le.xn(i)) then
            if (print_error) then
              if (iamp0) then
                write (9,*)
                write (9,*) '### ERROR in FLINT:'
                write (9,*) '### Abscissa table values are not'// &
                            ' monotonically increasing.'
                write (9,*) 'N = ',n
                write (9,*) 'XN = ',xn
              end if
            end if
            ierr=1
            return
          end if
        enddo
        return
      end if
!
! ****** Get the interpolated value.
!
      if (x.le.xn(1)) then
        flint=fn(1)
      else if (x.gt.xn(n)) then
        flint=fn(n)
      else
        do i=1,n-1
          if (x.ge.xn(i).and.x.lt.xn(i+1)) exit
        enddo
        x1=xn(i)
        x2=xn(i+1)
        alpha=(x-x1)/(x2-x1)
        flint=fn(i)*(one-alpha)+fn(i+1)*alpha
      end if
!
      return
end function
!#######################################################################
subroutine write_matrix_pot2d (fname)
!
!-----------------------------------------------------------------------
!
! ****** Write the matrix for the 2D potential solve to a file.
! ****** This can be useful for debugging.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
      use cgcom
      use vars
      use matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: xvec,yvec,dummy
      real(r_typ), dimension(:,:), allocatable :: amat
!
!-----------------------------------------------------------------------
!
      integer :: ierr,j,k,ll
!
!-----------------------------------------------------------------------
!
      if (nproc.ne.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from WRITE_MATRIX_POT2D:'
          write (*,*) '### Could not write the matrix.'
          write (*,*) '### For this diagnostic you must run'// &
                      ' on only 1 processor.'
        end if
        return
      end if
!
      N_CG=N_cgvec
      call alloc_cg_ax_tmp
!
      allocate (xvec(N_cgvec))
      allocate (yvec(N_cgvec))
      xvec=0.
      yvec=0.
      allocate (dummy(1))
!
      allocate (amat(N_cgvec,N_cgvec))
      amat=0.
!
      ll=0
      do k=2,npm-1
        do j=j0,ntm1
          ll=ll+1
          xvec(ll)=one
          call ax_pot2d (xvec,yvec)
          amat(:,ll)=yvec(:)
          xvec(ll)=0.
        enddo
      enddo
!
      call wrhdf_2d (fname,.false.,N_cgvec,N_cgvec, &
                     amat,dummy,dummy,hdf32,ierr)
!
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### WARNING from WRITE_MATRIX_POT2D:'
        write (*,*) '### Could not write the matrix.'
        write (*,*) 'IERR (from WRHDF_2D) = ',ierr
      else
        write (*,*)
        write (*,*) '### COMMENT from WRITE_MATRIX_POT2D:'
        write (*,*) 'Wrote the matrix for the boundary potential'// &
                    ' solve to file: '//fname
      end if
!
      deallocate (xvec)
      deallocate (yvec)
      deallocate (amat)
      deallocate (dummy)
      call dealloc_cg_ax_tmp
!
end subroutine
!#######################################################################
subroutine write_matrix_pot3d
!
!-----------------------------------------------------------------------
!
! ****** Write the matrix for the 3D potential solve to a file.
! ****** This can be useful for debugging.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
      use cgcom
      use vars
      use matrix_storage_pot3d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: xvec,yvec,dummy
      real(r_typ), dimension(:,:), allocatable :: amat
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k,ll
!
!-----------------------------------------------------------------------
!
      if (nproc.ne.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from WRITE_MATRIX_POT3D:'
          write (*,*) '### Could not write the matrix.'
          write (*,*) '### For this diagnostic you must run'// &
                      ' on only 1 processor.'
        end if
        return
      end if
!
      N_CG=N_cgvec
      call alloc_cg_ax_tmp
!
      allocate (xvec(N_cgvec))
      allocate (yvec(N_cgvec))
      xvec=0.
      yvec=0.
      allocate (dummy(1))
!
      allocate (amat(N_cgvec,N_cgvec))
      amat=0.
!
      ll=0
      do k=2,npm1
        do j=j0,j1
          do i=2,nrm1
            ll=ll+1
            xvec(ll)=one
            call ax_pot3d (xvec,yvec)
            amat(:,ll)=yvec(:)
            xvec(ll)=0.
          enddo
        enddo
      enddo
!
      call wrhdf_2d ('amat_pot3d.h5',.false.,N_cgvec,N_cgvec, &
                     amat,dummy,dummy,hdf32,ierr)
!
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### WARNING from WRITE_MATRIX_POT3D:'
        write (*,*) '### Could not write the matrix.'
        write (*,*) 'IERR (from WRHDF_2D) = ',ierr
      else
        write (*,*)
        write (*,*) '### COMMENT from WRITE_MATRIX_POT3D:'
        write (*,*) 'Wrote the matrix for the potential'// &
                    ' solve to file: amat_pot3d.h5'
      end if
!
      deallocate (xvec)
      deallocate (yvec)
      deallocate (amat)
      deallocate (dummy)
      call dealloc_cg_ax_tmp
!
end subroutine
!#######################################################################
subroutine init_alfven_wave1
!
!-----------------------------------------------------------------------
!
! ****** Initialize a test Alfven wave.
!
!-----------------------------------------------------------------------
!
! ****** This routine initializes an m=0 torsional Alfven wave
! ****** with perturbed v-theta and B-theta.
!
!-----------------------------------------------------------------------
!
! ****** The solution is given by:
!
!           A-phi = WAVE_AMPLITUDE*[A*j_sub_l(k*r)+B*y_sub_l(k*r)]
!                                 *P_sub_l_sup_1(theta)
!                                 *cos(omega*t)
!
! ****** where j_sub_l and y_sub_l are spherical Bessel functions,
! ****** and P_sub_l_sup_1 is the associated Legendre function,
! ****** and k = omega/va.
!
! ****** The theta mode-number l is given by WAVE_MODE_T.
! ****** The radial mode-number is given by WAVE_MODE_R.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use dissipation_profiles
      use constants
      use mpidefs
      use alfven_wave_params
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,ierr
      real(r_typ) :: va,fj0,fy0,coefj,coefy,sdt,fnr,fnt,arg
      real(r_typ) :: omega,omg0,omega0,domega,omegamx
!
!-----------------------------------------------------------------------
!
! ****** Spherical Bessel functions.
!
      real(r_typ), external :: bessel_j,bessel_y
!
! ****** Associated Legendre function.
!
      real(r_typ), external :: legendre_pl1
!
!-----------------------------------------------------------------------
!
      a%r=0.
      a%t=0.
      a%p=0.
!
      v%r=0.
      v%t=0.
      v%p=0.
!
      g0=0.
!
      if (wave_mode_r.lt.1.or.wave_mode_t.lt.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INIT_ALFVEN_WAVE1:'
          write (*,*) '### Invalid wave mode requested:'
          write (*,*) 'WAVE_MODE_R = ',wave_mode_r
          write (*,*) 'WAVE_MODE_T = ',wave_mode_t
        end if
        call endrun (.true.)
      end if
!
      va=abs(br00)/sqrt(rho0)
!
      if (va.eq.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INIT_ALFVEN_WAVE1:'
          write (*,*) '### The Alfven speed is zero.'
        end if
        call endrun (.true.)
      end if
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INIT_ALFVEN_WAVE1:'
        write (9,*) '### Alfven wave (type 1) parameters:'
        write (9,*)
        write (9,*) 'WAVE_MODE_R = ',wave_mode_r
        write (9,*) 'WAVE_MODE_T = ',wave_mode_t
        write (9,*) 'BR00 = ',br00
        write (9,*) 'RHO0 = ',rho0
        write (9,*) 'VA = ',va
      end if
!
! ****** Set up a mass density profile that gives a uniform Alfven
! ****** speed for a split monopole magnetic field.
!
      do i=1,nr
        rho(i,:,:)=rho0*(r0*rh_i(i))**4
      enddo
!
      pres=0.
!
! ****** Compute the analytic wave frequency.
!
      l_taw=wave_mode_t
      x0_taw=r0/va
      x1_taw=r1/va
!
! ****** Use a conservative guess for the starting frequency
! ****** for the first root.
!
      omg0=pi*va/(r1-r0)
      omega0=.1*omg0
      domega=.01*omg0
      omegamx=10.*wave_mode_r*omg0
!
! ****** Find the WAVE_MODE_R-th root.
!
      do i=1,wave_mode_r
        call find_next_wave_root (omega0,domega,omega,omegamx,ierr)
        if (ierr.eq.0) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from INIT_ALFVEN_WAVE1: '
            write (9,*) '### Found a root for the Alfven wave:'
            write (9,*) 'Radial mode number = ',i
            write (9,*) 'OMEGA = ',omega
          end if
        else
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in INIT_ALFVEN_WAVE1: '
            write (*,*) '### Could not find the requested root:'
            write (*,*) 'WAVE_MODE_R = ',wave_mode_r
            write (*,*) 'Number of roots found so far = ',i-1
          end if
          call endrun (.true.)
        end if
      enddo
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INIT_ALFVEN_WAVE1: '
        write (9,*) '### The normal mode frequency has been found.'
        write (9,*)
        write (9,*) 'OMEGA = ',omega
      end if
!
! ****** Get the coefficients of the j_sub_l and y_sub_l functions.
!
      fj0=bessel_j(wave_mode_t,omega*r0/va)
      fy0=bessel_y(wave_mode_t,omega*r0/va)
!
      if (abs(fj0).gt.abs(fy0)) then
        coefj=-fy0/fj0
        coefy=one
      else
        coefj=one
        coefy=-fj0/fy0
      end if
!
! ****** Initialize the fields.
! ****** Note that v is defined a half time-step ahead
! ****** of A, B, and J.
!
!
! ****** Note that dtime not set yet to use expected initial dt.
!
      if (dt_init.eq.0) then
        dt_init=dtmax
      end if
      sdt=sin(half*omega*dt_init)
!
      do j=1,nt
        fnt=legendre_pl1(wave_mode_t,th(j))
        do i=1,nr
          arg=omega*rh(i)/va
          fnr= coefj*bessel_j(wave_mode_t,arg) &
              +coefy*bessel_y(wave_mode_t,arg)
          a%p(i,j,:)=wave_amplitude*fnr*fnt
        enddo
      enddo
!
      do j=1,ntm
        fnt=legendre_pl1(wave_mode_t,t(j))
        do i=1,nr
          arg=omega*rh(i)/va
          fnr= coefj*bessel_j(wave_mode_t,arg) &
              +coefy*bessel_y(wave_mode_t,arg)
          v%t(i,j,:)= wave_amplitude*omega*rh(i)**2 &
                     *fnr*fnt*sdt/(r0**2*br00)
        enddo
      enddo
!
      call seam_avec_cpu (a)
      call set_pole_bc_avec_cpu (a)
!
      ab%r0%t(:,:)=half*(a%t(1,:,:)+a%t(2,:,:))
      ab%r1%t(:,:)=half*(a%t(nr,:,:)+a%t(nrm1,:,:))
      ab%r0%p(:,:)=half*(a%p(1,:,:)+a%p(2,:,:))
      ab%r1%p(:,:)=half*(a%p(nr,:,:)+a%p(nrm1,:,:))
!
      call seam (v%r)
      call seam (v%t)
      call seam (v%p)
      call set_pole_bc_vvec_cpu (v)
!
      vb%r0%r(:,:)=0.
      vb%r1%r(:,:)=0.
      vb%r0%t(:,:)=0.
      vb%r1%t(:,:)=0.
      vb%r0%p(:,:)=0.
      vb%r1%p(:,:)=0.
!
      eta_prof=one/slund
      vis_prof=visc
!
end subroutine
!#######################################################################
subroutine init_alfven_wave2
!
!-----------------------------------------------------------------------
!
! ****** Initialize a test Alfven wave.
!
!-----------------------------------------------------------------------
!
! ****** This routine initializes an m=0 torsional Alfven wave
! ****** with perturbed v-phi and B-phi.
!
!-----------------------------------------------------------------------
!
! ****** The solution is given by:
!
!           A-theta = WAVE_AMPLITUDE*[sin(k*(r-R0))/r]*f(theta)
!                                   *cos(omega*t)
!
! ****** where f(theta) is an arbitrary function of theta
! ****** (subject to f(0) = f(pi) = 0), and k = omega/va.
!
! ****** Currently, f = P_sub_l_sup_1 is used.
!
! ****** The theta mode-number l is given by WAVE_MODE_T.
! ****** The radial mode-number is given by WAVE_MODE_R.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use dissipation_profiles
      use constants
      use mpidefs
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j
      real(r_typ) :: va,omega,sdt,fnr,fnt
!
!-----------------------------------------------------------------------
!
! ****** Associated Legendre function.
!
      real(r_typ), external :: legendre_pl1
!
!-----------------------------------------------------------------------
!
      a%r=0.
      a%t=0.
      a%p=0.
!
      v%r=0.
      v%t=0.
      v%p=0.
!
      g0=0.
!
      if (wave_mode_r.lt.1.or.wave_mode_t.lt.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INIT_ALFVEN_WAVE2:'
          write (*,*) '### Invalid wave mode requested:'
          write (*,*) 'WAVE_MODE_R = ',wave_mode_r
          write (*,*) 'WAVE_MODE_T = ',wave_mode_t
        end if
        call endrun (.true.)
      end if
!
      va=abs(br00)/sqrt(rho0)
!
      if (va.eq.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INIT_ALFVEN_WAVE2:'
          write (*,*) '### The Alfven speed is zero.'
        end if
        call endrun (.true.)
      end if
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INIT_ALFVEN_WAVE2:'
        write (9,*) '### Alfven wave (type 2) parameters:'
        write (9,*)
        write (9,*) 'WAVE_MODE_R = ',wave_mode_r
        write (9,*) 'WAVE_MODE_T = ',wave_mode_t
        write (9,*) 'BR00 = ',br00
        write (9,*) 'RHO0 = ',rho0
        write (9,*) 'VA = ',va
      end if
!
! ****** Set up a mass density profile that gives a uniform Alfven
! ****** speed for a split monopole magnetic field.
!
      do i=1,nr
        rho(i,:,:)=rho0*(r0*rh_i(i))**4
      enddo
!
! ****** Compute the analytic wave frequency.
!
      omega=wave_mode_r*pi*va/(r1-r0)
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INIT_ALFVEN_WAVE2: '
        write (9,*) '### Normal mode frequency:'
        write (9,*)
        write (9,*) 'OMEGA = ',omega
      end if
!
! ****** Initialize the fields.
! ****** Note that v is defined a half-timestep ahead
! ****** of A, B and J.
!
! ****** Note that dtime not set yet to use expected initial dt.
!
      if (dt_init.eq.0) then
        dt_init=dtmax
      end if
      sdt=sin(half*omega*dt_init)
!
      do j=1,ntm1
        fnt=legendre_pl1(wave_mode_t,t(j))
        do i=1,nr
          fnr=sin(omega*(rh(i)-r0)/va)*rh_i(i)
          a%t(i,j,:)=wave_amplitude*fnr*fnt
        enddo
      enddo
!
      do j=1,nt
        fnt=legendre_pl1(wave_mode_t,th(j))
        do i=1,nr
          fnr=sin(omega*(rh(i)-r0)/va)
          v%p(i,j,:)=-wave_amplitude*omega*rh(i) &
                     *fnr*fnt*sdt/(r0**2*br00)
        enddo
      enddo
!
      call seam_avec_cpu (a)
      call set_pole_bc_avec_cpu (a)
!
      ab%r0%t(:,:)=half*(a%t(1,:,:)+a%t(2,:,:))
      ab%r1%t(:,:)=half*(a%t(nr,:,:)+a%t(nrm1,:,:))
      ab%r0%p(:,:)=half*(a%p(1,:,:)+a%p(2,:,:))
      ab%r1%p(:,:)=half*(a%p(nr,:,:)+a%p(nrm1,:,:))
!
      call seam (v%r)
      call seam (v%t)
      call seam (v%p)
      call set_pole_bc_vvec_cpu (v)
!
      vb%r0%r(:,:)=0.
      vb%r1%r(:,:)=0.
      vb%r0%t(:,:)=0.
      vb%r1%t(:,:)=0.
      vb%r0%p(:,:)=0.
      vb%r1%p(:,:)=0.
!
      eta_prof=one/slund
      vis_prof=visc
!
end subroutine
!#######################################################################
subroutine init_alfven_wave2_rotated
!
!-----------------------------------------------------------------------
!
! ****** Initialize a test Alfven wave.
!
!-----------------------------------------------------------------------
!
! ****** This routine initializes an m=0 torsional Alfven wave
! ****** with perturbed v-phi and B-phi rotated in theta.
!
!-----------------------------------------------------------------------
!
! ****** The axisymmetric solution is given by:
!
!           A-theta = WAVE_AMPLITUDE*[sin(k*(r-R0))/r]*f(theta)
!                                   *cos(omega*t)
!
! ****** where f(theta) is an arbitrary function of theta
! ****** (subject to f(0) = f(pi) = 0), and k = omega/va.
!
! ****** Currently, f = P_sub_l_sup_1 is used.
!
! ****** The theta mode-number l is given by WAVE_MODE_T.
! ****** The radial mode-number is given by WAVE_MODE_R.
!
! ****** The solution is rotated in the theta direction
!        by WAVE_ROTATION_T radians.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use dissipation_profiles
      use constants
      use mpidefs
      use s2c_interface
      use c2s_interface
      use sv2cv_interface
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: va,omega,sdt,fnr,fnt
      real(r_typ) :: x_0,y_0,z_0,x_1,y_1,z_1
      real(r_typ) :: r_0,t_0,p_0,r_1,t_1,p_1
      real(r_typ) :: ax_0,ay_0,az_0,ax_1,ay_1,az_1
      real(r_typ) :: ar_0,at_0,ap_0,ar_1,at_1,ap_1
      real(r_typ) :: vx_0,vy_0,vz_0,vx_1,vy_1,vz_1
      real(r_typ) :: vr_0,vt_0,vp_0,vr_1,vt_1,vp_1
      real(r_typ) :: psi,phi,theta
      real(r_typ), dimension(3,3) :: rotm,rotp
      real(r_typ), dimension(3) :: X0,X1,A0,A1,V0,V1
!
!-----------------------------------------------------------------------
!
! ****** Associated Legendre function.
!
      real(r_typ), external :: legendre_pl1
!
!-----------------------------------------------------------------------
!
      a%r=0.
      a%t=0.
      a%p=0.
!
      v%r=0.
      v%t=0.
      v%p=0.
!
      g0=0.
!
      if (wave_mode_r.lt.1.or.wave_mode_t.lt.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INIT_ALFVEN_WAVE2_rotated:'
          write (*,*) '### Invalid wave mode requested:'
          write (*,*) 'WAVE_MODE_R = ',wave_mode_r
          write (*,*) 'WAVE_MODE_T = ',wave_mode_t
        end if
        call endrun (.true.)
      end if
!
      va=abs(br00)/sqrt(rho0)
!
      if (va.eq.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INIT_ALFVEN_WAVE2_rotated:'
          write (*,*) '### The Alfven speed is zero.'
        end if
        call endrun (.true.)
      end if
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INIT_ALFVEN_WAVE2_rotated:'
        write (9,*) '### Alfven wave (type 2) parameters:'
        write (9,*)
        write (9,*) 'WAVE_MODE_R = ',wave_mode_r
        write (9,*) 'WAVE_MODE_T = ',wave_mode_t
        write (9,*) 'WAVE_MODE_T = ',wave_rotation_t
        write (9,*) 'BR00 = ',br00
        write (9,*) 'RHO0 = ',rho0
        write (9,*) 'VA = ',va
      end if
!
! ****** Set up a mass density profile that gives a uniform Alfven
! ****** speed for a split monopole magnetic field.
!
      do i=1,nr
        rho(i,:,:)=rho0*(r0*rh_i(i))**4
      enddo
!
! ****** Compute the analytic wave frequency.
!
      omega=wave_mode_r*pi*va/(r1-r0)
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INIT_ALFVEN_WAVE2: '
        write (9,*) '### Normal mode frequency:'
        write (9,*)
        write (9,*) 'OMEGA = ',omega
      end if
!
! ****** Initialize the fields.
! ****** Note that v is defined a half-timestep ahead
! ****** of A, B and J.
!
      psi=0
      phi=0
      theta=wave_rotation_t
!
      rotm(1,1)=-sin(psi)*sin(phi  )+cos(theta)*cos(phi)*cos(psi)
      rotm(1,2)= sin(psi)*cos(phi  )+cos(theta)*sin(phi)*cos(psi)
      rotm(1,3)=-cos(psi)*sin(theta)
      rotm(2,1)=-cos(psi)*sin(phi  )-cos(theta)*cos(phi)*sin(psi)
      rotm(2,2)= cos(psi)*cos(phi  )-cos(theta)*sin(phi)*sin(psi)
      rotm(2,3)= sin(psi)*sin(theta)
      rotm(3,1)= sin(theta)*cos(phi)
      rotm(3,2)= sin(theta)*sin(phi)
      rotm(3,3)= cos(theta)
!
      rotp=transpose(rotm)
!
! ****** For each point do the following for each mesh:
!        1) Get theta and phi values (r1,t1,p1)
!        2) Convert coordinates into cart x1,y1,z1
!        3) Do inverse rotation along theta to
!           get origin cords x0,y0,z0
!        4) Convert x0,y0,z0 into spherical
!           coordinates r_0,t_0,p_0
!        5) Compute alfven wave initial condition A0 at r0,t0,p0.
!        6) Convert A0 into cart ax0,ay0,az0
!        7) Hit solutions with rotation matrix to get
!           ax1,ay1,az1
!        8) Convert ax1,ay1,az1 into spherical cords ar1,at1,ap1
!        9) Set components of A according to the solutions
!           on the correct meshes.
!
! ****** Initialize A.
!
!      THE At MESH:
       do k=1,np
         do j=1,ntm1
           do i=1,nr
!          1)
             r_1=rh(i)
             t_1=t(j)
             p_1=ph(k)
!          2)
             call s2c (r_1,t_1,p_1,x_1,y_1,z_1)
!          3)
             X1(1)=x_1
             X1(2)=y_1
             X1(3)=z_1
             X0=matmul(rotp,X1)
             x_0=X0(1)
             y_0=X0(2)
             z_0=X0(3)
!          4)
             call c2s (x_0,y_0,z_0,r_0,t_0,p_0)
!          5)
             ar_0=0.
             fnt=legendre_pl1(wave_mode_t,t_0)
             fnr=sin(omega*(r_0-r0)/va)/r_0
             at_0=wave_amplitude*fnr*fnt
             ap_0=0.
!          6)
             call sv2cv (ar_0,at_0,ap_0,t_0,p_0,ax_0,ay_0,az_0)
!          7)
             A0(1)=ax_0
             A0(2)=ay_0
             A0(3)=az_0
             A1=matmul(rotm,A0)
             ax_1=A1(1)
             ay_1=A1(2)
             az_1=A1(3)
!          8)
             call cv2sv (ax_1,ay_1,az_1,t_1,p_1,ar_1,at_1,ap_1)
!          9)
             a%t(i,j,k)=at_1
           enddo
         enddo
       enddo
!
!      THE Ap MESH:
!
       do k=1,npm1
         do j=1,nt
           do i=1,nr
!          1)
             r_1=rh(i)
             t_1=th(j)
             p_1=p(k)
!          2)
             call s2c (r_1,t_1,p_1,x_1,y_1,z_1)
!          3)
             X1(1)=x_1
             X1(2)=y_1
             X1(3)=z_1
             X0=matmul(rotp,X1)
             x_0=X0(1)
             y_0=X0(2)
             z_0=X0(3)
!          4)
             call c2s (x_0,y_0,z_0,r_0,t_0,p_0)
!          5)
             ar_0=0.
             fnt=legendre_pl1(wave_mode_t,t_0)
             fnr=sin(omega*(r_0-r0)/va)/r_0
             at_0=wave_amplitude*fnr*fnt
             ap_0=0.
!          6)
             call sv2cv (ar_0,at_0,ap_0,t_0,p_0,ax_0,ay_0,az_0)
!          7)
             A0(1)=ax_0
             A0(2)=ay_0
             A0(3)=az_0
             A1=matmul(rotm,A0)
             ax_1=A1(1)
             ay_1=A1(2)
             az_1=A1(3)
!          8)
             call cv2sv (ax_1,ay_1,az_1,t_1,p_1,ar_1,at_1,ap_1)
!          9)
             a%p(i,j,k)=ap_1
           enddo
         enddo
       enddo
!
      call seam_avec_cpu (a)
      call set_pole_bc_avec_cpu (a)
!
      ab%r0%t(:,:)=half*(a%t(1,:,:)+a%t(2,:,:))
      ab%r1%t(:,:)=half*(a%t(nr,:,:)+a%t(nrm1,:,:))
      ab%r0%p(:,:)=half*(a%p(1,:,:)+a%p(2,:,:))
      ab%r1%p(:,:)=half*(a%p(nr,:,:)+a%p(nrm1,:,:))
!
! ****** Initialize V.
!
! ****** Note that dtime not set yet to use expected initial dt.
!
      if (dt_init.eq.0) then
        dt_init=dtmax
      end if
      sdt=sin(half*omega*dt_init)
!
!      THE Vt MESH:
!
       do k=1,np
         do j=1,ntm1
           do i=1,nr
!          1)
             r_1=rh(i)
             t_1=t(j)
             p_1=ph(k)
!          2)
             call s2c (r_1,t_1,p_1,x_1,y_1,z_1)
!          3)
             X1(1)=x_1
             X1(2)=y_1
             X1(3)=z_1
             X0=matmul(rotp,X1)
             x_0=X0(1)
             y_0=X0(2)
             z_0=X0(3)
!          4)
             call c2s (x_0,y_0,z_0,r_0,t_0,p_0)
!          5)
             vr_0=0.
             vt_0=0.
             fnt=legendre_pl1(wave_mode_t,t_0)
             fnr=sin(omega*(r_0-r0)/va)
             vp_0=-wave_amplitude*omega*r_0 &
                   *fnr*fnt*sdt/(r0**2*br00)
!          6)
             call sv2cv (vr_0,vt_0,vp_0,t_0,p_0,vx_0,vy_0,vz_0)
!          7)
             V0(1)=vx_0
             V0(2)=vy_0
             V0(3)=vz_0
             V1=matmul(rotm,V0)
             vx_1=V1(1)
             vy_1=V1(2)
             vz_1=V1(3)
!          8)
             call cv2sv (vx_1,vy_1,vz_1,t_1,p_1,vr_1,vt_1,vp_1)
!          9)
             v%t(i,j,k)=vt_1
           enddo
         enddo
       enddo
!
!      THE Vp MESH:
!
       do k=1,npm1
         do j=1,nt
           do i=1,nr
!          1)
             r_1=rh(i)
             t_1=th(j)
             p_1=p(k)
!          2)
             call s2c (r_1,t_1,p_1,x_1,y_1,z_1)
!          3)
             X1(1)=x_1
             X1(2)=y_1
             X1(3)=z_1
             X0=matmul(rotp,X1)
             x_0=X0(1)
             y_0=X0(2)
             z_0=X0(3)
!          4)
             call c2s (x_0,y_0,z_0,r_0,t_0,p_0)
!          5)
             vr_0=0.
             vt_0=0.
             fnt=legendre_pl1(wave_mode_t,t_0)
             fnr=sin(omega*(r_0-r0)/va)
             vp_0=-wave_amplitude*omega*r_0 &
                   *fnr*fnt*sdt/(r0**2*br00)
!          6)
             call sv2cv (vr_0,vt_0,vp_0,t_0,p_0,vx_0,vy_0,vz_0)
!          7)
             V0(1)=vx_0
             V0(2)=vy_0
             V0(3)=vz_0
             V1=matmul(rotm,V0)
             vx_1=V1(1)
             vy_1=V1(2)
             vz_1=V1(3)
!          8)
             call cv2sv (vx_1,vy_1,vz_1,t_1,p_1,vr_1,vt_1,vp_1)
!          9)
             v%p(i,j,k)=vp_1
           enddo
         enddo
       enddo
!
      call seam (v%r)
      call seam (v%t)
      call seam (v%p)
      call set_pole_bc_vvec_cpu (v)
!
      vb%r0%r(:,:)=0.
      vb%r1%r(:,:)=0.
      vb%r0%t(:,:)=0.
      vb%r1%t(:,:)=0.
      vb%r0%p(:,:)=0.
      vb%r1%p(:,:)=0.
!
      eta_prof=one/slund
      vis_prof=visc
!
end subroutine
!#######################################################################
subroutine find_next_wave_root (omega0,domega,omega,omegamx,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Find the next root of the test Alfven wave dispersion
! ****** relation OMEGA which is greater than or equal to OMEGA0.
!
!-----------------------------------------------------------------------
!
! ****** Upon successful completion (IERR=0), the root is
! ****** returned in OMEGA.  OMEGA0 is reset to the frequency
! ****** at which the search for more roots can be resumed
! ****** by calling FIND_NEXT_WAVE_ROOT again.
!
! ****** OMEGAMX is the maximum omega for the root search.
!
! ****** ROOT_TAW is the function of omega which needs to be zeroed.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: omega0
      real(r_typ) :: domega
      real(r_typ) :: omega
      real(r_typ) :: omegamx
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: w0,w1,ffm,ffp
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: root_taw
      real(r_typ), external :: rfsolve
!
!-----------------------------------------------------------------------
!
! ****** March with increasing omega until a root is located.
!
      ierr=1
!
      omega=omega0
      ffm=root_taw(omega)
!
      do
!
        w0=omega
        omega=omega+domega
        if (omega.gt.omegamx) return
        w1=omega
        ffp=root_taw(omega)
!
        if (ffp*ffm.le.0.) then
!
! ****** Find the root.
!
          omega=rfsolve(w0,w1,root_taw,ierr)
          if (ierr.ne.0) return
          omega0=w1
          return
!
        end if
!
! ****** Continue searching.
!
        ffm=ffp
!
      enddo
!
end subroutine
!#######################################################################
function root_taw (omega)
!
!-----------------------------------------------------------------------
!
! ****** Dispersion relation for a spherical torsional Alfven wave
! ****** with m=0 and finite v-theta.
!
!-----------------------------------------------------------------------
!
      use number_types
      use alfven_wave_params
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: root_taw
      real(r_typ) :: omega
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: w0,w1
!
!-----------------------------------------------------------------------
!
! ****** Spherical Bessel functions.
!
      real(r_typ), external :: bessel_j,bessel_y
!
!-----------------------------------------------------------------------
!
      w0=omega*x0_taw
      w1=omega*x1_taw
!
      root_taw= bessel_j(l_taw,w0)*bessel_y(l_taw,w1) &
               -bessel_j(l_taw,w1)*bessel_y(l_taw,w0)
!
      return
end function
!#######################################################################
function rfsolve (x0,x1,f,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Solve the equation F(X) = 0. using regula falsi.
!
!-----------------------------------------------------------------------
!
! ****** The function F should be designed to be called
! ****** with one real argument, with a solution FUNC(X)=0.
!
! ****** X0 and X1 are the limits of the interval which
! ****** brackets a root.
!
! ****** The fractional error in X is required to be smaller
! ****** than EPS.
!
! ****** NMAX is the maximum number of iterations.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: rfsolve
      real(r_typ) :: x0
      real(r_typ) :: x1
      real(r_typ), external :: f
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Convergence parameters.
!
      integer, parameter :: nmax=100
      real(r_typ), parameter :: eps=1.e-9_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ) :: w0,w1,w2,w2old,f0,f1,f2,err
!
!-----------------------------------------------------------------------
!
      ierr=0
      rfsolve=0.
!
      w0=x0
      w1=x1
!
      w2old=w0
      f0=f(w0)
      f1=f(w1)
!
      n=0
!
      do
!
        n=n+1
!
        if (f0.eq.0.) then
          w2=w0
          f2=f0
          exit
        end if
!
        if (f1.eq.0.) then
          w2=w1
          f2=f1
          exit
        end if
!
        if (f0*f1.gt.0.) then
          ierr=1
          return
        end if
!
        w2=(f1*w0-f0*w1)/(f1-f0)
        f2=f(w2)
!
! ****** Check if converged.
!
        err=(w2-w2old)
        if (w2.ne.0.) err=err/w2
!
        if (abs(err).le.eps) exit
!
        if (n.gt.nmax) then
          ierr=1
          rfsolve=w2
          return
        end if
!
        w2old=w2
        if (f2*f0.lt.0.) then
          f1=f2
          w1=w2
        else
          f0=f2
          w0=w2
        end if
!
      enddo
!
! ****** Converged.
!
      rfsolve=w2
!
      return
end function
!#######################################################################
function bessel_j (l,x)
!
!-----------------------------------------------------------------------
!
! ****** Evaluate the spherical Bessel function of the first kind,
! ****** j_sub_l(x).
!
!-----------------------------------------------------------------------
!
! ****** The accuracy of this routine for small x is not
! ****** very good for 32-bit precision, but is adequate when using
! ****** 64-bit precision.
! ****** The small-argument expansion should really be used.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: bessel_j
      integer :: l
      real(r_typ) :: x
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: sx,cx,f0,f1,g0,g1,fl,gl,flm1,glm1,flp1,glp1
!
!-----------------------------------------------------------------------
!
      if (l.lt.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in BESSEL_J:'
          write (*,*) '### Invalid order specified:'
          write (*,*) '[Spherical Bessel function j_sub_l.]'
          write (*,*) 'L = ',l
        end if
        call endrun (.true.)
      end if
!
      if (x.eq.0.) then
        if (l.eq.0) then
          bessel_j=one
        else
          bessel_j=0.
        end if
        return
      end if
!
      sx=sin(x)
      cx=cos(x)
!
      f0=one/x
      f1=one/x**2
      g0=0.
      g1=one/x
!
! ****** Use a recurrence relationship for L.gt.1.
!
      if (l.eq.0) then
        bessel_j=f0*sx
      else if (l.eq.1) then
        bessel_j=f1*sx-g1*cx
      else
        flm1=f0
        fl=f1
        glm1=g0
        gl=g1
        do i=1,l-1
          flp1=(2*i+one)*fl/x-flm1
          glp1=(2*i+one)*gl/x-glm1
          flm1=fl
          fl=flp1
          glm1=gl
          gl=glp1
        enddo
        bessel_j=flp1*sx-glp1*cx
      end if
!
      return
end function
!#######################################################################
function bessel_y (l,x)
!
!-----------------------------------------------------------------------
!
! ****** Evaluate the spherical Bessel function of the second kind,
! ****** y_sub_l(x).
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: bessel_y
      integer :: l
      real(r_typ) :: x
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: sx,cx,f0,f1,g0,g1,fl,gl,flm1,glm1,flp1,glp1
!
!-----------------------------------------------------------------------
!
      if (l.lt.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in BESSEL_Y:'
          write (*,*) '### Invalid order specified:'
          write (*,*) '[Spherical Bessel function y_sub_l.]'
          write (*,*) 'L = ',l
        end if
        call endrun (.true.)
      end if
!
      if (x.eq.0.) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in BESSEL_Y:'
          write (*,*) '### Invalid argument specified:'
          write (*,*) '[Spherical Bessel function y_sub_l.]'
          write (*,*) 'X = ',x
        end if
        call endrun (.true.)
      end if
!
      sx=sin(x)
      cx=cos(x)
!
      f0=one/x
      f1=one/x**2
      g0=0.
      g1=one/x
!
! ****** Use a recurrence relationship for L.gt.1.
!
      if (l.eq.0) then
        bessel_y=-f0*cx
      else if (l.eq.1) then
        bessel_y=-g1*sx-f1*cx
      else
        flm1=f0
        fl=f1
        glm1=g0
        gl=g1
        do i=1,l-1
          flp1=(2*i+one)*fl/x-flm1
          glp1=(2*i+one)*gl/x-glm1
          flm1=fl
          fl=flp1
          glm1=gl
          gl=glp1
        enddo
        bessel_y=-glp1*sx-flp1*cx
      end if
!
      return
end function
!#######################################################################
function legendre_pl1 (l,theta)
!
!-----------------------------------------------------------------------
!
! ****** Evaluate the associated Legendre function
! ****** P_sub_l_sup_1(cos(theta)).
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: legendre_pl1
      integer :: l
      real(r_typ) :: theta
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: three=3._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: x,st,p11,p21,plm1,pl,plp1
!
!-----------------------------------------------------------------------
!
      if (l.lt.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in LEGENDRE_PL1:'
          write (*,*) '### Invalid degree specified:'
          write (*,*) '[Associated Legendre function (m=1).]'
          write (*,*) 'L = ',l
        end if
        call endrun (.true.)
      end if
!
! ****** Use a recurrence relation for L.ge.3.
!
      x=cos(theta)
      st=sin(theta)
!
      p11=st
      p21=three*x*st
!
      if (l.eq.1) then
        legendre_pl1=p11
      else if (l.eq.2) then
        legendre_pl1=p21
      else
        plm1=p11
        pl=p21
        do i=2,l-1
          plp1=((2*i+one)*x*pl-(i+one)*plm1)/float(i)
          plm1=pl
          pl=plp1
        enddo
        legendre_pl1=plp1
      end if
!
      return
end function
!#######################################################################
subroutine alloc_avec (a)
!
!-----------------------------------------------------------------------
!
! ****** Allocate the components of an AVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
!
!-----------------------------------------------------------------------
!
      allocate (a%r(nrm1,nt,np))
      allocate (a%t(nr,ntm1,np))
      allocate (a%p(nr,nt,npm1))
!
!$acc enter data create(a,a%r,a%t,a%p)
      call zero_avec (a)
!
end subroutine
!#######################################################################
subroutine dealloc_avec (a)
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the components of an AVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a%r,a%t,a%p,a)
      deallocate (a%r)
      deallocate (a%t)
      deallocate (a%p)
!
end subroutine
!#######################################################################
subroutine alloc_bvec (b)
!
!-----------------------------------------------------------------------
!
! ****** Allocate the components of a BVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      allocate (b%r(nr,ntm,npm))
      allocate (b%t(nrm,nt,npm))
      allocate (b%p(nrm,ntm,np))
!$acc enter data create(b,b%r,b%t,b%p)
!
      call zero_bvec (b)
!
end subroutine
!#######################################################################
subroutine dealloc_bvec (b)
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the components of a BVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(b%r,b%t,b%p,b)
      deallocate (b%r)
      deallocate (b%t)
      deallocate (b%p)
!
end subroutine
!#######################################################################
subroutine alloc_vvec (v)
!
!-----------------------------------------------------------------------
!
! ****** Allocate the components of a VVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
!
!-----------------------------------------------------------------------
!
      allocate (v%r(nrm,nt,np))
      allocate (v%t(nr,ntm,np))
      allocate (v%p(nr,nt,npm))
!$acc enter data create(v,v%r,v%t,v%p)
!
      call zero_vvec (v)
!
end subroutine
!#######################################################################
subroutine dealloc_vvec (v)
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the components of a VVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(v%r,v%t,v%p,v)
      deallocate (v%r)
      deallocate (v%t)
      deallocate (v%p)
!
end subroutine
!#######################################################################
subroutine alloc_hvec (h)
!
!-----------------------------------------------------------------------
!
! ****** Allocate the components of a HVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(hvec) :: h
!
!-----------------------------------------------------------------------
!
      allocate (h%r(nr,nt,np))
      allocate (h%t(nr,nt,np))
      allocate (h%p(nr,nt,np))
!
!$acc enter data create(h,h%r,h%t,h%p)
!
      call zero_hvec (h)
!
end subroutine
!#######################################################################
subroutine dealloc_hvec (h)
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the components of a VVEC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(hvec) :: h
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(h%r,h%t,h%p,h)
      deallocate (h%r)
      deallocate (h%t)
      deallocate (h%p)
!
end subroutine
!#######################################################################
subroutine alloc_avec_bc (a)
!
!-----------------------------------------------------------------------
!
! ****** Allocate the components of an AVEC_BC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec_bc) :: a
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      allocate (a%r0%t(ntm1,np))
      allocate (a%r1%t(ntm1,np))
      allocate (a%r0%p(nt,npm1))
      allocate (a%r1%p(nt,npm1))
!$acc enter data create(a,a%r0,a%r1,a%r0%t,a%r1%t,a%r0%p,a%r1%p)
!
      do concurrent (k=1:np, j=1:ntm1)
        a%r0%t(j,k)=0.
        a%r1%t(j,k)=0.
      enddo
!
      do concurrent (k=1:npm1, j=1:nt)
        a%r0%p(j,k)=0.
        a%r1%p(j,k)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine dealloc_avec_bc (a)
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the components of an AVEC_BC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec_bc) :: a
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a%r0%t,a%r1%t,a%r0%p,a%r1%p,a%r0,a%r1,a)
      deallocate (a%r0%t)
      deallocate (a%r1%t)
      deallocate (a%r0%p)
      deallocate (a%r1%p)
!
end subroutine
!#######################################################################
subroutine alloc_vvec_bc (v)
!
!-----------------------------------------------------------------------
!
! ****** Allocate the components of a VVEC_BC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use vars, ONLY : freeze_b
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec_bc) :: v
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      allocate (v%r0%r(nt,np))
      allocate (v%r1%r(nt,np))
      allocate (v%r0%t(ntm,np))
      allocate (v%r1%t(ntm,np))
      allocate (v%r0%p(nt,npm))
      allocate (v%r1%p(nt,npm))
!$acc enter data create(v,v%r0,v%r1, &
!$acc                   v%r0%r,v%r0%t,v%r0%p,v%r1%r,v%r1%t,v%r1%p)
      if (freeze_b) then
        allocate (v%r0%par(nt,np))
        allocate (v%r1%par(nt,np))
!$acc enter data create(v%r0%par,v%r1%par)
      end if
!
      do concurrent (k=1:np, j=1:nt)
        v%r0%r(j,k)=0.
        v%r1%r(j,k)=0.
      enddo
!
      do concurrent (k=1:np, j=1:ntm)
        v%r0%t(j,k)=0.
        v%r1%t(j,k)=0.
      enddo
!
      do concurrent (k=1:npm, j=1:nt)
        v%r0%p(j,k)=0.
        v%r1%p(j,k)=0.
      enddo
!
      if (freeze_b) then
        do concurrent (k=1:np, j=1:nt)
          v%r0%par(j,k)=0.
          v%r1%par(j,k)=0.
        enddo
!$acc update self(v%r0%par,v%r1%par)
      end if
!$acc update self(v%r0%r,v%r0%t,v%r0%p,v%r1%r,v%r1%t,v%r1%p)
!
end subroutine
!#######################################################################
subroutine dealloc_vvec_bc (v)
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the components of a VVEC_BC structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use vars, ONLY : freeze_b
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec_bc) :: v
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(v%r0%r,v%r0%t,v%r0%p,v%r1%r,v%r1%t,v%r1%p)
      deallocate (v%r0%r)
      deallocate (v%r1%r)
      deallocate (v%r0%t)
      deallocate (v%r1%t)
      deallocate (v%r0%p)
      deallocate (v%r1%p)
      if (freeze_b) then
!$acc exit data delete(v%r0%par,v%r1%par)
        deallocate (v%r0%par)
        deallocate (v%r1%par)
      end if
!$acc exit data delete(v%r0,v%r1,v)
!
end subroutine
!#######################################################################
subroutine check_error_on_p0 (ierr0)
!
!-----------------------------------------------------------------------
!
! ****** Check if the error flag IERR0 on processor 0 in
! ****** MPI_COMM_WORLD (i.e., processor IPROC0 in COMM_ALL)
! ****** indicates that the code should exit.
!
! ****** If IERR0 is non-zero, all the processors are directed
! ****** to call FINAL_DIAGS to terminate the code.
!
!-----------------------------------------------------------------------
!
      use mpidefs
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr0
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Broadcast IERR0 to all processors.
!
      call MPI_Bcast (ierr0,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
!
! ****** Call FINAL_DIAGS if IERR0 is non-zero.
!
      if (ierr0.ne.0) then
        ifabort=.true.
        call final_diags
      end if
!
end subroutine
!#######################################################################
subroutine check_error_on_any_proc (ierror)
!
!-----------------------------------------------------------------------
!
! ****** Check if the error flag IERROR on any processor is nonzero.
!
! ****** If IERROR is non-zero, all the processors are directed
! ****** to call FINAL_DIAGS to terminate the code.
!
! ****** IMPORTANT: This routine needs IERROR to be defined on every
! ****** processor to work.
!
!-----------------------------------------------------------------------
!
      use mpidefs
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierror
!
!-----------------------------------------------------------------------
!
      integer :: ierror_abs,ierror_sum,ierr
!
!-----------------------------------------------------------------------
!
! ****** Check if IERROR is nonzero on any processor.  This is done
! ****** by summing the absolute values of all the IERROR values
! ****** over all processors.
!
      ierror_abs=abs(ierror)
!
      call MPI_Allreduce (ierror_abs,ierror_sum,1,MPI_INTEGER, &
                          MPI_SUM,MPI_COMM_WORLD,ierr)
!
! ****** Call FINAL_DIAGS if IERROR_SUM is non-zero.
!
      if (ierror_sum.ne.0) then
        ifabort=.true.
        call final_diags
      end if
!
end subroutine
!#######################################################################
subroutine endrun (ifstop)
!
!-----------------------------------------------------------------------
!
! ****** End the run and exit the code.
!
!-----------------------------------------------------------------------
!
      use mpidefs
      use io_units
      use vars
      use diagnostics
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: ifstop
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Close the output files.
!
      if (iamp0) then
        close(IO_OUT)
        close(IO_WARN)
        close(IO_DUMP_3D)
        if (trace_particles) close(IO_DUMP_TRACERS)
        if (n_tpslice_radii.gt.0) close(IO_DUMP_SLICE)
        if (irsdump.gt.0.or.trsdump.gt.0) close(IO_DUMP_RS)
      end if
!
! ****** Exit MPI gracefully.
!
      call MPI_Finalize (ierr)
!
! ****** Call the STOP statement if requested.
!
      if (ifstop) then
        stop
      end if
!
end subroutine
!#######################################################################
subroutine init_mpi
!
!-----------------------------------------------------------------------
!
! ****** Initialize MPI.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
      use time_limit
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr,tcheck
!
!-----------------------------------------------------------------------
!
      call MPI_Init_thread (MPI_THREAD_FUNNELED,tcheck,ierr)
!
! ****** Get the total number of processors.
!
      call MPI_Comm_size (MPI_COMM_WORLD,nproc,ierr)
!
! ****** Get the index (rank) of the local processor in
! ****** communicator MPI_COMM_WORLD in variable IPROCW.
!
      call MPI_Comm_rank (MPI_COMM_WORLD,iprocw,ierr)
!
! ****** Create a shared communicator for all ranks in the node.
!
      call MPI_Comm_split_type (MPI_COMM_WORLD,MPI_COMM_TYPE_SHARED,0, &
                                MPI_INFO_NULL,comm_shared,ierr)
!
! ****** Get the total number of processors in node.
!
      call MPI_Comm_size (comm_shared,nprocsh,ierr)
!
! ****** Get the index (rank) of the local processor in the local node.
!
      call MPI_Comm_rank (comm_shared,iprocsh,ierr)
!
! ****** Set the flag to designate whether this processor
! ****** has rank 0 in communicator MPI_COMM_WORLD.
!
      if (iprocw.eq.0) then
        iamp0=.true.
      else
        iamp0=.false.
      end if
!
! ****** Set the number type for communicating REAL numbers in
! ****** MPI calls.
!
      if (r_typ.eq.KIND_REAL_4) then
        ntype_real=MPI_REAL4
      else if (r_typ.eq.KIND_REAL_8) then
        ntype_real=MPI_REAL8
      else
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INIT_MPI:'
          write (*,*) '### Could not find the MPI number type'// &
                      ' for REALs of kind R_TYP:'
          write (*,*) 'R_TYP = ',r_typ
          write (*,*) 'This is a fatal error.'
        end if
        call endrun (.true.)
      end if
!
! ****** Record the initial time given by MPI_WTIME.
! ****** This is used in implementing the wall-clock time limit
! ****** and to remove the possible offset in the time reported
! ****** by MPI_WTIME.
!
      time_at_start_of_program=MPI_Wtime()
!
! ****** Set the GPU device number based on local rank.
! ****** NOTE! This assumes than #GPUs per node = #MPI ranks per node.
!
!$acc set device_num(iprocsh)
!
end subroutine
!#######################################################################
subroutine check_proc_topology
!
!-----------------------------------------------------------------------
!
! ****** Check/set the requested processor topology.
!
!-----------------------------------------------------------------------
!
      use mpidefs
      use decomposition_params
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,nreq
!
!-----------------------------------------------------------------------
!
! ****** Check the processor topology.
!
      do i=1,3
        if (nprocs(i).lt.1.and.nprocs(i).ne.-1) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in CHECK_PROC_TOPOLOGY:'
            write (*,*) '### Processor topology specification error.'
            write (*,*) 'Invalid number of processors requested.'
            write (*,*) 'Dimension = ',i
            write (*,*) 'Number of processors requested = ', &
                        nprocs(i)
            write (*,*) 'Maximum number of processors allowed = ', &
                        mx_procs_per_dim
          end if
          call endrun (.true.)
        end if
      enddo
!
! ****** Set the optimal values of the topology for unset dimensions.
!
      call set_proc_topology
!
      do i=1,3
        if (nprocs(i).gt.mx_procs_per_dim) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in CHECK_PROC_TOPOLOGY:'
            write (*,*) '### Processor topology specification error.'
            write (*,*) 'Invalid number of processors requested.'
            write (*,*) 'Dimension = ',i
            write (*,*) 'Number of processors requested = ', &
                        nprocs(i)
            write (*,*) 'Maximum number of processors allowed = ', &
                        mx_procs_per_dim
          end if
          call endrun (.true.)
        end if
      enddo
!
! ****** Check that the number of processors available
! ****** matches the number requested.
!
      nreq=nprocs(1)*nprocs(2)*nprocs(3)
!
      if (nreq.ne.nproc) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in CHECK_PROC_TOPOLOGY:'
          write (*,*) '### Processor topology specification error.'
          write (*,*) 'The number of processors requested does not'// &
                      ' equal the number available.'
          write (*,*) 'Number of processors requested = ',nreq
          write (*,*) 'Number of processors available = ',nproc
        end if
        call endrun (.true.)
      end if
!
end subroutine
!#######################################################################
subroutine set_proc_topology
!
!-----------------------------------------------------------------------
!
! ****** Set the optimal values of the MPI rank topology
! ****** in dimensions not set by user.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use decomposition_params
      use globals
      use restart
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: bigval=HUGE(1.0_r_typ)
!
!-----------------------------------------------------------------------
!
      integer, dimension(:), allocatable :: factors
      integer, dimension(:,:), allocatable :: rank_factors
      real(r_typ), dimension(:,:), allocatable :: nperrank
      real(r_typ), dimension(:), allocatable :: penalty
!
      integer :: i,j,k,fr,ft,fp,num_fac,num_rank_fac,best_idx
      real(r_typ) :: a12,a13,a23
!
!-----------------------------------------------------------------------
!
      if (restart_run) then
        nr_g=nr_rs
        nt_g=nt_rs
        np_g=np_rs
      else
        nr_g=nr_auto
        nt_g=nt_auto
        np_g=np_auto
      end if
!
! ****** Extract nproc values.  A value of -1 indicates the dimension
! ****** should be autoset.
!
      nproc_r=nprocs(1)
      nproc_t=nprocs(2)
      nproc_p=nprocs(3)
!
! ****** If no dimensions are to be autoset, return.
!
      if(nproc_r.ne.-1.and.nproc_t.ne.-1.and.nproc_p.ne.-1) return
!
! ****** Get all factors of nproc and store them in factors array.
!
      i=1
      num_fac=0
      do while(i.le.nproc)
        if (MOD(nproc,i).eq.0) then
          num_fac=num_fac+1
        end if
        i=i+1
      enddo
      allocate (factors(num_fac))
      i=1
      num_fac=0
      do while(i.le.nproc)
        if (MOD(nproc,i).eq.0) then
          num_fac=num_fac+1
          factors(num_fac)=i
        end if
        i=i+1
      enddo
!
! ****** Set penalty function parameters and any fixed dimensions
! ****** based on which dimensions are to be autoset.
!
      a12=one
      a13=one
      a23=one
!
      if (nproc_r.ne.-1) then
        fr=nproc_r
        a12=zero
        a13=zero
      end if
      if (nproc_t.ne.-1) then
        ft=nproc_t
        a12=zero
        a23=zero
      end if
      if (nproc_p.ne.-1) then
        fp=nproc_p
        a13=zero
        a23=zero
      end if
!
! ****** Loop over all combinations of factors and save those that
! ****** yield the correct number of MPI ranks into rank_factors array.
!
      num_rank_fac=0
      do k=1,num_fac
        do j=1,num_fac
          do i=1,num_fac
            if(nproc_r.eq.-1) fr=factors(i)
            if(nproc_t.eq.-1) ft=factors(j)
            if(nproc_p.eq.-1) fp=factors(k)
            if (fr*ft*fp.eq.nproc) then
              num_rank_fac=num_rank_fac+1
            end if
          enddo
        enddo
      enddo
!
      if (num_rank_fac.eq.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in SET_PROC_TOPOLOGY:'
          write (*,*) '### Processor topology specification error.'
          write (*,*) 'No valid topologies found for selected options.'
          write (*,*) 'Number of MPI ranks = ',nproc
          write (*,*) 'NPROC_R = ',nproc_r
          write (*,*) 'NPROC_T = ',nproc_t
          write (*,*) 'NPROC_P = ',nproc_p
        end if
        call endrun (.true.)
      end if
!
      allocate(rank_factors(num_rank_fac,3))
      allocate(nperrank(num_rank_fac,3))
      allocate(penalty(num_rank_fac))
!
      rank_factors(:,:)=-1
      penalty(:)=bigval
!
      num_rank_fac=0
      do k=1,num_fac
        do j=1,num_fac
          do i=1,num_fac
            if(nproc_r.eq.-1) fr=factors(i)
            if(nproc_t.eq.-1) ft=factors(j)
            if(nproc_p.eq.-1) fp=factors(k)
            if (fr*ft*fp.eq.nproc) then
              num_rank_fac=num_rank_fac+1
              rank_factors(num_rank_fac,1)=fr
              rank_factors(num_rank_fac,2)=ft
              rank_factors(num_rank_fac,3)=fp
            end if
          enddo
        enddo
      enddo
!
! ****** Get number of grid points per rank for each dimension.
!
      nperrank(:,1)=real(nr_g)/rank_factors(:,1)
      nperrank(:,2)=real(nt_g)/rank_factors(:,2)
      nperrank(:,3)=real(np_g)/rank_factors(:,3)
!
! ****** Compute penalty function.
!
      penalty(:)=a12*(nperrank(:,1)-nperrank(:,2))**2 &
                +a23*(nperrank(:,2)-nperrank(:,3))**2 &
                +a13*(nperrank(:,3)-nperrank(:,1))**2
!
! ****** Eliminate any choices that yield less than a minimum number
! ****** of grid points per rank.
!
      do i=1,num_rank_fac
        if (nperrank(i,1).lt.4) penalty(i)=bigval
        if (nperrank(i,2).lt.4) penalty(i)=bigval
        if (nperrank(i,3).lt.3) penalty(i)=bigval
      enddo
!
! ****** Find optimal topology.
!
      best_idx=MINLOC(penalty,1)
!
      if (penalty(best_idx).eq.bigval) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in SET_PROC_TOPOLOGY:'
          write (*,*) '### Processor topology specification error.'
          write (*,*) 'No valid topologies found for selected options'
          write (*,*) 'with selected grid.  '
          write (*,*) 'It is likely you are using too many MPI ranks.'
          write (*,*) 'Number of MPI ranks = ',nproc
          write (*,*) 'NPROC_R = ',nproc_r
          write (*,*) 'NPROC_T = ',nproc_t
          write (*,*) 'NPROC_P = ',nproc_p
          write (*,*) 'NR = ',nr_g
          write (*,*) 'NT = ',nt_g
          write (*,*) 'NP = ',np_g
        end if
        call endrun (.true.)
      end if
!
! ****** Set optimal topology.
!
      nprocs(1)=rank_factors(best_idx,1)
      nprocs(2)=rank_factors(best_idx,2)
      nprocs(3)=rank_factors(best_idx,3)
!
      deallocate(factors)
      deallocate(rank_factors)
      deallocate(nperrank)
      deallocate(penalty)
!
end subroutine
!#######################################################################
subroutine check_mesh_topology
!
!-----------------------------------------------------------------------
!
! ****** Check the validity of the requested mesh topology.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use decomposition_params
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Check that the number of mesh points on each processor
! ****** is valid.
!
      do i=1,nprocs(1)
        if (mp_r(i).lt.1) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in CHECK_MESH_TOPOLOGY:'
            write (*,*) '### Mesh topology specification error.'
            write (*,*) 'Invalid number of r mesh points requested.'
            write (*,*) 'Processor index = ',i
            write (*,*) 'Number of mesh points requested = ', &
                        mp_r(i)
            write (*,*) 'Minimum number of mesh points allowed = ',1
          end if
          call endrun (.true.)
        end if
      enddo
!
      do i=1,nprocs(2)
        if (mp_t(i).lt.1) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in CHECK_MESH_TOPOLOGY:'
            write (*,*) '### Mesh topology specification error.'
            write (*,*) 'Invalid number of theta mesh points requested.'
            write (*,*) 'Processor index = ',i
            write (*,*) 'Number of mesh points requested = ', &
                        mp_t(i)
            write (*,*) 'Minimum number of mesh points allowed = ',1
          end if
          call endrun (.true.)
        end if
      enddo
!
      do i=1,nprocs(3)
        if (mp_p(i).lt.1) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in CHECK_MESH_TOPOLOGY:'
            write (*,*) '### Mesh topology specification error.'
            write (*,*) 'Invalid number of phi mesh points requested.'
            write (*,*) 'Processor index = ',i
            write (*,*) 'Number of mesh points requested = ', &
                        mp_p(i)
            write (*,*) 'Minimum number of mesh points allowed = ',1
          end if
          call endrun (.true.)
        end if
      enddo
!
end subroutine
!#######################################################################
subroutine decompose_domain
!
!-----------------------------------------------------------------------
!
! ****** Decompose the domain into a Cartesian MPI topology.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use decomposition_params
      use decomposition
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      integer, parameter :: ndim=3
      integer, dimension(ndim) :: coords
      logical, dimension(ndim) :: periodic
      logical :: reorder
      logical, dimension(ndim) :: keep_dim
!
!-----------------------------------------------------------------------
!
! ****** Create a communicator over all processors, COMM_ALL,
! ****** that has a Cartesian topology.
!
! ****** Specify the periodicity of the coordinate system.
!
      periodic(1)=.false.
      periodic(2)=.false.
      periodic(3)=.true.
!
! ****** Allow re-ordering in the Cartesian topology.
!
      reorder=.true.
!
      call MPI_Cart_create (MPI_COMM_WORLD,ndim,nprocs, &
                            periodic,reorder,comm_all,ierr)
!
! ****** Get the index (rank) of the local processor in
! ****** communicator COMM_ALL in variable IPROC.
!
! ****** IMPORTANT NOTE:
! ****** If re-odering was allowed in the Cartesian topology
! ****** creation (above), then the rank of the local processor
! ****** in communicator COMM_ALL may be different from its rank
! ****** in communicator MPI_COMM_WORLD.
!
      call MPI_Comm_rank (comm_all,iproc,ierr)
      write (iproc_str,'(I12)') iproc
!$acc enter data copyin(iproc_str)
!
! ****** Set the processor rank IPROC0 in communicator COMM_ALL
! ****** for the processor that has rank 0 in MPI_COMM_WORLD.
! ****** This value is broadcast to all the processors.
!
      if (iamp0) then
        iproc0=iproc
      end if
      call MPI_Bcast (iproc0,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
!
! ****** Get the coordinate indices of this processor in the
! ****** Cartesian MPI topology.
!
      call MPI_Cart_coords (comm_all,iproc,ndim,coords,ierr)
!
      iproc_r=coords(1)
      iproc_t=coords(2)
      iproc_p=coords(3)
!
      nproc_r=nprocs(1)
      nproc_t=nprocs(2)
      nproc_p=nprocs(3)
!
      nproc_tp=nproc_t*nproc_p
!
! ****** Get the rank of the neighboring processors in the
! ****** Cartesian MPI topology.
!
      call MPI_Cart_shift (comm_all,0,1,iproc_rm,iproc_rp,ierr)
      call MPI_Cart_shift (comm_all,1,1,iproc_tm,iproc_tp,ierr)
      call MPI_Cart_shift (comm_all,2,1,iproc_pm,iproc_pp,ierr)
!
! ****** Create communicators for operations involving all
! ****** processors in the phi dimension.  These communicators
! ****** are stored in COMM_PHI (and generally represent different
! ****** communicators on different processors).
!
      keep_dim(1)=.false.
      keep_dim(2)=.false.
      keep_dim(3)=.true.
!
      call MPI_Cart_sub (comm_all,keep_dim,comm_phi,ierr)
!
! ****** Create communicators for operations involving
! ****** all processors in the theta and phi dimensions.
! ****** These communicators are stored in COMM_TP
! ****** (and generally represent different communicators on
! ****** different processors).
! ****** These communicators are used for operations that
! ****** involve radial planes.
!
      keep_dim(1)=.false.
      keep_dim(2)=.true.
      keep_dim(3)=.true.
!
      call MPI_Cart_sub (comm_all,keep_dim,comm_tp,ierr)
!
! ****** Get rank in the theta-phi communicator.
! ****** This is used for 2D IO.
!
      call MPI_Comm_rank (comm_tp,iproc2d_tp,ierr)
!
! ****** Create communicators for operations involving
! ****** all processors in the r dimension.
! ****** These communicators are stored in COMM_R
! ****** (and generally represent different communicators on
! ****** different processors).
!
      keep_dim(1)=.true.
      keep_dim(2)=.false.
      keep_dim(3)=.false.
!
      call MPI_Cart_sub (comm_all,keep_dim,comm_r,ierr)
!
end subroutine
!#######################################################################
subroutine decompose_mesh
!
!-----------------------------------------------------------------------
!
! ****** Decompose the mesh between processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
      use restart
      use decomposition_params
      use decomposition
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k
!
      integer :: i0_h,i1_h,i0_m,i1_m
      integer :: j0_h,j1_h,j0_m,j1_m
      integer :: k0_h,k1_h,k0_m,k1_m
!
!-----------------------------------------------------------------------
!
! ****** Compute the mesh decomposition.
! ****** This can be done in one of two ways.
!
! ****** For an automatic decomposition, specify
! ****** AUTO_DECOMPOSE=.true., and, if this is not a restart,
! ****** specify the global dimensions NR, NT, and NP in the input
! ****** file; for a restart, the global dimensions are read
! ****** from the restart file.
!
! ****** For a manual decomposition, specify
! ****** AUTO_DECOMPOSE=.false., and set the arrays MP_R, MP_T,
! ****** and MP_P to the desired dimensions.
!
! ****** If a restart file is being used in conjunction with a manual
! ****** decomposition, the parameters specified must agree with the
! ****** restart file mesh dimensions.
!
      if (auto_decompose) then
!
        if (restart_run) then
          nr_g=nr_rs
          nt_g=nt_rs
          np_g=np_rs
        else
          nr_g=nr_auto
          nt_g=nt_auto
          np_g=np_auto
        end if
!
! ****** Check that the specified mesh dimensions are valid.
!
        call check_mesh_dimensions (nr_g,nt_g,np_g)
!
        call decompose_dimension (nr_g,nproc_r,mp_r,ierr)
        if (ierr.ne.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in DECOMPOSE_MESH:'
            write (*,*) '### Anomaly in decomposing the mesh'// &
                        ' between processors.'
            write (*,*) '### Could not decompose the r mesh.'
            write (*,*) 'Number of mesh points in r = ',nr_g
            write (*,*) 'Number of processors along r = ',nproc_r
          end if
          call endrun (.true.)
        end if
!
        call decompose_dimension (nt_g,nproc_t,mp_t,ierr)
        if (ierr.ne.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in DECOMPOSE_MESH:'
            write (*,*) '### Anomaly in decomposing the mesh'// &
                        ' between processors.'
            write (*,*) '### Could not decompose the theta mesh.'
            write (*,*) 'Number of mesh points in theta = ',nt_g
            write (*,*) 'Number of processors along theta = ',nproc_t
          end if
          call endrun (.true.)
        end if
!
        call decompose_dimension (np_g,nproc_p,mp_p,ierr)
        if (ierr.ne.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in DECOMPOSE_MESH:'
            write (*,*) '### Anomaly in decomposing the mesh'// &
                        ' between processors.'
            write (*,*) '### Could not decompose the phi mesh.'
            write (*,*) 'Number of mesh points in phi = ',np_g
            write (*,*) 'Number of processors along phi = ',nproc_p
          end if
          call endrun (.true.)
        end if
!
      else
!
! ****** Calculate the global mesh dimensions from MP_R, MP_T,
! ****** and MP_P.
!
        nr_g=mp_r(1)+2
        do i=2,nproc_r
          nr_g=nr_g+mp_r(i)
        enddo
!
        nt_g=mp_t(1)+2
        do j=2,nproc_t
          nt_g=nt_g+mp_t(j)
        enddo
!
        np_g=mp_p(1)+2
        do k=2,nproc_p
          np_g=np_g+mp_p(k)
        enddo
!
! ****** Check that the specified mesh dimensions are valid.
!
        call check_mesh_dimensions (nr_g,nt_g,np_g)
!
! ****** If this is a restart case, check that these dimensions
! ****** agree with the restart file dimensions.
!
        if (restart_run) then
          if (nr_g.ne.nr_rs.or.nt_g.ne.nt_rs.or.np_g.ne.np_rs) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in DECOMPOSE_MESH:'
              write (*,*) '### The restart file mesh in not'// &
                          ' consistent with the specified mesh.'
              write (*,*)
              write (*,*) 'Restart file mesh:'
              write (*,*) 'NR = ',nr_rs
              write (*,*) 'NT = ',nt_rs
              write (*,*) 'NP = ',np_rs
              write (*,*)
              write (*,*) 'Specified mesh:'
              write (*,*) 'NR = ',nr_g
              write (*,*) 'NT = ',nt_g
              write (*,*) 'NP = ',np_g
            end if
            call endrun (.true.)
          end if
        end if
!
      end if
!
      nrm1_g=nr_g-1
      nrm2_g=nr_g-2
      ntm1_g=nt_g-1
      ntm2_g=nt_g-2
      npm1_g=np_g-1
      npm2_g=np_g-2
!
! ****** Set the flag for an axisymmetric run (requested by
! ****** setting NP_G = 3).
!
      if (np_g.eq.3) then
        axisymmetric=.true.
      else
        axisymmetric=.false.
      end if
!
! ****** Compute the mapping between the processor decomposition
! ****** and the global mesh.
!
! ****** Note that there is a two-point overlap in the mesh
! ****** between adjacent processors in r, theta, and phi.
!
      i0_g=1
      do i=1,iproc_r
        i0_g=i0_g+mp_r(i)
      enddo
      nr=mp_r(iproc_r+1)+2
      i1_g=i0_g+nr-1
!
      j0_g=1
      do j=1,iproc_t
        j0_g=j0_g+mp_t(j)
      enddo
      nt=mp_t(iproc_t+1)+2
      j1_g=j0_g+nt-1
!
      k0_g=1
      do k=1,iproc_p
        k0_g=k0_g+mp_p(k)
      enddo
      np=mp_p(iproc_p+1)+2
      k1_g=k0_g+np-1
!
      nrm1=nr-1
      nrm2=nr-2
      ntm1=nt-1
      ntm2=nt-2
      npm1=np-1
      npm2=np-2
!
! ****** Set the flags to indicate whether this processor has
! ****** points on the physical boundaries.
!
      if (iproc_r.eq.0) then
        rb0=.true.
      else
        rb0=.false.
      end if
!
      if (iproc_r.eq.nproc_r-1) then
        rb1=.true.
      else
        rb1=.false.
      end if
!
      if (iproc_t.eq.0) then
        tb0=.true.
      else
        tb0=.false.
      end if
!
      if (iproc_t.eq.nproc_t-1) then
        tb1=.true.
      else
        tb1=.false.
      end if
!
! ****** Send the rank of the processor that contains the lower
! ****** radial boundary r=R0 (IPROC_RB0) to all processors in
! ****** communicator COMM_R.
! ****** (Use a global reduce operation for convenience.)
!
      if (rb0) then
        call MPI_Comm_rank (comm_r,i,ierr)
      else
        i=0
      end if
      call MPI_Allreduce (i,iproc_rb0,1,MPI_INTEGER, &
                          MPI_SUM,comm_r,ierr)
!
! ****** Set the dimensions of arrays for the "main" meshes
! ****** (i.e., the "m" mesh) for which normal derivatives are
! ****** needed (e.g., v).  These vary on different processors,
! ****** depending if they are left-boundary, internal, or
! ****** right-boundary processors.
!
      if (rb1) then
        nrm=nrm1
      else
        nrm=nr
      end if
!
      if (tb1) then
        ntm=ntm1
      else
        ntm=nt
      end if
!
! ****** Since the phi dimension is periodic, all processors
! ****** have the same mesh limits.
!
      npm=np
!
! ****** Set the limits for internal points in theta.
! ****** This excludes the poles on processors that contain
! ****** the theta boundaries.
!
      if (tb0) then
        jm0=2
      else
        jm0=1
      end if
!
      if (tb1) then
        jm1=ntm2
      else
        jm1=ntm1
      end if
!
      if (tb0) then
        jh0=2
      else
        jh0=1
      end if
!
      if (tb1) then
        jh1=ntm1
      else
        jh1=nt
      end if
!
! ****** Store the decomposition parameters (for this processor).
!
      allocate (decomp(0:nproc-1))
!
      decomp(iproc)%iproc_r=iproc_r
      decomp(iproc)%iproc_t=iproc_t
      decomp(iproc)%iproc_p=iproc_p
      decomp(iproc)%nr=nr
      decomp(iproc)%nt=nt
      decomp(iproc)%np=np
      decomp(iproc)%i0_g=i0_g
      decomp(iproc)%i1_g=i1_g
      decomp(iproc)%j0_g=j0_g
      decomp(iproc)%j1_g=j1_g
      decomp(iproc)%k0_g=k0_g
      decomp(iproc)%k1_g=k1_g
      decomp(iproc)%iproc_rm=iproc_rm
      decomp(iproc)%iproc_rp=iproc_rp
      decomp(iproc)%iproc_tm=iproc_tm
      decomp(iproc)%iproc_tp=iproc_tp
      decomp(iproc)%iproc_pm=iproc_pm
      decomp(iproc)%iproc_pp=iproc_pp
!
! ****** Gather the global decomposition information by
! ****** communicating among all processors.
!
      call gather_decomp_info
!
! ****** Store the mapping structure (for this processor).
!
      allocate (map_rh(0:nproc-1))
      allocate (map_rm(0:nproc-1))
      allocate (map_th(0:nproc-1))
      allocate (map_tm(0:nproc-1))
      allocate (map_ph(0:nproc-1))
      allocate (map_pm(0:nproc-1))
!
      allocate (maptp_th(0:nproc_tp-1))
      allocate (maptp_tm(0:nproc_tp-1))
      allocate (maptp_ph(0:nproc_tp-1))
      allocate (maptp_pm(0:nproc_tp-1))
!
      if (rb0) then
        i0_h=1
      else
        i0_h=2
      end if
      if (rb1) then
        i1_h=nr
      else
        i1_h=nrm1
      end if
!
      if (rb0) then
        i0_m=1
      else
        i0_m=2
      end if
      i1_m=nrm1
!
      if (tb0) then
        j0_h=1
      else
        j0_h=2
      end if
      if (tb1) then
        j1_h=nt
      else
        j1_h=ntm1
      end if
!
      if (tb0) then
        j0_m=1
      else
        j0_m=2
      end if
      j1_m=ntm1
!
      if (iproc_p.eq.0) then
        k0_m=1
      else
        k0_m=2
      end if
      k1_m=npm1
!
      if (iproc_p.eq.0) then
        k0_h=1
      else
        k0_h=2
      end if
      if (iproc_p.eq.nproc_p-1) then
        k1_h=np
      else
        k1_h=npm1
      end if
!
      map_rh(iproc)%i0=i0_h
      map_rh(iproc)%i1=i1_h
!
      map_rm(iproc)%i0=i0_m
      map_rm(iproc)%i1=i1_m
!
      map_th(iproc)%i0=j0_h
      map_th(iproc)%i1=j1_h
!
      map_tm(iproc)%i0=j0_m
      map_tm(iproc)%i1=j1_m
!
      map_ph(iproc)%i0=k0_h
      map_ph(iproc)%i1=k1_h
!
      map_pm(iproc)%i0=k0_m
      map_pm(iproc)%i1=k1_m
!
      map_rh(iproc)%offset=i0_g+map_rh(iproc)%i0-1
      map_rh(iproc)%n=map_rh(iproc)%i1-map_rh(iproc)%i0+1
!
      map_rm(iproc)%offset=i0_g+map_rm(iproc)%i0-1
      map_rm(iproc)%n=map_rm(iproc)%i1-map_rm(iproc)%i0+1
!
      map_th(iproc)%offset=j0_g+map_th(iproc)%i0-1
      map_th(iproc)%n=map_th(iproc)%i1-map_th(iproc)%i0+1
!
      map_tm(iproc)%offset=j0_g+map_tm(iproc)%i0-1
      map_tm(iproc)%n=map_tm(iproc)%i1-map_tm(iproc)%i0+1
!
      map_ph(iproc)%offset=k0_g+map_ph(iproc)%i0-1
      map_ph(iproc)%n=map_ph(iproc)%i1-map_ph(iproc)%i0+1
!
      map_pm(iproc)%offset=k0_g+map_pm(iproc)%i0-1
      map_pm(iproc)%n=map_pm(iproc)%i1-map_pm(iproc)%i0+1
!
! ****** Set the iproc2d_tp map values to the iproc values.
!
      maptp_th(iproc2d_tp)%i0=map_th(iproc)%i0
      maptp_th(iproc2d_tp)%i1=map_th(iproc)%i1
!
      maptp_tm(iproc2d_tp)%i0=map_tm(iproc)%i0
      maptp_tm(iproc2d_tp)%i1=map_tm(iproc)%i1
!
      maptp_ph(iproc2d_tp)%i0=map_ph(iproc)%i0
      maptp_ph(iproc2d_tp)%i1=map_ph(iproc)%i1
!
      maptp_pm(iproc2d_tp)%i0=map_pm(iproc)%i0
      maptp_pm(iproc2d_tp)%i1=map_pm(iproc)%i1
!
      maptp_th(iproc2d_tp)%offset=map_th(iproc)%offset
      maptp_th(iproc2d_tp)%n=map_th(iproc)%n
!
      maptp_tm(iproc2d_tp)%offset=map_tm(iproc)%offset
      maptp_tm(iproc2d_tp)%n=map_tm(iproc)%n
!
      maptp_ph(iproc2d_tp)%offset=map_ph(iproc)%offset
      maptp_ph(iproc2d_tp)%n=map_ph(iproc)%n
!
      maptp_pm(iproc2d_tp)%offset=map_pm(iproc)%offset
      maptp_pm(iproc2d_tp)%n=map_pm(iproc)%n
!
! ****** Gather the mapping information by communicating among
! ****** all processors.
!
      call gather_mapping_info (map_rh)
      call gather_mapping_info (map_rm)
      call gather_mapping_info (map_th)
      call gather_mapping_info (map_tm)
      call gather_mapping_info (map_ph)
      call gather_mapping_info (map_pm)
!
      call gather_mapping_info_tp (maptp_th)
      call gather_mapping_info_tp (maptp_tm)
      call gather_mapping_info_tp (maptp_ph)
      call gather_mapping_info_tp (maptp_pm)
!
!$acc enter data copyin(map_rh,map_rm,map_th,map_tm,map_ph,map_pm, &
!$acc                   maptp_th,maptp_tm,maptp_ph,maptp_pm)
end subroutine
!#######################################################################
subroutine check_mesh_dimensions (nr_g,nt_g,np_g)
!
!-----------------------------------------------------------------------
!
! ****** Check that the requested (global) mesh dimensions are
! ****** valid.
!
!-----------------------------------------------------------------------
!
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: nr_g,nt_g,np_g
!
!-----------------------------------------------------------------------
!
      if (nr_g.lt.4) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in CHECK_MESH_DIMENSIONS:'
          write (*,*) '### Invalid number of r mesh points'// &
                    ' requested.'
          write (*,*) '### The minimum number of mesh points is 4.'
          write (*,*)
          write (*,*) 'Number of mesh points requested = ',nr_g
        end if
        call endrun (.true.)
      end if
!
      if (nt_g.lt.4) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in CHECK_MESH_DIMENSIONS:'
          write (*,*) '### Invalid number of theta mesh points'// &
                    ' requested.'
          write (*,*) '### The minimum number of mesh points is 4.'
          write (*,*)
          write (*,*) 'Number of mesh points requested = ',nt_g
        end if
        call endrun (.true.)
      end if
!
      if (np_g.lt.3) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in CHECK_MESH_DIMENSIONS:'
          write (*,*) '### Invalid number of phi mesh points'// &
                    ' requested.'
          write (*,*) '### The minimum number of mesh points is 3.'
          write (*,*)
          write (*,*) 'Number of mesh points requested = ',np_g
        end if
        call endrun (.true.)
      end if
!
end subroutine
!#######################################################################
subroutine decompose_dimension (nx,np,mp,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Decompose the mesh points NX along NP processors.
!
! ****** The decomposed mesh points are returned in array MP.
!
!-----------------------------------------------------------------------
!
! ****** This routine attempts to assign the mesh points as equally
! ****** as possible between the processors.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: nx
      integer :: np
      integer, dimension(np) :: mp
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      integer :: nxm2,mpav,nrem
!
!-----------------------------------------------------------------------
!
      ierr=0
!
      nxm2=nx-2
!
      if (nxm2.le.0) then
        ierr=1
        return
      end if
!
      if (np.le.0) then
        ierr=2
        return
      end if
!
      mpav=nxm2/np
!
      mp(:)=mpav
!
      nrem=nxm2-mpav*np
!
      mp(1:nrem)=mp(1:nrem)+1
!
end subroutine
!#######################################################################
subroutine gather_decomp_info
!
!-----------------------------------------------------------------------
!
! ****** Gather the global decomposition information array by
! ****** communicating among all processors.
!
!-----------------------------------------------------------------------
!
! ****** This routine is coded in the lame way that it is to avoid
! ****** communicating F90 structures directly using MPI.  One day
! ****** it may be easier to do this directly!
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use decomposition
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Buffers for packing the data.
!
      integer, parameter :: lbuf=18
      integer, dimension(lbuf) :: sbuf
      integer, dimension(lbuf,0:nproc-1) :: rbuf
!
!-----------------------------------------------------------------------
!
      integer :: irank
!
!-----------------------------------------------------------------------
!
! ****** Put the local section of the decomposition information
! ****** array into a buffer.
!
      sbuf( 1)=decomp(iproc)%iproc_r
      sbuf( 2)=decomp(iproc)%iproc_t
      sbuf( 3)=decomp(iproc)%iproc_p
      sbuf( 4)=decomp(iproc)%nr
      sbuf( 5)=decomp(iproc)%nt
      sbuf( 6)=decomp(iproc)%np
      sbuf( 7)=decomp(iproc)%i0_g
      sbuf( 8)=decomp(iproc)%i1_g
      sbuf( 9)=decomp(iproc)%j0_g
      sbuf(10)=decomp(iproc)%j1_g
      sbuf(11)=decomp(iproc)%k0_g
      sbuf(12)=decomp(iproc)%k1_g
      sbuf(13)=decomp(iproc)%iproc_rm
      sbuf(14)=decomp(iproc)%iproc_rp
      sbuf(15)=decomp(iproc)%iproc_tm
      sbuf(16)=decomp(iproc)%iproc_tp
      sbuf(17)=decomp(iproc)%iproc_pm
      sbuf(18)=decomp(iproc)%iproc_pp
!
! ****** Communicate among all processors.  After this call, all
! ****** processors have the complete decomposition information.
!
      call MPI_Allgather (sbuf,lbuf,MPI_INTEGER, &
                          rbuf,lbuf,MPI_INTEGER,comm_all,ierr)
!
! ****** Extract the decomposition information from the buffer.
!
      do irank=0,nproc-1
        decomp(irank)%iproc_r =rbuf( 1,irank)
        decomp(irank)%iproc_t =rbuf( 2,irank)
        decomp(irank)%iproc_p =rbuf( 3,irank)
        decomp(irank)%nr      =rbuf( 4,irank)
        decomp(irank)%nt      =rbuf( 5,irank)
        decomp(irank)%np      =rbuf( 6,irank)
        decomp(irank)%i0_g    =rbuf( 7,irank)
        decomp(irank)%i1_g    =rbuf( 8,irank)
        decomp(irank)%j0_g    =rbuf( 9,irank)
        decomp(irank)%j1_g    =rbuf(10,irank)
        decomp(irank)%k0_g    =rbuf(11,irank)
        decomp(irank)%k1_g    =rbuf(12,irank)
        decomp(irank)%iproc_rm=rbuf(13,irank)
        decomp(irank)%iproc_rp=rbuf(14,irank)
        decomp(irank)%iproc_tm=rbuf(15,irank)
        decomp(irank)%iproc_tp=rbuf(16,irank)
        decomp(irank)%iproc_pm=rbuf(17,irank)
        decomp(irank)%iproc_pp=rbuf(18,irank)
      enddo
!
end subroutine
!#######################################################################
subroutine gather_mapping_info (map)
!
!-----------------------------------------------------------------------
!
! ****** Gather the mapping information array by communicating
! ****** among all processors.
!
!-----------------------------------------------------------------------
!
! ****** This routine is coded in the lame way that it is to avoid
! ****** communicating F90 structures directly using MPI.  One day
! ****** it may be easier to do this directly!
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use decomposition
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(map_struct), dimension(0:nproc-1) :: map
!
!-----------------------------------------------------------------------
!
! ****** Buffers for packing the data.
!
      integer, parameter :: lbuf=4
      integer, dimension(lbuf) :: sbuf
      integer, dimension(lbuf,0:nproc-1) :: rbuf
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: irank
!
!-----------------------------------------------------------------------
!
! ****** Put the local section of the mapping information
! ****** array into a buffer.
!
      sbuf(1)=map(iproc)%n
      sbuf(2)=map(iproc)%i0
      sbuf(3)=map(iproc)%i1
      sbuf(4)=map(iproc)%offset
!
! ****** Communicate among all processors.  After this call, all
! ****** processors have the complete mapping information.
!
      call MPI_Allgather (sbuf,lbuf,MPI_INTEGER, &
                          rbuf,lbuf,MPI_INTEGER,comm_all,ierr)
!
! ****** Extract the mapping information from the buffer.
!
      do irank=0,nproc-1
        map(irank)%n     =rbuf(1,irank)
        map(irank)%i0    =rbuf(2,irank)
        map(irank)%i1    =rbuf(3,irank)
        map(irank)%offset=rbuf(4,irank)
      enddo
!
end subroutine
!#######################################################################
subroutine gather_mapping_info_tp (map)
!
!-----------------------------------------------------------------------
!
! ****** Gather the mapping information array by communicating
! ****** among all processors.
!
!-----------------------------------------------------------------------
!
! ****** This routine is coded in the lame way that it is to avoid
! ****** communicating F90 structures directly using MPI.  One day
! ****** it may be easier to do this directly!
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use decomposition
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(map_struct), dimension(0:nproc_tp-1) :: map
!
!-----------------------------------------------------------------------
!
! ****** Buffers for packing the data.
!
      integer, parameter :: lbuf=4
      integer, dimension(lbuf) :: sbuf
      integer, dimension(lbuf,0:nproc_tp-1) :: rbuf
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: irank
!
!-----------------------------------------------------------------------
!
! ****** Put the local section of the mapping information
! ****** array into a buffer.
!
      sbuf(1)=map(iproc2d_tp)%n
      sbuf(2)=map(iproc2d_tp)%i0
      sbuf(3)=map(iproc2d_tp)%i1
      sbuf(4)=map(iproc2d_tp)%offset
!
! ****** Communicate among all tp processors.  After this call, all
! ****** processors have the complete mapping information.
!
      call MPI_Allgather (sbuf,lbuf,MPI_INTEGER, &
                          rbuf,lbuf,MPI_INTEGER,comm_tp,ierr)
!
! ****** Extract the mapping information from the buffer.
!
      do irank=0,nproc_tp-1
        map(irank)%n     =rbuf(1,irank)
        map(irank)%i0    =rbuf(2,irank)
        map(irank)%i1    =rbuf(3,irank)
        map(irank)%offset=rbuf(4,irank)
      enddo
!
end subroutine
!#######################################################################
subroutine decomp_diags
!
!-----------------------------------------------------------------------
!
! ****** Print diagnostics about the mesh decomposition.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use mpidefs
      use debug
      use decomposition
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: irank
      real(r_typ) :: n_per_grid_min,n_per_grid_max
!
!-----------------------------------------------------------------------
!
      if (iamp0) then
        n_per_grid_min=floor(real(nr_g)/nproc_r) &
                      *floor(real(nt_g)/nproc_t) &
                      *floor(real(np_g)/nproc_p)
!
        n_per_grid_max=(ceiling(real(nr_g)/nproc_r)) &
                      *(ceiling(real(nt_g)/nproc_t)) &
                      *(ceiling(real(np_g)/nproc_p))
        write (*,*)
        write (*,'(A,I6)') 'Total number of ranks = ',nproc
        write (*,*)
        write (*,'(A,I7)') 'Number of ranks in r = ',nproc_r
        write (*,'(A,I7)') 'Number of ranks in t = ',nproc_t
        write (*,'(A,I7)') 'Number of ranks in p = ',nproc_p
        write (*,*)
        write (*,'(A,I6)') 'Global mesh dimension in r = ',nr_g
        write (*,'(A,I6)') 'Global mesh dimension in t = ',nt_g
        write (*,'(A,I6)') 'Global mesh dimension in p = ',np_g
        write (*,*)
        write (*,'(A,F6.1)') 'Average # of mesh pts per rank in r = ', &
                     real(nr_g)/nproc_r
        write (*,'(A,F6.1)') 'Average # of mesh pts per rank in t = ', &
                     real(nt_g)/nproc_t
        write (*,'(A,F6.1)') 'Average # of mesh pts per rank in p = ', &
                     real(np_g)/nproc_p
        write (*,*)
        write (*,'(A,F6.2,A)') 'Estimated load imbalance = ', &
            100.0*(1.0-real(n_per_grid_min)/real(n_per_grid_max)),' %'
      end if
!
      if (idebug.eq.0) return
!
      do irank=0,nproc-1
        call MPI_BARRIER (comm_all,ierr)
        if (irank.eq.iproc) then
          write (*,*)
          write (*,100)
          write (*,*)
          write (*,*) 'Processor id = ',iproc
          write (*,*) 'nr = ',nr
          write (*,*) 'nt = ',nt
          write (*,*) 'np = ',np
          write (*,*) 'i0_g = ',i0_g
          write (*,*) 'i1_g = ',i1_g
          write (*,*) 'j0_g = ',j0_g
          write (*,*) 'j1_g = ',j1_g
          write (*,*) 'k0_g = ',k0_g
          write (*,*) 'k1_g = ',k1_g
          write (*,*) 'Processor index in r    = ',iproc_r
          write (*,*) 'Processor index in t    = ',iproc_t
          write (*,*) 'Processor index in p    = ',iproc_p
          write (*,*) 'Processor to left  in r = ',iproc_rm
          write (*,*) 'Processor to right in r = ',iproc_rp
          write (*,*) 'Processor to left  in t = ',iproc_tm
          write (*,*) 'Processor to right in t = ',iproc_tp
          write (*,*) 'Processor to left  in p = ',iproc_pm
          write (*,*) 'Processor to right in p = ',iproc_pp
          write (*,*)
          write (*,*) 'Processor rank in MPI_COMM_WORLD = ',iprocw
          write (*,*) 'Processor rank in COMM_ALL       = ',iproc
          if (idebug.gt.1) then
            write (*,*)
            write (*,*) 'r mesh:'
            write (*,*) r
            write (*,*)
            write (*,*) 'theta mesh:'
            write (*,*) t
            write (*,*) 'phi mesh:'
            write (*,*) p(1:npm1)
          end if
          if (irank.eq.nproc-1) then
            write (*,*)
            write (*,100)
          end if
  100     format (80('-'))
        end if
      enddo
!
end subroutine
!#######################################################################
subroutine allocate_arrays
!
!-----------------------------------------------------------------------
!
! ****** Allocate arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use fields
      use characteristics
      use coef_storage
      use upwind_resistivity
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Allocate local mesh arrays.
!
      allocate (r (nrm))
      allocate (dr(nrm))
!
      allocate (rh (nr))
      allocate (drh(nr))
!
      allocate (t (ntm))
      allocate (dt(ntm))
!
      allocate (th (nt))
      allocate (dth(nt))
!
      allocate (p (np))  !!! npm???
      allocate (dp(np))  !!! npm???
!
      allocate (ph (np))
      allocate (dph(np))
!
      allocate (st(ntm))
      allocate (ct(ntm))
!
      allocate (sth(nt))
      allocate (cth(nt))
!
      allocate (sp(np))  !!! npm???
      allocate (cp(np))  !!! npm???
      allocate (sph(np))
      allocate (cph(np))
!
! ****** Allocate global mesh arrays.
!
      allocate (r_g (nrm1_g))
      allocate (dr_g(nrm1_g))
!
      allocate (rh_g (nr_g))
      allocate (drh_g(nr_g))
!
      allocate (t_g (ntm1_g))
      allocate (dt_g(ntm1_g))
!
      allocate (th_g (nt_g))
      allocate (dth_g(nt_g))
!
      allocate (p_g (np_g))
      allocate (dp_g(np_g))
!
      allocate (ph_g (np_g))
      allocate (dph_g(np_g))
!
      allocate (st_g(ntm1_g))
      allocate (ct_g(ntm1_g))
!
      allocate (sth_g(nt_g))
      allocate (cth_g(nt_g))
!
      allocate (sp_g(np_g))
      allocate (cp_g(np_g))
!
      allocate (sph_g(np_g))
      allocate (cph_g(np_g))
!
! ****** Allocate inverse quantities.  These are used for efficiency.
!
      allocate (dr_i(nrm))
      allocate (drh_i(nr))
!
      allocate (r_i (nrm))
      allocate (rh_i(nr))
!
      allocate (dt_i(ntm))
      allocate (st_i(ntm))
!
      allocate (dth_i(nt))
      allocate (sth_i(nt))
!
      allocate (dp_i (np))  !!! npm???
      allocate (dph_i(np))
!
! ****** Allocate area factors and  inverse quantities.
!
      allocate (fl_fac(nrm))
      allocate (fl_fach(nr))
      allocate (fl_fac_i(nrm))
      allocate (fl_fach_i(nr))
      allocate (fl_one(nrm))
      allocate (fl_oneh(nr))
!
! ****** True radial distances (equal to r and rh, except for field lines)
!
      allocate (r_true (nrm))
      allocate (rh_true (nr))
      allocate (r_true_i (nrm))
      allocate (rh_true_i (nr))
!
! ****** Allocate the primary fields.
!
      call alloc_avec (a)
      call alloc_bvec (b)
      call alloc_avec (fj)
      call alloc_vvec (v)
      call alloc_avec (e)
!$acc update self(a%r,a%t,a%p,b%r,b%t,b%p,fj%r,fj%t,fj%p)
!$acc update self(v%r,v%t,v%p,e%r,e%t,e%p)
      if (freeze_b) then
        allocate (v_par(nr,nt,np)); v_par(:,:,:)=0.
        allocate (v_par_old(nr,nt,np)); v_par_old(:,:,:)=0.
!$acc enter data copyin(v_par,v_par_old)
      end if
!
      allocate (    pres(nr,nt,np)); pres(:,:,:)=0.
      allocate (    rho (nr,nt,np)); rho(:,:,:)=0.
      allocate (    temp(nr,nt,np)); temp(:,:,:)=0.
      allocate (  temp_e(nr,nt,np)); temp_e(:,:,:)=0.
      allocate ( temp_e0(nr,nt,np)); temp_e0(:,:,:)=0.
      allocate (    heat(nr,nt,np)); heat(:,:,:)=0.
      allocate (      ep(nr,nt,np)); ep(:,:,:)=0.
      allocate (      em(nr,nt,np)); em(:,:,:)=0.
      allocate (      zp(nr,nt,np)); zp(:,:,:)=0.
      allocate (      zm(nr,nt,np)); zm(:,:,:)=0.
!$acc enter data copyin(pres,rho,temp,temp_e,temp_e0,heat, &
!$acc                   ep,em,zp,zm)
!
      if (advance_tp) then
        allocate ( temp_p(nr,nt,np)); temp_p(:,:,:)=0.
        allocate (temp_p0(nr,nt,np)); temp_p0(:,:,:)=0.
!$acc enter data copyin(temp_p,temp_p0)
      end if
!
      if (advance_fcs) then
        allocate (  rhoold(nr,nt,np)); rhoold(:,:,:)=0.
!$acc enter data copyin(rhoold)
      end if
!
      if (alpha_nocoll.ne.0..or.alpha_nocoll_p.ne.0.) then
        allocate(prof_nocoll(nr)); prof_nocoll(:)=0.
!$acc enter data copyin(prof_nocoll)
      end if
!
      if (advance_tc) then
        allocate (prof_coll(nr)); prof_coll(:)=0.
!$acc enter data copyin(prof_coll)
      end if
      allocate (dqdt(nr,nt,np)); dqdt(:,:,:)=0.
!$acc enter data copyin(dqdt)
!
      allocate (tr0v(nt,np)); tr0v(:,:)=0.
      allocate (tr1v(nt,np)); tr1v(:,:)=0.
      allocate (tr1v_p(nt,np)); tr1v_p(:,:)=0.
!$acc enter data copyin(tr0v,tr1v,tr1v_p)
!
      allocate (rho0i(nt,np)); rho0i(:,:)=0.
      allocate (rho0f(nt,np)); rho0f(:,:)=0.
      allocate (rho0v(nt,np)); rho0v(:,:)=0.
      allocate (pr0i(nt,np)); pr0i(:,:)=0.
      allocate (pr0f(nt,np)); pr0f(:,:)=0.
      allocate (pr0v(nt,np)); pr0v(:,:)=0.
!$acc enter data copyin(rho0i,rho0f,rho0v,pr0i,pr0f,pr0v)
!
      if (advance_pw) then
        allocate (epbcr1re(nt,np)); epbcr1re(:,:)=0.
        allocate (epbcr0re(nt,np)); epbcr0re(:,:)=0.
        allocate (embcr1re(nt,np)); embcr1re(:,:)=0.
        allocate (embcr0re(nt,np)); embcr0re(:,:)=0.
!$acc enter data copyin(embcr0re,embcr1re,epbcr0re,epbcr1re)
      end if
!
      if (advance_zw) then
        allocate (zpbcr1re(nt,np)); zpbcr1re(:,:)=0.
        allocate (zpbcr0re(nt,np)); zpbcr0re(:,:)=0.
        allocate (zmbcr1re(nt,np)); zmbcr1re(:,:)=0.
        allocate (zmbcr0re(nt,np)); zmbcr0re(:,:)=0.
!$acc enter data copyin(zpbcr1re,zpbcr0re,zmbcr1re,zmbcr0re)
        if (wtd_use_zw_limit) then
          allocate (zwlimit(nr)); zwlimit(:)=0.
!$acc enter data copyin(zwlimit)
        end if
      end if
!
      allocate (pw_rcut_main(nrm)); pw_rcut_main(:)=1._r_typ
      allocate (pw_rcut_half(nr)); pw_rcut_half(:)=1._r_typ
!$acc enter data copyin(pw_rcut_main,pw_rcut_half)
!
      allocate (psi_old(ntm,npm)); psi_old(:,:)=0.
      allocate (psi_n(ntm,npm)); psi_n(:,:)=0.
      allocate (psi_rn(ntm,npm)); psi_rn(:,:)=0.
      allocate (psi_rnp1(ntm,npm)); psi_rnp1(:,:)=0.
      allocate (phi_old(nt,np)); phi_old(:,:)=0.
!$acc enter data copyin(psi_old,psi_n,psi_rn,psi_rnp1,phi_old)
!
      if (ifrholimit) then
        allocate(rho_limit(nr,nt,np)); rho_limit(:,:,:)=0.
!$acc enter data copyin(rho_limit)
      end if
!
      call alloc_vvec (v_old)
!$acc update self(v_old%r,v_old%t,v_old%p)
!
      call alloc_vvec (vmoxrbb)
!$acc update self(vmoxrbb%r,vmoxrbb%t,vmoxrbb%p)
!
      allocate (eta(nrm,ntm,npm)); eta(:,:,:)=0.
      allocate (etacel(nrm,ntm,npm)); etacel(:,:,:)=0.
      allocate (vis(nrm,ntm,npm)); vis(:,:,:)=0.
      allocate (eta_prof(nrm,ntm,npm)); eta_prof(:,:,:)=0.
      allocate (vis_prof(nrm,ntm,npm)); vis_prof(:,:,:)=0.
      allocate (sifac(nrm,ntm,npm)); sifac(:,:,:)=0.
!$acc enter data copyin(eta,etacel,vis,eta_prof,vis_prof,sifac)
!
      call alloc_avec_bc (ab)
!$acc update self(ab%r0%t,ab%r1%t,ab%r0%p,ab%r1%p)
!
      call alloc_vvec_bc (vb)
!
! ****** Allocate storage for the COEF array.
!
      allocate (coef(nrm,ntm,npm)); coef(:,:,:)=0.
!$acc enter data copyin(coef)
!
! ****** Allocate storage for the upwind resistivity arrays.
!
      if (experimental_a_advance) then
        allocate (eta_uw%rt(nrm1,nt,np)); eta_uw%rt(:,:,:)=0.
        allocate (eta_uw%rp(nrm1,nt,np)); eta_uw%rp(:,:,:)=0.
        allocate (eta_uw%tr(nr,ntm1,np)); eta_uw%tr(:,:,:)=0.
        allocate (eta_uw%tp(nr,ntm1,np)); eta_uw%tp(:,:,:)=0.
        allocate (eta_uw%pr(nr,nt,npm1)); eta_uw%pr(:,:,:)=0.
        allocate (eta_uw%pt(nr,nt,npm1)); eta_uw%pt(:,:,:)=0.
        allocate (eta_uw%i(nrm1,ntm1,npm1)); eta_uw%i(:,:,:)=0.
!$acc enter data copyin(eta_uw%rt,eta_uw%rp,eta_uw%tr,eta_uw%tp)
!$acc enter data copyin(eta_uw%pr,eta_uw%pt,eta_uw%i)
      end if
!
! ****** Allocate storage for the characteristics.
!
      if (rb1.and.char_bc1) then
        allocate (cbc1_ub(nt,np));   cbc1_ub(:,:)=0.
        allocate (cbc1_rhob(nt,np)); cbc1_rhob(:,:)=0.
        allocate (cbc1_pb(nt,np));   cbc1_pb(:,:)=0.
!$acc enter data copyin(cbc1_ub,cbc1_rhob,cbc1_pb)
      end if
!
! ****** Allocate storage for the pressure force vectors.
!
      call alloc_vvec (fpw)
!$acc update self(fpw%r,fpw%t,fpw%p)
!
end subroutine
!#######################################################################
subroutine set_mesh
!
!-----------------------------------------------------------------------
!
! ****** Define the mesh arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use meshdef
      use restart
      use constants
!
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Define the global meshes.
!
! ****** Define the r mesh.
!
      if (.not.restart_run) then
        call genmesh (9,'r',nrm1_g,r0,r1,nmseg,rfrac,drratio, &
                      nfrmesh,.false.,zero,r_g)
      end if
!
      do i=2,nrm1_g
        rh_g(i)=half*(r_g(i)+r_g(i-1))
        drh_g(i)=r_g(i)-r_g(i-1)
      enddo
      rh_g(1)=rh_g(2)-drh_g(2)
      rh_g(nr_g)=rh_g(nrm1_g)+drh_g(nrm1_g)
      drh_g(1)=drh_g(2)
      drh_g(nr_g)=drh_g(nrm1_g)
!
      do i=1,nrm1_g
        dr_g(i)=rh_g(i+1)-rh_g(i)
      enddo
!
! ****** Define the theta mesh.
!
      if (.not.restart_run) then
        call genmesh (9,'t',ntm1_g,t0,t1,nmseg,tfrac,dtratio, &
                      nftmesh,.false.,zero,t_g)
      end if
!
      do j=2,ntm1_g
        th_g(j)=half*(t_g(j)+t_g(j-1))
        dth_g(j)=t_g(j)-t_g(j-1)
      enddo
      th_g(1)=th_g(2)-dth_g(2)
      th_g(nt_g)=th_g(ntm1_g)+dth_g(ntm1_g)
      dth_g(1)=dth_g(2)
      dth_g(nt_g)=dth_g(ntm1_g)
!
      do j=1,ntm1_g
        dt_g(j)=th_g(j+1)-th_g(j)
      enddo
!
! ****** Define the periodic phi mesh.
!
      if (.not.restart_run) then
        call genmesh (9,'p',npm1_g,p0,p1,nmseg,pfrac,dpratio, &
                      nfpmesh,.true.,phishift,p_g)
        p_g(np_g)=p_g(2)+pl
      end if
!
      do k=2,np_g
        ph_g(k)=half*(p_g(k)+p_g(k-1))
        dph_g(k)=p_g(k)-p_g(k-1)
      enddo
      ph_g(1)=ph_g(npm1_g)-pl
      dph_g(1)=dph_g(npm1_g)
!
      do k=1,npm1_g
        dp_g(k)=ph_g(k+1)-ph_g(k)
      enddo
      dp_g(np_g)=dp_g(2)
!
! ****** Enforce exact periodicity to protect symmetry properties
! ****** from round-off errors (especially for axisymmetric cases).
!
      dph_g(np_g)=dph_g(2)
      dp_g(1)=dp_g(npm1_g)
!
! ****** Set the phi cell size multiplier.  This is used to get
! ****** the correct behavior for 2D (axisymmetric) runs.
!
      if (axisymmetric) then
        dp_mult=0.
      else
        dp_mult=one
      end if
!
! ****** Define the local meshes.
!
      do i=1,nrm
        r(i)=r_g(i0_g+i-1)
        dr(i)=dr_g(i0_g+i-1)
      enddo
!
      do i=1,nr
        rh(i)=rh_g(i0_g+i-1)
        drh(i)=drh_g(i0_g+i-1)
      enddo
!
      do j=1,ntm
        t(j)=t_g(j0_g+j-1)
        dt(j)=dt_g(j0_g+j-1)
      enddo
!
      do j=1,nt
        th(j)=th_g(j0_g+j-1)
        dth(j)=dth_g(j0_g+j-1)
      enddo
!
      do k=1,npm
        p(k)=p_g(k0_g+k-1)
        dp(k)=dp_g(k0_g+k-1)
      enddo
!
      do k=1,np
        ph(k)=ph_g(k0_g+k-1)
        dph(k)=dph_g(k0_g+k-1)
      enddo
!
! ****** Define global auxiliary mesh-related arrays.
!
      st_g(:)=sin(t_g(:))
!
! ****** Set pole points explicitly so no round-off zeros:
!
      st_g(1)=0.
      st_g(ntm1_g)=0.
!
      ct_g(:)=cos(t_g(:))
      sth_g(:)=sin(th_g(:))
      cth_g(:)=cos(th_g(:))
!
      sp_g(:)=sin(p_g(:))
      cp_g(:)=cos(p_g(:))
      sph_g(:)=sin(ph_g(:))
      cph_g(:)=cos(ph_g(:))
!
! ****** For an axisymmetric case, set the exact values of
! ****** sin(phi) and cos(phi) to preserve symmetry properties
! ****** in the presence of round-off errors.
!
      if (axisymmetric) then
        sp_g(2)=0.
        cp_g(2)=one
        sph_g(2)=0.
        cph_g(2)=-one
      end if
!
! ****** Enforce exact periodicity to protect symmetry properties
! ****** from round-off errors (especially for axisymmetric cases).
!
      sph_g(1)=sph_g(npm1_g)
      sph_g(np_g)=sph_g(2)
      cph_g(1)=cph_g(npm1_g)
      cph_g(np_g)=cph_g(2)
      sp_g(1)=sp_g(npm1_g)
      sp_g(np_g)=sp_g(2)
      cp_g(1)=cp_g(npm1_g)
      cp_g(np_g)=cp_g(2)
!
! ****** Define local auxiliary mesh-related arrays.
!
      do j=1,ntm
        st(j)=st_g(j0_g+j-1)
        ct(j)=ct_g(j0_g+j-1)
      enddo
!
      do j=1,nt
        sth(j)=sth_g(j0_g+j-1)
        cth(j)=cth_g(j0_g+j-1)
      enddo
!
      do k=1,npm
        sp(k)=sp_g(k0_g+k-1)
        cp(k)=cp_g(k0_g+k-1)
      enddo
!
      do k=1,np
        sph(k)=sph_g(k0_g+k-1)
        cph(k)=cph_g(k0_g+k-1)
      enddo
!
      r_i(:)=one/r(:)
      dr_i(:)=one/dr(:)
      rh_i(:)=one/rh(:)
      drh_i(:)=one/drh(:)
      dt_i(:)=one/dt(:)
      do j=1,ntm
        if (st(j).ne.zero) then
          st_i(j)=one/st(j)
        else
          st_i(j)=zero
        end if
      enddo
      dth_i(:)=one/dth(:)
      sth_i(:)=one/sth(:)
      dp_i(:)=one/dp(:)
      dph_i(:)=one/dph(:)
!
! ****** Compute area factors.
!
      fl_one(:)=one
      fl_oneh(:)=one
      fl_fac(:)=one
      fl_fach(:)=one
      fl_fac_i(:)=one
      fl_fach_i(:)=one
!
! ****** True radial distances.
!
      r_true(:)=r(:)
      rh_true(:)=rh(:)
      r_true_i(:)=r_i(:)
      rh_true_i(:)=rh_i(:)
!
! ****** Compute the volume of the domain.
!
      volume=one
!
      if (.false.) then
      do i=0,nproc-1
      call MPI_BARRIER (comm_all,ierr)
      if (i.eq.iproc) then
      write (*,*) 'iproc=',iproc
      write (*,*) 'np_g=',np_g
      write (*,*) 'size(p_g)=',size(p_g)
      write (*,*) 'p_g=',p_g
      write (*,*) 'ph_g=',ph_g
      write (*,*) 'dp_g=',dp_g
      write (*,*) 'dph_g=',dph_g
      write (*,*) 'sp_g=',sp_g
      write (*,*) 'cp_g=',cp_g
      write (*,*) 'sph_g=',sph_g
      write (*,*) 'cph_g=',cph_g
      write (*,*) 'p=',p
      write (*,*) 'ph=',ph
      write (*,*) 'dp=',dp
      write (*,*) 'dph=',dph
      write (*,*) 'sp=',sp
      write (*,*) 'cp=',cp
      write (*,*) 'sph=',sph
      write (*,*) 'dp_i=',dp_i
      write (*,*) 'dph_i=',dph_i
      end if
      enddo
      end if
!
end subroutine
!#######################################################################
subroutine genmesh (io,label,nc,c0,c1,nseg,frac,dratio, &
                          nfilt,periodic,c_shift,c)
!
!-----------------------------------------------------------------------
!
! ****** Generate a one-dimensional mesh.
!
!-----------------------------------------------------------------------
!
! ****** Input arguments:
!
!          IO      : [integer]
!                    Fortran file unit number to which to write
!                    mesh diagnostics.  Set IO=0 if diagnostics
!                    are not of interest.  It is assumed that
!                    unit IO has been connected to a file prior
!                    to calling this routine.
!
!          LABEL   : [character(*)]
!                    Name for the mesh coordinate (example: 'x').
!
!          NC      : [integer]
!                    Number of mesh points to load.
!
!          C0      : [real]
!                    The starting location for the coordinate.
!
!          C1      : [real]
!                    The ending location for the coordinate.
!                    It is required that C1.gt.C0.
!
!          NSEG    : [integer]
!                    Maximum number of mesh segments.
!                    The mesh spacing in each segment varies
!                    exponentially with a uniform amplification
!                    factor.  The actual number of mesh segments
!                    used is NSEG or less.  It is obtained from the
!                    information in array FRAC.
!
!          FRAC    : [real array, dimension NSEG]
!                    The normalized positions of the mesh segment
!                    boundaries (as a fraction of the size of the
!                    domain).  For a non-periodic mesh, the first
!                    value of FRAC specified must equal 0. and the
!                    last value must equal 1.  For a periodic mesh,
!                    FRAC must not contain both 0. and 1., since
!                    these represent the same point.
!
!          DRATIO  : [real array, dimension NSEG]
!                    The ratio of the mesh spacing at the end of a
!                    segment to that at the beginning.
!
!          NFILT   : [integer]
!                    The number of times to filter the mesh-point
!                    distribution array.  Set NFILT=0 if filtering
!                    is not desired.  Filtering can reduce
!                    discontinuities in the derivative of the mesh
!                    spacing.
!
!          PERIODIC: [logical]
!                    A flag to indicate whether the mesh to be
!                    generated represents a periodic coordinate.
!                    If the coordinate is specified as periodic,
!                    the range [C0,C1] should be the whole periodic
!                    interval; the first mesh point is set at C0
!                    and the last mesh point, C(NC), is set at C1.
!
!          C_SHIFT : [real]
!                    Amount by which to shift the periodic coordinate.
!                    C_SHIFT is only used when PERIODIC=.true.,
!                    and is ignored otherwise.  A positive C_SHIFT
!                    moves the mesh points to the right.
!
! ****** Output arguments:
!
!          C       : [real array, dimension NC]
!                    The locations of the mesh points.
!
!-----------------------------------------------------------------------
!
! ****** The arrays DRATIO and FRAC define the mesh as follows.
!
! ****** For example, suppose that a (non-periodic) mesh with three
! ****** segments is desired.  Suppose the domain size is c=[0:2].
! ****** In the first segment (with c between 0 and .5) the mesh
! ****** spacing is decreasing with c, such that DC at c=.5 is half
! ****** DC at c=0.  From c=.5 to c=1, the mesh is uniform.  From c=1
! ****** to c=2, the mesh spacing is increasing with c such that DC at
! ****** c=2 is 10 times DC at c=1.  This mesh would be specified by:
! ******
! ******     FRAC=0.,.25,.5,1.
! ******     DRATIO=.5,1.,10.
! ******
! ****** The variable C_SHIFT can be used to shift the mesh point
! ****** distribution for a periodic coordinate.  For example,
! ****** suppose C represents mesh points in the interval [0,2*pi].
! ****** C_SHIFT=.5*pi would move the distribution of mesh points
! ****** so that the original mesh point with C(1)=0. would be
! ****** close to .5*pi in the new mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use debug
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, intent(in) :: io
      character(*), intent(in) :: label
      integer, intent(in) :: nc
      real(r_typ), intent(in) :: c0,c1
      integer, intent(in) :: nseg
      real(r_typ), dimension(nseg), intent(in) :: frac,dratio
      integer, intent(in) :: nfilt
      logical, intent(in) :: periodic
      real(r_typ), intent(in) :: c_shift
      real(r_typ), dimension(nc), intent(out) :: c
!
!-----------------------------------------------------------------------
!
! ****** Storage for the coordinate transformation.
!
      integer :: ns
      real(r_typ), dimension(:), allocatable :: xi,cs,a,r,f
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: eps=1.e-5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,nf,nr,ll,j0
      real(r_typ) :: alpha,dr,fac,d,dxi,xiv,cshft,xi_shift
      real(r_typ), dimension(:), allocatable :: dc,rdc
!
!-----------------------------------------------------------------------
!
! ****** Check that the number of mesh points is valid.
!
      if (nc.lt.2) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in GENMESH:'
          write (*,*) '### Invalid number of mesh points specified.'
          write (*,*) '### There must be at least two mesh points.'
          write (*,*) 'Mesh coordinate: ',label
          write (*,*) 'Number of mesh points specified = ',nc
        end if
        call endrun (.true.)
      end if
!
! ****** Check that a positive mesh interval has been specified.
!
      if (c0.ge.c1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in GENMESH:'
          write (*,*) '### Invalid mesh interval specified.'
          write (*,*) '### C1 must be greater than C0.'
          write (*,*) 'Mesh coordinate: ',label
          write (*,*) 'C0 = ',c0
          write (*,*) 'C1 = ',c1
        end if
        call endrun (.true.)
      end if
!
! ****** Find the number of values of FRAC specified.
!
      do nf=1,nseg-1
        if (frac(nf+1).eq.zero) exit
      enddo
!
! ****** When no values have been specified (NF=1, the default),
! ****** a uniform mesh is produced.
!
      if (nf.eq.1.and.frac(1).eq.zero) then
        ns=1
        allocate (cs(ns+1))
        allocate (r(ns))
        cs(1)=c0
        cs(2)=c1
        r(1)=one
        go to 100
      end if
!
! ****** Check that the specified values of FRAC are monotonically
! ****** increasing.
!
      do i=2,nf
        if (frac(i).lt.frac(i-1)) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GENMESH:'
            write (*,*) '### Invalid mesh specification.'
            write (*,*) 'Mesh coordinate: ',label
            write (*,*) 'The values in FRAC must increase'// &
                        ' monotonically.'
            write (*,*) 'FRAC = ',frac(1:nf)
          end if
          call endrun (.true.)
        end if
      enddo
!
! ****** Check the specified values of FRAC.
!
      if (periodic) then
!
! ****** A periodic mesh requires the specified values of FRAC
! ****** to be in the range 0. to 1.
!
        if (frac(1).lt.zero.or.frac(nf).gt.one) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GENMESH:'
            write (*,*) '### Invalid mesh specification.'
            write (*,*) 'Mesh coordinate: ',label
            write (*,*) 'For a periodic coordinate, the values in'// &
                        ' FRAC must be between 0. and 1.'
            write (*,*) 'FRAC = ',frac(1:nf)
          end if
          call endrun (.true.)
        end if
!
! ****** A periodic mesh cannot contain both 0. and 1. in FRAC,
! ****** since these represent the same point.
!
        if (frac(1).eq.zero.and.frac(nf).eq.one) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GENMESH:'
            write (*,*) '### Invalid mesh specification.'
            write (*,*) 'Mesh coordinate: ',label
            write (*,*) 'For a periodic coordinate, FRAC must not'// &
                        ' contain both 0. and 1.'
            write (*,*) 'FRAC = ',frac(1:nf)
          end if
          call endrun (.true.)
        end if
!
      else
!
! ****** A non-periodic mesh requires the first specified value
! ****** of FRAC to be 0., and the last value to equal 1.
!
        if (frac(1).ne.zero) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GENMESH:'
            write (*,*) '### Invalid mesh specification.'
            write (*,*) 'Mesh coordinate: ',label
            write (*,*) 'For a non-periodic coordinate, the first'// &
                      ' value of FRAC must equal 0.'
            write (*,*) 'FRAC = ',frac(1:nf)
          end if
          call endrun (.true.)
        end if
!
        if (frac(nf).ne.one) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GENMESH:'
            write (*,*) '### Invalid mesh specification.'
            write (*,*) 'Mesh coordinate: ',label
            write (*,*) 'For a non-periodic coordinate, the last'// &
                        ' value of FRAC must equal 1.'
            write (*,*) 'FRAC = ',frac(1:nf)
          end if
          call endrun (.true.)
        end if
!
      end if
!
! ****** Check that the required values of DRATIO have been set,
! ****** and are positive.
!
      if (periodic) then
        nr=nf
      else
        nr=nf-1
      end if
!
      do i=1,nr
        if (dratio(i).le.zero) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GENMESH:'
            write (*,*) '### Invalid mesh specification.'
            write (*,*) 'Mesh coordinate: ',label
            write (*,*) 'A required value in DRATIO has not been'// &
                        ' set or is not positive.'
            write (*,*) 'DRATIO = ',dratio(1:nr)
          end if
          call endrun (.true.)
        end if
      enddo
!
! ****** Check that an inherently discontinuous mesh has not been
! ****** specified inadvertently.
!
      if (periodic.and.nr.eq.1.and.dratio(1).ne.one) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from GENMESH:'
          write (*,*) '### Discontinuous mesh specification.'
          write (*,*) 'Mesh coordinate: ',label
          write (*,*) 'An inherently discontinuous mesh has been'// &
                      ' specified.'
          write (*,*) 'FRAC = ',frac(1:nf)
          write (*,*) 'DRATIO = ',dratio(1:nr)
        end if
      end if
!
! ****** Set the number of segments.
!
      ns=nf-1
!
! ****** For a periodic coordinate, add points at XI=0. and XI=1.
! ****** if they are not already present.
!
      if (periodic) then
        if (frac(1).ne.zero) ns=ns+1
        if (frac(nf).ne.one) ns=ns+1
      end if
!
      allocate (cs(ns+1))
      allocate (r(ns))
!
! ****** Set up the coordinate limits of the segments.
!
      if (periodic) then
        if (frac(1).ne.zero) then
          cs(1)=c0
          cs(2:nf+1)=c0+(c1-c0)*frac(1:nf)
          if (frac(nf).ne.one) then
            alpha=(one-frac(nf))/(frac(1)+one-frac(nf))
            r(1)=dratio(nr)/(one+alpha*(dratio(nr)-one))
            r(2:nr+1)=dratio(1:nr)
            cs(ns+1)=c1
            r(ns)=one+alpha*(dratio(nr)-one)
          else
            r(1)=dratio(nr)
            r(2:nr)=dratio(1:nr-1)
          end if
        else
          cs(1:nf)=c0+(c1-c0)*frac(1:nf)
          r(1:nr)=dratio(1:nr)
          cs(ns+1)=c1
        end if
      else
        cs(1:nf)=c0+(c1-c0)*frac(1:nf)
        r(1:nr)=dratio(1:nr)
      end if
!
  100 continue
!
      allocate (xi(ns+1))
      allocate (a(ns))
      allocate (f(ns))
!
! ****** Compute the XI values at the segment limits.
!
      do i=1,ns
        dr=r(i)-one
        if (abs(dr).lt.eps) then
          f(i)=(cs(i+1)-cs(i))*(one+half*dr)
        else
          f(i)=(cs(i+1)-cs(i))*log(r(i))/dr
        end if
      enddo
!
      fac=zero
      do i=ns,1,-1
        fac=fac/r(i)+f(i)
      enddo
!
      d=f(1)/fac
      xi(1)=zero
      do i=2,ns
        xi(i)=xi(i-1)+d
        if (i.lt.ns) d=d*f(i)/(f(i-1)*r(i-1))
      enddo
      xi(ns+1)=one
!
! ****** Set the amplification factor for each segment.
!
      do i=1,ns
        a(i)=log(r(i))/(xi(i+1)-xi(i))
      enddo
!
! ****** For a periodic coordinate, find the XI shift corresponding
! ****** to a shift of C_SHIFT in the coordinate.
! ****** Note that a positive value of C_SHIFT moves the mesh
! ****** points to the right.
!
      if (periodic) then
        cshft=-c_shift
        call map_c_to_xi (periodic,ns,xi,cs,a,r,cshft,xi_shift)
      else
        xi_shift=0.
      end if
!
! ****** Compute the location of the mesh points in array C
! ****** by mapping from the XI values.
!
      dxi=one/(nc-one)
!
      c(1)=c0
      do j=2,nc-1
        xiv=(j-1)*dxi
        call map_xi_to_c (periodic,ns,xi,cs,a,r, &
                          cshft,xi_shift,xiv,c(j))
      enddo
      c(nc)=c1
!
! ****** Filter the mesh if requested.
!
      if (nfilt.gt.0) then
        do i=1,nfilt
          if (periodic) then
            call filter_coord_periodic (c1-c0,nc,c)
          else
            call filter_coord (nc,c)
          end if
        enddo
      end if
!
! ****** Write out the mesh information.
!
      if (io.gt.0.and.iamp0) then
!
        write (io,*)
        write (io,*) '### COMMENT from GENMESH:'
        write (io,*) '### Mesh information for coordinate ',label,':'
!
        if (idebug.gt.0) then
          write (io,*)
          write (io,*) 'Flag to indicate a periodic mesh: ',periodic
          write (io,*) 'Number of mesh points = ',nc
          write (io,*) 'Lower mesh limit = ',c0
          write (io,*) 'Upper mesh limit = ',c1
          write (io,*) 'Number of times to filter the mesh = ',nfilt
          if (periodic) then
            write (io,*) 'Amount to shift the mesh = ',c_shift
          end if
        end if
!
        write (io,*)
        write (io,*) 'Number of mesh segments = ',ns
!
        ll=len_trim(label)
!
        write (io,900) 'Segment      xi0       xi1'// &
                       repeat (' ',16-ll)//label//'0'// &
                       repeat (' ',16-ll)//label//'1'// &
                       '            ratio'
        do i=1,ns
          write (io,910) i,xi(i),xi(i+1),cs(i),cs(i+1),r(i)
        enddo
!
        allocate (dc(nc))
        allocate (rdc(nc))
!
        dc=c-cshift(c,-1)
        if (periodic) dc(1)=dc(nc)
        rdc=dc/cshift(dc,-1)
        if (periodic) rdc(1)=rdc(nc)
!
        write (io,*)
        write (io,920) 'Mesh-point locations:'
        write (io,920) '     i'// &
                       repeat (' ',18-ll)//label// &
                       repeat (' ',17-ll)//'d'//label// &
                       '             ratio'
!
        if (periodic) then
          j0=1
        else
          j0=3
          write (io,930) 1,c(1)
          write (io,930) 2,c(2),dc(2)
        end if
        do j=j0,nc
          write (io,930) j,c(j),dc(j),rdc(j)
        enddo
!
        deallocate (dc)
        deallocate (rdc)
!
        FLUSH (io)
!
      end if
!
  900 format (/,tr1,a)
  910 format (tr1,i4,2x,2f10.6,4f17.8)
  920 format (tr1,a)
  930 format (tr1,i6,3f18.8)
!
      deallocate (cs)
      deallocate (r)
      deallocate (xi)
      deallocate (a)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine map_xi_to_c (periodic,ns,xi,cs,a,r, &
                              cshft,xi_shift,xiv,cv)
!
!-----------------------------------------------------------------------
!
! ****** Get the mesh coordinate value CV for the specified
! ****** xi value XIV.
!
! ****** Set PERIODIC=.true. for a periodic coordinate.
! ****** NS is the number of segments in the mesh definition.
! ****** The arrays XI, CS, A, and R define the mesh mapping.
!
! ****** CSHFT represents the amount to shift a periodic coordinate.
! ****** XI_SHIFT represents the corresponding amount to shift xi.
!
! ****** This is a utility routine for GENMESH.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical, intent(in) :: periodic
      integer, intent(in) :: ns
      real(r_typ), dimension(ns+1), intent(in) :: xi,cs
      real(r_typ), dimension(ns), intent(in) :: a,r
      real(r_typ), intent(in) :: cshft,xi_shift
      real(r_typ), intent(in) :: xiv
      real(r_typ), intent(out) :: cv
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: eps=1.e-5
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: xiv_p,d,d1,da,da1,fac
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: fold
!
!-----------------------------------------------------------------------
!
! ****** Find the index of the segment to which XIV belongs.
!
      if (periodic) then
!
! ****** Shift XIV by XI_SHIFT.
!
        xiv_p=xiv+xi_shift
!
! ****** Fold XIV_P into the main interval.
!
        xiv_p=fold(zero,one,xiv_p)
!
      else
!
        xiv_p=xiv
!
      end if
!
      do i=1,ns
        if (xiv_p.ge.xi(i).and.xiv_p.le.xi(i+1)) exit
      enddo
!
      if (i.gt.ns) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in MAP_XI_TO_C:'
          write (*,*) '### Error in finding the XI segment.'
          write (*,*) '### Could not find XIV in the XI table.'
          write (*,*) '[Utility routine for GENMESH.]'
          write (*,*) '[This is an internal error.]'
          write (*,*) 'XI = ',xi
          write (*,*) 'XIV = ',xiv
          write (*,*) 'XIV_P = ',xiv_p
        end if
        call endrun (.true.)
      end if
!
      d =xiv_p  -xi(i)
      d1=xi(i+1)-xi(i)
!
      da =a(i)*d
      da1=a(i)*d1
!
! ****** Interpolate the mapping function at XIV_P.
!
      if (abs(da1).lt.eps) then
        fac=(d*(one+half*da))/(d1*(one+half*da1))
      else
        fac=(exp(da)-one)/(r(i)-one)
      end if
!
      cv=cs(i)+(cs(i+1)-cs(i))*fac
!
      if (periodic) then
!
! ****** Shift CV by the amount CSHFT.
!
        cv=cv-cshft
!
! ****** Fold CV into the main interval.
!
        cv=fold(cs(1),cs(ns+1),cv)
!
      end if
!
end subroutine
!#######################################################################
subroutine map_c_to_xi (periodic,ns,xi,cs,a,r,cv,xiv)
!
!-----------------------------------------------------------------------
!
! ****** Get the xi value XIV for the specified coordinate value CV.
!
! ****** Set PERIODIC=.true. for a periodic coordinate.
! ****** NS is the number of segments in the mesh definition.
! ****** The arrays XI, CS, A, and R define the mesh mapping.
!
! ****** This is a utility routine for GENMESH.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical, intent(in) :: periodic
      integer, intent(in) :: ns
      real(r_typ), dimension(ns+1), intent(in) :: xi,cs
      real(r_typ), dimension(ns), intent(in) :: a,r
      real(r_typ), intent(in) :: cv
      real(r_typ), intent(out) :: xiv
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: eps=1.e-5
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: cv_p,d,da,fac
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: fold
!
!-----------------------------------------------------------------------
!
! ****** Find the index of the segment to which CV belongs.
!
      if (periodic) then
!
! ****** Fold CV_P into the main interval.
!
        cv_p=fold(cs(1),cs(ns+1),cv)
!
      else
!
        cv_p=cv
!
      end if
!
      do i=1,ns
        if (cv_p.ge.cs(i).and.cv_p.le.cs(i+1)) exit
      enddo
!
      if (i.gt.ns) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in MAP_C_TO_XI:'
          write (*,*) '### Error in finding the CS segment.'
          write (*,*) '### Could not find CV in the CS table.'
          write (*,*) '[Utility routine for GENMESH.]'
          write (*,*) '[This is an internal error.]'
          write (*,*) 'CS = ',cs
          write (*,*) 'CV = ',cv
          write (*,*) 'CV_P = ',cv_p
        end if
        call endrun (.true.)
      end if
!
      d=(cv_p-cs(i))/(cs(i+1)-cs(i))
      da=(r(i)-one)*d
!
! ****** Interpolate the mapping function at XIV_P.
!
      if (abs(da).lt.eps) then
        fac=d*(xi(i+1)-xi(i))
      else
        fac=log(da+one)/a(i)
      end if
!
      xiv=xi(i)+fac
!
end subroutine
!#######################################################################
subroutine filter_coord (n,f)
!
!-----------------------------------------------------------------------
!
! ****** Apply a "(1,2,1)/4" low-pass digital filter to a
! ****** 1D coordinate.
!
! ****** The end-points F(1) and F(N) are not changed.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: f
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(n) :: ff
!
!-----------------------------------------------------------------------
!
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Make a copy of the function.
!
      ff=f
!
! ****** Apply the filter.
!
      do i=2,n-1
        f(i)=quarter*(ff(i-1)+two*ff(i)+ff(i+1))
      enddo
!
end subroutine
!#######################################################################
subroutine filter_coord_periodic (xl,n,f)
!
!-----------------------------------------------------------------------
!
! ****** Apply a "(1,2,1)/4" low-pass digital filter to a
! ****** periodic 1D coordinate.
!
!-----------------------------------------------------------------------
!
! ****** XL is the periodic interval for the coordinate.
!
! ****** The filtered coordinate is translated so that F(1)
! ****** is preserved.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: xl
      integer :: n
      real(r_typ), dimension(n) :: f
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(0:n+1) :: ff
!
!-----------------------------------------------------------------------
!
      integer :: i
      real(r_typ) :: f1old,f1new
!
!-----------------------------------------------------------------------
!
! ****** Save the value of F(1).
!
      f1old=f(1)
!
! ****** Make a periodic copy of the function.
!
      ff(1:n)=f(:)
!
      ff(0)=f(n-1)-xl
      ff(n+1)=f(2)+xl
!
! ****** Apply the filter.
!
      do i=1,n
        f(i)=quarter*(ff(i-1)+two*ff(i)+ff(i+1))
      enddo
!
! ****** Translate F so that F(1) is preserved.
!
      f1new=f(1)
      do i=1,n
        f(i)=f(i)-f1new+f1old
      enddo
!
end subroutine
!#######################################################################
function fold (x0,x1,x)
!
!-----------------------------------------------------------------------
!
! ****** "Fold" X into the periodic interval [X0,X1].
!
! ****** On return, X is such that X0.le.X.lt.X1.
!
!-----------------------------------------------------------------------
!
! ****** It is assumed that X0 does not equal X1, as is physically
! ****** necessary.  If X0 and X1 are equal, the routine just
! ****** returns with FOLD=X.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: fold
      real(r_typ) :: x0,x1,x
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: xl
!
!-----------------------------------------------------------------------
!
      fold=x
!
      if (x0.eq.x1) return
!
      xl=x1-x0
!
      fold=mod(x-x0,xl)+x0
!
      if (fold.lt.x0) fold=fold+xl
      if (fold.ge.x1) fold=fold-xl
!
      return
end function
!#######################################################################
subroutine bfroma (a,b,brmono_fac)
!
!-----------------------------------------------------------------------
!
! ****** Get the magnetic field from the vector potential.
! ****** If a Br monopole is active, add brmono_fac*br_mono(r) to B.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
      use seam_rt_interface
      use seam_rp_interface
      use seam_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
      type(bvec) :: b
      real(r_typ) :: brmono_fac
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: four=4._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Get Br.
!
      do concurrent (k=1:npm1, j=jm0:jm1, i=1:nr)
        b%r(i,j,k)=( ( sth(j+1)*a%p(i,j+1,k) &
                      -sth(j  )*a%p(i,j  ,k))*dt_i(j) &
                     -(a%t(i,j,k+1)-a%t(i,j,k))*dp_i(k)*dp_mult &
                    )*rh_i(i)*st_i(j)
      enddo
!
! ****** Get Br at the poles.  These values are used to set Br
! ****** at the pole in SET_POLE_BC_BVEC.
!
      if (tb0) then
        do concurrent (k=1:npm1, i=1:nr)
!cc          b%r(i,   1,k)= two*a%p(i,   2,k)*sth_i(   2)*rh_i(i)
          b%r(i,   1,k)= four*a%p(i,   2,k)*dt_i(   1)*rh_i(i)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:npm1, i=1:nr)
!cc          b%r(i,ntm1,k)=-two*a%p(i,ntm1,k)*sth_i(ntm1)*rh_i(i)
          b%r(i,ntm1,k)=-four*a%p(i,ntm1,k)*dt_i(ntm1)*rh_i(i)
        enddo
      end if
!
! ****** Get Bt.
!
      do concurrent (k=1:npm1, j=jh0:jh1, i=1:nrm1)
        b%t(i,j,k)=( (a%r(i,j,k+1)-a%r(i,j,k))*dp_mult*dp_i(k)*sth_i(j) &
                    -( rh(i+1)*a%p(i+1,j,k) &
                       -rh(i  )*a%p(i  ,j,k))*dr_i(i) &
                   )*r_i(i)
      enddo
!
! ****** Get Bp.
!
      do concurrent (k=1:np, j=1:ntm1, i=1:nrm1)
        b%p(i,j,k)=( ( rh(i+1)*a%t(i+1,j,k) &
                      -rh(i  )*a%t(i  ,j,k))*dr_i(i) &
                    -(a%r(i,j+1,k)-a%r(i,j,k))*dt_i(j) &
                    )*r_i(i)
      enddo
!
! ****** Set boundary points at the poles.
!
      call set_pole_bc_bvec (b)
!
! ****** Seam the magnetic field.
! ****** This is required to define the points that will be used
! ****** to obtain the averages required in the "new" J x B.
!
      call seam_bvec (b)
!
! ****** Add in the radial field corresponding to the (artificial)
! ****** monopole BR_MONO.
!
      if (br_mono_active) then
        do concurrent (k=1:npm, j=1:ntm, i=1:nr)
          b%r(i,j,k)=b%r(i,j,k)+brmono_fac*br_mono(i)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine set_brmono
!
!-----------------------------------------------------------------------
!
! ****** Set up the br monopole if requested.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals, ONLY : nr,nrm
      use vars
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: f1ef,expef,sigma_i,afac
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i
!
!-----------------------------------------------------------------------
!
      allocate (grav(nrm))
      grav(:)=one
!
      if (fl_compute) then
        br_mono_active=.true.
        allocate (br_mono(nr))
        br_mono(:)=0._r_typ
        call initialize_field_line
        grav(:)=grav(:)*g0
        return
      end if
!
      if (br00.ne.0) then
        br_mono_active=.true.
        allocate (br_mono(nr))
        sigma_i=one/sigmaef
        f1ef=one-(fmaxef-one)*exp((one-r1ef)*sigma_i)
        do i=1,nr
          expef=exp(-(rh(i)-r1ef)*sigma_i)
          afac=(one+expef)/(fmaxef+f1ef*expef)
          br_mono(i)=br00*afac*(r0*rh_i(i))**2
        enddo
      end if
      grav(:)=grav(:)*g0
!
end subroutine
!#######################################################################
subroutine jfromb (b,fj)
!
!-----------------------------------------------------------------------
!
! ****** Get the current density from the magnetic field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
      type(avec) :: fj
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        fj%r(i,j,k)=( ( st(j  )*b%p(i,j  ,k) &
                       -st(j-1)*b%p(i,j-1,k))*dth_i(j) &
                     -(b%t(i,j,k)-b%t(i,j,k-1))*dp_mult*dph_i(k) &
                    )*r_i(i)*sth_i(j)
      enddo
!
      do concurrent (k=2:npm1, j=jm0:jm1, i=2:nrm1)
        fj%t(i,j,k)=( (b%r(i,j,k)-b%r(i,j,k-1))*dp_mult*dph_i(k)*st_i(j) &
                      -( r(i  )*b%p(i  ,j,k) &
                        -r(i-1)*b%p(i-1,j,k))*drh_i(i) &
                    )*rh_i(i)
      enddo
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        fj%p(i,j,k)=( ( r(i  )*b%t(i  ,j,k) &
                       -r(i-1)*b%t(i-1,j,k))*drh_i(i) &
                     -(b%r(i,j,k)-b%r(i,j-1,k))*dth_i(j) &
                    )*rh_i(i)
      enddo
!
      do concurrent (k=2:npm1, j=jm0:jm1)
        fj%t( 1,j,k)=EXTRAPR0(fj%t,   2,j,k)
        fj%t(nr,j,k)=EXTRAPR1(fj%t,nrm1,j,k)
      enddo
!
      do concurrent (k=1:npm1, j=2:ntm1)
        fj%p( 1,j,k)=EXTRAPR0(fj%p,   2,j,k)
        fj%p(nr,j,k)=EXTRAPR1(fj%p,nrm1,j,k)
      enddo
!
! ****** Set boundary points at the poles.
!
      call set_pole_bc_avec (fj)
!
      call seam_avec (fj)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_avec (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** defined on the A mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ) :: temp_sum1,temp_sum2
      real(r_typ), allocatable, dimension(:) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
! ****** The m=0 and m=1 components are all stored in one long array
! ****** for MPI efficiency and to avoid buffers.
! ****** sum0(1:nrm1)               -> sum0
! ****** sum0(nrm1+1:nrm1+nr)       -> sums0
! ****** sum0(nrm1+nr+1:nrm1+nr+nr) -> sumc0
!
      allocate (sum0(nrm1+nr+nr))
      allocate (sum1(nrm1+nr+nr))
!$acc enter data create(sum0,sum1)
!
      do concurrent (i=1:nrm1+nr+nr)
        sum0(i)=0.
        sum1(i)=0.
      end do
!
! ****** Ar has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nrm1)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a%r(i,2,k)*dph(k)*pl_i*two
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nrm1)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a%r(i,ntm1,k)*dph(k)*pl_i*two
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** At and Ap have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a%p(i,2,k)*sp(k)*dp(k)*pl_i*two
            temp_sum2=temp_sum2+a%p(i,2,k)*cp(k)*dp(k)*pl_i*two
          enddo
          sum0(nrm1+i)=temp_sum1
          sum0(nrm1+nr+i)=temp_sum2
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a%p(i,ntm1,k)*sp(k)*dp(k)*pl_i*two
            temp_sum2=temp_sum2+a%p(i,ntm1,k)*cp(k)*dp(k)*pl_i*two
          enddo
          sum1(nrm1+i)=temp_sum1
          sum1(nrm1+nr+i)=temp_sum2
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nrm1+nr+nr,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:np, i=1:nrm1)
          a%r(i,1,k)=sum0(i)-a%r(i,2,k)
        enddo
!
        do concurrent (k=1:np, i=1:nr)
          a%t(i,1,k)=sum0(nrm1+nr+i)*sph(k)-sum0(nrm1+i)*cph(k)
        enddo
!
        do concurrent (k=1:npm1, i=1:nr)
          a%p(i,1,k)= two*( sum0(nrm1+i)*sp(k)+sum0(nrm1+nr+i)*cp(k) ) &
                      -a%p(i,2,k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np, i=1:nrm1)
          a%r(i,nt,k)=sum1(i)-a%r(i,ntm1,k)
        enddo
!
        do concurrent (k=1:np, i=1:nr)
          a%t(i,ntm1,k)=-sum1(nrm1+nr+i)*sph(k)+sum1(nrm1+i)*cph(k)
        enddo
!
        do concurrent (k=1:npm1, i=1:nr)
          a%p(i,nt,k)= two*(sum1(nrm1+i)*sp(k)+sum1(nrm1+nr+i)*cp(k)) &
                       -a%p(i,ntm1,k)
        enddo
      end if
!
!$acc exit data delete(sum0,sum1)
      deallocate(sum0)
      deallocate(sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_avec_cpu (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** defined on the A mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ), allocatable, dimension(:) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
! ****** The m=0 and m=1 components are all stored in one long array
! ****** for MPI efficiency and to avoid buffers.
! ****** sum0(1:nrm1)               -> sum0
! ****** sum0(nrm1+1:nrm1+nr)       -> sums0
! ****** sum0(nrm1+nr+1:nrm1+nr+nr) -> sumc0
!
      allocate (sum0(nrm1+nr+nr))
      allocate (sum1(nrm1+nr+nr))
      do i=1,nrm1+nr+nr
        sum0(i)=0.
        sum1(i)=0.
      end do
!
! ****** Ar has only an m=0 component.
!
      if (tb0) then
        do k=2,npm1
          do i=1,nrm1
            sum0(i)=sum0(i)+a%r(i,2,k)*dph(k)*pl_i*two
          enddo
        enddo
      end if
!
      if (tb1) then
        do k=2,npm1
          do i=1,nrm1
            sum1(i)=sum1(i)+a%r(i,ntm1,k)*dph(k)*pl_i*two
          enddo
        enddo
      end if
!
! ****** At and Ap have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do k=2,npm1
          do i=1,nr
            sum0(nrm1+i)=sum0(nrm1+i)+a%p(i,2,k)*sp(k)*dp(k)*pl_i*two
            sum0(nrm1+nr+i)=sum0(nrm1+nr+i) &
                            +a%p(i,2,k)*cp(k)*dp(k)*pl_i*two
          enddo
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do k=2,npm1
          do i=1,nr
            sum1(nrm1+i)=sum1(nrm1+i)+a%p(i,ntm1,k)*sp(k)*dp(k)*pl_i*two
            sum1(nrm1+nr+i)=sum1(nrm1+nr+i) &
                            +a%p(i,ntm1,k)*cp(k)*dp(k)*pl_i*two
          enddo
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nrm1+nr+nr,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do k=1,np
          do i=1,nrm1
            a%r(i,1,k)=sum0(i)-a%r(i,2,k)
          enddo
        enddo
        do k=1,np
          do i=1,nr
            a%t(i,1,k)=sum0(nrm1+nr+i)*sph(k)-sum0(nrm1+i)*cph(k)
          enddo
        enddo
        do k=1,npm1
          do i=1,nr
            a%p(i,1,k)= two*( sum0(nrm1+i)*sp(k)+sum0(nrm1+nr+i)*cp(k) ) &
                        -a%p(i,2,k)
          enddo
        enddo
      end if
!
      if (tb1) then
        do k=1,np
          do i=1,nrm1
            a%r(i,nt,k)=sum1(i)-a%r(i,ntm1,k)
          enddo
        enddo
        do k=1,np
          do i=1,nr
            a%t(i,ntm1,k)=-sum1(nrm1+nr+i)*sph(k)+sum1(nrm1+i)*cph(k)
          enddo
        enddo
        do k=1,npm1
          do i=1,nr
            a%p(i,nt,k)= two*(sum1(nrm1+i)*sp(k)+sum1(nrm1+nr+i)*cp(k)) &
                         -a%p(i,ntm1,k)
          enddo
        enddo
      end if
!
      deallocate(sum0)
      deallocate(sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_avec_tp (at,ap)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** in the (t,p) plane defined on the A mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1,np) :: at
      real(r_typ), dimension(nt,npm1) :: ap
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: k
      real(r_typ) :: sums0,sumc0
      real(r_typ) :: sums1,sumc1
      real(r_typ), dimension(2) :: buf0,buf1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      sums0=0.
      sumc0=0.
      sums1=0.
      sumc1=0.
!
! ****** At and Ap have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
!$acc parallel loop default(present) copy(sums0,sumc0) &
!$acc                         reduction(+:sums0,sumc0)
!$omp parallel do default(shared) reduction(+:sums0,sumc0)
        do k=2,npm1
          sums0=sums0+ap(2,k)*sp(k)*dp(k)*pl_i*two
          sumc0=sumc0+ap(2,k)*cp(k)*dp(k)*pl_i*two
        enddo
!$omp end parallel do
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
!$acc parallel loop default(present) copy(sums1,sumc1) &
!$acc                         reduction(+:sums1,sumc1)
!$omp parallel do default(shared) reduction(+:sums1,sumc1)
        do k=2,npm1
          sums1=sums1+ap(ntm1,k)*sp(k)*dp(k)*pl_i*two
          sumc1=sumc1+ap(ntm1,k)*cp(k)*dp(k)*pl_i*two
        enddo
!$omp end parallel do
      end if
!
      buf0=(/sums0,sumc0/)
      buf1=(/sums1,sumc1/)
!
! ****** Sum over all processors.
!
      call sum_over_phi (2,buf0,buf1)
!
      sums0=buf0(1)
      sumc0=buf0(2)
      sums1=buf1(1)
      sumc1=buf1(2)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:np)
          at(1,k)=sumc0*sph(k)-sums0*cph(k)
        enddo
        do concurrent (k=1:npm1)
          ap(1,k)=two*( sums0*sp(k)+sumc0*cp(k))-ap(2,k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np)
          at(ntm1,k)=-sumc1*sph(k)+sums1*cph(k)
        enddo
        do concurrent (k=1:npm1)
          ap(nt,k)=two*( sums1*sp(k)+sumc1*cp(k))-ap(ntm1,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine set_pole_bc_avec_tp_cpu (at,ap)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** in the (t,p) plane defined on the A mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1,np) :: at
      real(r_typ), dimension(nt,npm1) :: ap
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: k
      real(r_typ) :: sums0,sumc0
      real(r_typ) :: sums1,sumc1
      real(r_typ), dimension(2) :: buf0,buf1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      sums0=0.
      sumc0=0.
      sums1=0.
      sumc1=0.
!
! ****** At and Ap have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do k=2,npm1
          sums0=sums0+ap(2,k)*sp(k)*dp(k)*pl_i*two
          sumc0=sumc0+ap(2,k)*cp(k)*dp(k)*pl_i*two
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do k=2,npm1
          sums1=sums1+ap(ntm1,k)*sp(k)*dp(k)*pl_i*two
          sumc1=sumc1+ap(ntm1,k)*cp(k)*dp(k)*pl_i*two
        enddo
      end if
!
      buf0=(/sums0,sumc0/)
      buf1=(/sums1,sumc1/)
!
! ****** Sum over all processors.
!
      call sum_over_phi (2,buf0,buf1)
!
      sums0=buf0(1)
      sumc0=buf0(2)
      sums1=buf1(1)
      sumc1=buf1(2)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do k=1,np
          at(1,k)=sumc0*sph(k)-sums0*cph(k)
        enddo
        do k=1,npm1
          ap(1,k)=two*( sums0*sp(k)+sumc0*cp(k))-ap(2,k)
        enddo
      end if
!
      if (tb1) then
        do k=1,np
          at(ntm1,k)=-sumc1*sph(k)+sums1*cph(k)
        enddo
        do k=1,npm1
          ap(nt,k)=two*( sums1*sp(k)+sumc1*cp(k))-ap(ntm1,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine set_pole_bc_vvec (v)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** defined on the v mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ) :: temp_sum1,temp_sum2
      real(r_typ), allocatable, dimension(:) :: sum0,sum1
      real(r_typ),dimension(:,:,:),pointer,contiguous :: v_r,v_t,v_p
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
!
! ****** Optimization: use ptrs to avoid type hopping within GPU kernel.
!
      v_r=>v%r
      v_t=>v%t
      v_p=>v%p
!
! ****** Get the local sums (on this processor).
! ****** The m=0 and m=1 components are all stored in one long array
! ****** for MPI efficiency (and to avoid buffers).
! ****** sum0(1:nrm)              -> sum0
! ****** sum0(nrm+1:nrm+nr)       -> sums0
! ****** sum0(nrm+nr+1:nrm+nr+nr) -> sumc0
!
      allocate (sum0(nrm+nr+nr))
      allocate (sum1(nrm+nr+nr))
!$acc enter data create(sum0,sum1)
!
      do concurrent (i=1:nrm+nr+nr)
        sum0(i)=0.
        sum1(i)=0.
      enddo
!
! ****** vr has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+v_r(i,2,k)*dph(k)*pl_i*two
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+v_r(i,ntm1,k)*dph(k)*pl_i*two
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** vt and vp have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+v_p(i,2,k)*sp(k)*dp(k)*pl_i*two
            temp_sum2=temp_sum2+v_p(i,2,k)*cp(k)*dp(k)*pl_i*two
          enddo
          sum0(nrm+i)=temp_sum1
          sum0(nrm+nr+i)=temp_sum2
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+v_p(i,ntm1,k)*sp(k)*dp(k)*pl_i*two
            temp_sum2=temp_sum2+v_p(i,ntm1,k)*cp(k)*dp(k)*pl_i*two
          enddo
          sum1(nrm+i)=temp_sum1
          sum1(nrm+nr+i)=temp_sum2
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nrm+nr+nr,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:np, i=1:nrm)
          v_r(i,1,k)=sum0(i)-v_r(i,2,k)
        enddo
!
        do concurrent (k=1:np, i=1:nr)
          v_t(i,1,k)=sum0(nrm+nr+i)*sph(k)-sum0(nrm+i)*cph(k)
        enddo
!
        do concurrent (k=1:npm1, i=1:nr)
          v_p(i,1,k)= two*( sum0(nrm+i)*sp(k)+sum0(nrm+nr+i)*cp(k) ) &
                      -v_p(i,2,k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np, i=1:nrm)
          v_r(i,nt,k)=sum1(i)-v_r(i,ntm1,k)
        enddo
!
        do concurrent (k=1:np, i=1:nr)
          v_t(i,ntm1,k)=-sum1(nrm+nr+i)*sph(k)+sum1(nrm+i)*cph(k)
        enddo
!
        do concurrent (k=1:npm1, i=1:nr)
          v_p(i,nt,k)= two*( sum1(nrm+i)*sp(k)+sum1(nrm+nr+i)*cp(k)) &
                       -v_p(i,ntm1,k)
        enddo
      end if
!
!$acc exit data delete(sum0,sum1)
!
      deallocate(sum0)
      deallocate(sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_vvec_cpu (v)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** defined on the v mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ), allocatable, dimension(:) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
! ****** The m=0 and m=1 components are all stored in one long array
! ****** for MPI efficiency (and to avoid buffers).
! ****** sum0(1:nrm)              -> sum0
! ****** sum0(nrm+1:nrm+nr)       -> sums0
! ****** sum0(nrm+nr+1:nrm+nr+nr) -> sumc0
!
      allocate (sum0(nrm+nr+nr))
      allocate (sum1(nrm+nr+nr))
!
      do i=1,nrm+nr+nr
        sum0(i)=0.
        sum1(i)=0.
      enddo
!
! ****** vr has only an m=0 component.
!
      if (tb0) then
        do k=2,npm1
          do i=1,nrm
            sum0(i)=sum0(i)+v%r(i,2,k)*dph(k)*pl_i*two
          enddo
        enddo
      end if
!
      if (tb1) then
        do k=2,npm1
          do i=1,nrm
            sum1(i)=sum1(i)+v%r(i,ntm1,k)*dph(k)*pl_i*two
          enddo
        enddo
      end if
!
! ****** vt and vp have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do k=2,npm1
          do i=1,nr
            sum0(nrm+i)=sum0(nrm+i)+v%p(i,2,k)*sp(k)*dp(k)*pl_i*two
            sum0(nrm+nr+i)=sum0(nrm+nr+i) &
                           +v%p(i,2,k)*cp(k)*dp(k)*pl_i*two
          enddo
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do k=2,npm1
          do i=1,nr
            sum1(nrm+i)=sum1(nrm+i)+v%p(i,ntm1,k)*sp(k)*dp(k)*pl_i*two
            sum1(nrm+nr+i)=sum1(nrm+nr+i) &
                           +v%p(i,ntm1,k)*cp(k)*dp(k)*pl_i*two
          enddo
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nrm+nr+nr,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do k=1,np
          do i=1,nrm
            v%r(i,1,k)=sum0(i)-v%r(i,2,k)
          enddo
        enddo
        do k=1,np
          do i=1,nr
            v%t(i,1,k)=sum0(nrm+nr+i)*sph(k)-sum0(nrm+i)*cph(k)
          enddo
        enddo
        do k=1,npm1
          do i=1,nr
            v%p(i,1,k)= two*( sum0(nrm+i)*sp(k)+sum0(nrm+nr+i)*cp(k) ) &
                        -v%p(i,2,k)
          enddo
        enddo
      end if
!
      if (tb1) then
        do k=1,np
          do i=1,nrm
            v%r(i,nt,k)=sum1(i)-v%r(i,ntm1,k)
          enddo
        enddo
        do k=1,np
          do i=1,nr
            v%t(i,ntm1,k)=-sum1(nrm+nr+i)*sph(k)+sum1(nrm+i)*cph(k)
          enddo
        enddo
        do k=1,npm1
          do i=1,nr
            v%p(i,nt,k)= two*( sum1(nrm+i)*sp(k)+sum1(nrm+nr+i)*cp(k)) &
                         -v%p(i,ntm1,k)
          enddo
        enddo
      end if
!
      deallocate(sum0)
      deallocate(sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_vvec_tp (vt,vp)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** in the (t,p) plane defined on the v mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,np) :: vt
      real(r_typ), dimension(nt,npm) :: vp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: k
      real(r_typ) :: sums0,sumc0
      real(r_typ) :: sums1,sumc1
      real(r_typ), dimension(2) :: buf0,buf1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      sums0=0.
      sumc0=0.
      sums1=0.
      sumc1=0.
!
! ****** vt and vp have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
!$acc parallel loop default(present) copy(sums0,sumc0) &
!$acc                         reduction(+:sums0,sumc0)
!$omp parallel do default(shared) reduction(+:sums0,sumc0)
        do k=2,npm1
          sums0=sums0+vp(2,k)*sp(k)*dp(k)*pl_i*two
          sumc0=sumc0+vp(2,k)*cp(k)*dp(k)*pl_i*two
        enddo
!$omp end parallel do
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
!$acc parallel loop default(present) copy(sums1,sumc1) &
!$acc                         reduction(+:sums1,sumc1)
!$omp parallel do default(shared) reduction(+:sums1,sumc1)
        do k=2,npm1
          sums1=sums1+vp(ntm1,k)*sp(k)*dp(k)*pl_i*two
          sumc1=sumc1+vp(ntm1,k)*cp(k)*dp(k)*pl_i*two
        enddo
!$omp end parallel do
      end if
!
      buf0=(/sums0,sumc0/)
      buf1=(/sums1,sumc1/)
!
! ****** Sum over all processors.
!
      call sum_over_phi (2,buf0,buf1)
!
      sums0=buf0(1)
      sumc0=buf0(2)
      sums1=buf1(1)
      sumc1=buf1(2)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:np)
          vt(1,k)=sumc0*sph(k)-sums0*cph(k)
        enddo
        do concurrent (k=1:npm)
          vp(1,k)=two*(sums0*sp(k)+sumc0*cp(k))-vp(2,k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np)
          vt(ntm1,k)=-sumc1*sph(k)+sums1*cph(k)
        enddo
        do concurrent (k=1:npm)
          vp(nt,k)=two*(sums1*sp(k)+sumc1*cp(k))-vp(ntm1,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine set_pole_bc_vvec_tp_cpu (vt,vp)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** in the (t,p) plane defined on the v mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,np) :: vt
      real(r_typ), dimension(nt,npm) :: vp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: k
      real(r_typ) :: sums0,sumc0
      real(r_typ) :: sums1,sumc1
      real(r_typ), dimension(2) :: buf0,buf1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      sums0=0.
      sumc0=0.
      sums1=0.
      sumc1=0.
!
! ****** vt and vp have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do k=2,npm1
          sums0=sums0+vp(2,k)*sp(k)*dp(k)*pl_i*two
          sumc0=sumc0+vp(2,k)*cp(k)*dp(k)*pl_i*two
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do k=2,npm1
          sums1=sums1+vp(ntm1,k)*sp(k)*dp(k)*pl_i*two
          sumc1=sumc1+vp(ntm1,k)*cp(k)*dp(k)*pl_i*two
        enddo
      end if
!
      buf0=(/sums0,sumc0/)
      buf1=(/sums1,sumc1/)
!
! ****** Sum over all processors.
!
      call sum_over_phi (2,buf0,buf1)
!
      sums0=buf0(1)
      sumc0=buf0(2)
      sums1=buf1(1)
      sumc1=buf1(2)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        vt(1,:)= sumc0*sph(:)-sums0*cph(:)
        vp(1,:)= two*( sums0*sp(:)+sumc0*cp(:)) &
                -vp(2,:)
      end if
!
      if (tb1) then
        vt(ntm1,:)=-sumc1*sph(:)+sums1*cph(:)
        vp(nt,:)= two*( sums1*sp(:)+sumc1*cp(:)) &
                 -vp(ntm1,:)
      end if
!
end subroutine
!#######################################################################
subroutine set_pole_bc_bvec (b)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** defined on the B mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ) :: temp_sum1,temp_sum2
      real(r_typ), allocatable, dimension(:) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
! ****** The m=0 and m=1 components are all stored in one long array
! ****** for MPI efficiency and to avoid buffers.
! ****** sum0(1:nr)                   -> sum0
! ****** sum0(nr+1:nr+nrm1)           -> sums0
! ****** sum0(nr+nrm1+1:nr+nrm1+nrm1) -> sumc0
!
      allocate (sum0(nr+nrm1+nrm1))
      allocate (sum1(nr+nrm1+nrm1))
!$acc enter data create(sum0,sum1)
!
      do concurrent (i=1:nr+nrm1+nrm1)
        sum0(i)=0.
        sum1(i)=0.
      enddo
!
! ****** Br has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+b%r(i,1,k)*dp(k)*pl_i
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+b%r(i,ntm1,k)*dp(k)*pl_i
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** Bt and Bp have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do concurrent (i=1:nrm1)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+b%t(i,2,k)*sp(k)*dp(k)*pl_i*two
            temp_sum2=temp_sum2+b%t(i,2,k)*cp(k)*dp(k)*pl_i*two
          enddo
          sum0(nr+i)=temp_sum1
          sum0(nr+nrm1+i)=temp_sum2
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do concurrent (i=1:nrm1)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+b%t(i,ntm1,k)*sp(k)*dp(k)*pl_i*two
            temp_sum2=temp_sum2+b%t(i,ntm1,k)*cp(k)*dp(k)*pl_i*two
          enddo
          sum1(nr+i)=temp_sum1
          sum1(nr+nrm1+i)=temp_sum2
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nr+nrm1+nrm1,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:npm1, i=1:nr)
          b%r(i,1,k)=sum0(i)
        enddo
!
        do concurrent (k=1:npm1, i=1:nrm1)
          b%t(i,1,k)=two*( sum0(nr+i)*sp(k)+sum0(nr+nrm1+i)*cp(k) ) &
                     -b%t(i,2,k)
        enddo
!
        do concurrent (k=1:np, i=1:nrm1)
          b%p(i,1,k)=-sum0(nr+nrm1+i)*sph(k)+sum0(nr+i)*cph(k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:npm1, i=1:nr)
          b%r(i,ntm1,k)=sum1(i)
        enddo
!
        do concurrent (k=1:npm1, i=1:nrm1)
          b%t(i,nt,k)=two*(sum1(nr+i)*sp(k)+sum1(nr+nrm1+i)*cp(k)) &
                     -b%t(i,ntm1,k)
        enddo
!
        do concurrent (k=1:np, i=1:nrm1)
          b%p(i,ntm1,k)=sum1(nr+nrm1+i)*sph(k)-sum1(nr+i)*cph(k)
        enddo
      end if
!
!$acc exit data delete(sum0,sum1)
!
      deallocate(sum0)
      deallocate(sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_bvec_cpu (b)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** defined on the B mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ), allocatable, dimension(:) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
! ****** The m=0 and m=1 components are all stored in one long array
! ****** for MPI efficiency and to avoid buffers.
! ****** sum0(1:nr)                   -> sum0
! ****** sum0(nr+1:nr+nrm1)           -> sums0
! ****** sum0(nr+nrm1+1:nr+nrm1+nrm1) -> sumc0
!
      allocate (sum0(nr+nrm1+nrm1))
      allocate (sum1(nr+nrm1+nrm1))
!
      do i=1,nr+nrm1+nrm1
        sum0(i)=0.
        sum1(i)=0.
      end do
!
! ****** Br has only an m=0 component.
!
      if (tb0) then
        do k=2,npm1
          do i=1,nr
            sum0(i)=sum0(i)+b%r(i,1,k)*dp(k)*pl_i
          enddo
        enddo
      end if
!
      if (tb1) then
        do k=2,npm1
          do i=1,nr
            sum1(i)=sum1(i)+b%r(i,ntm1,k)*dp(k)*pl_i
          enddo
        enddo
      end if
!
! ****** Bt and Bp have only an m=1 component.
!
      if (tb0.and.(.not.axisymmetric)) then
        do k=2,npm1
          do i=1,nrm1
            sum0(nr+i)=sum0(nr+i)+b%t(i,2,k)*sp(k)*dp(k)*pl_i*two
            sum0(nr+nrm1+i)=sum0(nr+nrm1+i) &
                            +b%t(i,2,k)*cp(k)*dp(k)*pl_i*two
          enddo
        enddo
      end if
!
      if (tb1.and.(.not.axisymmetric)) then
        do k=2,npm1
          do i=1,nrm1
            sum1(nr+i)=sum1(nr+i)+b%t(i,ntm1,k)*sp(k)*dp(k)*pl_i*two
            sum1(nr+nrm1+i)=sum1(nr+nrm1+i) &
                            +b%t(i,ntm1,k)*cp(k)*dp(k)*pl_i*two
          enddo
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nr+nrm1+nrm1,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do k=1,npm1
          do i=1,nr
            b%r(i,1,k)=sum0(i)
          enddo
        enddo
        do k=1,npm1
          do i=1,nrm1
            b%t(i,1,k)=two*( sum0(nr+i)*sp(k)+sum0(nr+nrm1+i)*cp(k) ) &
                       -b%t(i,2,k)
          enddo
        enddo
        do k=1,np
          do i=1,nrm1
            b%p(i,1,k)=-sum0(nr+nrm1+i)*sph(k)+sum0(nr+i)*cph(k)
          enddo
        enddo
      end if
!
      if (tb1) then
        do k=1,npm1
          do i=1,nr
            b%r(i,ntm1,k)=sum1(i)
          enddo
        enddo
        do k=1,npm1
          do i=1,nrm1
            b%t(i,nt,k)=two*(sum1(nr+i)*sp(k)+sum1(nr+nrm1+i)*cp(k)) &
                       -b%t(i,ntm1,k)
          enddo
        enddo
        do k=1,np
          do i=1,nrm1
            b%p(i,ntm1,k)=sum1(nr+nrm1+i)*sph(k)-sum1(nr+i)*cph(k)
          enddo
        enddo
      end if
!
      deallocate(sum0)
      deallocate(sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_scalar_hhh (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a scalar
! ****** defined on the (rh,th,ph) mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ) :: temp_sum1
      real(r_typ), dimension(nr) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
!$acc enter data create(sum0,sum1)
      do concurrent (i=1:nr)
        sum0(i)=0.
        sum1(i)=0.
      end do
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a(i,2,k)*dph(k)*pl_i*two
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a(i,ntm1,k)*dph(k)*pl_i*two
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nr,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:np, i=1:nr)
          a(i, 1,k)=sum0(i)-a(i,   2,k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np, i=1:nr)
          a(i,nt,k)=sum1(i)-a(i,ntm1,k)
        enddo
      end if
!
!$acc exit data delete(sum0,sum1)
end subroutine
!#######################################################################
subroutine set_pole_bc_scalar_hhh_cpu (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a scalar
! ****** defined on the (rh,th,ph) mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ), dimension(nr) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      do i=1,nr
        sum0(i)=0.
        sum1(i)=0.
      end do
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
        do k=2,npm1
          sum0(:)=sum0(:)+a(:,2,k)*dph(k)*pl_i*two
        enddo
      end if
!
      if (tb1) then
        do k=2,npm1
          sum1(:)=sum1(:)+a(:,ntm1,k)*dph(k)*pl_i*two
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nr,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do k=1,np
          a(:, 1,k)=sum0(:)-a(:,   2,k)
        enddo
      end if
!
      if (tb1) then
        do k=1,np
          a(:,nt,k)=sum1(:)-a(:,ntm1,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine smooth_poles_scalars (a)
!
!-----------------------------------------------------------------------
!
! ****** Smooth the inner polar points of hhh scalars [KLUDGE].
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: a
!
!-----------------------------------------------------------------------
!
      integer :: k,i
      real(r_typ) :: temp_sum1
      real(r_typ), dimension(nr) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!$acc enter data create(sum0,sum1)
!
! ****** Get the local sums (on this processor).
!
      do concurrent (i=1:nr)
        sum0(i)=0.
        sum1(i)=0.
      enddo
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a(i,2,k)*dph(k)*pl_i
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a(i,ntm1,k)*dph(k)*pl_i
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nr,sum0,sum1)
!
! ****** Set the inner point and ghost points for all phi to pole avg.
!
      if (tb0) then
        do concurrent (k=1:np, i=1:nr)
          a(i, 2,k)=sum0(i)
          a(i, 1,k)=sum0(i)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np, i=1:nr)
          a(i,ntm1,k)=sum1(i)
          a(i,nt,k)=sum1(i)
        enddo
      end if
!$acc exit data delete(sum0,sum1)
!
end subroutine
!#######################################################################
subroutine smooth_poles_vr (a)
!
!-----------------------------------------------------------------------
!
! ****** Smooth the inner polar points of vr [KLUDGE].
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,nt,np) :: a
!
!-----------------------------------------------------------------------
!
      integer :: k,i
      real(r_typ) :: temp_sum1
      real(r_typ), dimension(nrm) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!$acc enter data create(sum0,sum1)
!
! ****** Get the local sums (on this processor).
!
      do concurrent (i=1:nrm)
        sum0(i)=0.
        sum1(i)=0.
      enddo
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a(i,2,k)*dph(k)*pl_i
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+a(i,ntm1,k)*dph(k)*pl_i
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nrm,sum0,sum1)
!
! ****** Set the inner point and ghost points for all phi to pole avg.
!
      if (tb0) then
        do concurrent (k=1:np, i=1:nrm)
          a(i, 2,k)=sum0(i)
          a(i, 1,k)=sum0(i)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np, i=1:nrm)
          a(i,ntm1,k)=sum1(i)
          a(i,nt,k)=sum1(i)
        enddo
      end if
!
!$acc exit data delete(sum0,sum1)
end subroutine
!#######################################################################
subroutine set_pole_bc_scalar_mmm (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a scalar
! ****** defined on the (r,t,p) main mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: a
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ) :: temp_sum1
      real(r_typ), dimension(nrm) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!$acc enter data create(sum0,sum1)
!
! ****** Get the local sums (on this processor).
!
      do concurrent (i=1:nrm)
        sum0(i)=0.
        sum1(i)=0.
      enddo
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm-1
            temp_sum1=temp_sum1+a(i,2,k)*dp(k)*pl_i
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm-1
            temp_sum1=temp_sum1+a(i,ntm-1,k)*dp(k)*pl_i
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nrm,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:npm,i=1:nrm)
          a(i,1,k)=sum0(i)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:npm,i=1:nrm)
          a(i,ntm,k)=sum1(i)
        enddo
      end if
!$acc exit data delete (sum0,sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_divb_phi (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for
! ****** phi defined on the (r,t,p) main mesh for the divb solver.
! ****** This performs a internal phi average to set the pole.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: a
!
!-----------------------------------------------------------------------
!
      integer :: i,k
      real(r_typ) :: temp_sum1
      real(r_typ), dimension(nrm) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!$acc enter data create(sum0,sum1)
!
! ****** Get the local sums (on this processor).
!
      do concurrent (i=1:nrm)
        sum0(i)=0.
        sum1(i)=0.
      enddo
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm-1
            temp_sum1=temp_sum1+a(i,2,k)*dp(k)*pl_i
          enddo
          sum0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nrm)
          temp_sum1=0.
          do k=2,npm-1
            temp_sum1=temp_sum1+a(i,ntm-1,k)*dp(k)*pl_i
          enddo
          sum1(i)=temp_sum1
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nrm,sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:npm,i=1:nrm)
          a(i,1,k)=sum0(i)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:npm,i=1:nrm)
          a(i,ntm,k)=sum1(i)
        enddo
      end if
!$acc exit data delete (sum0,sum1)
!
end subroutine
!#######################################################################
subroutine set_pole_bc_scalar_tp_hh (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a 2D scalar
! ****** on the (th,ph) mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
      integer :: k
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      sum0=0.
      sum1=0.
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
!$acc parallel loop default(present) reduction(+:sum0)
!$omp parallel do default(shared) reduction(+:sum0)
        do k=2,npm1
          sum0=sum0+a(2,k)*dph(k)*pl_i*two
        enddo
!$omp end parallel do
      end if
!
      if (tb1) then
!$acc parallel loop default(present) reduction(+:sum1)
!$omp parallel do default(shared) reduction(+:sum1)
        do k=2,npm1
          sum1=sum1+a(ntm1,k)*dph(k)*pl_i*two
        enddo
!$omp end parallel do
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi_scalars (sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:np)
          a( 1,k)=sum0-a(   2,k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:np)
          a(nt,k)=sum1-a(ntm1,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine set_pole_bc_scalar_tp_hh_cpu (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a 2D scalar
! ****** on the (th,ph) mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
      integer :: k
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      sum0=0.
      sum1=0.
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
        do k=2,npm1
          sum0=sum0+a(2,k)*dph(k)*pl_i*two
        enddo
      end if
!
      if (tb1) then
        do k=2,npm1
          sum1=sum1+a(ntm1,k)*dph(k)*pl_i*two
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi_scalars (sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        a( 1,:)=sum0-a(   2,:)
      end if
!
      if (tb1) then
        a(nt,:)=sum1-a(ntm1,:)
      end if
!
end subroutine
!#######################################################################
subroutine set_pole_bc_scalar_tp_mm (a)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a 2D scalar
! ****** on the (t,p) mesh.
! ****** This ensures the pole is a single scalar value
! ****** since it was computed over individual phi locations.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sum0,sum1
!
!-----------------------------------------------------------------------
!
      integer :: k
!
!-----------------------------------------------------------------------
!
! ****** If this processor does not contain any points at the
! ****** pole, return.
!
      if (.not.(tb0.or.tb1)) return
!
! ****** Get the local sums (on this processor).
!
      sum0=0.
      sum1=0.
!
! ****** A scalar has only an m=0 component.
!
      if (tb0) then
!$acc parallel loop default(present) reduction(+:sum0)
!$omp parallel do default(shared) reduction(+:sum0)
        do k=2,npm-1
          sum0=sum0+a(1,k)*dp(k)*pl_i
        enddo
!$omp end parallel do
      end if
!
      if (tb1) then
!$acc parallel loop default(present) reduction(+:sum1)
!$omp parallel do default(shared) reduction(+:sum1)
        do k=2,npm-1
          sum1=sum1+a(ntm,k)*dp(k)*pl_i
        enddo
!$omp end parallel do
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi_scalars (sum0,sum1)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        do concurrent (k=1:npm)
          a( 1,k)=sum0
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=1:npm)
          a(ntm,k)=sum1
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine sum_over_phi (n,a0,a1)
!
!-----------------------------------------------------------------------
!
! ****** Perform a sum over all processors
! ****** in the phi dimension for arrays A0(N) and A1(N) at the
! ****** north and south poles.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals, ONLY : tb0,tb1
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n)   :: a0,a1
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_SUMPHI)
!
      if (tb0) then
!
! ****** Sum over all processors.
!
!$acc host_data use_device(a0) if_present
        call MPI_Allreduce (MPI_IN_PLACE,a0,n,ntype_real, &
                            MPI_SUM,comm_phi,ierr)
!$acc end host_data
!
      end if
!
      if (tb1) then
!
! ****** Sum over all processors.
!
!$acc host_data use_device(a1) if_present
        call MPI_Allreduce (MPI_IN_PLACE,a1,n,ntype_real, &
                            MPI_SUM,comm_phi,ierr)
!$acc end host_data
!
      end if
!
      if (use_timer) call timer (TIME_SUMPHI)
!
end subroutine
!#######################################################################
subroutine sum_over_phi_scalars (a0,a1)
!
!-----------------------------------------------------------------------
!
! ****** Perform a sum over all processors
! ****** in the phi dimension for scalars A0 and A1 at the
! ****** north and south poles.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals, ONLY : tb0,tb1
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: a0,a1
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_SUMPHI)
!
      if (tb0) then
!
! ****** Sum over all processors.
!
        call MPI_Allreduce (MPI_IN_PLACE,a0,1,ntype_real, &
                            MPI_SUM,comm_phi,ierr)
!
      end if
!
      if (tb1) then
!
! ****** Sum over all processors.
!
        call MPI_Allreduce (MPI_IN_PLACE,a1,1,ntype_real, &
                            MPI_SUM,comm_phi,ierr)
!
      end if
!
      if (use_timer) call timer (TIME_SUMPHI)
!
end subroutine
!#######################################################################
function sum_p (npts_r,npts_p,f,w)
!
!-----------------------------------------------------------------------
!
! ****** Get the local sum over phi on this processor of field F
! ****** weighted by the phi function W using extended precision.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh, ONLY : pl_i !(1/(2*pi))
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: npts_r
      integer :: npts_p
      real(r_typ),    dimension(npts_r,npts_p) :: f
      real(r_typ),    dimension(npts_p)        :: w
      real(r_typ),    dimension(npts_r)        :: sum_p
!
!-----------------------------------------------------------------------
!
      integer :: k
!
!-----------------------------------------------------------------------
!
      sum_p=0.
!
      do k=1,npts_p
        sum_p(:)=sum_p(:)+f(:,k)*w(k)
      enddo
!
      sum_p=sum_p*pl_i
!
      return
end function
!#######################################################################
subroutine adva
!
!-----------------------------------------------------------------------
!
! ****** Advance the vector potential.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use cgcom
      use mpidefs
      use timing
      use debug
      use eta_photosphere
      use upwind_resistivity
      use emerging_flux_params, ONLY :  tdc_edb_correction_etmod
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      type(avec) :: ap,vxb,rhs
      type(bvec) :: bp
!
!-----------------------------------------------------------------------
!
! ****** Tangential components of A at the boundaries.
!
      type(avec_bc) :: ap_b,vxb_b
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      integer :: ierr
!
      real(r_typ) :: dv,sig,dtime_i
      real(r_typ) :: vxb_fac
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVA)
!
      dtime_i=one/dtime
!
! ****** Allocate the temporary vectors.
!
      call alloc_avec (ap)
      call alloc_avec (vxb)
      call alloc_avec (rhs)
      call alloc_bvec (bp)
      call alloc_avec_bc (ap_b)
      call alloc_avec_bc (vxb_b)
!
! ****** Copy A at the present time step to the E arrays for later
! ****** use in getting the electric field.
!
      call copy_avec (a,e)
!
!-----------------------------------------------------------------------
! ****** Predictor step.
!-----------------------------------------------------------------------
!
      if (pred_a) then
!
! ****** Get v x B.
!
        if (experimental_a_advance) then
          vxb_fac=half
          call vcrossb_centered (v,b,vxb,vxb_b)
        else
          vxb_fac=betapc_a
          call vcrossb (v,b,vxb,vxb_b)
        end if
!
! ****** Get the predicted A at the internal points.
!
        do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
          ap%r(i,j,k)=a%r(i,j,k)+vxb_fac*dtime*vxb%r(i,j,k)
        enddo
!
        do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
          ap%t(i,j,k)=a%t(i,j,k)+vxb_fac*dtime*vxb%t(i,j,k)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
          ap%p(i,j,k)=a%p(i,j,k)+vxb_fac*dtime*vxb%p(i,j,k)
        enddo
!
! ****** Get the predicted A at the boundary points in AP_B.
!
        call get_at_b (a,ap_b)
!
        call advance_a_b (ap_b,vxb_b,vxb_fac)
!
! ****** Set boundary conditions on AP.
!
        call set_bc_a (ap_b,ap,one)
!
        call seam_avec (ap)
!
! ****** Get the predicted B.
!
        call bfroma (ap,bp,one)
!
      else
!
        call copy_bvec(b,bp)
!
      end if
!
!-----------------------------------------------------------------------
! ****** Corrector step.
!-----------------------------------------------------------------------
!
! ****** Get v x B.
!
      if (experimental_a_advance) then
        call vcrossb_centered (v,bp,vxb,vxb_b)
      else
        call vcrossb (v,bp,vxb,vxb_b)
      end if
!
! ****** Get the corrected A at the boundary points.
! ****** Note that this loads the structure AB in module FIELDS with
! ****** the tangential boundary values of A.
!
      call get_at_b (a,ab)
!
! ****** Diffuse A-tangential at the boundary if photospheric
! ****** resistivity is enabled.
!
      if (ifeta_phot.or.tdc_edb_correction_etmod) then
        if (rb0) then
          call adv_dsq_a_at_bc (ab)
        end if
      end if
!
      call advance_a_b (ab,vxb_b,one)
!
! ****** Load the averaged resistivity arrays that are used
! ****** in the A solve.
!
      allocate (eta_av_ar(nrm1,nt,np))
      allocate (eta_av_at(nr,ntm1,np))
      allocate (eta_av_ap(nr,nt,npm1))
!$acc enter data create(eta_av_ar,eta_av_at,eta_av_ap)
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm1)
        eta_av_ar(i,j,k)=0.
      enddo
!
      do concurrent (k=1:np, j=1:ntm1, i=1:nr)
        eta_av_at(i,j,k)=0.
      enddo
!
      do concurrent (k=1:npm1, j=1:nt, i=1:nr)
        eta_av_ap(i,j,k)=0.
      enddo
!
      call load_average_resistivity
!
! ****** Form the RHS and
! ****** get the initial guess for A for the solution of the
! ****** implicit resistivity equations.
!
! ****** Use A advanced by the explicit part of the solution.
! ****** This ought to make the CG solver converge in zero steps
! ****** when the resistivity is small (and, of course, for ideal
! ****** MHD).
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        dv=r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
        sig=one/max(eta_av_ar(i,j,k),small_value)
        rhs%r(i,j,k)=dv*sig*(a%r(i,j,k)+dtime*vxb%r(i,j,k))
!
        a%r(i,j,k)=a%r(i,j,k)+dtime*(vxb%r(i,j,k) &
                             -eta_av_ar(i,j,k)*fj%r(i,j,k))
      enddo
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        dv=rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
        sig=one/max(eta_av_at(i,j,k),small_value)
        rhs%t(i,j,k)=dv*sig*(a%t(i,j,k)+dtime*vxb%t(i,j,k))
!
        a%t(i,j,k)=a%t(i,j,k)+dtime*(vxb%t(i,j,k) &
                             -eta_av_at(i,j,k)*fj%t(i,j,k))
      enddo
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        dv=rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
        sig=one/max(eta_av_ap(i,j,k),small_value)
        rhs%p(i,j,k)=dv*sig*(a%p(i,j,k)+dtime*vxb%p(i,j,k))
!
        a%p(i,j,k)=a%p(i,j,k)+dtime*(vxb%p(i,j,k) &
                             -eta_av_ap(i,j,k)*fj%p(i,j,k))
      enddo
!
! ****** Solve the implicit equations for resistivity.
!
      equation_solved=EQ_A
!
      call a_solver (rhs,a,ab)
!
! ****** Remove temporary arrays.
!
!$acc exit data delete(eta_av_ar,eta_av_at,eta_av_ap)
      deallocate (eta_av_ar)
      deallocate (eta_av_at)
      deallocate (eta_av_ap)
!
! ****** Seam the final vector potential.
!
      call seam_avec (a)
!
! ****** Get B and J.
!
      call bfroma (a,b,one)
      call jfromb (b,fj)
!
! ****** Get the electric field in E structure.  Note that E was
! ****** loaded with the vector potential at the previous time step
! ****** at the beginning of this routine.
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm1)
        e%r(i,j,k)=-(a%r(i,j,k)-e%r(i,j,k))*dtime_i
      enddo
!
      do concurrent (k=1:np, j=1:ntm1, i=1:nr)
        e%t(i,j,k)=-(a%t(i,j,k)-e%t(i,j,k))*dtime_i
      enddo
!
      do concurrent (k=1:npm1, j=1:nt, i=1:nr)
        e%p(i,j,k)=-(a%p(i,j,k)-e%p(i,j,k))*dtime_i
      enddo
!
! ****** Deallocate the temporary vectors.
!
      call dealloc_avec (ap)
      call dealloc_avec (vxb)
      call dealloc_avec (rhs)
      call dealloc_bvec (bp)
      call dealloc_avec_bc (ap_b)
      call dealloc_avec_bc (vxb_b)
!
      if (use_timer) call timer (TIME_ADVA)
!
end subroutine
!#######################################################################
subroutine write_matrix_a
!
!-----------------------------------------------------------------------
!
! ****** Write the matrix for the implicit resistivity solve
! ****** to a file. This can be useful for debugging.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types
      use mpidefs
      use cgcom
      use vars
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      type(avec) :: a,aa
!
      integer :: n
      real(r_typ), dimension(:), allocatable :: x1d,y1d,xvec,dummy
      real(r_typ), dimension(:,:), allocatable :: amat
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k,l
!
!-----------------------------------------------------------------------
!
! ****** Write the 3D matrix to a file.
!
      if (nproc.ne.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from WRITE_MATRIX_ADVA:'
          write (*,*) '### Could not write the matrix.'
          write (*,*) '### For this diagnostic you must run'// &
                      ' on only 1 processor.'
        end if
        return
      end if
!
      N_CG=N_cgvec
      call alloc_cg_ax_tmp
!
! ****** Set the dimension of the matrix.
!
      n=  nrm1   *(nt  -2)*(np-2) &
        +(nr  -2)*(ntm1-2)*(np-2) &
        +(nr  -2)*(nt  -2)*(np-2)
!
! ****** Allocate storage.
!
      call alloc_avec (a)
      call alloc_avec (aa)
!
      allocate (x1d(N_cgvec))
      allocate (y1d(N_cgvec))
      x1d=0.
      y1d=0.
!
      allocate (amat(n,n))
      allocate (xvec(n))
      allocate (dummy(1))
!
      amat=0.
!
! ****** Process the r component.
!
      l=0
!
      do k=2,npm1
        do j=2,ntm1
          do i=1,nrm1
            l=l+1
            a%r=0.
            a%t=0.
            a%p=0.
            a%r(i,j,k)=one
            call pack_avec (a,x1d)
            call ax_a (x1d,y1d)
            call unpack_avec (aa,y1d)
            call avec_to_1d (aa,n,xvec)
            amat(:,l)=xvec(:)
          enddo
        enddo
      enddo
!
! ****** Process the theta component.
!
      do k=2,npm1
        do j=2,ntm2
          do i=2,nrm1
            l=l+1
            a%r=0.
            a%t=0.
            a%p=0.
            a%t(i,j,k)=one
            call pack_avec (a,x1d)
            call ax_a (x1d,y1d)
            call unpack_avec (aa,y1d)
            call avec_to_1d (aa,n,xvec)
            amat(:,l)=xvec(:)
          enddo
        enddo
      enddo
!
! ****** Process the phi component.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            l=l+1
            a%r=0.
            a%t=0.
            a%p=0.
            a%p(i,j,k)=one
            call pack_avec (a,x1d)
            call ax_a (x1d,y1d)
            call unpack_avec (aa,y1d)
            call avec_to_1d (aa,n,xvec)
            amat(:,l)=xvec(:)
          enddo
        enddo
      enddo
!
      call wrhdf_2d ('amat_adva.h5',.false.,n,n,amat,dummy,dummy, &
                     hdf32,ierr)
!
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### WARNING from WRITE_MATRIX_ADVA:'
        write (*,*) '### Could not write the matrix.'
        write (*,*) 'IERR (from WRHDF_2D) = ',ierr
      else
        write (*,*)
        write (*,*) '### COMMENT from WRITE_MATRIX_ADVA:'
        write (*,*) 'Wrote the matrix for the implicit'// &
                    ' resistivity solve to file: amat_adva.h5'
      end if
!
      deallocate (xvec)
      deallocate (amat)
      deallocate (dummy)
      deallocate (x1d)
      deallocate (y1d)
!
      call dealloc_avec (a)
      call dealloc_avec (aa)
      call dealloc_cg_ax_tmp
!
end subroutine
!#######################################################################
subroutine avec_to_1d (a,n,xvec)
!
!-----------------------------------------------------------------------
!
! ****** Pack the vector potential in structure A into
! ****** one-dimensional array XVEC.
!
! ****** This routine is used by WRITE_MATRIX_ADVA.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
      integer :: n
      real(r_typ), dimension(n) :: xvec
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
!
!-----------------------------------------------------------------------
!
! ****** Load the r component.
!
      l=0
!
      do k=2,npm1
        do j=2,ntm1
          do i=1,nrm1
            l=l+1
            xvec(l)=a%r(i,j,k)
          enddo
        enddo
      enddo
!
! ****** Load the theta component.
!
      do k=2,npm1
        do j=2,ntm2
          do i=2,nrm1
            l=l+1
            xvec(l)=a%t(i,j,k)
          enddo
        enddo
      enddo
!
! ****** Load the phi component.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            l=l+1
            xvec(l)=a%p(i,j,k)
          enddo
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine vcrossb (v,b,vxb,vxb_b)
!
!-----------------------------------------------------------------------
!
! ****** Compute (v x B).
!
!-----------------------------------------------------------------------
!
! ****** On input, V contains the velocity, and B contains
! ****** the magnetic field.
!
! ****** On return, VXB contains (v x B) at the internal points,
! ****** and VXB_B contains (v x B) at the tangential boundary
! ****** points.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use vars
      use shear_profile
      use drive_profile
      use flow_profile
      use upwind_resistivity
      use interplanetary_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      type(bvec) :: b
      type(avec) :: vxb
      type(avec_bc) :: vxb_b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,i0
      real(r_typ) :: av_vt_p,av_vt_m,av_vp_p,av_vp_m
      real(r_typ) :: av_br_p,av_br_m
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: cr,ct,cp
!
!-----------------------------------------------------------------------
!
! ****** Zero out the v x B array.
!
      call zero_avec (vxb)
!
!-----------------------------------------------------------------------
! ****** Internal points.
!-----------------------------------------------------------------------
!
! ****** Set the r component.
!
      if (rb0) then
        i0=2
      else
        i0=1
      end if
!
      do concurrent (k=2:npm1, j=2:ntm1, i=i0:nrm1)
        av_vt=AVGRT(v%t,i+1,j  ,k  )
        av_vp=AVGRP(v%p,i+1,j  ,k  )
        ct=sign(upwind_at,av_vt)
        cp=sign(upwind_ap,av_vp)
        av_bt=ADVP(b%t,i,j,k,cp)
        av_bp=ADVT(b%p,i,j,k,ct)
        vxb%r(i,j,k)=(av_vt*av_bp-av_vp*av_bt)
      enddo
!
! ****** Set the theta component.
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        av_vr=AVGRT(v%r,i  ,j+1,k  )
        av_vp=AVGTP(v%p,i  ,j+1,k  )
        cr=sign(upwind_ar,av_vr)
        cp=sign(upwind_ap,av_vp)
        av_br=ADVP(b%r,i,j,k,cp)
        av_bp=ADVR(b%p,i,j,k,cr)
        vxb%t(i,j,k)=(av_vp*av_br-av_vr*av_bp)
      enddo
!
! ****** Set the phi component.
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        av_vr=AVGRP(v%r,i  ,j  ,k+1)
        av_vt=AVGTP(v%t,i  ,j  ,k+1)
        cr=sign(upwind_ar,av_vr)
        ct=sign(upwind_at,av_vt)
        av_br=ADVT(b%r,i,j,k,ct)
        av_bt=ADVR(b%t,i,j,k,cr)
        vxb%p(i,j,k)=(av_vr*av_bt-av_vt*av_br)
      enddo
!
! ****** Set boundary conditions and vxb_r at the radial boundaries.
!
      if (interplanetary_run) then
        call bc_vcrossb_interplanetary (v,b,vxb,vxb_b)
      else
        call bc_vcrossb (v,b,vxb,vxb_b)
      end if
!
end subroutine
!#######################################################################
subroutine vcrossb_centered (v,b,vxb,vxb_b)
!
!-----------------------------------------------------------------------
!
! ****** Compute (v x B).
!
!-----------------------------------------------------------------------
!
! ****** On input, V contains the velocity, and B contains
! ****** the magnetic field.
!
! ****** On return, VXB contains (v x B) at the internal points,
! ****** and VXB_B contains (v x B) at the tangential boundary
! ****** points.
!
!-----------------------------------------------------------------------
!
! ****** This routine computes centered (v x B).
! ****** The upwind resistivity that is needed for stable advection
! ****** of A is also computed, and is used in routine ADVA as an
! ****** implicit resistivity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
      use shear_profile
      use drive_profile
      use flow_profile
      use upwind_resistivity
      use seam_rt_interface
      use seam_rp_interface
      use seam_tp_interface
      use emerging_flux_params
      use interplanetary_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      type(bvec) :: b
      type(avec) :: vxb
      type(avec_bc) :: vxb_b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: vdotb,bsq
      real(r_typ) :: v_perp_r,v_perp_t,v_perp_p
      real(r_typ) :: eta_uw_rt,eta_uw_rp
      real(r_typ) :: eta_uw_tr,eta_uw_tp
      real(r_typ) :: eta_uw_pr,eta_uw_pt
!
!-----------------------------------------------------------------------
!
! ****** Zero out the v x B array.
!
      vxb%r=0.
      vxb%t=0.
      vxb%p=0.
!
! ****** Zero out the upwind resistivity.
!
      eta_uw%rt=0.
      eta_uw%rp=0.
      eta_uw%tr=0.
      eta_uw%tp=0.
      eta_uw%pr=0.
      eta_uw%pt=0.
      eta_uw%i=0.
!
!-----------------------------------------------------------------------
! ****** Internal points.
!-----------------------------------------------------------------------
!
! ****** Set the r component.
!
      if (rb0) then
        do k=2,npm1
          do j=2,ntm1
            do i=2,nrm1
              av_vr=AVG   (v%r,i  ,j,k)
              av_vt=AVGRT (v%t,i+1,j,k)
              av_vp=AVGRP (v%p,i+1,j,k)
              av_br=AVGRTP(b%r,i+1,j,k)
              av_bt=AVGP  (b%t,i  ,j,k)
              av_bp=AVGT  (b%p,i  ,j,k)
              vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
              bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
              bsq=max(bsq,small_value)
              v_perp_r=av_vr-vdotb*av_br/bsq
              v_perp_t=av_vt-vdotb*av_bt/bsq
              v_perp_p=av_vp-vdotb*av_bp/bsq
              vxb%r(i,j,k)=av_vt*av_bp-av_vp*av_bt
              eta_uw%rt(i,j,k)=half*abs(v_perp_t)*r(i)*dth(j)
              eta_uw%rp(i,j,k)=half*abs(v_perp_p)*r(i)*sth(j)*dph(k)
            enddo
          enddo
        enddo
      else
        do k=2,npm1
          do j=2,ntm1
            do i=1,nrm1
              av_vr=AVG   (v%r,i  ,j,k)
              av_vt=AVGRT (v%t,i+1,j,k)
              av_vp=AVGRP (v%p,i+1,j,k)
              av_br=AVGRTP(b%r,i+1,j,k)
              av_bt=AVGP  (b%t,i  ,j,k)
              av_bp=AVGT  (b%p,i  ,j,k)
              vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
              bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
              bsq=max(bsq,small_value)
              v_perp_r=av_vr-vdotb*av_br/bsq
              v_perp_t=av_vt-vdotb*av_bt/bsq
              v_perp_p=av_vp-vdotb*av_bp/bsq
              vxb%r(i,j,k)=av_vt*av_bp-av_vp*av_bt
              eta_uw%rt(i,j,k)=half*abs(v_perp_t)*r(i)*dth(j)
              eta_uw%rp(i,j,k)=half*abs(v_perp_p)*r(i)*sth(j)*dph(k)
            enddo
          enddo
        enddo
      end if
!
! ****** Set the theta component.
!
      do k=2,npm1
        do j=1,ntm1
          do i=2,nrm1
            av_vr=AVGRT (v%r,i,j+1,k)
            av_vt=AVG   (v%t,i,j  ,k)
            av_vp=AVGTP (v%p,i,j+1,k)
            av_br=AVGP  (b%r,i,j  ,k)
            av_bt=AVGRTP(b%t,i,j+1,k)
            av_bp=AVGR  (b%p,i,j  ,k)
            vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
            bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
            bsq=max(bsq,small_value)
            v_perp_r=av_vr-vdotb*av_br/bsq
            v_perp_t=av_vt-vdotb*av_bt/bsq
            v_perp_p=av_vp-vdotb*av_bp/bsq
            vxb%t(i,j,k)=av_vp*av_br-av_vr*av_bp
            eta_uw%tr(i,j,k)=half*abs(v_perp_r)*drh(i)
            eta_uw%tp(i,j,k)=half*abs(v_perp_p)*rh(i)*st(j)*dph(k)
          enddo
        enddo
      enddo
!
! ****** Set the phi component.
!
      do k=1,npm1
        do j=2,ntm1
          do i=2,nrm1
            av_vr=AVGRP (v%r,i,j,k+1)
            av_vt=AVGTP (v%t,i,j,k+1)
            av_vp=AVG   (v%p,i,j,k  )
            av_br=AVGT  (b%r,i,j,k  )
            av_bt=AVGR  (b%t,i,j,k  )
            av_bp=AVGRTP(b%p,i,j,k+1)
            vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
            bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
            bsq=max(bsq,small_value)
            v_perp_r=av_vr-vdotb*av_br/bsq
            v_perp_t=av_vt-vdotb*av_bt/bsq
            v_perp_p=av_vp-vdotb*av_bp/bsq
            vxb%p(i,j,k)=av_vr*av_bt-av_vt*av_br
            eta_uw%pr(i,j,k)=half*abs(v_perp_r)*drh(i)
            eta_uw%pt(i,j,k)=half*abs(v_perp_t)*rh(i)*dth(j)
          enddo
        enddo
      enddo
!
!-----------------------------------------------------------------------
! ****** Boundary values.
!-----------------------------------------------------------------------
!
! ****** Set the theta component at r=R1.
! ****** This is not upwinded.  Should it be?
!
      if (interplanetary_run) then
        call bc_vcrossb_interplanetary (v,b,vxb,vxb_b)
      else
        call bc_vcrossb_centered (v,b,vxb,vxb_b)
      end if
!
! ****** Seam the upwind resistivity.
!
      call seam_tp (eta_uw%rt)
      call seam_tp (eta_uw%rp)
      call seam_rp (eta_uw%tr)
      call seam_rp (eta_uw%tp)
      call seam_rt (eta_uw%pr)
      call seam_rt (eta_uw%pt)
!
! ****** Scale the upwind resistivity by the factor ETA_UW_MULT.
!
      eta_uw%rt=eta_uw_mult*eta_uw%rt
      eta_uw%rp=eta_uw_mult*eta_uw%rp
      eta_uw%tr=eta_uw_mult*eta_uw%tr
      eta_uw%tp=eta_uw_mult*eta_uw%tp
      eta_uw%pr=eta_uw_mult*eta_uw%pr
      eta_uw%pt=eta_uw_mult*eta_uw%pt
!
! ****** Compute the isotropic upwind resistivity.
!
      do k=1,npm1
        do j=1,ntm1
          do i=1,nrm1
            eta_uw_rt=AVGTP(eta_uw%rt,i,j+1,k+1)
            eta_uw_rp=AVGTP(eta_uw%rp,i,j+1,k+1)
            eta_uw_tr=AVGRP(eta_uw%tr,i+1,j,k+1)
            eta_uw_tp=AVGRP(eta_uw%tp,i+1,j,k+1)
            eta_uw_pr=AVGRT(eta_uw%pr,i+1,j+1,k)
            eta_uw_pt=AVGRT(eta_uw%pt,i+1,j+1,k)
            eta_uw%i(i,j,k)=max(eta_uw_rt, &
                                eta_uw_rp, &
                                eta_uw_tr, &
                                eta_uw_tp, &
                                eta_uw_pr, &
                                eta_uw_pt)
          enddo
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine adv_dsq_a_at_bc (ab)
!
!-----------------------------------------------------------------------
!
! ****** Apply a diffusive term for A tangential at the boundary.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
      use eta_photosphere
      use emerging_flux_params, ONLY : eflux_eta
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec_bc) :: ab, delta_ab
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: etav,curlsq_at,curlsq_ap
!
!-----------------------------------------------------------------------
!
! ****** Allocate the temporary array to hold change to ab.
!
      call alloc_avec_bc (delta_ab)
!
! ****** Theta component.
!
      do concurrent (k=2:npm1, j=jm0:jm1)
        etav=eta_phot_mag*half*( eta_phot_prof(j,k  ) &
                                +eta_phot_prof(j,k-1)) &
                         +half*( eflux_eta(j,k  ) &
                                +eflux_eta(j,k-1))
        curlsq_at=(-( dp_i(k  )*( ab%r0%t(j,k+1) &
                                 -ab%r0%t(j,k  )) &
                     -dp_i(k-1)*( ab%r0%t(j,k  ) &
                                 -ab%r0%t(j,k-1)) &
                    )*(r_i(1)*st_i(j))**2*dph_i(k)*dp_mult &
                   +( ( sth(j+1)*ab%r0%p(j+1,k  ) &
                       -sth(j  )*ab%r0%p(j  ,k  )) &
                     -( sth(j+1)*ab%r0%p(j+1,k-1) &
                       -sth(j  )*ab%r0%p(j  ,k-1)) &
                    )*(r_i(1)*st_i(j))**2*dt_i(j)*dph_i(k)*dp_mult &
                  )
        delta_ab%r0%t(j,k)=-etav*curlsq_at
      enddo
!
! ****** Phi component.
!
! ****** Note that the points adjacent to the poles are special.
!
      do concurrent (k=1:npm1, j=jh0+1:jh1-1)
        etav=eta_phot_mag*half*( eta_phot_prof(j,k  ) &
                                +eta_phot_prof(j-1,k)) &
                         +half*( eflux_eta(j,k  ) &
                                +eflux_eta(j-1,k))
        curlsq_ap=(-(  st_i(j  ) &
                      *dt_i(j  )*( sth(j+1)*ab%r0%p(j+1,k) &
                                  -sth(j  )*ab%r0%p(j  ,k)) &
                     - st_i(j-1) &
                      *dt_i(j-1)*( sth(j  )*ab%r0%p(j  ,k) &
                                  -sth(j-1)*ab%r0%p(j-1,k)) &
                    )*r_i(1)**2*dth_i(j) &
                   +( st_i(j  )*( ab%r0%t(j  ,k+1) &
                                 -ab%r0%t(j  ,k  )) &
                     -st_i(j-1)*( ab%r0%t(j-1,k+1) &
                                 -ab%r0%t(j-1,k  )) &
                    )*r_i(1)**2*dth_i(j)*dp_i(k)*dp_mult &
                  )
        delta_ab%r0%p(j,k)=-etav*curlsq_ap
      enddo
!
! ****** Update the components. ToDo: CHECK TIMESTEP CFL!.
!
      do concurrent (k=2:npm1, j=jm0:jm1)
        ab%r0%t(j,k)=ab%r0%t(j,k)+dtime*delta_ab%r0%t(j,k)
      enddo
!
      do concurrent (k=1:npm1, j=jh0+1:jh1-1)
        ab%r0%p(j,k)=ab%r0%p(j,k)+dtime*delta_ab%r0%p(j,k)
      enddo
!
! ****** ToDo: Set the pole points!!!.
!
      call dealloc_avec_bc (delta_ab)
!
end subroutine
!#######################################################################
subroutine get_at_b (a,ab)
!
!-----------------------------------------------------------------------
!
! ****** Get the tangential values of A on the physical boundaries
! ****** and put them into structure AB.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
      type(avec_bc) :: ab
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: rh_i1,rh_i2
!
!-----------------------------------------------------------------------
!
! ****** Get the r-boundary values of At.
!
      rh_i1=rh_i(1)
      rh_i2=rh_i(2)
!
      if (rb0) then
        do concurrent (k=1:np, j=1:ntm1)
          ab%r0%t(j,k)=r0*half* &
                       (a%t( 1,j,k)*rh_i1+a%t( 2,j,k)*rh_i2)
        enddo
      end if
      if (rb1) then
        do concurrent (k=1:np, j=1:ntm1)
          ab%r1%t(j,k)=half*(a%t(nr,j,k)+a%t(nrm1,j,k))
        enddo
      end if
!
! ****** Get the r-boundary values of Ap.
!
      if (rb0) then
        do concurrent (k=1:npm1, j=1:nt)
          ab%r0%p(j,k)=r0*half* &
                       (a%p( 1,j,k)*rh_i1+a%p( 2,j,k)*rh_i2)
        enddo
      end if
      if (rb1) then
        do concurrent (k=1:npm1, j=1:nt)
          ab%r1%p(j,k)=half*(a%p(nr,j,k)+a%p(nrm1,j,k))
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine advance_a_b (ab,vxb_b,betapc)
!
!-----------------------------------------------------------------------
!
! ****** Advance the tangential values of A on the physical
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
! ****** On input, AB has the boundary values of A.
!
! ****** On return, the advanced boundary values of A are
! ****** overwritten in AB.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use vars
      use emerging_flux_params
      use prescribe_b_v_at_r0_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec_bc) :: ab,vxb_b
      real(r_typ) :: betapc
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** Advance the tangential components of A at the r=R1 boundary.
!
      if (rb1) then
        do concurrent (k=1:np, j=1:ntm1)
          ab%r1%t(j,k)=ab%r1%t(j,k)+betapc*dtime*vxb_b%r1%t(j,k)
        enddo
!
        do concurrent (k=1:npm1, j=1:nt)
          ab%r1%p(j,k)=ab%r1%p(j,k)+betapc*dtime*vxb_b%r1%p(j,k)
        enddo
      end if
!
! ****** Advance the tangential components of A at the r=R0 boundary.
!
      if (rb0) then
        if (.not.rotation_flux) then
          do concurrent (k=1:np, j=1:ntm1)
            ab%r0%t(j,k)=ab%r0%t(j,k)+betapc*dtime*vxb_b%r0%t(j,k)
          enddo
!
          do concurrent (k=1:npm1, j=1:nt)
            ab%r0%p(j,k)=ab%r0%p(j,k)+betapc*dtime*vxb_b%r0%p(j,k)
          enddo
        end if
!
        if (emerging_flux.and.ef%phi%active) then
          do concurrent (k=1:np, j=1:ntm1)
            ab%r0%t(j,k)=ab%r0%t(j,k)- &
                         betapc*dtime*ef%phi%e0*ef%phi%et(j,k)
          enddo
!
          do concurrent (k=1:npm1, j=1:nt)
            ab%r0%p(j,k)=ab%r0%p(j,k)- &
                         betapc*dtime*ef%phi%e0*ef%phi%ep(j,k)
          enddo
        end if
        if (emerging_flux.and.ef%psi%active) then
          do concurrent (k=1:np, j=1:ntm1)
            ab%r0%t(j,k)=ab%r0%t(j,k)- &
                         betapc*dtime*ef%psi%e0*ef%psi%et(j,k)
          enddo
!
          do concurrent (k=1:npm1, j=1:nt)
            ab%r0%p(j,k)=ab%r0%p(j,k)- &
                         betapc*dtime*ef%psi%e0*ef%psi%ep(j,k)
          enddo
        end if
        if (emerging_flux.and.ef%edrive%active) then
          do concurrent (k=1:np, j=1:ntm1)
            ab%r0%t(j,k)=ab%r0%t(j,k)- &
                         betapc*dtime*ef%edrive%e0*ef%edrive%et(j,k)
          enddo
!
          do concurrent (k=1:npm1, j=1:nt)
            ab%r0%p(j,k)=ab%r0%p(j,k)- &
                         betapc*dtime*ef%edrive%e0*ef%edrive%ep(j,k)
          enddo
        end if
        if (evolve_flux.or.prescribe_bv) then
          do concurrent (k=1:np, j=1:ntm1)
            ab%r0%t(j,k)=ab%r0%t(j,k)-betapc*dtime*eflux_et(j,k)
          enddo
!
          do concurrent (k=1:npm1, j=1:nt)
            ab%r0%p(j,k)=ab%r0%p(j,k)-betapc*dtime*eflux_ep(j,k)
          enddo
        end if
      end if
!
end subroutine
!#######################################################################
subroutine solve (x,rhs,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Solve the implicit equations iteratively using a
! ****** Conjugate Gradient solver.
!
!-----------------------------------------------------------------------
!
! ****** Return IERR=0 if the iteration converges; otherwise,
! ****** IERR is set to a nonzero value.
!
! ****** X is the initial guess at the solution.
! ****** RHS is the right-hand side.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: x,rhs
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Solve the equations using the CG method.
!
      if (use_timer) call timer (TIME_SOLVE)
!
      call cgsolve (x,rhs,ierr)
!
      if (use_timer) call timer (TIME_SOLVE)
!
! ****** Check for convergence.
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in SOLVE:'
          write (*,*) '### The field solver did not converge.'
          write (*,*) 'IERR = ',ierr
          write (*,100) ncg,epsn
  100     format (tr1,'N = ',i6,' EPSN = ',1pe13.6)
        end if
      end if
!
! ****** Update the cumulative iteration counters.
!
      select case (equation_solved)
      case (EQ_A)
        nsolves_a=nsolves_a+1
        ntotal_a=ntotal_a+ncg
      case (EQ_SI_PREDICTOR)
        nsolves_si_p=nsolves_si_p+1
        ntotal_si_p=ntotal_si_p+ncg
      case (EQ_SI_CORRECTOR)
        nsolves_si_c=nsolves_si_c+1
        ntotal_si_c=ntotal_si_c+ncg
      case (EQ_VISC)
        nsolves_visc=nsolves_visc+1
        ntotal_visc=ntotal_visc+ncg
      case (EQ_POT2D)
        nsolves_pot2d=nsolves_pot2d+1
        ntotal_pot2d=ntotal_pot2d+ncg
      case (EQ_POT2D_NEWFLUX)
        nsolves_pot2d_newflux=nsolves_pot2d_newflux+1
        ntotal_pot2d_newflux=ntotal_pot2d_newflux+ncg
      case (EQ_POT2DH)
        nsolves_pot2dh=nsolves_pot2dh+1
        ntotal_pot2dh=ntotal_pot2dh+ncg
      case (EQ_POT3D)
        nsolves_pot3d=nsolves_pot3d+1
        ntotal_pot3d=ntotal_pot3d+ncg
      case (EQ_TE)
        nsolves_te=nsolves_te+1
        ntotal_te=ntotal_te+ncg
      case (EQ_TP)
        nsolves_tp=nsolves_tp+1
        ntotal_tp=ntotal_tp+ncg
      case (EQ_DIVB)
        nsolves_divb=nsolves_divb+1
        ntotal_divb=ntotal_divb+ncg
      end select
!
end subroutine
!#######################################################################
subroutine alloc_cg_ax_tmp
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use cgcom
      use globals
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      select case (solve_type)
      case (ST_V)
        call alloc_vvec (ps_v)
      case (ST_V_PAR)
        allocate (ps_v_par(nr,nt,np))
!$acc enter data create(ps_v_par)
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          ps_v_par(i,j,k)=0.
        enddo
      case (ST_T)
        allocate(ps_t(nr,nt,np))
!$acc enter data create(ps_t)
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          ps_t(i,j,k)=0.
        enddo
      case (ST_POT2D)
        allocate(ps_pot2d(ntm,npm))
!$acc enter data create(ps_pot2d)
        do concurrent (k=1:npm, j=1:ntm)
          ps_pot2d(j,k)=0.
        enddo
      case (ST_POT2DH)
        allocate(ps_pot2dh(nt,np))
!$acc enter data create(ps_pot2dh)
        do concurrent (k=1:np, j=1:nt)
          ps_pot2dh(j,k)=0.
        enddo
      case (ST_A)
        call alloc_avec (ps_a)
      case (ST_POT3D)
        allocate(ps_pot3d(nr,ntm,npm))
!$acc enter data create(ps_pot3d)
        do concurrent (k=1:npm, j=1:ntm, i=1:nr)
          ps_pot3d(i,j,k)=0.
        enddo
      case (ST_DIVB)
        allocate(ps_divb(nrm,ntm,npm))
!$acc enter data create(ps_divb)
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          ps_divb(i,j,k)=0.
        enddo
      case default
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in alloc_cg_ax_tmp:'
          write (*,*) '### Invalid SOLVE_TYPE.'
          write (*,*) '### SOLVE_TYPE = ',solve_type
          write (*,*) '### [This is an internal error.]'
        end if
        call endrun (.true.)
      end select
!
end subroutine
!#######################################################################
subroutine dealloc_cg_ax_tmp
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use cgcom
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      select case (solve_type)
      case (ST_V)
        call dealloc_vvec(ps_v)
      case (ST_V_PAR)
!$acc exit data delete(ps_v_par)
        deallocate (ps_v_par)
      case (ST_T)
!$acc exit data delete(ps_t)
        deallocate(ps_t)
      case (ST_POT2D)
!$acc exit data delete(ps_pot2d)
        deallocate(ps_pot2d)
      case (ST_POT2DH)
!$acc exit data delete(ps_pot2dh)
        deallocate(ps_pot2dh)
      case (ST_A)
        call dealloc_avec(ps_a)
      case (ST_POT3D)
!$acc exit data delete(ps_pot3d)
        deallocate(ps_pot3d)
      case (ST_DIVB)
!$acc exit data delete(ps_divb)
        deallocate(ps_divb)
      case default
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in dealloc_cg_ax_tmp:'
          write (*,*) '### Invalid SOLVE_TYPE.'
          write (*,*) '### SOLVE_TYPE = ',solve_type
          write (*,*) '### [This is an internal error.]'
        end if
        call endrun (.true.)
      end select
!
end subroutine
!#######################################################################
subroutine cgsolve (x,r,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Solve the linear system:
!
!            A * x = b
!
! ****** using the classical Conjugate Gradient method for symmetric
! ****** and positive-definite matrices.
!
!-----------------------------------------------------------------------
!
! ****** On input, X contains a guess at the solution, and
! ****** R contains the right-hand side, b.
!
! ****** On exit, X contains an estimate to the solution, and
! ****** R contains the residual (b-ax).
!
! ****** IERR=0 indicates that the solution converged to the
! ****** requested accuracy.  Other values indicate that the
! ****** iteration did not converge for the given maximum number
! ****** of iterations.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: x,r
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer     :: i
      real(r_typ) :: bdotb,rdotr,rdotr_old,pdotap,alphai,betai
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: cgdot
!
!-----------------------------------------------------------------------
!
! ****** Allocate temporary field storage for use in ax routine.
!
      allocate(p_cg(N_CG))
      allocate(ap_cg(N_CG))
!$acc enter data create(p_cg,ap_cg)
!
      if (ifprec_32) then
        allocate(p_cg_sp(N_CG))
        allocate(ap_cg_sp(N_CG))
!$acc enter data create(p_cg_sp,ap_cg_sp)
      end if
!
      call alloc_cg_ax_tmp
!
      ncg=0
!
! ****** Get the norm of the RHS.  dot(b,prec_inv[b])
!
      do concurrent (i=1:N_CG)
        p_cg(i)=r(i)
      enddo
      call prec_inv (p_cg,p_cg_sp)
      bdotb=cgdot(r,p_cg)
      bnrm=sign(one,bdotb)*sqrt(abs(bdotb))
!
! ****** If the RHS is zero, return with a zero solution.
!
      if (bdotb.eq.0.) then
        do concurrent (i=1:N_CG)
          x(i)=0.
        enddo
        rnrm=0.
        epsn=0.
        ierr=0
        call dealloc_cg_ax_tmp
!$acc exit data delete(p_cg,ap_cg)
        deallocate (p_cg)
        deallocate (ap_cg)
        if (ifprec_32) then
!$acc exit data delete(p_cg_sp,ap_cg_sp)
          deallocate (p_cg_sp)
          deallocate (ap_cg_sp)
        end if
        return
      end if
!
!-----------------------------------------------------------------------
! ****** Initialization.
!-----------------------------------------------------------------------
!
      call ax (x,ap_cg)
!
      do concurrent (i=1:N_CG)
        r(i)=r(i)-ap_cg(i)
        p_cg(i)=r(i)
      enddo
!
! ****** Find the initial error norm.
!
      call prec_inv (p_cg,p_cg_sp)
!
      rdotr=cgdot(r,p_cg)
!
      call err_norm (rdotr,ierr)
      if (ierr.ge.0) then
        call dealloc_cg_ax_tmp
!$acc exit data delete(p_cg,ap_cg)
        deallocate (p_cg)
        deallocate (ap_cg)
        if (ifprec_32) then
!$acc exit data delete(p_cg_sp,ap_cg_sp)
          deallocate (p_cg_sp)
          deallocate (ap_cg_sp)
        end if
        return
      end if
!
!-----------------------------------------------------------------------
! ****** Main iteration loop.
!-----------------------------------------------------------------------
!
      do
        ncg=ncg+1
!
! ***** Get matrix-vector product:
!
        call ax (p_cg,ap_cg)
!
        pdotap=cgdot(p_cg,ap_cg)
        alphai=rdotr/pdotap
!
        do concurrent (i=1:N_CG)
          x(i)=x(i)+alphai*p_cg(i)
          r(i)=r(i)-alphai*ap_cg(i)
          ap_cg(i)=r(i)
        enddo
!
! ***** Apply preconditioner:
!
        call prec_inv (ap_cg,ap_cg_sp)
!
        rdotr_old=rdotr
        rdotr=cgdot(r,ap_cg)
!
! ****** Check for convergence.
!
        call err_norm (rdotr,ierr)
        if (ierr.ge.0) exit
!
        betai=rdotr/rdotr_old
!
        do concurrent (i=1:N_CG)
          p_cg(i)=betai*p_cg(i)+ap_cg(i)
        enddo
!
      enddo
!
      call dealloc_cg_ax_tmp
!
!$acc exit data delete(p_cg,ap_cg)
      deallocate (p_cg)
      deallocate (ap_cg)
      if (ifprec_32) then
!$acc exit data delete(p_cg_sp,ap_cg_sp)
        deallocate (p_cg_sp)
        deallocate (ap_cg_sp)
      end if
!
end subroutine
!#######################################################################
subroutine copy_vvec (from,to)
!
!-----------------------------------------------------------------------
!
! ****** Copy the vvec FROM to vvec TO.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : vvec
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: from,to
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm)
        to%r(i,j,k)=from%r(i,j,k)
      enddo
!
      do concurrent (k=1:np, j=1:ntm, i=1:nr)
        to%t(i,j,k)=from%t(i,j,k)
      enddo
!
      do concurrent (k=1:npm, j=1:nt, i=1:nr)
        to%p(i,j,k)=from%p(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine zero_vvec (v0)
!
!-----------------------------------------------------------------------
!
! ****** Set the vvec V0 to 0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : vvec
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v0
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm)
        v0%r(i,j,k)=0.
      enddo
!
      do concurrent (k=1:np, j=1:ntm, i=1:nr)
        v0%t(i,j,k)=0.
      enddo
!
      do concurrent (k=1:npm, j=1:nt, i=1:nr)
        v0%p(i,j,k)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine zero_hvec (h0)
!
!-----------------------------------------------------------------------
!
! ****** Set the hvec H0 to 0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : hvec
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(hvec) :: h0
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        h0%r(i,j,k)=0.
        h0%t(i,j,k)=0.
        h0%p(i,j,k)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine copy_avec (from,to)
!
!-----------------------------------------------------------------------
!
! ****** Copy the avec FROM to avec TO.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : avec
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: from,to
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm1)
        to%r(i,j,k)=from%r(i,j,k)
      enddo
!
      do concurrent (k=1:np, j=1:ntm1, i=1:nr)
        to%t(i,j,k)=from%t(i,j,k)
      enddo
!
      do concurrent (k=1:npm1, j=1:nt, i=1:nr)
        to%p(i,j,k)=from%p(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine zero_avec (a0)
!
!-----------------------------------------------------------------------
!
! ****** Set the avec A0 to 0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : avec
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a0
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm1)
        a0%r(i,j,k)=0.
      enddo
!
      do concurrent (k=1:np, j=1:ntm1, i=1:nr)
        a0%t(i,j,k)=0.
      enddo
!
      do concurrent (k=1:npm1, j=1:nt, i=1:nr)
        a0%p(i,j,k)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine zero_bvec (b0)
!
!-----------------------------------------------------------------------
!
! ****** Set the bvec B0 to 0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : bvec
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b0
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nr)
        b0%r(i,j,k)=0.
      enddo
!
      do concurrent (k=1:npm, j=1:nt, i=1:nrm)
        b0%t(i,j,k)=0.
      enddo
!
      do concurrent (k=1:np, j=1:ntm, i=1:nrm)
        b0%p(i,j,k)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine copy_bvec (from,to)
!
!-----------------------------------------------------------------------
!
! ****** Copy the vvec FROM to vvec TO.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : bvec
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: from,to
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nr)
        to%r(i,j,k)=from%r(i,j,k)
      enddo
!
      do concurrent (k=1:npm, j=1:nt, i=1:nrm)
        to%t(i,j,k)=from%t(i,j,k)
      enddo
!
      do concurrent (k=1:np, j=1:ntm, i=1:nrm)
        to%p(i,j,k)=from%p(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine err_norm (rdotr,ierr)
!
!-----------------------------------------------------------------------
!
! ****** This subroutine checks if the iterative solver has
! ****** converged or if the maximum allowed number of iterations,
! ****** NCGMAX, has been exceeded.
!
!-----------------------------------------------------------------------
!
! ****** Convergence is deemed to have occurred when:
! ******
! ******     ||R||/||B|| .lt. EPSCG_DESIRED
! ******
! ****** where ||R|| is the norm of the (preconditioned)
! ****** residual, ||B|| is the norm of the (preconditioned)
! ****** RHS, and EPSCG_DESIRED is the specified convergence
! ****** criterion.
!
! ****** Set IERR=0 if the error is below the error criterion
! ****** (i.e., the solution has converged).
! ****** Set IERR=-1 if the error does not yet meet the error
! ****** criterion and the number of iterations is less than NCGMAX.
! ****** Set IERR=1 if the maximum number of iterations has
! ****** been exceeded without convergence.
!
!-----------------------------------------------------------------------
!
! ****** On input, RDOTR has the dot product of the residual vector
! ****** with itself, weighted by the preconditioning matrix.
!
! ****** This routine assumes that the norm of the rhs, BNRM, has
! ****** already been computed.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use mpidefs
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: rdotr
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      ierr=-1
!
! ****** Compute the normalized error estimate.
!
      rnrm=sign(one,rdotr)*sqrt(abs(rdotr))
!
      epsn=rnrm/bnrm
!
      if (ncghist.gt.0) then
        if (mod(ncg,ncghist).eq.0) then
          if (iamp0) then
            if (ncg.eq.0) then
              write (IO_OUT,*)
              write (IO_OUT,*) '### Comment from ERR_NORM:'
              write (IO_OUT,*) '### Convergence information:'
            end if
            write (IO_OUT,100) ncg,epsn
            FLUSH (IO_OUT)
  100       format (1x,'Iteration: ',i8,'   Residual: ',1pe23.15)
          end if
        end if
      end if
!
! ****** Check for convergence.
!
      if (epsn.ge.0..and.epsn.lt.epscg_desired) then
        if (ncghist.gt.0) then
          if (iamp0) then
            write (IO_OUT,*)
            write (IO_OUT,*) '### Comment from ERR_NORM:'
            write (IO_OUT,*) '### The CG solver has converged.'
            write (IO_OUT,100) ncg,epsn
            FLUSH (IO_OUT)
          end if
        end if
        ierr=0
      else if (ncg.ge.ncgmax) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in ERR_NORM:'
          write (*,*) '### Exceeded maximum number of iterations.'
          write (*,*) 'NCGMAX = ',ncgmax
          write (*,*) 'EPSN = ',epsn
          FLUSH (IO_OUT)
        end if
        ierr=1
      end if
!
end subroutine
!#######################################################################
subroutine ax (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P.
!
!-----------------------------------------------------------------------
!
! ****** This routine selects the appropriate matrix,
! ****** depending on which equation is being solved.
!
!-----------------------------------------------------------------------
!
      use cgcom
      use mpidefs
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
      select case (solve_type)
      case (ST_A)
        call ax_a (p,q)
      case (ST_V)
        call ax_v (p,q)
      case (ST_V_PAR)
        call ax_v_par (p,q)
      case (ST_POT2D)
        call ax_pot2d (p,q)
      case (ST_POT3D)
        call ax_pot3d (p,q)
      case (ST_T)
        call ax_t (p,q)
      case (ST_POT2DH)
        call ax_pot2dh (p,q)
      case (ST_DIVB)
        call ax_divb (p,q)
      case default
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in AX:'
          write (*,*) '### Invalid SOLVE_TYPE.'
          write (*,*) '### SOLVE_TYPE = ',solve_type
          write (*,*) '### [This is an internal error.]'
        end if
        call endrun (.true.)
      end select
!
end subroutine
!#######################################################################
subroutine prec_inv (p,p_32)
!
!-----------------------------------------------------------------------
!
! ****** Apply the preconditioner.
!        Set P := M(inv) * P.
!
!-----------------------------------------------------------------------
!
      use cgcom
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(N_CG) :: p
      real(r_typ_sp), dimension(N_CG) :: p_32
!
      select case (solve_type)
      case (ST_A)
        call prec_inv_a (p)
      case (ST_V)
        call prec_inv_v (p,p_32)
      case (ST_V_PAR)
        call prec_inv_v_par (p,p_32)
      case (ST_POT2D)
        call prec_inv_pot2d (p,p_32)
      case (ST_POT2DH)
        call prec_inv_pot2dh (p,p_32)
      case (ST_POT3D)
        call prec_inv_pot3d (p)
      case (ST_T)
        call prec_inv_t (p,p_32)
      case (ST_DIVB)
        call prec_inv_divb (p,p_32)
      case default
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in PREC_INV:'
          write (*,*) '### Invalid SOLVE_TYPE.'
          write (*,*) '### SOLVE_TYPE = ',solve_type
          write (*,*) '### [This is an internal error.]'
        end if
        call endrun (.true.)
      end select
!
end subroutine
!#######################################################################
subroutine prec_inv_a (p)
!
!-----------------------------------------------------------------------
!
! ****** Set P = M(inv) * P for the implicit resistivity advance.
!
!-----------------------------------------------------------------------
!
      use cgcom, ONLY : ifprec_a
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_cgvec) :: p
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_a.eq.0) return
!
      if (ifprec_a.eq.1) then
!
! ****** Point-Jacobi (diagonal scaling):
!
        do concurrent (i=1:N_cgvec)
          p(i)=a_dia_i(i)*p(i)
        enddo
!
      end if
!
end subroutine
!#######################################################################
subroutine prec_inv_v (p,p_32)
!
!-----------------------------------------------------------------------
!
! ****** Set P = M(inv) * P for the implicit momentum advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_v,ifprec_32
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(N_cgvec) :: p
      real(r_typ_sp), dimension(N_cgvec) :: p_32
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_v.eq.0) return
!
      if (ifprec_v.eq.1) then
!
! ****** Point-Jacobi (diagonal scaling):
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i_sp(i)*p(i)
          enddo
        else
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i(i)*p(i)
          enddo
        end if
      elseif (ifprec_v.ge.2) then
!
! ****** SGS or ILU Partial-Block-Jacobi:
!
        call lusol (N_cgvec,M_nzz,p,p_32,lu_csr,lu_csr_sp, &
                    lu_csr_ja,a_N1,a_N2,a_csr_d,a_csr_d_sp)
!
      end if
!
end subroutine
!#######################################################################
subroutine prec_inv_v_par (p,p_32)
!
!-----------------------------------------------------------------------
!
! ****** Set P = M(inv) * P for the parallel flow solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use matrix_storage_v_par_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(N_cgvec) :: p
      real(r_typ_sp), dimension(N_cgvec) :: p_32
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_v.eq.0) return
!
      if (ifprec_v.eq.1) then
!
! ****** Jacobi (diagonal):
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i_sp(i)*p(i)
          enddo
        else
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i(i)*p(i)
          enddo
        end if
!
      elseif (ifprec_v.ge.2) then
!
! ****** SGS or ILU:
!
        call lusol (N_cgvec,M_nnz,p,p_32,lu_csr,lu_csr_sp, &
                    lu_csr_ja,a_N1,a_N2,a_csr_d,a_csr_d_sp)
!
      end if
!
end subroutine
!#######################################################################
subroutine prec_inv_t (p,p_32)
!
!-----------------------------------------------------------------------
!
! ****** Set P = M(inv) * P for the thermal conduction solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use matrix_storage_t_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(N_cgvec) :: p
      real(r_typ_sp), dimension(N_cgvec) :: p_32
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_t.eq.0) return
!
      if (ifprec_t.eq.1) then
!
! ****** Jacobi (diagonal):
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i_sp(i)*p(i)
          enddo
        else
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i(i)*p(i)
          enddo
        end if
!
      elseif (ifprec_t.ge.2) then
!
! ****** SGS or ILU:
!
        call lusol (N_cgvec,M_nnz,p,p_32,lu_csr,lu_csr_sp, &
                    lu_csr_ja,a_N1,a_N2,a_csr_d,a_csr_d_sp)
!
      end if
!
end subroutine
!#######################################################################
subroutine prec_inv_pot2d (p,p_32)
!
!-----------------------------------------------------------------------
!
! ****** Set P = M(inv) * P for the 2D potential field solve for the
! ****** potential at the lower radial boundary.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(N_cgvec) :: p
      real(r_typ_sp), dimension(N_cgvec) :: p_32
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_pot2d.eq.0) return
!
      if (ifprec_pot2d.eq.1) then
!
! ****** Jacobi (diagonal):
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i_sp(i)*p(i)
          enddo
        else
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i(i)*p(i)
          enddo
        end if
!
      elseif (ifprec_pot2d.ge.2) then
!
! ****** SGS or ILU:
!
        call lusol (N_cgvec,M_nnz,p,p_32,lu_csr,lu_csr_sp, &
                    lu_csr_ja,a_N1,a_N2,a_csr_d,a_csr_d_sp)
!
      end if
!
end subroutine
!#######################################################################
subroutine prec_inv_pot2dh (p,p_32)
!
!-----------------------------------------------------------------------
!
! ***** Set P = M(inv) * P for the 2D potential field solve for the
! ***** potential at the lower radial boundary on the semi-integer mesh
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_pot2d,ifprec_32
      use matrix_storage_pot2dh_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(N_cgvec) :: p
      real(r_typ_sp), dimension(N_cgvec) :: p_32
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_pot2d.eq.0) return
!
      if (ifprec_pot2d.eq.1) then
!
! ****** Jacobi (diagonal):
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i_sp(i)*p(i)
          enddo
        else
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i(i)*p(i)
          enddo
        end if
!
      elseif (ifprec_pot2d.ge.2) then
!
! ****** SGS or ILU:
!
        call lusol (N_cgvec,M_nnz,p,p_32,lu_csr,lu_csr_sp, &
                    lu_csr_ja,a_N1,a_N2,a_csr_d,a_csr_d_sp)
!
      end if
!
end subroutine
!#######################################################################
subroutine prec_inv_pot3d (p)
!
!-----------------------------------------------------------------------
!
! ****** Set P = M(inv) * P for the 3D potential field solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use matrix_storage_pot3d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_cgvec) :: p
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_pot3d.eq.0) return
!
      if (ifprec_pot3d.eq.1) then
!
! ****** Jacobi (diagonal):
!
        do concurrent (i=1:N_cgvec)
          p(i)=a_dia_i(i)*p(i)
        enddo
!
      end if
!
end subroutine
!#######################################################################
subroutine prec_inv_divb (p,p_32)
!
!-----------------------------------------------------------------------
!
! ***** Set P = M(inv) * P for the divergence cleaning solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_divb,ifprec_32
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ),    dimension(N_cgvec) :: p
      real(r_typ_sp), dimension(N_cgvec) :: p_32
      integer :: i
!
!-----------------------------------------------------------------------
!
      if (ifprec_divb.eq.0) return
!
      if (ifprec_divb.eq.1) then
!
! ****** Jacobi (diagonal):
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i_sp(i)*p(i)
          enddo
        else
          do concurrent (i=1:N_cgvec)
            p(i)=a_dia_i(i)*p(i)
          enddo
        end if
!
      elseif (ifprec_divb.ge.2) then
!
! ****** SGS or ILU:
!
        call lusol (N_cgvec,M_nnz,p,p_32,lu_csr,lu_csr_sp, &
                    lu_csr_ja,a_N1,a_N2,a_csr_d,a_csr_d_sp)
!
      end if
!
end subroutine
!#######################################################################
subroutine pack_scalar (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the half-mesh scalar s into
! ****** array x excluding boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(2:nrm1,2:ntm1,2:npm1) :: x
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        x(i,j,k)=s(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine unpack_scalar (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Unpack the half-mesh scalar s into
! ****** array x excluding boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(2:nrm1,2:ntm1,2:npm1) :: x
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        s(i,j,k)=x(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine pack_avec (a,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the vector-potential vector a into
! ****** one-dimensional array x excluding boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types, ONLY : avec
      use matrix_storage_a_solve, ONLY: N_cgvec
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
      real(r_typ), dimension(N_cgvec) :: x
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
!
!-----------------------------------------------------------------------
!
! ****** Pack the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        l=ntm2*nrm1*(k-2)+nrm1*(j-2)+i
        x(l)=a%r(i,j,k)
      enddo
!
! ****** Pack the theta component.
!
      do concurrent (k=2:npm1, j=jm0:jm1, i=2:nrm1)
        l=(npm2*ntm2*nrm1) &
         +(jm1-jm0+1)*nrm2*(k-2)+nrm2*(j-jm0)+(i-1)
        x(l)=a%t(i,j,k)
      enddo
!
! ****** Pack the phi component.
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        l=(npm2*ntm2*nrm1) &
         +(npm2*(jm1-jm0+1)*nrm2) &
         +ntm2*nrm2*(k-1)+nrm2*(j-2)+(i-1)
        x(l)=a%p(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine unpack_avec (a,x)
!
!-----------------------------------------------------------------------
!
! ****** Unpack the one-dimensional array x excluding boundaries
! ****** into the vector-potential vector a.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types, ONLY : avec
      use matrix_storage_a_solve, ONLY: N_cgvec
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
      real(r_typ), dimension(N_cgvec) :: x
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
!
!-----------------------------------------------------------------------
!
! ****** Unpack the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        l=ntm2*nrm1*(k-2)+nrm1*(j-2)+i
        a%r(i,j,k)=x(l)
      enddo
!
! ****** Unpack the theta component.
!
      do concurrent (k=2:npm1, j=jm0:jm1, i=2:nrm1)
        l=(npm2*ntm2*nrm1) &
         +(jm1-jm0+1)*nrm2*(k-2)+nrm2*(j-jm0)+(i-1)
        a%t(i,j,k)=x(l)
      enddo
!
! ****** Unpack the phi component.
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        l=(npm2*ntm2*nrm1) &
         +(npm2*(jm1-jm0+1)*nrm2) &
         +ntm2*nrm2*(k-1)+nrm2*(j-2)+(i-1)
        a%p(i,j,k)=x(l)
      enddo
!
end subroutine
!#######################################################################
subroutine pack_pot3d (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the half-main-main-mesh 3D (r,theta,phi) pot3d
! ****** scalar s into one-dimensional array x.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot3d_solve, ONLY : j0,j1
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,ntm,npm) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(2:nrm1,j0:j1,2:npm-1) :: x
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1, j=j0:j1, i=2:nrm1)
        x(i,j,k)=s(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine unpack_pot3d (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Unpack the half-main-main-mesh 3D (r,theta,phi) pot3d
! ****** scalar s from one-dimensional array x.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot3d_solve, ONLY : j0,j1
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,ntm,npm) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(2:nrm1,j0:j1,2:npm-1) :: x
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1, j=j0:j1, i=2:nrm1)
        s(i,j,k)=x(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine pack_divb (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the main-main-mesh 3D (r,theta,phi)
! ****** scalar s into one-dimensional array x including radial BCs.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(i0:nrm1,2:ntm-1,2:npm-1) :: x
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1,j=2:ntm-1,i=i0:nrm1)
        x(i,j,k)=s(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine unpack_divb (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Unpack one-dimensional array x including radial BCs
! ****** into the main-main-mesh 3D (r,theta,phi) scalar s.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(i0:nrm1,2:ntm-1,2:npm-1) :: x
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1,j=2:ntm-1,i=i0:nrm1)
        s(i,j,k)=x(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine pack_pot2d (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the main-mesh 2D (theta,phi) pot2d scalar s into
! ****** one-dimensional array x.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use matrix_storage_pot2d_solve, ONLY : j0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(j0:ntm1,2:npm-1) :: x
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1, j=j0:ntm1)
        x(j,k)=s(j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine unpack_pot2d (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the main-mesh 2D (theta,phi) pot2d scalar s into
! ****** one-dimensional array x.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use matrix_storage_pot2d_solve, ONLY : j0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(j0:ntm1,2:npm-1) :: x
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1, j=j0:ntm1)
        s(j,k)=x(j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine pack_pot2dh (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the half-mesh 2D (theta,phi) pot2dh scalar s into
! ****** one-dimensional array x.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(2:ntm1,2:npm1) :: x
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1)
        x(j,k)=s(j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine unpack_pot2dh (s,x)
!
!-----------------------------------------------------------------------
!
! ****** Unpack one-dimensional array x into
! ****** the half-mesh 2D (theta,phi) pot2dh scalar s.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: s
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(2:ntm1,2:npm1) :: x
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1)
        s(j,k)=x(j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine pack_vvec (v,x)
!
!-----------------------------------------------------------------------
!
! ****** Pack the velocity vector v into
! ****** one-dimensional array x excluding boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types, ONLY : vvec
      use matrix_storage_v_solve, ONLY: N_cgvec
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      real(r_typ), dimension(N_cgvec) :: x
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
      real(r_typ),dimension(:,:,:),pointer,contiguous :: v_r,v_t,v_p
!
!-----------------------------------------------------------------------
!
! ****** Optimization: use ptrs to avoid type hopping within GPU kernel.
!
      v_r=>v%r
      v_t=>v%t
      v_p=>v%p
!
! ****** Pack the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        l=ntm2*(nrm-2)*(k-2)+(nrm-2)*(j-2)+(i-1)
        x(l)=v_r(i,j,k)
      enddo
!
! ****** Pack the theta component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        l=(npm2*ntm2*(nrm-2)) &
         +(ntm-2)*nrm2*(k-2)+nrm2*(j-2)+(i-1)
        x(l)=v_t(i,j,k)
      enddo
!
! ****** Pack the phi component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        l=(npm2*ntm2*(nrm-2))+(npm2*(ntm-2)*nrm2) &
          +ntm2*nrm2*(k-2)+nrm2*(j-2)+(i-1)
        x(l)=v_p(i,j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine unpack_vvec (v,x)
!
!-----------------------------------------------------------------------
!
! ****** Unpack the velocity vector v into
! ****** one-dimensional array x excluding boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types, ONLY : vvec
      use matrix_storage_v_solve, ONLY: N_cgvec
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      real(r_typ), dimension(N_cgvec) :: x
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
      real(r_typ),dimension(:,:,:),pointer,contiguous :: v_r,v_t,v_p
!
!-----------------------------------------------------------------------
!
! ****** Optimization: use ptrs to avoid type hopping within GPU kernel.
!
      v_r=>v%r
      v_t=>v%t
      v_p=>v%p
!
! ****** Unpack the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        l=ntm2*(nrm-2)*(k-2)+(nrm-2)*(j-2)+(i-1)
        v_r(i,j,k) = x(l)
      enddo
!
! ****** Unpack the theta component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        l=(npm2*ntm2*(nrm-2)) &
         +(ntm-2)*nrm2*(k-2)+nrm2*(j-2)+(i-1)
        v_t(i,j,k)=x(l)
      enddo
!
! ****** Unpack the phi component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        l=(npm2*ntm2*(nrm-2))+(npm2*(ntm-2)*nrm2) &
          +ntm2*nrm2*(k-2)+nrm2*(j-2)+(i-1)
        v_p(i,j,k)=x(l)
      enddo
!
end subroutine
!#######################################################################
function cgdot (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Get the dot product of the vectors P and Q.
!
!-----------------------------------------------------------------------
!
      use number_types
      use timing
      use cgcom
      use types
      use globals
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: cgdot
      real(r_typ), dimension(N_CG) :: p,q
      integer :: i,j,k,l
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_CGDOT)
!
      cgdot=0.
!
      if (solve_type.eq.ST_A) then
!
! ****** Need to manually make sure not to count
! ****** overlaps twice.  This is a special
! ****** case for the A solve since it is on a unique single-overlap
! ****** grid in the main mesh directions.
!
!$acc parallel default(present) reduction(+:cgdot)
!$omp parallel default(shared) reduction(+:cgdot)
!$acc loop collapse(3) reduction(+:cgdot)
!$omp do collapse(3) reduction(+:cgdot)
        do k=2,npm1
          do j=2,ntm1
            do i=1,nrm1
              l=ntm2*nrm1*(k-2)+nrm1*(j-2)+i
              if (rb0.or.i.gt.1) then
                cgdot=cgdot+p(l)*q(l)
              end if
            enddo
          enddo
        enddo
!$omp enddo
!$acc loop collapse(3) reduction(+:cgdot)
!$omp do collapse(3) reduction(+:cgdot)
        do k=2,npm1
          do j=jm0,jm1
            do i=2,nrm1
              l=(npm2*ntm2*nrm1) &
               +(jm1-jm0+1)*nrm2*(k-2)+nrm2*(j-jm0)+(i-1)
              if (tb0.or.j.gt.1) then
                cgdot=cgdot+p(l)*q(l)
              end if
            enddo
          enddo
        enddo
!$omp enddo
!$acc loop collapse(3) reduction(+:cgdot)
!$omp do collapse(3) reduction(+:cgdot)
        do k=1,npm1
          do j=2,ntm1
            do i=2,nrm1
              l=(npm2*ntm2*nrm1) &
               +(npm2*(jm1-jm0+1)*nrm2) &
               +ntm2*nrm2*(k-1)+nrm2*(j-2)+(i-1)
              if (iproc_p.eq.0.or.k.gt.1) then
                cgdot=cgdot+p(l)*q(l)
              end if
            enddo
          enddo
        enddo
!$omp enddo
!$omp end parallel
!$acc end parallel
      else
!
! ****** For all other solves, this is much easier!
!
!$acc parallel loop default(present) reduction(+:cgdot)
!$omp parallel do default(shared) reduction(+:cgdot)
        do i=1,N_CG
          cgdot=cgdot+p(i)*q(i)
        enddo
!$omp end parallel do
      end if
!
! ****** Sum over all the processors.
!
      if (solve_type.eq.ST_POT2D.or.solve_type.eq.ST_POT2DH) then
        call global_sum_tp (cgdot)
      else
        call global_sum (cgdot)
      end if
!
      if (use_timer) call timer (TIME_CGDOT)
!
      return
end function
!#######################################################################
subroutine ax_a (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the implicit resistivity advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ps_a, N_CG
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
!
!-----------------------------------------------------------------------
!
! ***** Unpack p into avec ps_a.
!
      call unpack_avec (ps_a,p)
!
! ****** Set the boundary values of P.
!
      call set_bc_a (ab,ps_a,zero)
!
! ****** Seam P along edges between processors.
!
      call seam_avec (ps_a)
!
! ****** Get the matrix-vector product.
!
      call one_plus_curl_curl_a (ps_a,q)
!
end subroutine
!#######################################################################
subroutine ax_v (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the implicit momentum advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom
      use sts, ONLY : use_sts_visc,use_exp_visc
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0._r_typ
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ) :: hpar
!
!-----------------------------------------------------------------------
!
      if ((use_sts_visc.or.use_exp_visc) &
           .and.equation_solved.eq.EQ_VISC) then
        hpar=one
      else
        hpar=zero
      end if
!
! ***** Unpack p into vvec ps_v.
!
      call unpack_vvec (ps_v,p)
!
! ***** Set the boundary values of ps.
!
      call set_bc_v (ps_v,hpar)
!
! ***** Seam ps along edges between processors.
!
      call seam_vvec (ps_v)
!
! ***** Get the matrix-vector product.
!
      call one_minus_div_grad_v (ps_v,q)
!
end subroutine
!#######################################################################
subroutine ax_pot2d (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the potential field 2D solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ps_pot2d,N_CG
      use globals, ONLY : ntm,npm
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
! ***** Unpack p into ps_pot2d.
!
      call unpack_pot2d (ps_pot2d,p)
!
! ****** Seam P along edges between processors.
!
      call seam_2d_tp (ps_pot2d,ntm,npm,.true.,.true.)
!
! ****** Get the matrix-vector product.
!
      call delsq_perp_pot2d (ps_pot2d,q)
!
end subroutine
!#######################################################################
subroutine ax_pot3d (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the potential field 3D solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ps_pot3d,N_CG
      use globals, ONLY : nr,ntm,npm
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
!
!-----------------------------------------------------------------------
!
! ***** Unpack p into ps_pot3d.
!
      call unpack_pot3d (ps_pot3d,p)
!
! ****** Set the boundary values of P.
!
      call set_bc_pot3d (ps_pot3d,zero)
!
! ****** Seam P along edges between processors.
!
      call seam_scalar (ps_pot3d,nr,ntm,npm)
!
! ****** Get the matrix-vector product.
!
      call delsq_mod_pot3d (ps_pot3d,q)
!
end subroutine
!#######################################################################
subroutine load_average_resistivity
!
!-----------------------------------------------------------------------
!
! ****** Load the average resistivity arrays that are used in the
! ****** A solve.  These are precomputed to increase the efficiency
! ****** of the solver.
!
!-----------------------------------------------------------------------
!
      use globals
      use fields
      use upwind_resistivity
      use dissipation_profiles
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        eta_av_ar(i,j,k)= AVGTP(eta,i,j,k)+eta_bg
      enddo
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        eta_av_at(i,j,k)= AVGRP(eta,i,j,k)+eta_bg
      enddo
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        eta_av_ap(i,j,k)= AVGRT(eta,i,j,k)+eta_bg
      enddo
!
      if (experimental_a_advance) then
        do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
          eta_av_ar(i,j,k)= eta_av_ar(i,j,k)+AVGTP(eta_uw%i,i,j,k)
        enddo
!
        do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
          eta_av_at(i,j,k)= eta_av_at(i,j,k)+AVGRP(eta_uw%i,i,j,k)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
          eta_av_ap(i,j,k)= eta_av_ap(i,j,k)+AVGRT(eta_uw%i,i,j,k)
        enddo
      end if
!
      if (dynamic_eta) then
        do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
          eta_av_ar(i,j,k)= eta_av_ar(i,j,k)+AVGTP(etacel,i,j,k)
        enddo
!
        do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
          eta_av_at(i,j,k)= eta_av_at(i,j,k)+AVGRP(etacel,i,j,k)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
          eta_av_ap(i,j,k)= eta_av_ap(i,j,k)+AVGRT(etacel,i,j,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine one_plus_curl_curl_a (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = dV * (1/eta + dtime*curl-curl) P
! ******
! ****** at the internal points, and set all other points
! ****** of Q to zero.
!
!-----------------------------------------------------------------------
!
! ****** This routine is for the implicit resistivity advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use vars
      use upwind_resistivity
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: ps
      real(r_typ), dimension(N_cgvec) :: q
      real(r_typ) :: temp_sum1
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: small_value=1.e-30_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr) :: ap0,ap1
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sig,dv
      integer :: i,j,k,N,ii
!
!-----------------------------------------------------------------------
!
!$acc enter data create(ap0,ap1)
      do concurrent (i=1:nr)
        ap0(i)=0.
        ap1(i)=0.
      enddo
!
! ****** First, get Ap (m=0 component) adjacent to the pole.
!
      if (tb0) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+ps%p(i,2,k)*dp(k)*pl_i
          enddo
          ap0(i)=temp_sum1
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          do k=2,npm1
            temp_sum1=temp_sum1+ps%p(i,ntm1,k)*dp(k)*pl_i
          enddo
          ap1(i)=temp_sum1
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (nr,ap0,ap1)
!
! ****** Set the internal points of Q.
!
! ****** R component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        ii=ntm2*nrm1*(k-2)+nrm1*(j-2)+i
        sig=one/max(eta_av_ar(i,j,k),small_value)
        dv=r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
        q(ii)= dv*sig*ps%r(i,j,k) &
                    +dtime*( ( st(j  )*( rh(i+1)*ps%t(i+1,j  ,k) &
                                        -rh(i  )*ps%t(i  ,j  ,k)) &
                              -st(j-1)*( rh(i+1)*ps%t(i+1,j-1,k) &
                                        -rh(i  )*ps%t(i  ,j-1,k)) &
                             )*dph(k) &
                            -( st(j  )*dt_i(j  )*( ps%r(i,j+1,k) &
                                                  -ps%r(i,j  ,k)) &
                              -st(j-1)*dt_i(j-1)*( ps%r(i,j  ,k) &
                                                  -ps%r(i,j-1,k)) &
                             )*dr(i)*dph(k) &
                            -( dp_i(k  )*( ps%r(i,j,k+1) &
                                          -ps%r(i,j,k  )) &
                              -dp_i(k-1)*( ps%r(i,j,k  ) &
                                          -ps%r(i,j,k-1)) &
                             )*dr(i)*dth(j)*sth_i(j)*dp_mult &
                            +( ( rh(i+1)*ps%p(i+1,j,k  ) &
                                -rh(i  )*ps%p(i  ,j,k  )) &
                              -( rh(i+1)*ps%p(i+1,j,k-1) &
                                -rh(i  )*ps%p(i  ,j,k-1)) &
                             )*dth(j)*dp_mult &
                           )
      enddo
!
! ****** Theta component.
!
      do concurrent (k=2:npm1, j=jm0:jm1, i=2:nrm1)
        ii=(npm2*ntm2*nrm1) &
           +(jm1-jm0+1)*nrm2*(k-2)+nrm2*(j-jm0)+(i-1)
        sig=one/max(eta_av_at(i,j,k),small_value)
        dv=rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
        q(ii)= dv*sig*ps%t(i,j,k) &
                    +dtime*(-( dr_i(i  )*( rh(i+1)*ps%t(i+1,j,k) &
                                          -rh(i  )*ps%t(i  ,j,k)) &
                              -dr_i(i-1)*( rh(i  )*ps%t(i  ,j,k) &
                                          -rh(i-1)*ps%t(i-1,j,k)) &
                             )*rh(i)*st(j)*dt(j)*dph(k) &
                            -( dp_i(k  )*( ps%t(i,j,k+1) &
                                          -ps%t(i,j,k  )) &
                              -dp_i(k-1)*( ps%t(i,j,k  ) &
                                          -ps%t(i,j,k-1)) &
                             )*drh(i)*dt(j)*st_i(j)*dp_mult &
                            +( ( sth(j+1)*ps%p(i,j+1,k  ) &
                                -sth(j  )*ps%p(i,j  ,k  )) &
                              -( sth(j+1)*ps%p(i,j+1,k-1) &
                                -sth(j  )*ps%p(i,j  ,k-1)) &
                             )*drh(i)*st_i(j)*dp_mult &
                            +( ( ps%r(i  ,j+1,k) &
                                -ps%r(i  ,j  ,k)) &
                              -( ps%r(i-1,j+1,k) &
                                -ps%r(i-1,j  ,k)) &
                             )*rh(i)*st(j)*dph(k) &
                           )
      enddo
!
! ****** Phi component.
! ****** Note that the points adjacent to the poles are special.
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        ii=(npm2*ntm2*nrm1) &
          +(npm2*(jm1-jm0+1)*nrm2) &
           +ntm2*nrm2*(k-1)+nrm2*(j-2)+(i-1)
        sig=one/max(eta_av_ap(i,j,k),small_value)
        dv=rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
!
        if (tb0.and.j.eq.2) then
          q(ii)= dv*sig*ps%p(i,j,k) &
                    +dtime*(-( dr_i(i  )*( rh(i+1)*ps%p(i+1,j,k) &
                                          -rh(i  )*ps%p(i  ,j,k)) &
                              -dr_i(i-1)*( rh(i  )*ps%p(i  ,j,k) &
                                          -rh(i-1)*ps%p(i-1,j,k)) &
                             )*rh(i)*sth(j)*dth(j)*dp(k) &
                            -(  st_i(j  ) &
                               *dt_i(j  )*( sth(j+1)*ps%p(i,j+1,k) &
                                           -sth(j  )*ps%p(i,j  ,k)) &
                              -four*dt_i(1)*ap0(i) &
                             )*drh(i)*sth(j)*dp(k) &
                            +( st_i(j  )*( ps%t(i,j  ,k+1) &
                                          -ps%t(i,j  ,k  )) &
                             )*drh(i)*sth(j)*dp_mult &
                            +( ( ps%r(i  ,j,k+1) &
                                -ps%r(i  ,j,k  )) &
                              -( ps%r(i-1,j,k+1) &
                                -ps%r(i-1,j,k  )) &
                             )*rh(i)*dth(j)*dp_mult &
                           )
        elseif (tb1.and.j.eq.ntm1) then
          q(ii)= dv*sig*ps%p(i,j,k) &
                    +dtime*(-( dr_i(i  )*( rh(i+1)*ps%p(i+1,j,k) &
                                          -rh(i  )*ps%p(i  ,j,k)) &
                              -dr_i(i-1)*( rh(i  )*ps%p(i  ,j,k) &
                                          -rh(i-1)*ps%p(i-1,j,k)) &
                             )*rh(i)*sth(j)*dth(j)*dp(k) &
                            -(-four*dt_i(ntm1)*ap1(i) &
                              - st_i(j-1) &
                               *dt_i(j-1)*( sth(j  )*ps%p(i,j  ,k) &
                                           -sth(j-1)*ps%p(i,j-1,k)) &
                             )*drh(i)*sth(j)*dp(k) &
                            +(-st_i(j-1)*( ps%t(i,j-1,k+1) &
                                          -ps%t(i,j-1,k  )) &
                             )*drh(i)*sth(j)*dp_mult &
                            +( ( ps%r(i  ,j,k+1) &
                                -ps%r(i  ,j,k  )) &
                              -( ps%r(i-1,j,k+1) &
                                -ps%r(i-1,j,k  )) &
                             )*rh(i)*dth(j)*dp_mult &
                           )
        else
          q(ii)= dv*sig*ps%p(i,j,k) &
                    +dtime*(-( dr_i(i  )*( rh(i+1)*ps%p(i+1,j,k) &
                                          -rh(i  )*ps%p(i  ,j,k)) &
                              -dr_i(i-1)*( rh(i  )*ps%p(i  ,j,k) &
                                          -rh(i-1)*ps%p(i-1,j,k)) &
                             )*rh(i)*sth(j)*dth(j)*dp(k) &
                            -(  st_i(j  ) &
                               *dt_i(j  )*( sth(j+1)*ps%p(i,j+1,k) &
                                           -sth(j  )*ps%p(i,j  ,k)) &
                              - st_i(j-1) &
                               *dt_i(j-1)*( sth(j  )*ps%p(i,j  ,k) &
                                           -sth(j-1)*ps%p(i,j-1,k)) &
                             )*drh(i)*sth(j)*dp(k) &
                            +( st_i(j  )*( ps%t(i,j  ,k+1) &
                                          -ps%t(i,j  ,k  )) &
                              -st_i(j-1)*( ps%t(i,j-1,k+1) &
                                          -ps%t(i,j-1,k  )) &
                             )*drh(i)*sth(j)*dp_mult &
                            +( ( ps%r(i  ,j,k+1) &
                                -ps%r(i  ,j,k  )) &
                              -( ps%r(i-1,j,k+1) &
                                -ps%r(i-1,j,k  )) &
                             )*rh(i)*dth(j)*dp_mult &
                           )
        end if
!
      enddo
!$acc exit data delete(ap0,ap1)
!
end subroutine
!#######################################################################
subroutine load_preconditioner_a
!
!-----------------------------------------------------------------------
!
! ****** Set a_dia_i := 1 / diag(A)
!
!-----------------------------------------------------------------------
!
! ****** This routine is for the implicit resistivity advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use upwind_resistivity
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: small_value=1.e-30_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sig,dv
      integer :: i,j,k,ii
!
!-----------------------------------------------------------------------
!
! ****** Do the internal points of P.
!
! ****** R component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        ii=ntm2*nrm1*(k-2)+nrm1*(j-2)+i
        sig=one/max(eta_av_ar(i,j,k),small_value)
        dv=r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
        a_dia_i(ii)=one/( dv*sig &
                      +dtime*( ( st(j  )*dt_i(j  ) &
                                +st(j-1)*dt_i(j-1) &
                               )*dr(i)*dph(k) &
                              +( dp_i(k  ) &
                                +dp_i(k-1) &
                               )*dr(i)*dth(j)*sth_i(j)*dp_mult &
                             ) &
                     )
      enddo
!
! ****** Theta component.
!
      do concurrent (k=2:npm1, j=jm0:jm1, i=2:nrm1)
        ii=(npm2*ntm2*nrm1) &
           +(jm1-jm0+1)*nrm2*(k-2)+nrm2*(j-jm0)+(i-1)
        sig=one/max(eta_av_at(i,j,k),small_value)
        dv=rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
        a_dia_i(ii)=one/( dv*sig &
                      +dtime*( ( dr_i(i  ) &
                                +dr_i(i-1) &
                               )*rh(i)**2*dt(j)*st(j)*dph(k) &
                              +( dp_i(k  ) &
                                +dp_i(k-1) &
                               )*drh(i)*dt(j)*st_i(j)*dp_mult &
                             ) &
                     )
      enddo
!
! ****** Phi component.
!
! ****** Note that the points adjacent to the poles are special.
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        ii=(npm2*ntm2*nrm1) &
           +(npm2*(jm1-jm0+1)*nrm2) &
           +ntm2*nrm2*(k-1)+nrm2*(j-2)+(i-1)
        sig=one/max(eta_av_ap(i,j,k),small_value)
        dv=rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
!
        if (tb0.and.j.eq.2) then
          a_dia_i(ii)=one/( dv*sig &
                      +dtime*( ( dr_i(i  ) &
                                +dr_i(i-1) &
                               )*rh(i)**2*dth(j)*sth(j)*dp(k) &
                              +( st_i(j  )*dt_i(j  )*sth(j) &
                                +four*dt_i(1)*dp(k)*pl_i &
                               )*drh(i)*sth(j)*dp(k) &
                             ) &
                     )
        elseif (tb1.and.j.eq.ntm1) then
          a_dia_i(ii)=one/( dv*sig &
                      +dtime*( ( dr_i(i  ) &
                                +dr_i(i-1) &
                               )*rh(i)**2*dth(j)*sth(j)*dp(k) &
                              +( four*dt_i(ntm1)*dp(k)*pl_i &
                                +st_i(j-1)*dt_i(j-1)*sth(j) &
                               )*drh(i)*sth(j)*dp(k) &
                             ) &
                     )
        else
          a_dia_i(ii)=one/( dv*sig &
                      +dtime*( ( dr_i(i  ) &
                                +dr_i(i-1) &
                               )*rh(i)**2*dth(j)*sth(j)*dp(k) &
                              +( st_i(j  )*dt_i(j  )*sth(j) &
                                +st_i(j-1)*dt_i(j-1)*sth(j) &
                               )*drh(i)*sth(j)*dp(k) &
                             ) &
                     )
        end if
!
      enddo
!
end subroutine
!#######################################################################
subroutine one_minus_div_grad_v (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = dV * (rho - div-[rho*coef]-grad) P
! ****** OR
! ******   Q = (1/rho) div([nu*rho]*grad(P))
! ****** OR
! ******   Q = div(nu*grad(P))
!
! ****** at the internal points, and set all other points
! ****** of Q to zero.
!
!-----------------------------------------------------------------------
!
! ****** This routine is for the semi-implicit momentum advance
! ****** and the implicit viscosity solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: ps
      real(r_typ), dimension(N_cgvec) :: q
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ii
      real(r_typ),dimension(:,:,:),pointer,contiguous :: ps_r,ps_t,ps_p
!
!-----------------------------------------------------------------------
!
! ****** Optimization: use ptrs to avoid type hopping within GPU kernel.
!
      ps_r=>ps%r
      ps_t=>ps%t
      ps_p=>ps%p
!
! ****** Get the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        ii=ntm2*(nrm-2)*(k-2)+(nrm-2)*(j-2)+(i-1)
        q(ii)=a_r( 1,i,j,k)*ps_r(i  ,j  ,k-1) &
             +a_r( 2,i,j,k)*ps_r(i  ,j-1,k  ) &
             +a_r( 3,i,j,k)*ps_r(i-1,j  ,k  ) &
             +a_r( 4,i,j,k)*ps_r(i  ,j  ,k  ) &
             +a_r( 5,i,j,k)*ps_r(i+1,j  ,k  ) &
             +a_r( 6,i,j,k)*ps_r(i  ,j+1,k  ) &
             +a_r( 7,i,j,k)*ps_r(i  ,j  ,k+1) &
             +a_r( 8,i,j,k)*ps_t(i  ,j-1,k  ) &
             +a_r( 9,i,j,k)*ps_t(i+1,j-1,k  ) &
             +a_r(10,i,j,k)*ps_t(i  ,j  ,k  ) &
             +a_r(11,i,j,k)*ps_t(i+1,j  ,k  ) &
             +a_r(12,i,j,k)*ps_p(i  ,j  ,k-1) &
             +a_r(13,i,j,k)*ps_p(i+1,j  ,k-1) &
             +a_r(14,i,j,k)*ps_p(i  ,j  ,k  ) &
             +a_r(15,i,j,k)*ps_p(i+1,j  ,k  )
      enddo
!
! ****** Get the t component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        ii=(npm2*ntm2*(nrm-2)) &
          +(ntm-2)*nrm2*(k-2)+nrm2*(j-2)+(i-1)
        q(ii)= &
             a_t( 1,i,j,k)*ps_r(i-1,j  ,k  ) &
            +a_t( 2,i,j,k)*ps_r(i  ,j  ,k  ) &
            +a_t( 3,i,j,k)*ps_r(i-1,j+1,k  ) &
            +a_t( 4,i,j,k)*ps_r(i  ,j+1,k  ) &
            +a_t( 5,i,j,k)*ps_t(i  ,j  ,k-1) &
            +a_t( 6,i,j,k)*ps_t(i  ,j-1,k  ) &
            +a_t( 7,i,j,k)*ps_t(i-1,j  ,k  ) &
            +a_t( 8,i,j,k)*ps_t(i  ,j  ,k  ) &
            +a_t( 9,i,j,k)*ps_t(i+1,j  ,k  ) &
            +a_t(10,i,j,k)*ps_t(i  ,j+1,k  ) &
            +a_t(11,i,j,k)*ps_t(i  ,j  ,k+1) &
            +a_t(12,i,j,k)*ps_p(i  ,j  ,k-1) &
            +a_t(13,i,j,k)*ps_p(i  ,j+1,k-1) &
            +a_t(14,i,j,k)*ps_p(i  ,j  ,k  ) &
            +a_t(15,i,j,k)*ps_p(i  ,j+1,k  )
      enddo
!
! ****** Get the p component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        ii=(npm2*ntm2*(nrm-2))+(npm2*(ntm-2)*nrm2) &
           +ntm2*nrm2*(k-2)+nrm2*(j-2)+(i-1)
        q(ii)= &
              a_p( 1,i,j,k)*ps_r(i-1,j  ,k  ) &
             +a_p( 2,i,j,k)*ps_r(i  ,j  ,k  ) &
             +a_p( 3,i,j,k)*ps_r(i-1,j  ,k+1) &
             +a_p( 4,i,j,k)*ps_r(i  ,j  ,k+1) &
             +a_p( 5,i,j,k)*ps_t(i  ,j-1,k  ) &
             +a_p( 6,i,j,k)*ps_t(i  ,j  ,k  ) &
             +a_p( 7,i,j,k)*ps_t(i  ,j-1,k+1) &
             +a_p( 8,i,j,k)*ps_t(i  ,j  ,k+1) &
             +a_p( 9,i,j,k)*ps_p(i  ,j  ,k-1) &
             +a_p(10,i,j,k)*ps_p(i  ,j-1,k  ) &
             +a_p(11,i,j,k)*ps_p(i-1,j  ,k  ) &
             +a_p(12,i,j,k)*ps_p(i  ,j  ,k  ) &
             +a_p(13,i,j,k)*ps_p(i+1,j  ,k  ) &
             +a_p(14,i,j,k)*ps_p(i  ,j+1,k  ) &
             +a_p(15,i,j,k)*ps_p(i  ,j  ,k+1)
      enddo
!
end subroutine
!#######################################################################
subroutine one_minus_div_grad_v_par (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = dV * (rho - div-[rho*coef]-grad) P
! ******
! ****** at the internal points.
!
!-----------------------------------------------------------------------
!
! ****** This routine is for the parallel semi-implicit momentum
! ****** advance and the parallel implicit viscosity solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use matrix_storage_v_par_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: ps
      real(r_typ), dimension(2:nrm1,2:ntm1,2:npm1) :: q
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Set the internal points of Q.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
         q(i,j,k)= a_dia(1,i,j,k)*ps(i  ,j  ,k-1) &
                  +a_dia(2,i,j,k)*ps(i  ,j-1,k  ) &
                  +a_dia(3,i,j,k)*ps(i-1,j  ,k  ) &
                  +a_dia(4,i,j,k)*ps(i  ,j  ,k  ) &
                  +a_dia(5,i,j,k)*ps(i+1,j  ,k  ) &
                  +a_dia(6,i,j,k)*ps(i  ,j+1,k  ) &
                  +a_dia(7,i,j,k)*ps(i  ,j  ,k+1)
      enddo
!
end subroutine
!#######################################################################
subroutine load_matrix_v_solve_implicit
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix coefficients for the Backward Euler v solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use coef_storage
      use cgcom
      use matrix_storage_v_solve
      use dissipation_profiles, ONLY : visc_rho_outside
      use vars, ONLY : fl_compute
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), pointer, contiguous :: fl_fac_local
      real(r_typ), dimension(:), pointer, contiguous :: fl_fac_localh
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: five=5._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,pm
      real(r_typ) :: crp,crm,cr0
      real(r_typ) :: ctp,ctm,ct0
      real(r_typ) :: cpp,cpm,cp0
      real(r_typ) :: dpp,dpm,dmp,dmm
      real(r_typ) :: epp,epm,emp,emm
      real(r_typ), dimension(ntm) :: stp_i
      real(r_typ) :: dv,avrho,xi2,fac
      real(r_typ) :: a_rr_000, a_rr_p00, a_rr_m00, a_rr_0p0
      real(r_typ) :: a_rr_0m0, a_rr_00p, a_rr_00m, a_rt_p00
      real(r_typ) :: a_rt_pm0, a_rt_000, a_rt_0m0, a_rp_p00
      real(r_typ) :: a_rp_p0m, a_rp_000, a_rp_00m
!
      real(r_typ) :: a_tt_000, a_tt_p00, a_tt_m00, a_tt_0p0
      real(r_typ) :: a_tt_0m0, a_tt_00p, a_tt_00m, a_tr_0p0
      real(r_typ) :: a_tr_000, a_tr_mp0, a_tr_m00, a_tp_0p0
      real(r_typ) :: a_tp_0pm, a_tp_000, a_tp_00m
!
      real(r_typ) :: a_pp_000, a_pp_p00, a_pp_m00, a_pp_0p0
      real(r_typ) :: a_pp_0m0, a_pp_00p, a_pp_00m, a_pr_00p
      real(r_typ) :: a_pr_000, a_pr_m0p, a_pr_m00, a_pt_00p
      real(r_typ) :: a_pt_000, a_pt_0mp, a_pt_0m0
!
!-----------------------------------------------------------------------
!
! ****** The p component requires taking a limit of 1/sin(t)
! ****** at the poles.  Set STP_I=1/sin(t) with the appropriate
! ****** limit at the poles.
!
!$acc enter data create(stp_i)
      do concurrent (j=1:ntm)
         if (tb0.and.j.eq.1) then
           stp_i(   1)=five*dt_i(   1)
         elseif (tb1.and.j.eq.ntm) then
           stp_i(ntm)=five*dt_i(ntm)
         else
           stp_i(j)=st_i(j)
         end if
      enddo
!
      fl_fac_local => fl_fac
      fl_fac_localh => fl_fach
!
      if (fl_compute.and.equation_solved.eq.EQ_VISC) then
        fl_fac_local => fl_one
        fl_fac_localh => fl_oneh
      end if
!
! ****** Load the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          crp=AVGRTP(coef,i+1,j  ,k  )
          crm=AVGRTP(coef,i  ,j  ,k  )
          ctp=  AVGP(coef,i  ,j  ,k  )
          ctm=  AVGP(coef,i  ,j-1,k  )
          cpp=  AVGT(coef,i  ,j  ,k  )
          cpm=  AVGT(coef,i  ,j  ,k-1)
          cr0= AVGTP(coef,i  ,j  ,k  )
          dpp= AVGRP(coef,i+1,j  ,k  )
          dpm= AVGRP(coef,i+1,j-1,k  )
          dmp= AVGRP(coef,i  ,j  ,k  )
          dmm= AVGRP(coef,i  ,j-1,k  )
          epp= AVGRT(coef,i+1,j  ,k  )
          epm= AVGRT(coef,i+1,j  ,k-1)
          emp= AVGRT(coef,i  ,j  ,k  )
          emm= AVGRT(coef,i  ,j  ,k-1)
        else
          crp=  AVG(rho,i+1,j  ,k  )*AVGRTP(coef,i+1,j  ,k  )
          crm=  AVG(rho,i  ,j  ,k  )*AVGRTP(coef,i  ,j  ,k  )
          ctp=AVGRT(rho,i+1,j+1,k  )*  AVGP(coef,i  ,j  ,k  )
          ctm=AVGRT(rho,i+1,j  ,k  )*  AVGP(coef,i  ,j-1,k  )
          cpp=AVGRP(rho,i+1,j  ,k+1)*  AVGT(coef,i  ,j  ,k  )
          cpm=AVGRP(rho,i+1,j  ,k  )*  AVGT(coef,i  ,j  ,k-1)
          cr0= AVGR(rho,i+1,j  ,k  )* AVGTP(coef,i  ,j  ,k  )
          dpp= AVGT(rho,i+1,j+1,k  )* AVGRP(coef,i+1,j  ,k  )
          dpm= AVGT(rho,i+1,j  ,k  )* AVGRP(coef,i+1,j-1,k  )
          dmp= AVGT(rho,i  ,j+1,k  )* AVGRP(coef,i  ,j  ,k  )
          dmm= AVGT(rho,i  ,j  ,k  )* AVGRP(coef,i  ,j-1,k  )
          epp= AVGP(rho,i+1,j  ,k+1)* AVGRT(coef,i+1,j  ,k  )
          epm= AVGP(rho,i+1,j  ,k  )* AVGRT(coef,i+1,j  ,k-1)
          emp= AVGP(rho,i  ,j  ,k+1)* AVGRT(coef,i  ,j  ,k  )
          emm= AVGP(rho,i  ,j  ,k  )* AVGRT(coef,i  ,j  ,k-1)
        end if
!
        a_rr_p00=crp*rh(i+1)*rh(i+1)*drh_i(i+1)*dth(j)*sth(j)*dph(k)
        a_rr_m00=crm*rh(i  )*rh(i  )*drh_i(i  )*dth(j)*sth(j)*dph(k)
!
        a_rr_0p0=ctp*st(j  )*dt_i(j  )*dr(i)*dph(k)
        a_rr_0m0=ctm*st(j-1)*dt_i(j-1)*dr(i)*dph(k)
!
        a_rr_00p=dp_mult*cpp*dp_i(k  )*dr(i)*sth_i(j)*dth(j)
        a_rr_00m=dp_mult*cpm*dp_i(k-1)*dr(i)*sth_i(j)*dth(j)
!
        a_rr_000=-(a_rr_p00+a_rr_m00+a_rr_0p0+a_rr_0m0+a_rr_00p+ &
                   a_rr_00m+two*cr0*dr(i)*dth(j)*sth(j)*dph(k))
!
        dv=half*r(i)**2*dph(k)
        xi2=r_i(i)**2
        a_rt_p00= (dpp+cr0)*st(j  )*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rt_pm0=-(dpm+cr0)*st(j-1)*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rt_000=-(dmp+cr0)*st(j  )*(rh_i(i  )-xi2*rh(i  ))*dv
        a_rt_0m0= (dmm+cr0)*st(j-1)*(rh_i(i  )-xi2*rh(i  ))*dv
!
        dv=dp_mult*half*fl_fac_local(i)*r(i)**2*dth(j)
        a_rp_p00= (epp+cr0)*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rp_p0m=-(epm+cr0)*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rp_000=-(emp+cr0)*(rh_i(i  )-xi2*rh(i  ))*dv
        a_rp_00m= (emm+cr0)*(rh_i(i  )-xi2*rh(i  ))*dv
!
        dv=r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVGR(rho,i+1,j,k)
        end if
!
        a_r( 1,i,j,k)=-a_rr_00m
        a_r( 2,i,j,k)=-a_rr_0m0
        a_r( 3,i,j,k)=-a_rr_m00
        a_r( 4,i,j,k)=dv*avrho-a_rr_000
        a_r( 5,i,j,k)=-a_rr_p00
        a_r( 6,i,j,k)=-a_rr_0p0
        a_r( 7,i,j,k)=-a_rr_00p
        a_r( 8,i,j,k)=-a_rt_0m0
        a_r( 9,i,j,k)=-a_rt_pm0
        a_r(10,i,j,k)=-a_rt_000
        a_r(11,i,j,k)=-a_rt_p00
        a_r(12,i,j,k)=-a_rp_00m
        a_r(13,i,j,k)=-a_rp_p0m
        a_r(14,i,j,k)=-a_rp_000
        a_r(15,i,j,k)=-a_rp_p00
      enddo
!
! ****** Load the t component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          crp=  AVGP(coef,i  ,j  ,k  )
          crm=  AVGP(coef,i-1,j  ,k  )
          ctp=AVGRTP(coef,i  ,j+1,k  )
          ctm=AVGRTP(coef,i  ,j  ,k  )
          cpp=  AVGR(coef,i  ,j  ,k  )
          cpm=  AVGR(coef,i  ,j  ,k-1)
          ct0= AVGRP(coef,i  ,j  ,k  )
          dpp= AVGTP(coef,i  ,j+1,k  )
          dpm= AVGTP(coef,i  ,j  ,k  )
          dmp= AVGTP(coef,i-1,j+1,k  )
          dmm= AVGTP(coef,i-1,j  ,k  )
          epp= AVGRT(coef,i  ,j+1,k  )
          epm= AVGRT(coef,i  ,j+1,k-1)
          emp= AVGRT(coef,i  ,j  ,k  )
          emm= AVGRT(coef,i  ,j  ,k-1)
        else
          crp=AVGRT(rho,i+1,j+1,k  )*  AVGP(coef,i  ,j  ,k  )
          crm=AVGRT(rho,i  ,j+1,k  )*  AVGP(coef,i-1,j  ,k  )
          ctp=  AVG(rho,i  ,j+1,k  )*AVGRTP(coef,i  ,j+1,k  )
          ctm=  AVG(rho,i  ,j  ,k  )*AVGRTP(coef,i  ,j  ,k  )
          cpp=AVGTP(rho,i  ,j+1,k+1)*  AVGR(coef,i  ,j  ,k  )
          cpm=AVGTP(rho,i  ,j+1,k  )*  AVGR(coef,i  ,j  ,k-1)
          ct0= AVGT(rho,i  ,j+1,k  )* AVGRP(coef,i  ,j  ,k  )
          dpp= AVGR(rho,i+1,j+1,k  )* AVGTP(coef,i  ,j+1,k  )
          dpm= AVGR(rho,i+1,j  ,k  )* AVGTP(coef,i  ,j  ,k  )
          dmp= AVGR(rho,i  ,j+1,k  )* AVGTP(coef,i-1,j+1,k  )
          dmm= AVGR(rho,i  ,j  ,k  )* AVGTP(coef,i-1,j  ,k  )
          epp= AVGP(rho,i  ,j+1,k+1)* AVGRT(coef,i  ,j+1,k  )
          epm= AVGP(rho,i  ,j+1,k  )* AVGRT(coef,i  ,j+1,k-1)
          emp= AVGP(rho,i  ,j  ,k+1)* AVGRT(coef,i  ,j  ,k  )
          emm= AVGP(rho,i  ,j  ,k  )* AVGRT(coef,i  ,j  ,k-1)
        end if
!
        a_tt_p00=crp*fl_fac_local(i  )*r(i  )**2*dr_i(i  )* &
        dt(j)*st(j)*dph(k)
        a_tt_m00=crm*fl_fac_local(i-1)*r(i-1)**2*dr_i(i-1)* &
        dt(j)*st(j)*dph(k)
!
        a_tt_0p0=ctp*sth(j+1)*dth_i(j+1)*drh(i)*dph(k)
        a_tt_0m0=ctm*sth(j  )*dth_i(j  )*drh(i)*dph(k)
!
        a_tt_00p=dp_mult*cpp*dp_i(k  )*drh(i)*st_i(j)*dt(j)
        a_tt_00m=dp_mult*cpm*dp_i(k-1)*drh(i)*st_i(j)*dt(j)
!
        a_tt_000=-(a_tt_p00+a_tt_m00+a_tt_0p0+a_tt_0m0+a_tt_00p+ &
                   a_tt_00m+ct0*drh(i)*st_i(j)*dt(j)*dph(k))
!
        dv=half*rh(i)*st(j)*dph(k)
        a_tr_0p0= (dpp+ct0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_tr_000=-(dpm+ct0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_tr_mp0=-(dmp+ct0)*((rh_i(i)*r(i-1))**2-one)*dv
        a_tr_m00= (dmm+ct0)*((rh_i(i)*r(i-1))**2-one)*dv
!
        dv=dp_mult*half*drh(i)*st(j)
        xi2=st_i(j)**2
        a_tp_0p0= (epp+ct0)*(sth_i(j+1)-sth(j+1)*xi2)*dv
        a_tp_0pm=-(epm+ct0)*(sth_i(j+1)-sth(j+1)*xi2)*dv
        a_tp_000=-(emp+ct0)*(sth_i(j  )-sth(j  )*xi2)*dv
        a_tp_00m= (emm+ct0)*(sth_i(j  )-sth(j  )*xi2)*dv
!
        dv=fl_fac_localh(i)*rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVGT(rho,i,j+1,k)
        end if
!
        a_t( 1,i,j,k)=-a_tr_m00
        a_t( 2,i,j,k)=-a_tr_000
        a_t( 3,i,j,k)=-a_tr_mp0
        a_t( 4,i,j,k)=-a_tr_0p0
        a_t( 5,i,j,k)=-a_tt_00m
        a_t( 6,i,j,k)=-a_tt_0m0
        a_t( 7,i,j,k)=-a_tt_m00
        a_t( 8,i,j,k)=dv*avrho-a_tt_000
        a_t( 9,i,j,k)=-a_tt_p00
        a_t(10,i,j,k)=-a_tt_0p0
        a_t(11,i,j,k)=-a_tt_00p
        a_t(12,i,j,k)=-a_tp_00m
        a_t(13,i,j,k)=-a_tp_0pm
        a_t(14,i,j,k)=-a_tp_000
        a_t(15,i,j,k)=-a_tp_0p0
      enddo
!
! ****** Load the p component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          crp=  AVGT(coef,i  ,j  ,k  )
          crm=  AVGT(coef,i-1,j  ,k  )
          ctp=  AVGR(coef,i  ,j  ,k  )
          ctm=  AVGR(coef,i  ,j-1,k  )
          cpp=AVGRTP(coef,i  ,j  ,k+1)
          cpm=AVGRTP(coef,i  ,j  ,k  )
          cp0= AVGRT(coef,i  ,j  ,k  )
          dpp= AVGTP(coef,i  ,j  ,k+1)
          dmp= AVGTP(coef,i-1,j  ,k+1)
          dpm= AVGTP(coef,i  ,j  ,k  )
          dmm= AVGTP(coef,i-1,j  ,k  )
          epp= AVGRP(coef,i  ,j  ,k+1)
          emp= AVGRP(coef,i  ,j-1,k+1)
          epm= AVGRP(coef,i  ,j  ,k  )
          emm= AVGRP(coef,i  ,j-1,k  )
        else
          crp=AVGRP(rho,i+1,j  ,k+1)*  AVGT(coef,i  ,j  ,k  )
          crm=AVGRP(rho,i  ,j  ,k+1)*  AVGT(coef,i-1,j  ,k  )
          ctp=AVGTP(rho,i  ,j+1,k+1)*  AVGR(coef,i  ,j  ,k  )
          ctm=AVGTP(rho,i  ,j  ,k+1)*  AVGR(coef,i  ,j-1,k  )
          cpp=  AVG(rho,i  ,j  ,k+1)*AVGRTP(coef,i  ,j  ,k+1)
          cpm=  AVG(rho,i  ,j  ,k  )*AVGRTP(coef,i  ,j  ,k  )
          cp0= AVGP(rho,i  ,j  ,k+1)* AVGRT(coef,i  ,j  ,k  )
          dpp= AVGR(rho,i+1,j  ,k+1)* AVGTP(coef,i  ,j  ,k+1)
          dmp= AVGR(rho,i  ,j  ,k+1)* AVGTP(coef,i-1,j  ,k+1)
          dpm= AVGR(rho,i+1,j  ,k  )* AVGTP(coef,i  ,j  ,k  )
          dmm= AVGR(rho,i  ,j  ,k  )* AVGTP(coef,i-1,j  ,k  )
          epp= AVGT(rho,i  ,j+1,k+1)* AVGRP(coef,i  ,j  ,k+1)
          emp= AVGT(rho,i  ,j  ,k+1)* AVGRP(coef,i  ,j-1,k+1)
          epm= AVGT(rho,i  ,j+1,k  )* AVGRP(coef,i  ,j  ,k  )
          emm= AVGT(rho,i  ,j  ,k  )* AVGRP(coef,i  ,j-1,k  )
        end if
!
        a_pp_p00=crp*fl_fac_local(i  )*r(i  )**2*dr_i(i  )* &
        dth(j)*sth(j)*dp(k)
        a_pp_m00=crm*fl_fac_local(i-1)*r(i-1)**2*dr_i(i-1)* &
        dth(j)*sth(j)*dp(k)
!
        a_pp_0p0=ctp*st(j  )*dt_i(j  )*drh(i)*dp(k)
        a_pp_0m0=ctm*st(j-1)*dt_i(j-1)*drh(i)*dp(k)
!
        a_pp_00p=dp_mult*cpp*dph_i(k+1)*drh(i)*sth_i(j)*dth(j)
        a_pp_00m=dp_mult*cpm*dph_i(k  )*drh(i)*sth_i(j)*dth(j)
!
        a_pp_000=-(a_pp_p00+a_pp_m00+a_pp_0p0+a_pp_0m0+a_pp_00p+ &
                   a_pp_00m+cp0*drh(i)*sth_i(j)*dth(j)*dp(k))
!
        dv=dp_mult*half*rh(i)*dth(j)
        a_pr_00p= (dpp+cp0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_pr_000=-(dpm+cp0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_pr_m0p=-(dmp+cp0)*((rh_i(i)*r(i-1))**2-one)*dv
        a_pr_m00= (dmm+cp0)*((rh_i(i)*r(i-1))**2-one)*dv
!
        dv=dp_mult*half*drh(i)*sth(j)
        xi2=sth_i(j)**2
        a_pt_00p=-(epp+cp0)*(stp_i(j  )-st(j  )*xi2)*dv
        a_pt_000= (epm+cp0)*(stp_i(j  )-st(j  )*xi2)*dv
        a_pt_0mp= (emp+cp0)*(stp_i(j-1)-st(j-1)*xi2)*dv
        a_pt_0m0=-(emm+cp0)*(stp_i(j-1)-st(j-1)*xi2)*dv
!
        dv=fl_fac_localh(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVGP(rho,i,j,k+1)
        end if
!
        a_p( 1,i,j,k)=-a_pr_m00
        a_p( 2,i,j,k)=-a_pr_000
        a_p( 3,i,j,k)=-a_pr_m0p
        a_p( 4,i,j,k)=-a_pr_00p
        a_p( 5,i,j,k)=-a_pt_0m0
        a_p( 6,i,j,k)=-a_pt_000
        a_p( 7,i,j,k)=-a_pt_0mp
        a_p( 8,i,j,k)=-a_pt_00p
        a_p( 9,i,j,k)=-a_pp_00m
        a_p(10,i,j,k)=-a_pp_0m0
        a_p(11,i,j,k)=-a_pp_m00
        a_p(12,i,j,k)=dv*avrho-a_pp_000
        a_p(13,i,j,k)=-a_pp_p00
        a_p(14,i,j,k)=-a_pp_0p0
        a_p(15,i,j,k)=-a_pp_00p
      enddo
!
!$acc exit data delete(stp_i)
end subroutine
!#######################################################################
subroutine load_matrix_v_solve_explicit
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix coefficients for the viscosity operator.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use coef_storage
      use cgcom
      use matrix_storage_v_solve
      use dissipation_profiles, ONLY : visc_rho_outside
      use vars, ONLY : fl_compute
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), pointer, contiguous :: fl_fac_local
      real(r_typ), dimension(:), pointer, contiguous :: fl_fac_localh
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: five=5._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,pm
      real(r_typ) :: crp,crm,cr0
      real(r_typ) :: ctp,ctm,ct0
      real(r_typ) :: cpp,cpm,cp0
      real(r_typ) :: dpp,dpm,dmp,dmm
      real(r_typ) :: epp,epm,emp,emm
      real(r_typ), dimension(ntm) :: stp_i
      real(r_typ) :: dv,avrho,xi2,fac
      real(r_typ) :: a_rr_000, a_rr_p00, a_rr_m00, a_rr_0p0
      real(r_typ) :: a_rr_0m0, a_rr_00p, a_rr_00m, a_rt_p00
      real(r_typ) :: a_rt_pm0, a_rt_000, a_rt_0m0, a_rp_p00
      real(r_typ) :: a_rp_p0m, a_rp_000, a_rp_00m
!
      real(r_typ) :: a_tt_000, a_tt_p00, a_tt_m00, a_tt_0p0
      real(r_typ) :: a_tt_0m0, a_tt_00p, a_tt_00m, a_tr_0p0
      real(r_typ) :: a_tr_000, a_tr_mp0, a_tr_m00, a_tp_0p0
      real(r_typ) :: a_tp_0pm, a_tp_000, a_tp_00m
!
      real(r_typ) :: a_pp_000, a_pp_p00, a_pp_m00, a_pp_0p0
      real(r_typ) :: a_pp_0m0, a_pp_00p, a_pp_00m, a_pr_00p
      real(r_typ) :: a_pr_000, a_pr_m0p, a_pr_m00, a_pt_00p
      real(r_typ) :: a_pt_000, a_pt_0mp, a_pt_0m0
!
!-----------------------------------------------------------------------
!
! ****** The p component requires taking a limit of 1/sin(t)
! ****** at the poles.  Set STP_I=1/sin(t) with the appropriate
! ****** limit at the poles.
!
!$acc enter data create(stp_i)
      do concurrent (j=1:ntm)
        if (tb0.and.j.eq.1) then
          stp_i(   1)=five*dt_i(   1)
        elseif (tb1.and.j.eq.ntm) then
          stp_i(ntm)=five*dt_i(ntm)
        else
          stp_i(j)=st_i(j)
        end if
      enddo
!
      fl_fac_local => fl_fac
      fl_fac_localh => fl_fach
!
      if (fl_compute.and.equation_solved.eq.EQ_VISC) then
        fl_fac_local => fl_one
        fl_fac_localh => fl_oneh
      end if
!
! ****** Load the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          crp=AVGRTP(coef,i+1,j  ,k  )
          crm=AVGRTP(coef,i  ,j  ,k  )
          ctp=  AVGP(coef,i  ,j  ,k  )
          ctm=  AVGP(coef,i  ,j-1,k  )
          cpp=  AVGT(coef,i  ,j  ,k  )
          cpm=  AVGT(coef,i  ,j  ,k-1)
          cr0= AVGTP(coef,i  ,j  ,k  )
          dpp= AVGRP(coef,i+1,j  ,k  )
          dpm= AVGRP(coef,i+1,j-1,k  )
          dmp= AVGRP(coef,i  ,j  ,k  )
          dmm= AVGRP(coef,i  ,j-1,k  )
          epp= AVGRT(coef,i+1,j  ,k  )
          epm= AVGRT(coef,i+1,j  ,k-1)
          emp= AVGRT(coef,i  ,j  ,k  )
          emm= AVGRT(coef,i  ,j  ,k-1)
        else
          crp=  AVG(rho,i+1,j  ,k  )*AVGRTP(coef,i+1,j  ,k  )
          crm=  AVG(rho,i  ,j  ,k  )*AVGRTP(coef,i  ,j  ,k  )
          ctp=AVGRT(rho,i+1,j+1,k  )*  AVGP(coef,i  ,j  ,k  )
          ctm=AVGRT(rho,i+1,j  ,k  )*  AVGP(coef,i  ,j-1,k  )
          cpp=AVGRP(rho,i+1,j  ,k+1)*  AVGT(coef,i  ,j  ,k  )
          cpm=AVGRP(rho,i+1,j  ,k  )*  AVGT(coef,i  ,j  ,k-1)
          cr0= AVGR(rho,i+1,j  ,k  )* AVGTP(coef,i  ,j  ,k  )
          dpp= AVGT(rho,i+1,j+1,k  )* AVGRP(coef,i+1,j  ,k  )
          dpm= AVGT(rho,i+1,j  ,k  )* AVGRP(coef,i+1,j-1,k  )
          dmp= AVGT(rho,i  ,j+1,k  )* AVGRP(coef,i  ,j  ,k  )
          dmm= AVGT(rho,i  ,j  ,k  )* AVGRP(coef,i  ,j-1,k  )
          epp= AVGP(rho,i+1,j  ,k+1)* AVGRT(coef,i+1,j  ,k  )
          epm= AVGP(rho,i+1,j  ,k  )* AVGRT(coef,i+1,j  ,k-1)
          emp= AVGP(rho,i  ,j  ,k+1)* AVGRT(coef,i  ,j  ,k  )
          emm= AVGP(rho,i  ,j  ,k  )* AVGRT(coef,i  ,j  ,k-1)
        end if
!
        a_rr_p00=crp*rh(i+1)*rh(i+1)*drh_i(i+1)*dth(j)*sth(j)*dph(k)
        a_rr_m00=crm*rh(i  )*rh(i  )*drh_i(i  )*dth(j)*sth(j)*dph(k)
!
        a_rr_0p0=ctp*st(j  )*dt_i(j  )*dr(i)*dph(k)
        a_rr_0m0=ctm*st(j-1)*dt_i(j-1)*dr(i)*dph(k)
!
        a_rr_00p=dp_mult*cpp*dp_i(k  )*dr(i)*sth_i(j)*dth(j)
        a_rr_00m=dp_mult*cpm*dp_i(k-1)*dr(i)*sth_i(j)*dth(j)
!
        a_rr_000=-(a_rr_p00+a_rr_m00+a_rr_0p0+a_rr_0m0+a_rr_00p+ &
                   a_rr_00m+two*cr0*dr(i)*dth(j)*sth(j)*dph(k))
!
        dv=half*r(i)**2*dph(k)
        xi2=r_i(i)**2
        a_rt_p00= (dpp+cr0)*st(j  )*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rt_pm0=-(dpm+cr0)*st(j-1)*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rt_000=-(dmp+cr0)*st(j  )*(rh_i(i  )-xi2*rh(i  ))*dv
        a_rt_0m0= (dmm+cr0)*st(j-1)*(rh_i(i  )-xi2*rh(i  ))*dv
!
        dv=dp_mult*half*fl_fac_local(i)*r(i)**2*dth(j)
        a_rp_p00= (epp+cr0)*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rp_p0m=-(epm+cr0)*(rh_i(i+1)-xi2*rh(i+1))*dv
        a_rp_000=-(emp+cr0)*(rh_i(i  )-xi2*rh(i  ))*dv
        a_rp_00m= (emm+cr0)*(rh_i(i  )-xi2*rh(i  ))*dv
!
        dv=r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
        if (visc_rho_outside) then
          avrho=one
        else
          avrho=AVGR(rho,i+1,j,k)
        end if
!
        fac=one/(dv*avrho)
!
        a_r( 1,i,j,k)=fac*a_rr_00m
        a_r( 2,i,j,k)=fac*a_rr_0m0
        a_r( 3,i,j,k)=fac*a_rr_m00
        a_r( 4,i,j,k)=fac*a_rr_000
        a_r( 5,i,j,k)=fac*a_rr_p00
        a_r( 6,i,j,k)=fac*a_rr_0p0
        a_r( 7,i,j,k)=fac*a_rr_00p
        a_r( 8,i,j,k)=fac*a_rt_0m0
        a_r( 9,i,j,k)=fac*a_rt_pm0
        a_r(10,i,j,k)=fac*a_rt_000
        a_r(11,i,j,k)=fac*a_rt_p00
        a_r(12,i,j,k)=fac*a_rp_00m
        a_r(13,i,j,k)=fac*a_rp_p0m
        a_r(14,i,j,k)=fac*a_rp_000
        a_r(15,i,j,k)=fac*a_rp_p00
      enddo
!
! ****** Load the t component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          crp=  AVGP(coef,i  ,j  ,k  )
          crm=  AVGP(coef,i-1,j  ,k  )
          ctp=AVGRTP(coef,i  ,j+1,k  )
          ctm=AVGRTP(coef,i  ,j  ,k  )
          cpp=  AVGR(coef,i  ,j  ,k  )
          cpm=  AVGR(coef,i  ,j  ,k-1)
          ct0= AVGRP(coef,i  ,j  ,k  )
          dpp= AVGTP(coef,i  ,j+1,k  )
          dpm= AVGTP(coef,i  ,j  ,k  )
          dmp= AVGTP(coef,i-1,j+1,k  )
          dmm= AVGTP(coef,i-1,j  ,k  )
          epp= AVGRT(coef,i  ,j+1,k  )
          epm= AVGRT(coef,i  ,j+1,k-1)
          emp= AVGRT(coef,i  ,j  ,k  )
          emm= AVGRT(coef,i  ,j  ,k-1)
        else
          crp=AVGRT(rho,i+1,j+1,k  )*  AVGP(coef,i  ,j  ,k  )
          crm=AVGRT(rho,i  ,j+1,k  )*  AVGP(coef,i-1,j  ,k  )
          ctp=  AVG(rho,i  ,j+1,k  )*AVGRTP(coef,i  ,j+1,k  )
          ctm=  AVG(rho,i  ,j  ,k  )*AVGRTP(coef,i  ,j  ,k  )
          cpp=AVGTP(rho,i  ,j+1,k+1)*  AVGR(coef,i  ,j  ,k  )
          cpm=AVGTP(rho,i  ,j+1,k  )*  AVGR(coef,i  ,j  ,k-1)
          ct0= AVGT(rho,i  ,j+1,k  )* AVGRP(coef,i  ,j  ,k  )
          dpp= AVGR(rho,i+1,j+1,k  )* AVGTP(coef,i  ,j+1,k  )
          dpm= AVGR(rho,i+1,j  ,k  )* AVGTP(coef,i  ,j  ,k  )
          dmp= AVGR(rho,i  ,j+1,k  )* AVGTP(coef,i-1,j+1,k  )
          dmm= AVGR(rho,i  ,j  ,k  )* AVGTP(coef,i-1,j  ,k  )
          epp= AVGP(rho,i  ,j+1,k+1)* AVGRT(coef,i  ,j+1,k  )
          epm= AVGP(rho,i  ,j+1,k  )* AVGRT(coef,i  ,j+1,k-1)
          emp= AVGP(rho,i  ,j  ,k+1)* AVGRT(coef,i  ,j  ,k  )
          emm= AVGP(rho,i  ,j  ,k  )* AVGRT(coef,i  ,j  ,k-1)
        end if
!
        a_tt_p00=crp*fl_fac_local(i  )*r(i  )**2*dr_i(i  )* &
        dt(j)*st(j)*dph(k)
        a_tt_m00=crm*fl_fac_local(i-1)*r(i-1)**2*dr_i(i-1)* &
        dt(j)*st(j)*dph(k)
!
        a_tt_0p0=ctp*sth(j+1)*dth_i(j+1)*drh(i)*dph(k)
        a_tt_0m0=ctm*sth(j  )*dth_i(j  )*drh(i)*dph(k)
!
        a_tt_00p=dp_mult*cpp*dp_i(k  )*drh(i)*st_i(j)*dt(j)
        a_tt_00m=dp_mult*cpm*dp_i(k-1)*drh(i)*st_i(j)*dt(j)
!
        a_tt_000=-(a_tt_p00+a_tt_m00+a_tt_0p0+a_tt_0m0+a_tt_00p+ &
                   a_tt_00m+ct0*drh(i)*st_i(j)*dt(j)*dph(k))
!
        dv=half*rh(i)*st(j)*dph(k)
        a_tr_0p0= (dpp+ct0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_tr_000=-(dpm+ct0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_tr_mp0=-(dmp+ct0)*((rh_i(i)*r(i-1))**2-one)*dv
        a_tr_m00= (dmm+ct0)*((rh_i(i)*r(i-1))**2-one)*dv
!
        dv=dp_mult*half*drh(i)*st(j)
        xi2=st_i(j)**2
        a_tp_0p0= (epp+ct0)*(sth_i(j+1)-sth(j+1)*xi2)*dv
        a_tp_0pm=-(epm+ct0)*(sth_i(j+1)-sth(j+1)*xi2)*dv
        a_tp_000=-(emp+ct0)*(sth_i(j  )-sth(j  )*xi2)*dv
        a_tp_00m= (emm+ct0)*(sth_i(j  )-sth(j  )*xi2)*dv
!
        dv=fl_fac_localh(i)*rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVGT(rho,i,j+1,k)
        end if
!
        fac=one/(dv*avrho)
!
        a_t( 1,i,j,k)=fac*a_tr_m00
        a_t( 2,i,j,k)=fac*a_tr_000
        a_t( 3,i,j,k)=fac*a_tr_mp0
        a_t( 4,i,j,k)=fac*a_tr_0p0
        a_t( 5,i,j,k)=fac*a_tt_00m
        a_t( 6,i,j,k)=fac*a_tt_0m0
        a_t( 7,i,j,k)=fac*a_tt_m00
        a_t( 8,i,j,k)=fac*a_tt_000
        a_t( 9,i,j,k)=fac*a_tt_p00
        a_t(10,i,j,k)=fac*a_tt_0p0
        a_t(11,i,j,k)=fac*a_tt_00p
        a_t(12,i,j,k)=fac*a_tp_00m
        a_t(13,i,j,k)=fac*a_tp_0pm
        a_t(14,i,j,k)=fac*a_tp_000
        a_t(15,i,j,k)=fac*a_tp_0p0
      enddo
!
! ****** Load the p component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          crp=  AVGT(coef,i  ,j  ,k  )
          crm=  AVGT(coef,i-1,j  ,k  )
          ctp=  AVGR(coef,i  ,j  ,k  )
          ctm=  AVGR(coef,i  ,j-1,k  )
          cpp=AVGRTP(coef,i  ,j  ,k+1)
          cpm=AVGRTP(coef,i  ,j  ,k  )
          cp0= AVGRT(coef,i  ,j  ,k  )
          dpp= AVGTP(coef,i  ,j  ,k+1)
          dmp= AVGTP(coef,i-1,j  ,k+1)
          dpm= AVGTP(coef,i  ,j  ,k  )
          dmm= AVGTP(coef,i-1,j  ,k  )
          epp= AVGRP(coef,i  ,j  ,k+1)
          emp= AVGRP(coef,i  ,j-1,k+1)
          epm= AVGRP(coef,i  ,j  ,k  )
          emm= AVGRP(coef,i  ,j-1,k  )
        else
          crp=AVGRP(rho,i+1,j  ,k+1)*  AVGT(coef,i  ,j  ,k  )
          crm=AVGRP(rho,i  ,j  ,k+1)*  AVGT(coef,i-1,j  ,k  )
          ctp=AVGTP(rho,i  ,j+1,k+1)*  AVGR(coef,i  ,j  ,k  )
          ctm=AVGTP(rho,i  ,j  ,k+1)*  AVGR(coef,i  ,j-1,k  )
          cpp=  AVG(rho,i  ,j  ,k+1)*AVGRTP(coef,i  ,j  ,k+1)
          cpm=  AVG(rho,i  ,j  ,k  )*AVGRTP(coef,i  ,j  ,k  )
          cp0= AVGP(rho,i  ,j  ,k+1)* AVGRT(coef,i  ,j  ,k  )
          dpp= AVGR(rho,i+1,j  ,k+1)* AVGTP(coef,i  ,j  ,k+1)
          dmp= AVGR(rho,i  ,j  ,k+1)* AVGTP(coef,i-1,j  ,k+1)
          dpm= AVGR(rho,i+1,j  ,k  )* AVGTP(coef,i  ,j  ,k  )
          dmm= AVGR(rho,i  ,j  ,k  )* AVGTP(coef,i-1,j  ,k  )
          epp= AVGT(rho,i  ,j+1,k+1)* AVGRP(coef,i  ,j  ,k+1)
          emp= AVGT(rho,i  ,j  ,k+1)* AVGRP(coef,i  ,j-1,k+1)
          epm= AVGT(rho,i  ,j+1,k  )* AVGRP(coef,i  ,j  ,k  )
          emm= AVGT(rho,i  ,j  ,k  )* AVGRP(coef,i  ,j-1,k  )
        end if
!
        a_pp_p00=crp*fl_fac_local(i  )*r(i  )**2*dr_i(i  )* &
        dth(j)*sth(j)*dp(k)
        a_pp_m00=crm*fl_fac_local(i-1)*r(i-1)**2*dr_i(i-1)* &
        dth(j)*sth(j)*dp(k)
!
        a_pp_0p0=ctp*st(j  )*dt_i(j  )*drh(i)*dp(k)
        a_pp_0m0=ctm*st(j-1)*dt_i(j-1)*drh(i)*dp(k)
!
        a_pp_00p=dp_mult*cpp*dph_i(k+1)*drh(i)*sth_i(j)*dth(j)
        a_pp_00m=dp_mult*cpm*dph_i(k  )*drh(i)*sth_i(j)*dth(j)
!
        a_pp_000=-(a_pp_p00+a_pp_m00+a_pp_0p0+a_pp_0m0+a_pp_00p+ &
                   a_pp_00m+cp0*drh(i)*sth_i(j)*dth(j)*dp(k))
!
        dv=dp_mult*half*rh(i)*dth(j)
        a_pr_00p= (dpp+cp0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_pr_000=-(dpm+cp0)*((rh_i(i)*r(i  ))**2-one)*dv
        a_pr_m0p=-(dmp+cp0)*((rh_i(i)*r(i-1))**2-one)*dv
        a_pr_m00= (dmm+cp0)*((rh_i(i)*r(i-1))**2-one)*dv
!
        dv=dp_mult*half*drh(i)*sth(j)
        xi2=sth_i(j)**2
        a_pt_00p=-(epp+cp0)*(stp_i(j  )-st(j  )*xi2)*dv
        a_pt_000= (epm+cp0)*(stp_i(j  )-st(j  )*xi2)*dv
        a_pt_0mp= (emp+cp0)*(stp_i(j-1)-st(j-1)*xi2)*dv
        a_pt_0m0=-(emm+cp0)*(stp_i(j-1)-st(j-1)*xi2)*dv
!
        dv=fl_fac_localh(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVGP(rho,i,j,k+1)
        end if
!
        fac=one/(dv*avrho)
!
        a_p( 1,i,j,k)=fac*a_pr_m00
        a_p( 2,i,j,k)=fac*a_pr_000
        a_p( 3,i,j,k)=fac*a_pr_m0p
        a_p( 4,i,j,k)=fac*a_pr_00p
        a_p( 5,i,j,k)=fac*a_pt_0m0
        a_p( 6,i,j,k)=fac*a_pt_000
        a_p( 7,i,j,k)=fac*a_pt_0mp
        a_p( 8,i,j,k)=fac*a_pt_00p
        a_p( 9,i,j,k)=fac*a_pp_00m
        a_p(10,i,j,k)=fac*a_pp_0m0
        a_p(11,i,j,k)=fac*a_pp_m00
        a_p(12,i,j,k)=fac*a_pp_000
        a_p(13,i,j,k)=fac*a_pp_p00
        a_p(14,i,j,k)=fac*a_pp_0p0
        a_p(15,i,j,k)=fac*a_pp_00p
      enddo
!
!$acc exit data delete(stp_i)
end subroutine
!#######################################################################
subroutine load_preconditioner_v_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the preconditioner for the v solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_v,ifprec_32
      use globals
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ii,ierr
!
!-----------------------------------------------------------------------
!
      if (ifprec_v.eq.0) return
!
      if (ifprec_v.eq.1) then
!
! ****** Diagonal scaling:
!
        if (ifprec_32) then
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
            ii=ntm2*(nrm-2)*(k-2)+(nrm-2)*(j-2)+(i-1)
            a_dia_i_sp(ii)=real(one/a_r(4,i,j,k),r_typ_sp)
          enddo
!
          do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
            ii=(npm2*ntm2*(nrm-2)) &
              +(ntm-2)*nrm2*(k-2)+nrm2*(j-2)+(i-1)
            a_dia_i_sp(ii)=real(one/a_t(8,i,j,k),r_typ_sp)
          enddo
!
          do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
            ii=(npm2*ntm2*(nrm-2))+(npm2*(ntm-2)*nrm2) &
              +ntm2*nrm2*(k-2)+nrm2*(j-2)+(i-1)
            a_dia_i_sp(ii)=real(one/a_p(12,i,j,k),r_typ_sp)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
            ii=ntm2*(nrm-2)*(k-2)+(nrm-2)*(j-2)+(i-1)
            a_dia_i(ii)=one/a_r(4,i,j,k)
          enddo
!
          do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
            ii=(npm2*ntm2*(nrm-2)) &
              +(ntm-2)*nrm2*(k-2)+nrm2*(j-2)+(i-1)
            a_dia_i(ii)=one/a_t(8,i,j,k)
          enddo
!
          do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
            ii=(npm2*ntm2*(nrm-2))+(npm2*(ntm-2)*nrm2) &
              +ntm2*nrm2*(k-2)+nrm2*(j-2)+(i-1)
            a_dia_i(ii)=one/a_p(12,i,j,k)
          enddo
        end if
!
      elseif (ifprec_v.ge.2) then
!
! ****** Convert A matrix into CSR format:
!
        call diacsr_v (N_cgvec,M_nzz,a_r,a_t,a_p,a_vr_offsets, &
                       a_vt_offsets,a_vp_offsets,N_vr,N_vt,N_vp, &
                       a_csr,a_csr_ja,a_csr_ia,a_csr_dptr)
!
! ****** Overwrite CSR A with preconditioner L and U matrices:
!
        if (ifprec_v.eq.2) then
!
! ****** Symmetric Gauss-Seidel (SGS)
!
          do i=1,N_cgvec
            do k=a_csr_ia(i),a_csr_dptr(i)-1
              a_csr(k)=a_csr(k)/a_csr(a_csr_dptr(a_csr_ja(k)))
            enddo
          enddo
!
        elseif (ifprec_v.eq.3) then
!
! ****** Incomplete LU (ILU)
!
          ierr=0
          call ilu0 (N_cgvec,M_nzz,a_csr,a_csr_ja, &
                     a_csr_ia,a_csr_dptr,ierr)
!
          if (ierr.ne.0) then
            write(*,*) '### ERROR IN ILU FORMATION'
          end if
!
          call check_error_on_any_proc (ierr)
!
        end if
!
! ****** Convert LU stored in CSR A to LU matrix in optimized layout.
!
        call lu2luopt (N_cgvec,M_nzz,lu_csr,a_csr,a_csr_ia,a_csr_ja, &
                       lu_csr_ja,a_csr_dptr,a_N1,a_N2)
!
! ****** Store inverse of diagonal of LU matrix.
!
        do i=1,N_cgvec
          a_csr_d(i)=one/a_csr(a_csr_dptr(i))
        enddo
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            a_csr_d_sp(i)=real(a_csr_d(i),r_typ_sp)
          enddo
          do concurrent (i=1:M_nzz)
            lu_csr_sp(i)=real(lu_csr(i),r_typ_sp)
          enddo
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine load_matrix_v_par_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix coefficients for the parallel velocity solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use coef_storage
      use cgcom
      use matrix_storage_v_par_solve
      use dissipation_profiles, ONLY : visc_rho_outside
      use vars, ONLY : fl_compute
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), pointer, contiguous :: fl_fac_local
      real(r_typ), dimension(:), pointer, contiguous :: fl_fac_localh
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: dv
      real(r_typ) :: avrho
      real(r_typ) :: crp,crm,ctp,ctm,cpp,cpm
!
!-----------------------------------------------------------------------
!
      fl_fac_local => fl_fac
      fl_fac_localh => fl_fach
      if (fl_compute.and.equation_solved.eq.EQ_VISC) then
        fl_fac_local => fl_one
        fl_fac_localh => fl_oneh
      end if
!
! ****** Set matrix coefficients.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
!
        dv=fl_fac_localh(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
!
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
          crp=AVGTP(coef,i  ,j  ,k  )
          crm=AVGTP(coef,i-1,j  ,k  )
          ctp=AVGRP(coef,i  ,j  ,k  )
          ctm=AVGRP(coef,i  ,j-1,k  )
          cpp=AVGRT(coef,i  ,j  ,k  )
          cpm=AVGRT(coef,i  ,j  ,k-1)
        else
          avrho=AVG(rho,i,j,k)
          crp=AVGTP(coef,i  ,j  ,k  )*AVGR(rho,i+1,j  ,k  )
          crm=AVGTP(coef,i-1,j  ,k  )*AVGR(rho,i  ,j  ,k  )
          ctp=AVGRP(coef,i  ,j  ,k  )*AVGT(rho,i  ,j+1,k  )
          ctm=AVGRP(coef,i  ,j-1,k  )*AVGT(rho,i  ,j  ,k  )
          cpp=AVGRT(coef,i  ,j  ,k  )*AVGP(rho,i  ,j  ,k+1)
          cpm=AVGRT(coef,i  ,j  ,k-1)*AVGP(rho,i  ,j  ,k  )
        end if
!
!       a*ps(i,j,k-1):
        a_dia(1,i,j,k)=-cpm*dp_i(k-1) &
                           *drh(i)*dth(j)*sth_i(j)
!
!       a*ps(i,j-1,k):
        a_dia(2,i,j,k)=-ctm*st(j-1)*dt_i(j-1) &
                               *drh(i)*dph(k)
!
!       a*ps(i-1,j,k):
        a_dia(3,i,j,k)=-crm*fl_fac_local(i-1)*r(i-1)**2*dr_i(i-1) &
                               *sth(j)*dth(j)*dph(k)
!
!       a*ps(i,j,k):
        a_dia(4,i,j,k)= dv*avrho &
                       +( crp*fl_fac_local(i  )*r(i  )**2*dr_i(i  ) &
                         +crm*fl_fac_local(i-1)*r(i-1)**2*dr_i(i-1)) &
                        *sth(j)*dth(j)*dph(k) &
                       +( ctp*st(j  )*dt_i(j  ) &
                         +ctm*st(j-1)*dt_i(j-1)) &
                        *drh(i)*dph(k) &
                       +( cpp*dp_i(k  ) &
                         +cpm*dp_i(k-1)) &
                        *drh(i)*dth(j)*sth_i(j)
!
!       a*ps(i+1,j,k):
        a_dia(5,i,j,k)=-crp*fl_fac_local(i  )*r(i  )**2*dr_i(i  ) &
                           *sth(j)*dth(j)*dph(k)
!
!       a*ps(i,j+1,k):
        a_dia(6,i,j,k)=-ctp*st(j  )*dt_i(j  )*drh(i)*dph(k)
!
!       a*ps(i,j,k+1):
        a_dia(7,i,j,k)=-cpp*dp_i(k  )*drh(i)*dth(j)*sth_i(j)
!
      enddo
!
end subroutine
!#######################################################################
subroutine load_preconditioner_v_par_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the preconditioner for the parallel velocity solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_v,ifprec_32
      use globals
      use matrix_storage_v_par_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ii,icode
!
!-----------------------------------------------------------------------
!
      if (ifprec_v.eq.0) return
!
      if (ifprec_v.eq.1) then
!
! ****** Diagonal scaling:
!
        if (ifprec_32) then
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            ii=ntm2*(nrm2)*(k-2)+(nrm2)*(j-2)+(i-1)
            a_dia_i_sp(ii)=real(one/a_dia(4,i,j,k),r_typ_sp)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            ii=ntm2*(nrm2)*(k-2)+(nrm2)*(j-2)+(i-1)
            a_dia_i(ii)=one/a_dia(4,i,j,k)
          enddo
        end if
!
      elseif (ifprec_v.ge.2) then
!
! ****** Convert A matrix into CSR format:
!
        call diacsr_v_par (N_cgvec,M_nnz,a_dia,a_dia_offsets,a_csr, &
                           a_csr_ja,a_csr_ia,a_csr_dptr,1)
!
! ****** Overwrite CSR A with preconditioner L and U matrices:
!
        if (ifprec_v.eq.2) then
!
! ****** Symmetric Gauss-Seidel (SGS)
!
          do i=1,N_cgvec
            do k=a_csr_ia(i),a_csr_dptr(i)-1
              a_csr(k)=a_csr(k)/ &
                          a_csr(a_csr_dptr(a_csr_ja(k)))
            enddo
          enddo
!
        elseif (ifprec_v.eq.3) then
!
! ****** Incomplete LU (ILU)
!
          icode=0
          call ilu0 (N_cgvec,M_nnz,a_csr,a_csr_ja,a_csr_ia, &
                     a_csr_dptr,icode)
!
          if (icode.ne.0) then
            write(*,*) '### ERROR IN ILU FORMATION'
          end if
!
          call check_error_on_any_proc (icode)
!
        end if
!
! ****** Convert LU stored in A to LU matrix in optimized layout.
!
        call lu2luopt (N_cgvec,M_nnz,lu_csr,a_csr,a_csr_ia, &
                       a_csr_ja,lu_csr_ja,a_csr_dptr, &
                       a_N1,a_N2)
!
! ****** Store inverse of diagonal of LU matrix.
!
        do i=1,N_cgvec
          a_csr_d(i)=one/a_csr(a_csr_dptr(i))
        enddo
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            a_csr_d_sp(i)=real(a_csr_d(i),r_typ_sp)
          enddo
          do concurrent (i=1:M_nnz)
            lu_csr_sp(i)=real(lu_csr(i),r_typ_sp)
          enddo
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine load_matrix_divb_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix coefficients for the divergence cleaning solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use cgcom
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: rm,rp
!
!-----------------------------------------------------------------------
!
! ****** Set matrix coefficients.
!
      do concurrent(k=2:npm-1, j=2:ntm-1, i=i0:nrm1)
!
!       a*ps(i,j,k-1):
        a_dia(1,i,j,k)=dr(i)*dt(j)*st_i(j)*dph_i(k)
!
!       a*ps(i,j-1,k):
        a_dia(2,i,j,k)=dr(i)*dp(k)*sth(j)*dth_i(j)
!
!       a*ps(i-1,j,k):
        a_dia(3,i,j,k)=st(j)*dt(j)*dp(k)*fl_fach(i)* &
                       rh(i)**2*drh_i(i)
!
!       a*ps(i+1,j,k):
        a_dia(5,i,j,k)=st(j)*dt(j)*dp(k)*fl_fach(i+1)* &
                       rh(i+1)**2*drh_i(i+1)
!
!       a*ps(i,j+1,k):
        a_dia(6,i,j,k)=dr(i)*dp(k)*sth(j+1)*dth_i(j+1)
!
!       a*ps(i,j,k+1):
        a_dia(7,i,j,k)=dr(i)*dt(j)*st_i(j)*dph_i(k+1)
!
!       a*ps(i,j,k):
        a_dia(4,i,j,k)=-(a_dia(1,i,j,k)+a_dia(2,i,j,k) &
                        +a_dia(3,i,j,k)+a_dia(5,i,j,k) &
                        +a_dia(6,i,j,k)+a_dia(7,i,j,k))
!
      enddo
!
end subroutine
!#######################################################################
subroutine load_preconditioner_divb_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the preconditioner for the divergence cleaning solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_divb,ifprec_32
      use globals
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ii,icode
!
!-----------------------------------------------------------------------
!
      if (ifprec_divb.eq.0) return
!
      if (ifprec_divb.eq.1) then
!
! ****** Diagonal scaling:
!
        if (ifprec_32) then
          do concurrent (k=2:npm-1, j=2:ntm-1, i=i0:nrm1)
            ii=(ntm-2)*(nrm1-i0+1)*(k-2)+(nrm1-i0+1)*(j-2)+(i-(i0-1))
            a_dia_i_sp(ii)=real(one/a_dia(4,i,j,k),r_typ_sp)
          enddo
        else
          do concurrent (k=2:npm-1, j=2:ntm-1, i=i0:nrm1)
            ii=(ntm-2)*(nrm1-i0+1)*(k-2)+(nrm1-i0+1)*(j-2)+(i-(i0-1))
            a_dia_i(ii)=one/a_dia(4,i,j,k)
          enddo
        end if
!
      elseif (ifprec_divb.ge.2) then
!
! ****** Convert A matrix into CSR format:
!
        call diacsr_divb (N_cgvec,M_nnz,a_dia,a_dia_offsets,a_csr, &
                           a_csr_ja,a_csr_ia,a_csr_dptr,1)
!
! ****** Overwrite CSR A with preconditioner L and U matrices:
!
        if (ifprec_divb.eq.2) then
!
! ****** Symmetric Gauss-Seidel (SGS)
!
          do i=1,N_cgvec
            do k=a_csr_ia(i),a_csr_dptr(i)-1
              a_csr(k)=a_csr(k)/ &
                          a_csr(a_csr_dptr(a_csr_ja(k)))
            enddo
          enddo
!
        elseif (ifprec_divb.eq.3) then
!
! ****** Incomplete LU (ILU)
!
          icode=0
          call ilu0 (N_cgvec,M_nnz,a_csr,a_csr_ja,a_csr_ia, &
                     a_csr_dptr,icode)
!
          if (icode.ne.0) then
            write(*,*) '### ERROR IN ILU FORMATION'
          end if
!
          call check_error_on_any_proc (icode)
!
        end if
!
! ****** Convert LU stored in A to LU matrix in optimized layout.
!
        call lu2luopt (N_cgvec,M_nnz,lu_csr,a_csr,a_csr_ia, &
                       a_csr_ja,lu_csr_ja,a_csr_dptr, &
                       a_N1,a_N2)
!
! ****** Store inverse of diagonal of LU matrix.
!
        do i=1,N_cgvec
          a_csr_d(i)=one/a_csr(a_csr_dptr(i))
        enddo
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            a_csr_d_sp(i)=real(a_csr_d(i),r_typ_sp)
          enddo
          do concurrent (i=1:M_nnz)
            lu_csr_sp(i)=real(lu_csr(i),r_typ_sp)
          enddo
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine take_sts_step_rk2 (y,dtime_current)
!
!-----------------------------------------------------------------------
!
! ****** Integrate by one time step using RKL2 or RKG2 STS.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_interface
      use cgcom, ONLY : N_CG
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: y
      real(r_typ) :: dtime_current
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer(8) :: s_i
      integer :: i
!
!-----------------------------------------------------------------------
!
      call ax (y,dty0)
!
      do concurrent (i=1:N_CG)
        u0(i)=y(i)
        ukm2(i)=y(i)
        dty0(i)=dtime_current*dty0(i)
        ukm1(i)=u0(i)+sts_ubj(1)*dty0(i)
      enddo
!
! ****** Inner s-step loop
!
      do s_i=2,sts_s
!
        call ax (ukm1,ykm1)
!
        do concurrent (i=1:N_CG)
          y(i) =                 sts_uj(s_i)*ukm1(i) + &
                                 sts_vj(s_i)*ukm2(i) + &
                 (one-sts_uj(s_i)-sts_vj(s_i))*u0(i) + &
                          sts_ubj(s_i)*dtime_current*ykm1(i) + &
                                 sts_gj(s_i)*dty0(i)
          ukm2(i)=ukm1(i)
          ukm1(i)=y(i)
        enddo
!
      enddo
!
end subroutine
!#######################################################################
subroutine take_sts_step_rkl1 (y,dtime_current)
!
!-----------------------------------------------------------------------
!
! ****** Integrate by one time step using RKL1 STS.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_interface
      use cgcom, ONLY : N_CG
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: y
      real(r_typ) :: dtime_current
!
!-----------------------------------------------------------------------
!
      integer(8) :: s_i
      integer :: i
!
!-----------------------------------------------------------------------
!
      call ax (y,ykm1)
!
      do concurrent (i=1:N_CG)
        ukm2(i)=y(i)
        y(i)=y(i)+dtime_current*sts_ubj(1)*ykm1(i)
        ukm1(i)=y(i)
      enddo
!
! ****** Inner s-step loop
!
      do s_i=2,sts_s
!
        call ax (ukm1,ykm1)
!
        do concurrent (i=1:N_CG)
          y(i)=sts_uj(s_i)*ukm1(i)+sts_vj(s_i)*ukm2(i) &
           +sts_ubj(s_i)*dtime_current*ykm1(i)
!
          ukm2(i)=ukm1(i)
          ukm1(i)=y(i)
        enddo
!
      enddo
!
end subroutine
!#######################################################################
subroutine take_exp_step (y,steps,dt)
!
!-----------------------------------------------------------------------
!
! ****** Integrate by one time step using EULER.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars, ONLY : ntime
      use cgcom
      use mpidefs
      use debug
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: y
      integer(8) :: steps
      real(r_typ) :: dt
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: Ay
      integer(8) :: i,j
      character(30) :: solve_name
!
!-----------------------------------------------------------------------
!
      do i=1,steps
        call ax (y,Ay)
!
        do concurrent (j=1:N_CG)
          y(j)=y(j)+dt*Ay(j)
        enddo
      enddo
!
      if (solve_type.eq.ST_T) then
        if (equation_solved.eq.EQ_TE) then
          nsolves_te=nsolves_te+1
          ntotal_te=ntotal_te+steps
          solve_name='thermal conduction (e)'
        elseif (equation_solved.eq.EQ_TP) then
          nsolves_tp=nsolves_tp+1
          ntotal_tp=ntotal_tp+steps
          solve_name='thermal conduction (p)'
        end if
      elseif (solve_type.eq.ST_V) then
        nsolves_visc=nsolves_visc+1
        ntotal_visc=ntotal_visc+steps
        solve_name='viscosity'
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if(iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from TAKE_EXP_STEP:'
          write (9,*) '### Explicit Euler for '//solve_name//':'
          write (9,*) 'NTIME  = ',ntime
          write (9,*) 'DTEXP  = ',dt
          write (9,*) 'Steps      = ',steps
        end if
      end if
!
end subroutine
!#######################################################################
subroutine load_matrix_t_solve_implicit (tc)
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix coefficients for the thermal conduction solve.
! ****** tc is the temp array to use for computing the nonlinear part
! ****** of kappa.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars
      use mesh
      use fields
      use globals
      use cgcom
      use seam_interface
      use sts
      use matrix_storage_t_solve
      use boost_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: btol=tiny(one)
      real(r_typ), parameter :: quarter=0.25_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: tc
!
      real(r_typ) :: fac,dv,dv_i,kf,tav,fkpar0,brav,btav,bpav,bsq
      real(r_typ) :: frr,ftt,fpp,frt,frp,ftp,bf,fkpar
      real(r_typ) :: tb0_del,tb0_add,tb1_del,tb1_add
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Set kappa to the Spitzer value, multiplied by TCOND.
!
      if (equation_solved.eq.EQ_TE) then
        fkpar0=tcond*fkspitz
      elseif (equation_solved.eq.EQ_TP) then
        fkpar0=tcondp*fkspitz_p
      end if
!
! ****** Allocate temporary arrays.
!
      allocate (fkrr(nr,nt,np))
      allocate (fktt(nr,nt,np))
      allocate (fkpp(nr,nt,np))
      allocate (fkrt(nr,nt,np))
      allocate (fkrp(nr,nt,np))
      allocate (fktp(nr,nt,np))
!$acc enter data create(fkrr,fktt,fkpp,fkrt,fkrp,fktp)
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        fkrr(i,j,k)=0.
        fktt(i,j,k)=0.
        fkpp(i,j,k)=0.
        fkrt(i,j,k)=0.
        fkrp(i,j,k)=0.
        fktp(i,j,k)=0.
      enddo
!
! ****** Set internal points for fk arrays.
!
!$acc parallel loop collapse(3) default(present)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            brav=AVGTP(b%r,i,j,k)
            btav=AVGRP(b%t,i,j,k)
            bpav=AVGRT(b%p,i,j,k)
            bsq=brav**2+btav**2+bpav**2
            if (bsq.lt.btol) then
              frr=one
              ftt=one
              fpp=one
              frt=0.
              frp=0.
              ftp=0.
            else
              frr=brav*brav/bsq
              ftt=btav*btav/bsq
              fpp=bpav*bpav/bsq
              frt=brav*btav/bsq
              frp=brav*bpav/bsq
              ftp=btav*bpav/bsq
            end if
            tav=tc(i,j,k)*fn_t
            bf=boost(tav)
            fkpar=bf*fkpar0*(tav)**2.5_r_typ
            kf=kappa_mask(i,j,k)
            fkrr(i,j,k)=(kf*frr+(one-kf))*fkpar
            fktt(i,j,k)=(kf*ftt+(one-kf))*fkpar
            fkpp(i,j,k)=(kf*fpp+(one-kf))*fkpar
            fkrt(i,j,k)=kf*frt*fkpar
            fkrp(i,j,k)=kf*frp*fkpar
            fktp(i,j,k)=kf*ftp*fkpar
          enddo
        enddo
      enddo
!
! ****** Boundary points at r=R0.
!
      if (rb0) then
!$acc parallel loop collapse(2) default(present)
        do k=2,npm1
          do j=2,ntm1
            brav=AVGRTP(b%r,   2,j  ,k)
            btav=AVGP  (b%t,   1,j  ,k)
            bpav=AVGT  (b%p,   1,j  ,k)
            bsq=brav**2+btav**2+bpav**2
            if (bsq.lt.btol) then
              frr=one
              ftt=one
              fpp=one
              frt=0.
              frp=0.
              ftp=0.
            else
              frr=brav*brav/bsq
              ftt=btav*btav/bsq
              fpp=bpav*bpav/bsq
              frt=brav*btav/bsq
              frp=brav*bpav/bsq
              ftp=btav*bpav/bsq
            end if
            tav=(AVGR (tc,   2,j  ,k))*fn_t
            bf=boost(tav)
            fkpar=bf*fkpar0*(tav)**2.5_r_typ
            kf=kappa_mask(2,j,k)
            fkrr(1,j,k)=(kf*frr+(one-kf))*fkpar
            fktt(1,j,k)=(kf*ftt+(one-kf))*fkpar
            fkpp(1,j,k)=(kf*fpp+(one-kf))*fkpar
            fkrt(1,j,k)=kf*frt*fkpar
            fkrp(1,j,k)=kf*frp*fkpar
            fktp(1,j,k)=kf*ftp*fkpar
            fkrr(1,j,k)=two*fkrr(1,j,k)-fkrr(2,j,k)
            fktt(1,j,k)=two*fktt(1,j,k)-fktt(2,j,k)
            fkpp(1,j,k)=two*fkpp(1,j,k)-fkpp(2,j,k)
            fkrt(1,j,k)=two*fkrt(1,j,k)-fkrt(2,j,k)
            fkrp(1,j,k)=two*fkrp(1,j,k)-fkrp(2,j,k)
            fktp(1,j,k)=two*fktp(1,j,k)-fktp(2,j,k)
          enddo
        enddo
      end if
!
! ****** Boundary points at r=R1.
!
      if (rb1) then
!$acc parallel loop collapse(2) default(present)
        do k=2,npm1
          do j=2,ntm1
            brav=AVGRTP(b%r,  nr,j  ,k)
            btav=AVGP  (b%t,nrm1,j  ,k)
            bpav=AVGT  (b%p,nrm1,j  ,k)
            bsq=brav**2+btav**2+bpav**2
            if (bsq.lt.btol) then
              frr=one
              ftt=one
              fpp=one
              frt=0.
              frp=0.
              ftp=0.
            else
              frr=brav*brav/bsq
              ftt=btav*btav/bsq
              fpp=bpav*bpav/bsq
              frt=brav*btav/bsq
              frp=brav*bpav/bsq
              ftp=btav*bpav/bsq
            end if
            tav=(AVGR (tc,  nr,j  ,k))*fn_t
            bf=boost(tav)
            fkpar=bf*fkpar0*(tav)**2.5_r_typ
            kf=kappa_mask(nrm1,j,k)
            fkrr(nr,j,k)=(kf*frr+(one-kf))*fkpar
            fktt(nr,j,k)=(kf*ftt+(one-kf))*fkpar
            fkpp(nr,j,k)=(kf*fpp+(one-kf))*fkpar
            fkrt(nr,j,k)=kf*frt*fkpar
            fkrp(nr,j,k)=kf*frp*fkpar
            fktp(nr,j,k)=kf*ftp*fkpar
            fkrr(nr,j,k)=two*fkrr(nr,j,k)-fkrr(2,j,k)
            fktt(nr,j,k)=two*fktt(nr,j,k)-fktt(2,j,k)
            fkpp(nr,j,k)=two*fkpp(nr,j,k)-fkpp(2,j,k)
            fkrt(nr,j,k)=two*fkrt(nr,j,k)-fkrt(2,j,k)
            fkrp(nr,j,k)=two*fkrp(nr,j,k)-fkrp(2,j,k)
            fktp(nr,j,k)=two*fktp(nr,j,k)-fktp(2,j,k)
          enddo
        enddo
      end if
!
! ****** Apply the radial profile to reduce kappa in the
! ****** collisionless regime and zero-out phi-derivative
! ****** coeffs when in axisymmetric mode.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        fkrr(i,j,k)=fkrr(i,j,k)*prof_coll(i)
        fkrt(i,j,k)=fkrt(i,j,k)*prof_coll(i)
        fktt(i,j,k)=fktt(i,j,k)*prof_coll(i)
        fkrp(i,j,k)=fkrp(i,j,k)*prof_coll(i)*dp_mult
        fktp(i,j,k)=fktp(i,j,k)*prof_coll(i)*dp_mult
        fkpp(i,j,k)=fkpp(i,j,k)*prof_coll(i)*dp_mult
      enddo
!
! ****** Digital filtering and seaming. It is not necessary to impose
! ****** boundary conditions at the poles because those values are
! ****** never used. Inside FILTER_HHH I impose b.c. at the poles
! ****** because they are needed for the filtering.
! ****** The filtering also seams at the start.
!
      if (nfilt_kappa.ge.1) then
        do i=1,nfilt_kappa
          call filter_hhh (fkrr)
          call filter_hhh (fktt)
          call filter_hhh (fkrt)
          if (.not.axisymmetric) then
            call filter_hhh (fkrp)
            call filter_hhh (fktp)
            call filter_hhh (fkpp)
          end if
        enddo
      end if
!
! ****** Seam fk arrays.
!
      call seam_scalar (fkrr,nr,nt,np)
      call seam_scalar (fkrt,nr,nt,np)
      call seam_scalar (fktt,nr,nt,np)
      if (.not.axisymmetric) then
        call seam_scalar (fkrp,nr,nt,np)
        call seam_scalar (fktp,nr,nt,np)
        call seam_scalar (fkpp,nr,nt,np)
      end if
!
! ****** Set prefactor:
!
      fac=(gamma-one)*dtime/(he_p_x*fn_kappa)
!
! ****** Set matrix coefs
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        if (tb0.and.j.eq.2) then
          tb0_del=0.;  tb0_add=one
          tb1_del=one; tb1_add=0.
        elseif (tb1.and.j.eq.ntm1) then
          tb0_del=one; tb0_add=0.
          tb1_del=0.;  tb1_add=one
        else
          tb0_del=one; tb0_add=0.
          tb1_del=one; tb1_add=0.
        end if
!
! ****** Set volume element for diagonal term:
!
        dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
!
!       a*ps(i,j-1,k-1):
        a_dia(1,i,j,k)=-tb0_del*fac*quarter*drh(i)* &
                                       (fktp(i,j-1,k)+fktp(i,j,k-1))
!
!       a*ps(i-1,j,k-1):
        a_dia(2,i,j,k)=-fac*quarter*dth(j)* &
                         (rh(i-1)*fkrp(i-1,j,k)+rh(i)*fkrp(i,j,k-1))
!
!       a*ps(i,j,k-1):
        a_dia(3,i,j,k)=-fac*drh(i)*dth(j)*sth_i(j)*half*dp_i(k-1)* &
                                         (fkpp(i,j,k)+fkpp(i,j,k-1))
!
!       a*ps(i+1,j,k-1):
        a_dia(4,i,j,k)=fac*quarter*dth(j)* &
                         (rh(i+1)*fkrp(i+1,j,k)+rh(i)*fkrp(i,j,k-1))
!
!       a*ps(i,j+1,k-1):
        a_dia(5,i,j,k)=tb1_del*fac*quarter*drh(i)* &
                                       (fktp(i,j+1,k)+fktp(i,j,k-1))
!
!       a*ps(i-1,j-1,k):
        a_dia(6,i,j,k)=-tb0_del*fac*quarter*dph(k)* &
           (rh(i-1)*sth(j)*fkrt(i-1,j,k)+rh(i)*sth(j-1)*fkrt(i,j-1,k))
!
!       a*ps(i,j-1,k):
        a_dia(7,i,j,k)=tb0_del*( &
            -fac*drh(i)*dph(k)*st(j-1)*half*dt_i(j-1)* &
                                          (fktt(i,j,k)+fktt(i,j-1,k)))
!
!       a*ps(i+1,j-1,k):
        a_dia(8,i,j,k)=tb0_del*fac*quarter*dph(k)* &
           (rh(i+1)*sth(j)*fkrt(i+1,j,k)+rh(i)*sth(j-1)*fkrt(i,j-1,k))
!
!       a*ps(i-1,j,k):
        a_dia(9,i,j,k)=fac*sth(j)*dph(k)*( &
             -dth(j)*fl_fac(i-1)*r(i-1)**2*half*dr_i(i-1)* &
                                           (fkrr(i,j,k)+fkrr(i-1,j,k)) &
                      +(tb1_add-tb0_add)*quarter*rh(i-1)*fkrt(i-1,j,k) &
                      +(tb0_add-tb1_add)*quarter*rh(i  )*fkrt(i  ,j,k) &
             )
!
!       a*ps(i,j,k):
        a_dia(10,i,j,k)= &
             fac*sth(j)*dth(j)*dph(k)*half*( &
              fl_fac(i  )*r(i  )**2*dr_i(i  )*(fkrr(i+1,j,k)+ &
              fkrr(i  ,j,k))+ &
              fl_fac(i-1)*r(i-1)**2*dr_i(i-1)*(fkrr(i  ,j,k)+ &
              fkrr(i-1,j,k))) &
            +fac*drh(i)*dph(k)*half*( &
                       st(j  )*dt_i(j  )*(fktt(i,j+1,k)+fktt(i,j  ,k)) &
                      +st(j-1)*dt_i(j-1)*(fktt(i,j  ,k)+fktt(i,j-1,k)) &
             ) &
            +fac*drh(i)*dth(j)*sth_i(j)*half*( &
                               dp_i(k  )*(fkpp(i,j,k+1)+fkpp(i,j,k  )) &
                              +dp_i(k-1)*(fkpp(i,j,k  )+fkpp(i,j,k-1)) &
             ) &
            +       (tb0_add-tb1_add)*fac*quarter*drh(i)*fktp(i,j,k+1) &
            +       (tb1_add-tb0_add)*fac*quarter*drh(i)*fktp(i,j,k-1) &
            +                 dv*(rho(i,j,k)/he_rho)*(one+dqdt(i,j,k))
!
!         a*ps(i+1,j,k):
        a_dia(11,i,j,k)=fac*sth(j)*dph(k)*(-dth(j)* &
            fl_fac(i)*r(i)**2*half*dr_i(i)*(fkrr(i+1,j,k)+fkrr(i,j,k)) &
                    +(tb0_add-tb1_add)*quarter*rh(i+1)*fkrt(i+1,j,k) &
                    +(tb1_add-tb0_add)*quarter*rh(i  )*fkrt(i  ,j,k) &
         )
!
!       a*ps(i-1,j+1,k):
        a_dia(12,i,j,k)=tb1_del*fac*quarter*dph(k)* &
          (rh(i-1)*sth(j)*fkrt(i-1,j,k)+rh(i)*sth(j+1)*fkrt(i,j+1,k))
!
!       a*ps(i,j+1,k):
        a_dia(13,i,j,k)=tb1_del*( &
          -fac*drh(i)*dph(k)*st(j)*half*dt_i(j)* &
                                        (fktt(i,j+1,k)+fktt(i,j,k)))
!
!       a*ps(i+1,j+1,k):
        a_dia(14,i,j,k)=-tb1_del*fac*quarter*dph(k)* &
          (rh(i+1)*sth(j)*fkrt(i+1,j,k)+rh(i)*sth(j+1)*fkrt(i,j+1,k))
!
!       a*ps(i,j-1,k+1):
        a_dia(15,i,j,k)=tb0_del*fac*quarter*drh(i)* &
                                       (fktp(i,j-1,k)+fktp(i,j,k+1))
!
!       a*ps(i-1,j,k+1):
        a_dia(16,i,j,k)=fac*quarter*dth(j)* &
                         (rh(i-1)*fkrp(i-1,j,k)+rh(i)*fkrp(i,j,k+1))
!
!       a*ps(i,j,k+1):
        a_dia(17,i,j,k)= &
          -fac*drh(i)*dth(j)*sth_i(j)*half*dp_i(k)* &
                                         (fkpp(i,j,k+1)+fkpp(i,j,k))
!
!       a*ps(i+1,j,k+1):
        a_dia(18,i,j,k)=-fac*quarter*dth(j)* &
                             (rh(i+1)*fkrp(i+1,j,k)+rh(i)*fkrp(i,j,k+1))
!
!       a*ps(i,j+1,k+1):
        a_dia(19,i,j,k)=-tb1_del*fac*quarter*drh(i)* &
                                       (fktp(i,j+1,k)+fktp(i,j,k+1))
      enddo
!
! ****** Free temporary fk arrays.
!
!$acc exit data delete(fkrr,fktt,fkpp,fkrt,fkrp,fktp)
      deallocate (fkrr)
      deallocate (fktt)
      deallocate (fkpp)
      deallocate (fkrt)
      deallocate (fkrp)
      deallocate (fktp)
!
end subroutine
!#######################################################################
subroutine load_matrix_t_solve_explicit (tc)
!
!-----------------------------------------------------------------------
!
! ****** Load matrix coefficients for the thermal conduction operator.
! ****** tc is the temp array to use for computing the nonlinear part
! ****** of kappa.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars
      use mesh
      use fields
      use globals
      use cgcom
      use seam_interface
      use sts
      use matrix_storage_t_solve
      use boost_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: btol=tiny(one)
      real(r_typ), parameter :: quarter=0.25_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: tc
!
      real(r_typ) :: fac,dv,dv_i,kf,tav,fkpar0,brav,btav,bpav,bsq
      real(r_typ) :: frr,ftt,fpp,frt,frp,ftp,bf,fkpar
      real(r_typ) :: tb0_del,tb0_add,tb1_del,tb1_add
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Set kappa to the Spitzer value, multiplied by TCOND.
!
      if (equation_solved.eq.EQ_TE) then
        fkpar0=tcond*fkspitz
      elseif (equation_solved.eq.EQ_TP) then
        fkpar0=tcondp*fkspitz_p
      end if
!
! ****** Allocate temporary arrays.
!
      allocate (fkrr(nr,nt,np))
      allocate (fktt(nr,nt,np))
      allocate (fkpp(nr,nt,np))
      allocate (fkrt(nr,nt,np))
      allocate (fkrp(nr,nt,np))
      allocate (fktp(nr,nt,np))
!$acc enter data create(fkrr,fktt,fkpp,fkrt,fkrp,fktp)
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        fkrr(i,j,k)=0.
        fktt(i,j,k)=0.
        fkpp(i,j,k)=0.
        fkrt(i,j,k)=0.
        fkrp(i,j,k)=0.
        fktp(i,j,k)=0.
      enddo
!
! ****** Set internal points for fk arrays.
!
!$acc parallel loop collapse(3) default(present)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            brav=AVGTP(b%r,i,j,k)
            btav=AVGRP(b%t,i,j,k)
            bpav=AVGRT(b%p,i,j,k)
            bsq=brav**2+btav**2+bpav**2
            if (bsq.lt.btol) then
              frr=one
              ftt=one
              fpp=one
              frt=0.
              frp=0.
              ftp=0.
            else
              frr=brav*brav/bsq
              ftt=btav*btav/bsq
              fpp=bpav*bpav/bsq
              frt=brav*btav/bsq
              frp=brav*bpav/bsq
              ftp=btav*bpav/bsq
            end if
            tav=tc(i,j,k)*fn_t
            bf=boost(tav)
            fkpar=bf*fkpar0*(tav)**2.5_r_typ
            kf=kappa_mask(i,j,k)
            fkrr(i,j,k)=(kf*frr+(one-kf))*fkpar
            fktt(i,j,k)=(kf*ftt+(one-kf))*fkpar
            fkpp(i,j,k)=(kf*fpp+(one-kf))*fkpar
            fkrt(i,j,k)=kf*frt*fkpar
            fkrp(i,j,k)=kf*frp*fkpar
            fktp(i,j,k)=kf*ftp*fkpar
          enddo
        enddo
      enddo
!
! ****** Boundary points at r=R0.
!
      if (rb0) then
!$acc parallel loop collapse(2) default(present)
        do k=2,npm1
          do j=2,ntm1
            brav=AVGRTP(b%r,   2,j  ,k)
            btav=AVGP  (b%t,   1,j  ,k)
            bpav=AVGT  (b%p,   1,j  ,k)
            bsq=brav**2+btav**2+bpav**2
            if (bsq.lt.btol) then
              frr=one
              ftt=one
              fpp=one
              frt=0.
              frp=0.
              ftp=0.
            else
              frr=brav*brav/bsq
              ftt=btav*btav/bsq
              fpp=bpav*bpav/bsq
              frt=brav*btav/bsq
              frp=brav*bpav/bsq
              ftp=btav*bpav/bsq
            end if
            tav=(AVGR (tc,   2,j  ,k))*fn_t
            bf=boost(tav)
            fkpar=bf*fkpar0*(tav)**2.5_r_typ
            kf=kappa_mask(2,j,k)
            fkrr(1,j,k)=(kf*frr+(one-kf))*fkpar
            fktt(1,j,k)=(kf*ftt+(one-kf))*fkpar
            fkpp(1,j,k)=(kf*fpp+(one-kf))*fkpar
            fkrt(1,j,k)=kf*frt*fkpar
            fkrp(1,j,k)=kf*frp*fkpar
            fktp(1,j,k)=kf*ftp*fkpar
            fkrr(1,j,k)=two*fkrr(1,j,k)-fkrr(2,j,k)
            fktt(1,j,k)=two*fktt(1,j,k)-fktt(2,j,k)
            fkpp(1,j,k)=two*fkpp(1,j,k)-fkpp(2,j,k)
            fkrt(1,j,k)=two*fkrt(1,j,k)-fkrt(2,j,k)
            fkrp(1,j,k)=two*fkrp(1,j,k)-fkrp(2,j,k)
            fktp(1,j,k)=two*fktp(1,j,k)-fktp(2,j,k)
          enddo
        enddo
      end if
!
! ****** Boundary points at r=R1.
!
      if (rb1) then
!$acc parallel loop collapse(2) default(present)
        do k=2,npm1
          do j=2,ntm1
            brav=AVGRTP(b%r,  nr,j  ,k)
            btav=AVGP  (b%t,nrm1,j  ,k)
            bpav=AVGT  (b%p,nrm1,j  ,k)
            bsq=brav**2+btav**2+bpav**2
            if (bsq.lt.btol) then
              frr=one
              ftt=one
              fpp=one
              frt=0.
              frp=0.
              ftp=0.
            else
              frr=brav*brav/bsq
              ftt=btav*btav/bsq
              fpp=bpav*bpav/bsq
              frt=brav*btav/bsq
              frp=brav*bpav/bsq
              ftp=btav*bpav/bsq
            end if
            tav=(AVGR (tc,  nr,j  ,k))*fn_t
            bf=boost(tav)
            fkpar=bf*fkpar0*(tav)**2.5_r_typ
            kf=kappa_mask(nrm1,j,k)
            fkrr(nr,j,k)=(kf*frr+(one-kf))*fkpar
            fktt(nr,j,k)=(kf*ftt+(one-kf))*fkpar
            fkpp(nr,j,k)=(kf*fpp+(one-kf))*fkpar
            fkrt(nr,j,k)=kf*frt*fkpar
            fkrp(nr,j,k)=kf*frp*fkpar
            fktp(nr,j,k)=kf*ftp*fkpar
            fkrr(nr,j,k)=two*fkrr(nr,j,k)-fkrr(2,j,k)
            fktt(nr,j,k)=two*fktt(nr,j,k)-fktt(2,j,k)
            fkpp(nr,j,k)=two*fkpp(nr,j,k)-fkpp(2,j,k)
            fkrt(nr,j,k)=two*fkrt(nr,j,k)-fkrt(2,j,k)
            fkrp(nr,j,k)=two*fkrp(nr,j,k)-fkrp(2,j,k)
            fktp(nr,j,k)=two*fktp(nr,j,k)-fktp(2,j,k)
          enddo
        enddo
      end if
!
! ****** Apply the radial profile to reduce kappa in the
! ****** collisionless regime and zero-out phi-derivative
! ****** coeffs when in axisymmetric mode.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        fkrr(i,j,k)=fkrr(i,j,k)*prof_coll(i)
        fkrt(i,j,k)=fkrt(i,j,k)*prof_coll(i)
        fktt(i,j,k)=fktt(i,j,k)*prof_coll(i)
        fkrp(i,j,k)=fkrp(i,j,k)*prof_coll(i)*dp_mult
        fktp(i,j,k)=fktp(i,j,k)*prof_coll(i)*dp_mult
        fkpp(i,j,k)=fkpp(i,j,k)*prof_coll(i)*dp_mult
      enddo
!
! ****** Digital filtering and seaming. It is not necessary to impose
! ****** boundary conditions at the poles because those values are
! ****** never used. Inside FILTER_HHH I impose b.c. at the poles
! ****** because they are needed for the filtering.
! ****** The filtering also seams at the start.
!
      if (nfilt_kappa.ge.1) then
        do i=1,nfilt_kappa
          call filter_hhh (fkrr)
          call filter_hhh (fktt)
          call filter_hhh (fkrt)
          if (.not.axisymmetric) then
            call filter_hhh (fkrp)
            call filter_hhh (fktp)
            call filter_hhh (fkpp)
          end if
        enddo
      end if
!
! ****** Seam fk arrays.
!
      call seam_scalar (fkrr,nr,nt,np)
      call seam_scalar (fkrt,nr,nt,np)
      call seam_scalar (fktt,nr,nt,np)
      if (.not.axisymmetric) then
        call seam_scalar (fkrp,nr,nt,np)
        call seam_scalar (fktp,nr,nt,np)
        call seam_scalar (fkpp,nr,nt,np)
      end if
!
! ****** Set matrix coefs
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        if (tb0.and.j.eq.2) then
          tb0_del=0.;  tb0_add=one
          tb1_del=one; tb1_add=0.
        elseif (tb1.and.j.eq.ntm1) then
          tb0_del=one; tb0_add=0.
          tb1_del=0.;  tb1_add=one
        else
          tb0_del=one; tb0_add=0.
          tb1_del=one; tb1_add=0.
        end if
!
! ****** Set volume element for diagonal term:
!
        dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
        dv_i=one/dv
!
! ****** Set fac:
!
        fac=-dv_i*(he_rho/rho(i,j,k))*(gamma-one)/(he_p_x*fn_kappa)
!
!       a*ps(i,j-1,k-1):
        a_dia(1,i,j,k)=-tb0_del*fac*quarter*drh(i)* &
                                       (fktp(i,j-1,k)+fktp(i,j,k-1))
!
!       a*ps(i-1,j,k-1):
        a_dia(2,i,j,k)=-fac*quarter*dth(j)* &
                         (rh(i-1)*fkrp(i-1,j,k)+rh(i)*fkrp(i,j,k-1))
!
!       a*ps(i,j,k-1):
        a_dia(3,i,j,k)=-fac*drh(i)*dth(j)*sth_i(j)*half*dp_i(k-1)* &
                                         (fkpp(i,j,k)+fkpp(i,j,k-1))
!
!       a*ps(i+1,j,k-1):
        a_dia(4,i,j,k)=fac*quarter*dth(j)* &
                         (rh(i+1)*fkrp(i+1,j,k)+rh(i)*fkrp(i,j,k-1))
!
!       a*ps(i,j+1,k-1):
        a_dia(5,i,j,k)=tb1_del*fac*quarter*drh(i)* &
                                       (fktp(i,j+1,k)+fktp(i,j,k-1))
!
!       a*ps(i-1,j-1,k):
        a_dia(6,i,j,k)=-tb0_del*fac*quarter*dph(k)* &
           (rh(i-1)*sth(j)*fkrt(i-1,j,k)+rh(i)*sth(j-1)*fkrt(i,j-1,k))
!
!       a*ps(i,j-1,k):
        a_dia(7,i,j,k)=tb0_del*( &
            -fac*drh(i)*dph(k)*st(j-1)*half*dt_i(j-1)* &
                                          (fktt(i,j,k)+fktt(i,j-1,k)))
!
!       a*ps(i+1,j-1,k):
        a_dia(8,i,j,k)=tb0_del*fac*quarter*dph(k)* &
           (rh(i+1)*sth(j)*fkrt(i+1,j,k)+rh(i)*sth(j-1)*fkrt(i,j-1,k))
!
!       a*ps(i-1,j,k):
        a_dia(9,i,j,k)=fac*sth(j)*dph(k)*( &
             -dth(j)*fl_fac(i-1)*r(i-1)**2*half*dr_i(i-1)* &
                                           (fkrr(i,j,k)+fkrr(i-1,j,k)) &
                      +(tb1_add-tb0_add)*quarter*rh(i-1)*fkrt(i-1,j,k) &
                      +(tb0_add-tb1_add)*quarter*rh(i  )*fkrt(i  ,j,k) &
             )
!
!       a*ps(i,j,k):
        a_dia(10,i,j,k)= &
             fac*sth(j)*dth(j)*dph(k)*half*( &
              fl_fac(i  )*r(i  )**2*dr_i(i  )*(fkrr(i+1,j,k)+ &
              fkrr(i  ,j,k))+ &
              fl_fac(i-1)*r(i-1)**2*dr_i(i-1)*(fkrr(i  ,j,k)+ &
              fkrr(i-1,j,k))) &
            +fac*drh(i)*dph(k)*half*( &
                       st(j  )*dt_i(j  )*(fktt(i,j+1,k)+fktt(i,j  ,k)) &
                      +st(j-1)*dt_i(j-1)*(fktt(i,j  ,k)+fktt(i,j-1,k)) &
             ) &
            +fac*drh(i)*dth(j)*sth_i(j)*half*( &
                               dp_i(k  )*(fkpp(i,j,k+1)+fkpp(i,j,k  )) &
                              +dp_i(k-1)*(fkpp(i,j,k  )+fkpp(i,j,k-1)) &
             ) &
            +       (tb0_add-tb1_add)*fac*quarter*drh(i)*fktp(i,j,k+1) &
            +       (tb1_add-tb0_add)*fac*quarter*drh(i)*fktp(i,j,k-1)
!
!         a*ps(i+1,j,k):
        a_dia(11,i,j,k)=fac*sth(j)*dph(k)*(-dth(j)* &
            fl_fac(i)*r(i)**2*half*dr_i(i)*(fkrr(i+1,j,k)+fkrr(i,j,k)) &
                    +(tb0_add-tb1_add)*quarter*rh(i+1)*fkrt(i+1,j,k) &
                    +(tb1_add-tb0_add)*quarter*rh(i  )*fkrt(i  ,j,k) &
         )
!
!       a*ps(i-1,j+1,k):
        a_dia(12,i,j,k)=tb1_del*fac*quarter*dph(k)* &
          (rh(i-1)*sth(j)*fkrt(i-1,j,k)+rh(i)*sth(j+1)*fkrt(i,j+1,k))
!
!       a*ps(i,j+1,k):
        a_dia(13,i,j,k)=tb1_del*( &
          -fac*drh(i)*dph(k)*st(j)*half*dt_i(j)* &
                                        (fktt(i,j+1,k)+fktt(i,j,k)))
!
!       a*ps(i+1,j+1,k):
        a_dia(14,i,j,k)=-tb1_del*fac*quarter*dph(k)* &
          (rh(i+1)*sth(j)*fkrt(i+1,j,k)+rh(i)*sth(j+1)*fkrt(i,j+1,k))
!
!       a*ps(i,j-1,k+1):
        a_dia(15,i,j,k)=tb0_del*fac*quarter*drh(i)* &
                                       (fktp(i,j-1,k)+fktp(i,j,k+1))
!
!       a*ps(i-1,j,k+1):
        a_dia(16,i,j,k)=fac*quarter*dth(j)* &
                         (rh(i-1)*fkrp(i-1,j,k)+rh(i)*fkrp(i,j,k+1))
!
!       a*ps(i,j,k+1):
        a_dia(17,i,j,k)= &
          -fac*drh(i)*dth(j)*sth_i(j)*half*dp_i(k)* &
                                         (fkpp(i,j,k+1)+fkpp(i,j,k))
!
!       a*ps(i+1,j,k+1):
        a_dia(18,i,j,k)=-fac*quarter*dth(j)* &
                             (rh(i+1)*fkrp(i+1,j,k)+rh(i)*fkrp(i,j,k+1))
!
!       a*ps(i,j+1,k+1):
        a_dia(19,i,j,k)=-tb1_del*fac*quarter*drh(i)* &
                                       (fktp(i,j+1,k)+fktp(i,j,k+1))
      enddo
!
! ****** Free temporary fk arrays.
!
!$acc exit data delete(fkrr,fktt,fkpp,fkrt,fkrp,fktp)
      deallocate (fkrr)
      deallocate (fktt)
      deallocate (fkpp)
      deallocate (fkrt)
      deallocate (fkrp)
      deallocate (fktp)
!
end subroutine
!#######################################################################
subroutine load_preconditioner_t_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the preconditioner for the thermal conduction solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_t,ifprec_32
      use globals
      use matrix_storage_t_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ii,ierr
!
!-----------------------------------------------------------------------
!
      if (ifprec_t.eq.0) return
!
      if (ifprec_t.eq.1) then
!
! ****** Diagonal scaling:
!
        if (ifprec_32) then
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            ii=ntm2*nrm2*(k-2)+nrm2*(j-2)+(i-1)
            a_dia_i_sp(ii)=real(one/a_dia(10,i,j,k),r_typ_sp)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            ii=ntm2*nrm2*(k-2)+nrm2*(j-2)+(i-1)
            a_dia_i(ii)=one/a_dia(10,i,j,k)
          enddo
        end if
!
      elseif (ifprec_t.ge.2) then
!
! ****** Convert A matrix into CSR format:
!
        call diacsr_tc (N_cgvec,M_nnz,a_dia,a_dia_offsets,a_csr, &
                        a_csr_ja,a_csr_ia,a_csr_dptr,1)
!
! ****** Overwrite CSR A with preconditioner L and U matrices:
!
        if (ifprec_t.eq.2) then
!
! ****** Symmetric Gauss-Seidel (SGS)
!
          do i=1,N_cgvec
            do k=a_csr_ia(i),a_csr_dptr(i)-1
              a_csr(k)=a_csr(k)/ &
                          a_csr(a_csr_dptr(a_csr_ja(k)))
            enddo
          enddo
!
        elseif (ifprec_t.eq.3) then
!
! ****** Incomplete LU (ILU)
!
          ierr=0
          call ilu0 (N_cgvec,M_nnz,a_csr,a_csr_ja,a_csr_ia, &
                     a_csr_dptr,ierr)
!
          if (ierr.ne.0) then
            write(*,*) '### ERROR IN ILU FORMATION'
          end if
!
          call check_error_on_any_proc (ierr)
!
        end if
!
! ****** Convert LU stored in A to LU matrix in optimized layout.
!
        call lu2luopt (N_cgvec,M_nnz,lu_csr,a_csr,a_csr_ia, &
                       a_csr_ja,lu_csr_ja,a_csr_dptr, &
                       a_N1,a_N2)
!
! ****** Store inverse of diagonal of LU matrix.
!
        do i=1,N_cgvec
          a_csr_d(i)=one/a_csr(a_csr_dptr(i))
        enddo
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            a_csr_d_sp(i)=real(a_csr_d(i),r_typ_sp)
          enddo
          do concurrent (i=1:M_nnz)
            lu_csr_sp(i)=real(lu_csr(i),r_typ_sp)
          enddo
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine lu2luopt (N,M,LU,A,IA,JA,LUJA,A_da,N1,N2)
!
!-----------------------------------------------------------------------
!
! ****** Re-order elements of LU matrix in CSR format into custom,
! ****** optimized format for use with lusol().
! ****** (Eventually, this could be merged with the ilu0 and/or diacsr)
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      integer :: JA(M),LUJA(M),IA(N+1),A_da(N)
      integer :: N1(N),N2(N)
      real(r_typ) :: A(M),LU(M)
!
!-----------------------------------------------------------------------
!
      integer :: i,k,ii
!
!-----------------------------------------------------------------------
!
      ii=0
!
      do i=1,N
        do k=IA(i),A_da(i)-1
           ii=ii+1
           LU(ii)=A(k)
           LUJA(ii)=JA(k)
        enddo
!
!       Store k1 and k2 ranges for lusolve:
!
        N1(i)=A_da(i)-1-IA(i)
        N2(i)=IA(i+1)-2-A_da(i)
      enddo
!
      do i=N,1,-1
        do k=A_da(i)+1,IA(i+1)-1
           ii=ii+1
           LU(ii)=A(k)
           LUJA(ii)=JA(k)
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine diacsr_tc (N,M,Adia,ioff,Acsr,JA,IA,Adptr,ind)
!
!-----------------------------------------------------------------------
!
! *** DIACSR_TC converts MAS local thermal conduction matrix in
!     diagonal format to standard
!     compressed sparse row (CSR) with zero or one-based indexing.
!     This routine will eventually store level-of-fill 0 entries
!     for use with ilu(k).  One-based indexing is required for MAS
!     CG solver.
!
! *** This version includes periodic coefficents when nproc_p=1, so
!     that the resulting CSR matrix can be solved in external code
!     packages instead of MAS's CG solver.
!
!     Author of original diacsr: Youcef Saad
!     Modifications for MAS:     RM Caplan
!
!     Input:
!                     N: Size of the matrix (NxN)
!                     M: Number of non-zero entries in matrix
!                        (computed with getM_nnz_tc())
!            Adia(N,19): The tc matrix in MAS "DIA" format
!              ioff(19): Offsets of the diagonals in A.
!                   ind: Select (0) or (1)-based indexing for CSR.
!
!     Output:
!            Acsr(M), JA(M), IA(N+1): The matrix A in CSR.
!                           Adptr(N): Pointers to diag elements in A,
!                                     [e.g. A(i,i) == A(Adptr(i))]
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs, ONLY : nproc_p
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=19
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      real (r_typ) :: Acsr(M)
      real (r_typ) :: Adia(IDIAG,N)
      integer :: Adptr(N)
      integer :: IA(N+1)
      integer :: JA(M)
      integer :: ioff(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mi,mj,mk,ko,ind,x
      integer :: ioffok(IDIAG)
!
!-----------------------------------------------------------------------
!
      if (ind.eq.0) then
        x=1
      else
        x=0
      end if
!
!$acc enter data create(ioffok)
!$acc parallel loop collapse(3) default(present) private(ioffok)
      do mk=2,npm1
        do mj=2,ntm1
          do mi=2,nrm1
! ********* Set index of value and column indicies array:
            i = (mk-2)*(ntm1-1)*(nrm1-1)+(mj-2)*(nrm1-1)+(mi-1)
            ko = IA(i)
!
! ********* Do not add coefs that multiply boundaries:
!           For each boundary, there is a sub-set of coefs in the
!           matrix row that should not be added.
!           This makes "local" matrices have no bc info
!
! ********* Reset "i-offset-ok-to-use-coef-jj" array:
!
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok( 2)=0; ioffok( 6)=0; ioffok( 9)=0
              ioffok(12)=0; ioffok(16)=0
            end if
!
            if (mi.eq.nrm1) then
              ioffok( 4)=0; ioffok( 8)=0; ioffok(11)=0
              ioffok(14)=0; ioffok(18)=0
            end if
!
            if (mj.eq.2) then
              ioffok( 1)=0; ioffok( 6)=0; ioffok( 7)=0
              ioffok( 8)=0; ioffok(15)=0
            end if
!
            if (mj.eq.ntm1) then
              ioffok( 5)=0; ioffok(12)=0; ioffok(13)=0
              ioffok(14)=0; ioffok(19)=0
            end if
!
! ********* Eliminate periodic ceofs in the (usual) case nproc_p>1
!
            if (nproc_p.gt.1.or.axisymmetric) then
              if (mk.eq.2) then
                ioffok( 1)=0; ioffok( 2)=0; ioffok( 3)=0
                ioffok( 4)=0; ioffok( 5)=0
              end if
              if (mk.eq.npm1) then
                ioffok(15)=0; ioffok(16)=0; ioffok(17)=0
                ioffok(18)=0; ioffok(19)=0
              end if
            end if
!
! ********* To handle periodicity of phi in nproc_p=1 case:
!           We want CSR matrix to be in order so
!           have to sweep three times to avoid sorting:
!
! ********* Add periodic coefs of "right side":
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.gt.N-x) then
                  j=j-N
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
!
! ********* Now do non-periodic coefs:
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.ge.ind.and.j.le.N-x) then
!                 Store pointer to diagonal elements in A:
                  if (jj.eq.10) Adptr(i)=ko
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
!
! ********* Now do periodic coefs of "left side":
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.lt.ind) then
                  j=N+j
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
          enddo
        enddo
      enddo
!$acc exit data delete(ioffok)
!
end subroutine
!#######################################################################
subroutine diacsr_v (N,M,Adia_r,Adia_t,Adia_p,ioff_r,ioff_t, &
                           ioff_p,Nvr,Nvt,Nvp,Acsr,JA,IA,Adptr)
!
!-----------------------------------------------------------------------
!
! *** DIACSR_V converts MAS local velocity matrix in
!     diagonal format to standard
!     compressed sparse row (CSR) format with one-based indexing.
!     This routine may eventually store level-of-fill 0 entries
!     for use with ilu(k).
!
!     Author of original diacsr: Youcef Saad
!     Modifications for MAS:     RM Caplan
!
!     Input:
!                     N: Size of the matrix (NxN)
!                     M: Number of non-zero entries in matrix
!                        (computed with getM_nzz_v())
!         Adia_x(Nx,15): The velocity matrix in MAS "DIA" format
!                        for the "x" componant.
!            ioff_x(15): Offsets of the diagonals in A
!                        for the "x" componant.
!                   Nvx: Size of "x" componant without boundaries.
!
!     Output:
!            Acsr(M), JA(M), IA(N+1): The matrix A in CSR.
!                           Adptr(N): Pointers to diag elements in A,
!                                     [e.g. A(i,i) == A(Adptr(i))]
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=15
!
!-----------------------------------------------------------------------
!
      integer :: N,Nvr,Nvt,Nvp,M
      real (r_typ) :: Acsr(M)
      real (r_typ) :: Adia_r(IDIAG,Nvr),Adia_t(IDIAG,Nvt), &
                      Adia_p(IDIAG,Nvp)
      integer :: Adptr(N),IA(N+1),JA(M)
      integer :: ioff_r(IDIAG),ioff_t(IDIAG),ioff_p(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mi,mj,mk,ko,rowr,rowt,rowp
      integer :: ioffok(IDIAG)
!
!-----------------------------------------------------------------------
!
! *** Do not add coefs that multiply boundaries:
!     For each boundary, there is a sub-set of coefs in the
!     matrix row that should not be added.
!     This makes "local" matrices have no bc info
!
! *** Add r-rows:
!$acc enter data create(ioffok)
!$acc parallel loop collapse(3) default(present) private(ioffok)
      do mk=2,npm1
        do mj=2,ntm1
          do mi=2,nrm-1
!
! ********* Set index of value and column indicies array:
!
            i=(mk-2)*(ntm1-1)*(nrm-2)+(mj-2)*(nrm-2)+(mi-1)
            ko=IA(i)
            rowr=i
!
! ********* Reset "i-offset-ok-to-use-coef-jj" array:
!
            ioffok(:)=1
!
            if (mi.eq.2) ioffok( 3)=0
!
            if (mj.eq.2) then
              ioffok( 2)=0; ioffok( 8)=0; ioffok( 9)=0
            end if
!
            if (mk.eq.2) then
              ioffok( 1)=0; ioffok(12)=0; ioffok(13)=0
            end if
!
            if (mi.eq.nrm-1) then
              ioffok( 5)=0
              if (nr.eq.nrm) then
                ioffok( 9)=0; ioffok(11)=0
                ioffok(13)=0; ioffok(15)=0
              end if
            end if
!
            if (mj.eq.ntm1) ioffok( 6)=0
!
            if (mk.eq.npm1) ioffok( 7)=0
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=rowr+ioff_r(jj)
                if ( &
                    ( (jj.le.7) .and. &
                      (j.ge.1      .and.j.le.Nvr) ) .or. &
                    ( (jj.ge.8.and.jj.le.11) .and. &
                      (j.ge.Nvr+1    .and.j.le.Nvr+Nvt) ) .or. &
                    ( (jj.ge.12) .and. &
                      (j.ge.Nvr+Nvt+1.and.j.le.N) ) ) then
!
!                 Store pointer to diagonal elements in A:
                  if (jj.eq.4) Adptr(i)=ko
!
                  Acsr(ko)=Adia_r(jj,rowr)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
          enddo
        enddo
      enddo
!
! *** Add t-rows:
!
!$acc parallel loop collapse(3) default(present) private(ioffok)
      do mk=2,npm1
        do mj=2,ntm-1
          do mi=2,nrm1
!
            rowr=(npm1-1)*(ntm1-1)*(nrm-2)
            rowt=(mk-2)*(ntm-2)*(nrm1-1)+(mj-2)*(nrm1-1)+(mi-1)
            i=rowr+rowt
            ko=IA(i)
!
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok( 1)=0; ioffok( 3)=0; ioffok( 7)=0
            end if
!
            if (mj.eq.2) ioffok( 6)=0
!
            if (mk.eq.2) then
              ioffok( 5)=0; ioffok(12)=0; ioffok(13)=0
            end if
!
            if (mi.eq.nrm1) ioffok( 9)=0
!
            if (mj.eq.ntm-1) then
              ioffok(10)=0
              if (nt.eq.ntm) then
                ioffok( 3)=0; ioffok( 4)=0
                ioffok(13)=0; ioffok(15)=0
              end if
            end if
!
            if (mk.eq.npm1) ioffok(11)=0
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=rowt+ioff_t(jj)
                if ( &
                    ( (jj.le.4) .and. &
                      (j.ge.1      .and.j.le.Nvr) ) .or. &
                    ( (jj.ge.5.and.jj.le.11) .and. &
                      (j.ge.Nvr+1    .and.j.le.Nvr+Nvt) ) .or. &
                    ( (jj.ge.12) .and. &
                      (j.ge.Nvr+Nvt+1.and.j.le.N) ) ) then
!                 Store pointer to diagonal elements in A:
                  if (jj.eq.8) Adptr(i)=ko
                  Acsr(ko)=Adia_t(jj,rowt)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
          enddo
        enddo
      enddo
!
! *** Add p-rows:
!
!$acc parallel loop collapse(3) default(present) private(ioffok)
      do mk=2,npm-1
        do mj=2,ntm1
          do mi=2,nrm1
! ********* Set index of value and column indicies array:
            rowr=(npm1-1)*(ntm1-1)*(nrm-2)
            rowt=(npm1-1)*(ntm-2)*(nrm1-1)
            rowp=(mk-2)*(ntm1-1)*(nrm1-1)+(mj-2)*(nrm1-1)+(mi-1)
            i=rowr+rowt+rowp
            ko=IA(i)
!           Reset "i-offset-ok-to-use-coef-jj" array:
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok( 1)=0; ioffok( 3)=0; ioffok(11)=0
            end if
!
            if (mj.eq.2) then
              ioffok( 5)=0; ioffok( 7)=0; ioffok(10)=0
            end if
!
            if (mk.eq.2)    ioffok( 9)=0
!
            if (mi.eq.nrm1) ioffok(13)=0
!
            if (mj.eq.ntm1) ioffok(14)=0
!
            if (mk.eq.npm-1) then
              if (np.eq.npm) then
                ioffok( 3)=0; ioffok( 4)=0
                ioffok( 7)=0; ioffok( 8)=0
              end if
              ioffok(15)=0
            end if
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=rowp+ioff_p(jj)
                if (((jj.le.4).and.(j.ge.1.and.j.le.Nvr)).or. &
                    ((jj.ge.5.and.jj.le.8).and. &
                     (j.ge.Nvr+1.and.j.le.Nvr+Nvt)).or. &
                    ((jj.ge.9).and.(j.ge.Nvr+Nvt+1.and.j.le.N))) then
!
!                 Store pointer to diagonal elements in A:
!
                  if (jj.eq.12) Adptr(i)=ko
!
                  Acsr(ko)=Adia_p(jj,rowp)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
          enddo
        enddo
      enddo
!$acc exit data delete(ioffok)
!
end subroutine
!#######################################################################
subroutine diacsr_v_par (N,M,Adia,ioff,Acsr,JA,IA,Adptr,ind)
!
!-----------------------------------------------------------------------
!
! *** DIACSR_V_PAR converts MAS local parallel flow matrix in
!     diagonal format to standard
!     compressed sparse row (CSR) with zero or one-based indexing.
!     This routine will eventually store level-of-fill 0 entries
!     for use with ilu(k).  One-based indexing is required for MAS
!     CG solver.
!
! *** This version includes periodic coefficents when nproc_p=1, so
!     that the resulting CSR matrix can be solved in external code
!     packages instead of MAS's CG solver.
!
!     Author of original diacsr: Youcef Saad
!     Modifications for MAS:     RM Caplan
!
!     Input:
!                     N: Size of the matrix (NxN)
!                     M: Number of non-zero entries in matrix
!                        (computed with getM_nnz_v_par())
!             Adia(N,7): The parallel flow matrix in MAS "DIA" format
!               ioff(7): Offsets of the diagonals in A.
!                   ind: Select (0) or (1)-based indexing for CSR.
!
!     Output:
!            Acsr(M), JA(M), IA(N+1): The matrix A in CSR.
!                           Adptr(N): Pointers to diag elements in A,
!                                     [e.g. A(i,i) == A(Adptr(i))]
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs, ONLY : nproc_p
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=7
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      real (r_typ) :: Acsr(M)
      real (r_typ) :: Adia(IDIAG,N)
      integer :: Adptr(N)
      integer :: IA(N+1)
      integer :: JA(M)
      integer :: ioff(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mi,mj,mk,ko,ind,x
      integer :: ioffok(IDIAG)
!
!-----------------------------------------------------------------------
!
      if (ind.eq.0) then
        x=1
      else
        x=0
      end if
!
!$acc enter data create(ioffok)
!$acc parallel loop collapse(3) default(present) private(ioffok)
      do mk=2,npm1
        do mj=2,ntm1
          do mi=2,nrm1
! ********* Set index of value and column indicies array:
            i = (mk-2)*(ntm1-1)*(nrm1-1)+(mj-2)*(nrm1-1)+(mi-1)
            ko = IA(i)
!
! ********* Do not add coefs that multiply boundaries:
!           For each boundary, there is a sub-set of coefs in the
!           matrix row that should not be added.
!           This makes "local" matrices have no bc info
!
! ********* Reset "i-offset-ok-to-use-coef-jj" array:
!
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok(3)=0
            end if
!
            if (mi.eq.nrm1) then
              ioffok(5)=0
            end if
!
            if (mj.eq.2) then
              ioffok(2)=0
            end if
!
            if (mj.eq.ntm1) then
              ioffok(6)=0
            end if
!
            if (nproc_p.gt.1.or.axisymmetric) then
              if (mk.eq.2) then
                ioffok(1)=0
              end if
              if (mk.eq.npm1) then
                ioffok(7)=0
              end if
            end if
!
! ********* To handle periodicity of phi in nproc_p=1 case:
!           We want CSR matrix to be in order so
!           have to sweep three times to avoid sorting:
!
! ********* Add periodic coefs of "right side":
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.gt.N-x) then
                  j=j-N
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
!
! ********* Now do non-periodic coefs:
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.ge.ind.and.j.le.N-x) then
!                 Store pointer to diagonal elements in A:
                  if (jj.eq.4) Adptr(i)=ko
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
!
! ********* Now do periodic coefs of "left side":
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.lt.ind) then
                  j=N+j
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
          enddo
        enddo
      enddo
!$acc exit data delete(ioffok)
!
end subroutine
!#######################################################################
subroutine diacsr_divb (N,M,Adia,ioff,Acsr,JA,IA,Adptr,ind)
!
!-----------------------------------------------------------------------
!
! *** DIACSR_DIVB converts MAS local parallel flow matrix in
!     diagonal format to standard
!     compressed sparse row (CSR) with zero or one-based indexing.
!     This routine will eventually store level-of-fill 0 entries
!     for use with ilu(k).  One-based indexing is required for MAS
!     CG solver.
!
! *** This version includes periodic coefficents when nproc_p=1, so
!     that the resulting CSR matrix can be solved in external code
!     packages instead of MAS's CG solver.
!
!     Author of original diacsr: Youcef Saad
!     Modifications for MAS:     RM Caplan
!
!     Input:
!                     N: Size of the matrix (NxN)
!                     M: Number of non-zero entries in matrix
!                        (computed with getM_nnz_v_par())
!             Adia(N,7): The parallel flow matrix in MAS "DIA" format
!               ioff(7): Offsets of the diagonals in A.
!                   ind: Select (0) or (1)-based indexing for CSR.
!
!     Output:
!            Acsr(M), JA(M), IA(N+1): The matrix A in CSR.
!                           Adptr(N): Pointers to diag elements in A,
!                                     [e.g. A(i,i) == A(Adptr(i))]
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs, ONLY : nproc_p
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=7
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      real (r_typ) :: Acsr(M)
      real (r_typ) :: Adia(IDIAG,N)
      integer :: Adptr(N)
      integer :: IA(N+1)
      integer :: JA(M)
      integer :: ioff(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mi,mj,mk,ko,ind,x
      integer :: ioffok(IDIAG)
      integer      :: i0
!
!-----------------------------------------------------------------------
!
      if (rb0) then
        i0=1
      else
        i0=2
      end if
!
      if (ind.eq.0) then
        x=1
      else
        x=0
      end if
!
!$acc enter data create(ioffok)
!$acc parallel loop collapse(3) default(present) private(ioffok)
      do mk=2,npm-1
        do mj=2,ntm-1
          do mi=i0,nrm1
! ********* Set index of value and column indicies array:
            i = (mk-2)*(ntm-2)*(nrm1-i0+1)+(mj-2)*(nrm1-i0+1)+(mi-i0)+1
            ko = IA(i)
!
! ********* Do not add coefs that multiply boundaries:
!           For each boundary, there is a sub-set of coefs in the
!           matrix row that should not be added.
!           This makes "local" matrices have no bc info
!
! ********* Reset "i-offset-ok-to-use-coef-jj" array:
!
            ioffok(:)=1
!
            if (mi.eq.i0) then
              ioffok(3)=0
            end if
!
            if (mi.eq.nrm1) then
              ioffok(5)=0
            end if
!
            if (mj.eq.2) then
              ioffok(2)=0
            end if
!
            if (mj.eq.ntm-1) then
              ioffok(6)=0
            end if
!
            if (nproc_p.gt.1.or.axisymmetric) then
              if (mk.eq.2) then
                ioffok(1)=0
              end if
              if (mk.eq.npm-1) then
                ioffok(7)=0
              end if
            end if
!
! ********* To handle periodicity of phi in nproc_p=1 case:
!           We want CSR matrix to be in order so
!           have to sweep three times to avoid sorting:
!
! ********* Add periodic coefs of "right side":
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.gt.N-x) then
                  j=j-N
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
!
! ********* Now do non-periodic coefs:
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.ge.ind.and.j.le.N-x) then
!                 Store pointer to diagonal elements in A:
                  if (jj.eq.4) Adptr(i)=ko
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
!
! ********* Now do periodic coefs of "left side":
!
            do jj=1,IDIAG
              if (ioffok(jj).eq.1) then
                j=i+ioff(jj)-x
                if (j.lt.ind) then
                  j=N+j
                  Acsr(ko)=Adia(jj,i)
                  JA(ko)=j
                  ko=ko+1
                end if
              end if
            enddo
          enddo
        enddo
      enddo
!$acc exit data delete(ioffok)
!
end subroutine
!#######################################################################
subroutine getM_nzz_v (N, Nvr,Nvt,ioff_r,ioff_t,ioff_p,M,IA)
!
!-----------------------------------------------------------------------
!
! *** This routine computes the number of non-zeros in the
!     velocity coeff matrix for use with allocating the matrices.
!     See diacsr_v() for description of most inputs.
!     Output:  M  # of nonzeros.
!
!-----------------------------------------------------------------------
!
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=15
      integer      :: N,Nvr,Nvt,M,i,j,jj,mi,mj,mk,ko
      integer      :: rowr,rowt,rowp
      integer      :: ioff_r(IDIAG),ioff_t(IDIAG),ioff_p(IDIAG)
      integer      :: ioffok(IDIAG)
      integer      :: IA(N+1)
!
      i    =0
      IA(1)=1
!
      rowr =0
!     Add r-rows:
      do mk=2,npm1
        do mj=2,ntm1
          do mi=2,nrm-1
! ********* Set index of value and column indicies array:
            i=i+1
            rowr=rowr+1
!           Reset "i-offset-ok-to-use-coef-jj" array:
            ioffok(:)=1
!
            if (mi.eq.2) ioffok( 3)=0
!
            if (mj.eq.2) then
              ioffok( 2)=0; ioffok( 8)=0; ioffok( 9)=0
            end if
!
            if (mk.eq.2) then
              ioffok( 1)=0; ioffok(12)=0; ioffok(13)=0
            end if
!
            if (mi.eq.nrm-1) then
              ioffok( 5)=0
              if (nr.eq.nrm) then
                ioffok( 9)=0; ioffok(11)=0
                ioffok(13)=0; ioffok(15)=0
              end if
            end if
!
            if (mj.eq.ntm1) ioffok( 6)=0
!
            if (mk.eq.npm1) ioffok( 7)=0
!
            ko=0
            do jj=1, IDIAG
              if (ioffok(jj).eq.1) then
                j=rowr+ioff_r(jj)
                if ( &
                    ( (jj.le.7) .and. &
                      (j.ge.1      .and.j.le.Nvr) ) .or. &
                    ( (jj.ge.8.and.jj.le.11) .and. &
                      (j.ge.Nvr+1    .and.j.le.Nvr+Nvt) ) .or. &
                    ( (jj.ge.12) .and. &
                      (j.ge.Nvr+Nvt+1.and.j.le.N) ) ) then
                  ko=ko+1
                end if
              end if
            enddo
            IA(i+1)=IA(i)+ko
          enddo
        enddo
      enddo
!     t-rows:
      rowt=0
      do mk=2,npm1
        do mj=2,ntm-1
          do mi=2,nrm1
!
            i=i+1
            rowt=rowt+1
!
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok( 1)=0; ioffok( 3)=0; ioffok( 7)=0
            end if
!
            if (mj.eq.2) ioffok( 6)=0
!
            if (mk.eq.2) then
              ioffok( 5)=0; ioffok(12)=0; ioffok(13)=0
            end if
!
            if (mi.eq.nrm1) ioffok( 9)=0
!
            if (mj.eq.ntm-1) then
              ioffok(10)=0
              if (nt.eq.ntm) then
                ioffok( 3)=0; ioffok( 4)=0
                ioffok(13)=0; ioffok(15)=0
              end if
            end if
!
            if (mk.eq.npm1) ioffok(11)=0
!
            ko=0
            do jj=1, IDIAG
              if (ioffok(jj).eq.1) then
                j=rowt+ioff_t(jj)
                if ( &
                    ( (jj.le.4) .and. &
                      (j.ge.1      .and.j.le.Nvr) ) .or. &
                    ( (jj.ge.5.and.jj.le.11) .and. &
                      (j.ge.Nvr+1    .and.j.le.Nvr+Nvt) ) .or. &
                    ( (jj.ge.12) .and. &
                      (j.ge.Nvr+Nvt+1.and.j.le.N) ) ) then
                  ko=ko+1
                end if
              end if
            enddo
            IA(i+1)=IA(i)+ko
          enddo
        enddo
      enddo
!     p-rows:
      rowp=0
      do mk=2,npm-1
        do mj=2,ntm1
          do mi=2,nrm1
            i=i+1
            rowp=rowp+1
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok( 1)=0; ioffok( 3)=0; ioffok(11)=0
            end if
!
            if (mj.eq.2) then
              ioffok( 5)=0; ioffok( 7)=0; ioffok(10)=0
            end if
!
            if (mk.eq.2) ioffok( 9)=0
!
            if (mi.eq.nrm1) ioffok(13)=0
!
            if (mj.eq.ntm1) ioffok(14)=0
!
            if (mk.eq.npm-1) then
              if (np.eq.npm) then
                ioffok( 3)=0; ioffok( 4)=0
                ioffok( 7)=0; ioffok( 8)=0
              end if
              ioffok(15)=0
            end if
!
            ko=0
            do jj=1, IDIAG
              if (ioffok(jj).eq.1) then
                j=rowp+ioff_p(jj)
                if ( &
                    ( (jj.le.4) .and. &
                      (j.ge.1      .and.j.le.Nvr) ) .or. &
                    ( (jj.ge.5.and.jj.le.8) .and. &
                      (j.ge.Nvr+1    .and.j.le.Nvr+Nvt) ) .or. &
                    ( (jj.ge.9) .and. &
                      (j.ge.Nvr+Nvt+1.and.j.le.N) ) ) then
                  ko=ko+1
                end if
              end if
            enddo
            IA(i+1)=IA(i)+ko
          enddo
        enddo
      enddo
!
! *** Save number of non-zeros of matrix:
!
      M=IA(N+1)-1
!
end subroutine
!#######################################################################
subroutine getM_nnz_v_par (N,ioff,M,ind,IA)
!
!-----------------------------------------------------------------------
!
! *** This routine computes the number of non-zeros in the
!     parallel solve coeff matrix for use with allocating the
!     matrices.
!     See diacsr_v_par() for description of most inputs.
!     Output:  M  # of nonzeros.
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=7
      integer      :: N,M,i,j,jj,ko,mi,mj,mk,ind,x
      integer      :: ioff(IDIAG)
      integer      :: ioffok(IDIAG)
      integer      :: IA(N+1)
!
      if (ind.eq.0) then
         x=1
      else
         x=0
      end if
      i    =0
!
      IA(1)=ind
!
      do mk=2,npm1
        do mj=2,ntm1
          do mi=2,nrm1
!
            i=i+1
!
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok(3)=0
            end if
!
            if (mi.eq.nrm1) then
              ioffok(5)=0
            end if
!
            if (mj.eq.2) then
              ioffok(2)=0
            end if
!
            if (mj.eq.ntm1) then
              ioffok(6)=0
            end if
!
            if (nproc_p.gt.1.or.axisymmetric) then
              if (mk.eq.2) then
                ioffok(1)=0
              end if
              if (mk.eq.npm1) then
                ioffok(7)=0
              end if
            end if
!
            ko=0
            do jj=1, IDIAG
              if (ioffok(jj).eq.1) then
                ko=ko+1
              end if
            enddo
            IA(i+1)=IA(i)+ko
          enddo
        enddo
      enddo
!
! *** Save number of non-zeros of matrix:
!
      M=IA(N+1)-1
!
end subroutine
!#######################################################################
subroutine getM_nnz_tc (N,ioff,M,ind,IA)
!
!-----------------------------------------------------------------------
!
! *** This routine computes the number of non-zeros in the
!     thermal conduction coeff matrix for use with allocating the
!     matrices.
!     See diacsr_tc() for description of most inputs.
!     Output:  M  # of nonzeros.
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=19
      integer      :: N,M,i,j,jj,ko,mi,mj,mk,ind,x
      integer      :: ioff(IDIAG)
      integer      :: ioffok(IDIAG)
      integer      :: IA(N+1)
!
      if (ind.eq.0) then
         x=1
      else
         x=0
      end if
      i    =0
!
      IA(1)=ind
!
      do mk=2,npm1
        do mj=2,ntm1
          do mi=2,nrm1
!
            i=i+1
!
            ioffok(:)=1
!
            if (mi.eq.2) then
              ioffok( 2)=0; ioffok( 6)=0; ioffok( 9)=0
              ioffok(12)=0; ioffok(16)=0
            end if
!
            if (mi.eq.nrm1) then
              ioffok( 4)=0; ioffok( 8)=0; ioffok(11)=0
              ioffok(14)=0; ioffok(18)=0
            end if
!
            if (mj.eq.2) then
              ioffok( 1)=0; ioffok( 6)=0; ioffok( 7)=0
              ioffok( 8)=0; ioffok(15)=0
            end if
!
            if (mj.eq.ntm1) then
              ioffok( 5)=0; ioffok(12)=0; ioffok(13)=0
              ioffok(14)=0; ioffok(19)=0
            end if
!
            if (nproc_p.gt.1.or.axisymmetric) then
              if (mk.eq.2) then
                ioffok( 1)=0; ioffok( 2)=0; ioffok( 3)=0
                ioffok( 4)=0; ioffok( 5)=0
              end if
              if (mk.eq.npm1) then
                ioffok(15)=0; ioffok(16)=0; ioffok(17)=0
                ioffok(18)=0; ioffok(19)=0
              end if
            end if
!
            ko=0
            do jj=1, IDIAG
              if (ioffok(jj).eq.1) then
                ko=ko+1
              end if
            enddo
            IA(i+1)=IA(i)+ko
          enddo
        enddo
      enddo
!
! *** Save number of non-zeros of matrix:
!
      M=IA(N+1)-1
!
end subroutine
!#######################################################################
subroutine getM_nnz_divb (N,ioff,M,ind,IA)
!
!-----------------------------------------------------------------------
!
! *** This routine computes the number of non-zeros in the
!     parallel solve coeff matrix for use with allocating the
!     matrices.
!     See diacsr_divb() for description of most inputs.
!     Output:  M  # of nonzeros.
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=7
      integer      :: N,M,i,j,jj,ko,mi,mj,mk,ind,x
      integer      :: ioff(IDIAG)
      integer      :: ioffok(IDIAG)
      integer      :: i0
      integer      :: IA(N+1)
!
!-----------------------------------------------------------------------
!
      if (rb0) then
        i0=1
      else
        i0=2
      end if
!
      if (ind.eq.0) then
         x=1
      else
         x=0
      end if
      i    =0
!
      IA(1)=ind
!
      do mk=2,npm-1
        do mj=2,ntm-1
          do mi=i0,nrm1
!
            i=i+1
!
            ioffok(:)=1
!
            if (mi.eq.i0) then
              ioffok(3)=0
            end if
!
            if (mi.eq.nrm1) then
              ioffok(5)=0
            end if
!
            if (mj.eq.2) then
              ioffok(2)=0
            end if
!
            if (mj.eq.ntm-1) then
              ioffok(6)=0
            end if
!
            if (nproc_p.gt.1.or.axisymmetric) then
              if (mk.eq.2) then
                ioffok(1)=0
              end if
              if (mk.eq.npm-1) then
                ioffok(7)=0
              end if
            end if
!
            ko=0
            do jj=1, IDIAG
              if (ioffok(jj).eq.1) then
                ko=ko+1
              end if
            enddo
            IA(i+1)=IA(i)+ko
          enddo
        enddo
      enddo
!
! *** Save number of non-zeros of matrix:
!
      M=IA(N+1)-1
!
end subroutine
!#######################################################################
subroutine lusol (N,M,x,x_sp,LU,LU_sp,LU_ja,N1,N2,LUd_i,LUd_i_sp)
!
!-----------------------------------------------------------
!
!     Performs a forward and a backward solve for the sparse system
!     (LU) x=y  where LU is in an optimized custom CSR format
!                                              (see lu2luopt())
!
!     For use where LU is an ILU or SSOR/SGS factorization.
!
!     Author of original lusol: Yousef Saad
!           Iterative Methods for Sparse Linear Systems 2nd Ed. pg. 299
!
!     Modified by RM Caplan for optimized memory access.
!
!     Optimization described in
!     B. Smith, H. Zhang  Inter. J. of High Perf. Comp. Appl.
!     Vol. 25 #4 pg. 386-391 (2011)
!
!-----------------------------------------------------------
!     PARAMETERS:
!     N     : Dimension of problem
!     x     : At input, x is rhs (y), at output x is the solution.
!     LU    : Values of the LU matrix. L and U are stored together in
!             order of access in this routine.
!     LU_ja : Column indices of elements in LU.
!     N1    : Row-start indicies in original CSR LU.
!     N2    : Indices of diagonal elements in orig CSR LU
!     LUd_i : Inverse diagonal elements of U
!------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_32
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      real(r_typ) :: x(N),LUd_i(N),LU(M)
      real(r_typ_sp) :: x_sp(N),LUd_i_sp(N),LU_sp(M)
      integer :: N1(N),N2(N),LU_ja(M)
!
!-----------------------------------------------------------------------
!
      integer :: i,k,k1,k2
!
!-----------------------------------------------------------------------
!
      k2=0
      if (ifprec_32) then
!
! ****** Convert input array to single precision.
!
        do concurrent (i=1:N)
          x_sp(i) = real(x(i),r_typ_sp)
        enddo
!
! ***** FORWARD SOLVE: Solve L x'=y
!
        do i=1,N
!         Compute xi := xi - sum Lij*xj
          k1=k2+1
          k2=k1+N1(i)
          do k=k1,k2
            x_sp(i)=x_sp(i)-LU_sp(k)*x_sp(LU_ja(k))
          enddo
!         Compute xi := xi/Lii
!         Diagonal is always 1 for L so no computation nessesary.
        enddo
!
! ***** BACKWARD SOLVE: Solve U x=x'
!
        do i=N,1,-1
!         Compute xi := xi - sum Uij*xj
          k1=k2+1
          k2=k1+N2(i)
          do k=k1,k2
            x_sp(i)=x_sp(i)-LU_sp(k)*x_sp(LU_ja(k))
          enddo
!         Compute xi := xi/Uii
          x_sp(i)=x_sp(i)*LUd_i_sp(i)
        enddo
!
! ****** Convert result back to double precision.
!
        do concurrent (i=1:N)
          x(i) = real(x_sp(i),r_typ)
        enddo
!
      else
!
! ***** FORWARD SOLVE: Solve L x'=y
!
        do i=1,N
!         Compute xi := xi - sum Lij*xj
          k1=k2+1
          k2=k1+N1(i)
          do k=k1,k2
            x(i)=x(i)-LU(k)*x(LU_ja(k))
          enddo
!         Compute xi := xi/Lii
!         Diagonal is always 1 for L so no computation nessesary.
        enddo
!
! ***** BACKWARD SOLVE: Solve U x=x'
!
        do i=N,1,-1
!         Compute xi := xi - sum Uij*xj
          k1=k2+1
          k2=k1+N2(i)
          do k=k1,k2
            x(i)=x(i)-LU(k)*x(LU_ja(k))
          enddo
!         Compute xi := xi/Uii
          x(i)=x(i)*LUd_i(i)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine ilu0 (N,M,A,JA,IA,A_da,ierr)
!
!-----------------------------------------------------------
!
!     Set-up routine for ILU(0) preconditioner. This routine
!     computes the L and U factors of the ILU(0) factorization
!     of a general sparse matrix A stored in CSR format with
!     1-based indexing. Since
!     L is unit triangular, the L and U factors can be stored
!     as a single matrix which occupies the same storage as A.
!     New ja and ia arrays are not needed for the LU matrix
!     since the pattern of the LU matrix is identical with
!     that of A.
!
!     Original Author:  Yousef Saad
!            Iterative Methods for Sparse Linear Systems 2nd Ed. pg. 309
!     Modified by R.M. Caplan
!
!-----------------------------------------------------------
!     INPUT:
!     N         : Dimension of matrix
!     A, JA, IA : Sparse matrix in CSR sparse storage format
!     A_da      : Pointers to the diagonal elements in the CSR
!                 data structure luval
!
!     OUTPUT:
!     A     : L/U matrices stored together. On return A,
!             JA, and IA are the combined CSR data structure for
!             the L and U factors.
!     ierr : Integer indicating error code on return:
!             (0): Normal return.
!             (k): Encountered a zero pivot at step k.
!------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr,N,M
      integer :: JA(M),IA(N+1),A_da(N),iw(N)
      real(r_typ) :: A(M)
!
!-----------------------------------------------------------------------
!
      integer :: i,ik,kj,k,ij,IA_i,IA_ip1m1
      real(r_typ) :: Aik
!
!-----------------------------------------------------------------------
!
      ierr=0
!     Initialize scratch index array:
      iw(:)=0
!
      do i=2,N
!       Store index of (i,j) in A in scratch array of iw(j=1:N)
!       This allows lookup given a column index (j) in row (k)
!       to see if the column is in row (i).
        IA_i    =IA(i)
        IA_ip1m1=IA(i+1)-1
!
        do ij=IA_i,IA_ip1m1
          iw(JA(ij))=ij
        enddo
!
!       Loop from first element in row i to 1 less than diagonal elem:
        do ik=IA_i,A_da(i)-1     !IA(i+1) !ik is index of (i,k) in A[]
          k    =JA(ik)           !Actual column index in matrix (k)
          Aik  =A(ik)/A(A_da(k)) !Save Aik for next loop as an optim.
          A(ik)=Aik
!
!         Loop from 1 more than diag elem to last elem in row k:
          do kj=A_da(k)+1,IA(k+1)-1 !kj is index of (k,j) in A[]
!            Get ij location from scratch array (if 0, no ij present)
             ij=iw(JA(kj))
             if (ij .ne. 0) then
               A(ij)=A(ij)-Aik*A(kj)
             end if
          enddo
        enddo
!
        if (A(ik).eq.0) then
          ierr=i
          exit
        end if
!
!       Reset scratch index array:
        do ij=IA_i,IA_ip1m1
          iw(JA(ij))=0
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine load_sts_coeffs_rkl2 (dtime_current,dtime_exp)
!
!-----------------------------------------------------------------------
!
! ****** Set up parameters and coefficient arrays for STS advance.
! ****** This uses the RKL2 2nd-order STS as given in
! ****** Meyer, et. al. J. Comp. Phys. 257 (2014) 594-626
!
!-----------------------------------------------------------------------
!
      use number_types
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: three=3._r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: six=6._r_typ
      real(r_typ), parameter :: nine=9._r_typ
      real(r_typ), parameter :: sixteen=16._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: flag=-9999.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer(8),   parameter :: two_int=2
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sts_s_real,bj_bjm2,bj_bjm1,dtime_exp,dtime_current
      integer(8) :: j
!
!-----------------------------------------------------------------------
!
! ****** Compute number of iterations per super-step.
!
      sts_s_real=half*(sqrt(nine+sixteen*(dtime_current/dtime_exp))-one)
      sts_s=ceiling(sts_s_real)
!
! ****** Make sure that there are at least 5 steps.
!
      if (sts_s.lt.5) then
        sts_s=5
      end if
!
! ****** Make sure s is odd for better stability.
!
      if(MOD(sts_s,two_int).eq.0) then
        sts_s=sts_s+1
      end if
!
! ****** Allocate RKL2 super-time-step coefficent arrays.
!
      allocate ( sts_uj(sts_s))
      allocate ( sts_vj(sts_s))
      allocate (sts_ubj(sts_s))
      allocate ( sts_gj(sts_s))
      allocate (  sts_b(sts_s))
!
! ****** Compute super-time-step coefficents.
!
      sts_b(1)=one/three
      sts_b(2)=one/three
!
! ****** Use flag values for coefficents that are not used.
!
      sts_uj(1)=flag
      sts_vj(1)=flag
      sts_ubj(1)=four/(three*(sts_s*sts_s+sts_s-two_int))
      sts_gj(1)=flag
!
      sts_uj(2)=three/two
      sts_vj(2)=-half
      sts_ubj(2)=six/(sts_s*sts_s+sts_s-two_int)
      sts_gj(2)=-four/(sts_s*sts_s+sts_s-two_int)
!
      do j=3,sts_s
        sts_b(j)=(j*j+j-two)/(two*j*(j+1))
        bj_bjm1=sts_b(j)/sts_b(j-1)
        bj_bjm2=sts_b(j)/sts_b(j-2)
!
        sts_uj(j)=bj_bjm1*(two-one/j)
        sts_vj(j)=-bj_bjm2*(one-one/j)
        sts_ubj(j)=sts_uj(j)*four/(sts_s*sts_s+sts_s-two_int)
        sts_gj(j)=-(one-sts_b(j-1))*sts_ubj(j)
      enddo
!
!$acc enter data copyin(sts_uj,sts_vj,sts_ubj,sts_gj,sts_b)
end subroutine
!#######################################################################
subroutine load_sts_coeffs_rkl1 (dtime_current,dtime_exp)
!
!-----------------------------------------------------------------------
!
! ****** Set up parameters and coefficient arrays for STS advance.
! ****** This uses the RKL1 1st-order STS as given in
! ****** Meyer, et. al. J. Comp. Phys. 257 (2014) 594-626
!
!-----------------------------------------------------------------------
!
      use number_types
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: eight=8._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
      integer(8),  parameter :: two_int=2
!
!-----------------------------------------------------------------------
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sts_s_real,dtime_exp,dtime_current
      integer(8) :: j
!
!-----------------------------------------------------------------------
!
! ****** Compute number of iterations per super-step.
!
      sts_s_real=half*(sqrt(one+eight*(dtime_current/dtime_exp))-one)
      sts_s=ceiling(sts_s_real)
!
! ****** Make sure that there are at least 5 steps.
!
      if (sts_s.lt.5) then
        sts_s=5
      end if
!
! ****** Make sure s is odd for better stability
! ****** And due to rkl1 high-mode issue, add another couple of steps.
!
      if(MOD(sts_s,two_int).eq.0) then
        sts_s=sts_s+3
      end if
!
! ****** Allocate.
!
      allocate ( sts_uj(sts_s))
      allocate ( sts_vj(sts_s))
      allocate (sts_ubj(sts_s))
!
! ****** Compute super-time-step coefficents.
!
      do j=1,sts_s
        sts_uj(j)=(two*j-one)/j
        sts_vj(j)=(one-j)/j
        sts_ubj(j)=((two*j-one)/j)*two/(sts_s*sts_s+sts_s)
      enddo
!
!$acc enter data copyin(sts_uj,sts_vj,sts_ubj)
end subroutine
!#######################################################################
subroutine load_sts_coeffs_rkg2 (dtime_current,dtime_exp)
!
!-----------------------------------------------------------------------
!
! ****** Set up parameters and coefficient arrays for STS advance.
! ****** This uses the RKG2 2nd-order STS as given in
! ****** Skaras, et. al. J. Comp. Phys. 425 (2021) 109879
!
!-----------------------------------------------------------------------
!
      use number_types
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: dtime_exp,dtime_current
!
!-----------------------------------------------------------------------
!
      integer(8),  parameter :: one_int=1
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      integer(8),  parameter :: two_int=2
      real(r_typ), parameter :: three=3._r_typ
      real(r_typ), parameter :: four=4._r_typ
      integer(8),  parameter :: four_int=4
      real(r_typ), parameter :: six=6._r_typ
      real(r_typ), parameter :: ten=10._r_typ
      real(r_typ), parameter :: fifteen=15._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: twentyfour=24.0_r_typ
      real(r_typ), parameter :: twentyfive=25.0_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: flag=-9999.0_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sts_s_real,bj_bjm2,bj_bjm1,w
      integer(8) :: j
!
!-----------------------------------------------------------------------
!
! ****** Compute number of iterations per super-step.
!
      sts_s_real=half*(sqrt(twentyfive+ &
                            twentyfour*(dtime_current/dtime_exp)) &
                       -three)
!
      sts_s=CEILING(sts_s_real)
!
! ****** Make sure s is at least 5.
!
      if (sts_s.lt.5) then
        sts_s=5
      endif
!
! ****** Make sure s is odd.
!
      if (MOD(sts_s,two_int).eq.0) then
        sts_s=sts_s+1
      endif
!
! ****** Allocate super-time-step coefficent arrays.
!
      allocate ( sts_uj(sts_s))
      allocate ( sts_vj(sts_s))
      allocate (sts_ubj(sts_s))
      allocate ( sts_gj(sts_s))
      allocate (  sts_b(sts_s))
!
! ****** Compute super-time-step coefficents.
!
      w=six/((sts_s+four_int)*(sts_s-one_int))
!
! ****** Compute super-time-step coefficents.
!
      !b0=one
      sts_b(1)=one/three
      sts_b(2)=one/fifteen
!
      sts_uj(1)=one
      sts_vj(1)=flag
      sts_ubj(1)=w
      sts_gj(1)=flag
!
      sts_uj(2)=one/two
      sts_vj(2)=-one/ten
      sts_ubj(2)=sts_uj(2)*w
      sts_gj(2)=zero
!
      do j=3,sts_s
        sts_b(j)=(four*(j-1)*(j+4))/(three*j*(j+1)*(j+2)*(j+3))
        bj_bjm1=sts_b(j)/sts_b(j-1)
        bj_bjm2=sts_b(j)/sts_b(j-2)
!
        sts_uj(j)=bj_bjm1*(two+one/j)
        sts_vj(j)=-bj_bjm2*(one/j+one)
        sts_ubj(j)=sts_uj(j)*w
        sts_gj(j)=(half*j*(j+one)*sts_b(j-1)-one)*sts_ubj(j)
      enddo
!
!$acc enter data copyin(sts_uj,sts_vj,sts_ubj,sts_gj,sts_b)
end subroutine
!#######################################################################
subroutine alloc_t_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays in which the matrix coefficients and
! ****** preconditioners for the thermal conduction solve are stored.
!
!-----------------------------------------------------------------------
!
      use globals, ONLY : nrm1,ntm1,npm1
      use cgcom,   ONLY : ifprec_t,ifprec_32
      use sts,     ONLY : use_sts_tc
      use matrix_storage_t_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
!
!-----------------------------------------------------------------------
!
      allocate (a_dia(19,2:nrm1,2:ntm1,2:npm1))
!$acc enter data create(a_dia)
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1, l=1:19)
        a_dia(l,i,j,k)=0.
      enddo
!
      if (ifprec_32) then
        allocate (a_dia_i_sp(N_cgvec))
!$acc enter data create(a_dia_i_sp)
        do concurrent (i=1:N_cgvec)
          a_dia_i_sp(i)=0.
        enddo
      else
        allocate (a_dia_i(N_cgvec))
!$acc enter data create(a_dia_i)
        do concurrent (i=1:N_cgvec)
          a_dia_i(i)=0.
        enddo
      endif
!
! ****** Allocate CSR storage of matrix and LU preconditioner:
!
      if (ifprec_t.ge.2.and..not.use_sts_tc) then
        if (ifprec_32) then
          allocate (lu_csr_sp  (    M_nnz))
          allocate (a_csr_d_sp (  N_cgvec))
        end if
        allocate (a_csr   (    M_nnz))
        allocate (lu_csr  (    M_nnz))
        allocate (a_csr_d (    N_cgvec))
        allocate (lu_csr_ja(   M_nnz))
        allocate (a_csr_ja(    M_nnz))
        allocate (a_N1(        N_cgvec))
        allocate (a_N2(        N_cgvec))
        allocate (a_csr_dptr(  N_cgvec))
      end if
!
end subroutine
!#######################################################################
subroutine dealloc_t_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the arrays in which the matrix coefficients
! ****** for the thermal conduction solve are stored.
!
!-----------------------------------------------------------------------
!
      use matrix_storage_t_solve
      use cgcom, ONLY : ifprec_t,ifprec_32
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a_dia)
      deallocate (a_dia)
!
      if (ifprec_32) then
!$acc exit data delete(a_dia_i_sp)
        deallocate (a_dia_i_sp)
      else
!$acc exit data delete(a_dia_i)
        deallocate (a_dia_i)
      endif
!
      if (ifprec_t.ge.2.and..not.use_sts_tc) then
        if (ifprec_32) then
          deallocate (lu_csr_sp)
          deallocate (a_csr_d_sp)
        end if
        deallocate (a_csr)
        deallocate (lu_csr)
        deallocate (a_csr_d)
        deallocate (lu_csr_ja)
        deallocate (a_csr_ja)
        deallocate (a_N1)
        deallocate (a_N2)
        deallocate (a_csr_dptr)
      end if
!
end subroutine
!#######################################################################
subroutine alloc_a_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays in which the matrix coefficients
! ****** for the resistivity solve are stored.
!
!-----------------------------------------------------------------------
!
      use globals
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i
!
!-----------------------------------------------------------------------
!
      allocate (a_dia_i(N_cgvec))
!$acc enter data create(a_dia_i)
      do concurrent (i=1:N_cgvec)
        a_dia_i(i)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine dealloc_a_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the arrays in which the matrix coefficients
! ****** for the resistivity solve are stored.
!
!-----------------------------------------------------------------------
!
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a_dia_i)
      deallocate (a_dia_i)
!
end subroutine
!#######################################################################
subroutine load_sts (dtime_current)
!
!-----------------------------------------------------------------------
!
! ****** Set up the STS thermal conduction integration step.
!
!-----------------------------------------------------------------------
!
      use vars, ONLY : ntime
      use cgcom
      use mpidefs
      use debug
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: dtime_exp,dtime_current
      character(32) :: solve_name=' '
!
!-----------------------------------------------------------------------
!
! ****** Allocate scratch arrays.
!
      allocate (  u0(N_CG))
      allocate (dty0(N_CG))
      allocate (ykm1(N_CG))
      allocate (ukm1(N_CG))
      allocate (ukm2(N_CG))
!$acc enter data create(u0,dty0,ykm1,ukm1,ukm2)
!
      call alloc_cg_ax_tmp
!
! *** Get the explicit Euler time-step limit.
!
      if (solve_type.eq.ST_T) then
        call get_dtexp_tc (dtime_exp)
      elseif (solve_type.eq.ST_V) then
        call get_dtexp_visc (dtime_exp)
      end if
!
! *** Compute the STS step coefficents.
!
      if (sts_type.eq.1) then
        call load_sts_coeffs_rkl1 (dtime_current,dtime_exp)
      elseif (sts_type.eq.2) then
        call load_sts_coeffs_rkl2 (dtime_current,dtime_exp)
      elseif (sts_type.eq.3) then
        call load_sts_coeffs_rkg2 (dtime_current,dtime_exp)
      end if
!
! *** Record the number of STS sub-steps.
!
      if (solve_type.eq.ST_T) then
        if (equation_solved.eq.EQ_TE) then
          nsolves_te=nsolves_te+1
          ntotal_te=ntotal_te+sts_s
          solve_name='thermal conduction (e)'
        elseif (equation_solved.eq.EQ_TP) then
          nsolves_tp=nsolves_tp+1
          ntotal_tp=ntotal_tp+sts_s
          solve_name='thermal conduction (p)'
        end if
      elseif (solve_type.eq.ST_V) then
        nsolves_visc=nsolves_visc+1
        ntotal_visc=ntotal_visc+sts_s
        solve_name='viscosity'
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if(iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_STS:'
          write (9,*) '### STS setup for '//trim(solve_name)//':'
          write (9,*) 'NTIME  = ',ntime
          write (9,*) 'DTEXP  = ',dtime_exp
          write (9,*) 'STSFAC = ',dtime_current/dtime_exp
          write (9,*) 'STS_S  = ',sts_s
        end if
      end if
!
end subroutine
!#######################################################################
subroutine unload_sts
!
!-----------------------------------------------------------------------
!
! ****** Clean up the STS thermal conduction integration step.
!
!-----------------------------------------------------------------------
!
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the scratch arrays.
!
!$acc exit data delete (u0,dty0,ykm1,ukm1,ukm2)
      deallocate (  u0)
      deallocate (dty0)
      deallocate (ykm1)
      deallocate (ukm1)
      deallocate (ukm2)
!
! ****** Deallocate the STS coefficent arrays.
!
!$acc exit data delete (sts_uj,sts_vj,sts_ubj)
      deallocate (sts_uj)
      deallocate (sts_vj)
      deallocate (sts_ubj)
      if (sts_type.ge.2) then
!$acc exit data delete (sts_gj,sts_b)
        deallocate (sts_gj)
        deallocate (sts_b)
      end if
!
      call dealloc_cg_ax_tmp
!
end subroutine
!#######################################################################
subroutine alloc_v_matrix_coefs
!
!-----------------------------------------------------------------------
!
! *** Allocate the arrays in which the matrix coefficients are stored
!
!-----------------------------------------------------------------------
!
      use globals
      use cgcom, ONLY : ifprec_v,ifprec_32
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
!
!-----------------------------------------------------------------------
!
! ****** Since only 2:nxm1 elements accessed, set custom indices
! ****** to save storage and obtain better memory accesses.
!
      allocate (a_r(15, 2:nrm-1, 2:ntm1,  2:npm1  ))
      allocate (a_t(15, 2:nrm1,  2:ntm-1, 2:npm1  ))
      allocate (a_p(15, 2:nrm1,  2:ntm1,  2:npm-1 ))
!$acc enter data create(a_r,a_t,a_p)
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1, l=1:15)
        a_r(l,i,j,k)=0.
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1, l=1:15)
        a_t(l,i,j,k)=0.
      enddo
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1, l=1:15)
        a_p(l,i,j,k)=0.
      enddo
!
      if (ifprec_32) then
        allocate (a_dia_i_sp(N_cgvec))
!$acc enter data create(a_dia_i_sp)
        do concurrent (i=1:N_cgvec)
          a_dia_i_sp(i)=0.
        enddo
      else
        allocate (a_dia_i(N_cgvec))
!$acc enter data create(a_dia_i)
        do concurrent (i=1:N_cgvec)
          a_dia_i(i)=0.
        enddo
      endif
!
! ****** Allocate CSR storage of matrix:
!
      if (ifprec_v.ge.2) then
        if (ifprec_32) then
          allocate (lu_csr_sp  (    M_nzz))
          allocate (a_csr_d_sp (    N_cgvec))
        end if
        allocate (a_csr   (   M_nzz))
        allocate (lu_csr  (   M_nzz))
        allocate (a_csr_d (   N_cgvec))
        allocate (lu_csr_ja(  M_nzz))
        allocate (a_csr_ja(   M_nzz))
        allocate (a_N1(       N_cgvec))
        allocate (a_N2(       N_cgvec))
        allocate (a_csr_dptr( N_cgvec))
      end if
!
end subroutine
!#######################################################################
subroutine dealloc_v_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the arrays in which the matrix coefficients
! ****** for the v solve are stored.
!
!-----------------------------------------------------------------------
!
      use matrix_storage_v_solve
      use cgcom, ONLY : ifprec_v,ifprec_32
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a_r,a_t,a_p)
      deallocate (a_r)
      deallocate (a_t)
      deallocate (a_p)
      if (ifprec_32) then
!$acc exit data delete(a_dia_i_sp)
        deallocate (a_dia_i_sp)
      else
!$acc exit data delete(a_dia_i)
        deallocate (a_dia_i)
      endif
!
      if (ifprec_v.ge.2) then
        if (ifprec_32) then
          deallocate (lu_csr_sp)
          deallocate (a_csr_d_sp)
        end if
        deallocate (a_csr)
        deallocate (lu_csr)
        deallocate (a_csr_d)
        deallocate (lu_csr_ja)
        deallocate (a_csr_ja)
        deallocate (a_N1)
        deallocate (a_N2)
        deallocate (a_csr_dptr)
      end if
!
end subroutine
!#######################################################################
subroutine alloc_v_par_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays in which the matrix coefficients and
! ****** preconditioners for the parallel velocity solve are stored.
!
!-----------------------------------------------------------------------
!
      use globals
      use cgcom, ONLY : ifprec_v,ifprec_32
      use matrix_storage_v_par_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      allocate (a_dia(7,2:nrm1,2:ntm1,2:npm1))
!$acc enter data create(a_dia)
      if (ifprec_32) then
        allocate (a_dia_i_sp(N_cgvec))
!$acc enter data create(a_dia_i_sp)
      else
        allocate (a_dia_i(N_cgvec))
!$acc enter data create(a_dia_i)
      endif
!
! ****** Allocate CSR storage of matrix and LU preconditioner:
!
      if (ifprec_v.ge.2) then
        if (ifprec_32) then
          allocate (lu_csr_sp  (    M_nnz))
          allocate (a_csr_d_sp (    N_cgvec))
        end if
        allocate (a_csr   (    M_nnz))
        allocate (lu_csr  (    M_nnz))
        allocate (a_csr_d (    N_cgvec))
        allocate (lu_csr_ja(   M_nnz))
        allocate (a_csr_ja(    M_nnz))
        allocate (a_N1(        N_cgvec))
        allocate (a_N2(        N_cgvec))
        allocate (a_csr_dptr(  N_cgvec))
      end if
!
end subroutine
!#######################################################################
subroutine dealloc_v_par_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the arrays in which the matrix coefficients
! ****** for the parallel velocity solve are stored.
!
!-----------------------------------------------------------------------
!
      use matrix_storage_v_par_solve
      use cgcom, ONLY : ifprec_v,ifprec_32
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a_dia)
      deallocate (a_dia)
      if (ifprec_32) then
!$acc exit data delete(a_dia_i_sp)
        deallocate (a_dia_i_sp)
      else
!$acc exit data delete(a_dia_i)
        deallocate (a_dia_i)
      endif
!
      if (ifprec_v.ge.2) then
        if (ifprec_32) then
          deallocate (lu_csr_sp)
          deallocate (a_csr_d_sp)
        end if
        deallocate (a_csr)
        deallocate (lu_csr)
        deallocate (a_csr_d)
        deallocate (lu_csr_ja)
        deallocate (a_csr_ja)
        deallocate (a_N1)
        deallocate (a_N2)
        deallocate (a_csr_dptr)
      end if
!
end subroutine
!#######################################################################
subroutine alloc_divb_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays in which the matrix coefficients and
! ****** preconditioners for the divergence cleaning solve are stored.
!
!-----------------------------------------------------------------------
!
      use globals
      use cgcom, ONLY : ifprec_divb,ifprec_32
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      allocate (a_dia(7,i0:nrm1,2:ntm-1,2:npm-1))
!$acc enter data create(a_dia)
      if (ifprec_32) then
        allocate (a_dia_i_sp(N_cgvec))
!$acc enter data create(a_dia_i_sp)
      else
        allocate (a_dia_i(N_cgvec))
!$acc enter data create(a_dia_i)
      endif
!
! ****** Allocate CSR storage of matrix and LU preconditioner:
!
      if (ifprec_divb.ge.2) then
        if (ifprec_32) then
          allocate (lu_csr_sp  (    M_nnz))
          allocate (a_csr_d_sp (    N_cgvec))
        end if
        allocate (a_csr   (    M_nnz))
        allocate (lu_csr  (    M_nnz))
        allocate (a_csr_d (    N_cgvec))
        allocate (lu_csr_ja(   M_nnz))
        allocate (a_csr_ja(    M_nnz))
        allocate (a_N1(        N_cgvec))
        allocate (a_N2(        N_cgvec))
        allocate (a_csr_dptr(  N_cgvec))
      end if
!
end subroutine
!#######################################################################
subroutine dealloc_divb_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the arrays in which the matrix coefficients
! ****** for the divergence cleaning solve are stored.
!
!-----------------------------------------------------------------------
!
      use matrix_storage_divb_solve
      use cgcom, ONLY : ifprec_divb,ifprec_32
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a_dia)
      deallocate (a_dia)
      if (ifprec_32) then
!$acc exit data delete(a_dia_i_sp)
        deallocate (a_dia_i_sp)
      else
!$acc exit data delete(a_dia_i)
        deallocate (a_dia_i)
      endif
!
      if (ifprec_divb.ge.2) then
        if (ifprec_32) then
          deallocate (lu_csr_sp)
          deallocate (a_csr_d_sp)
        end if
        deallocate (a_csr)
        deallocate (lu_csr)
        deallocate (a_csr_d)
        deallocate (lu_csr_ja)
        deallocate (a_csr_ja)
        deallocate (a_N1)
        deallocate (a_N2)
        deallocate (a_csr_dptr)
      end if
!
end subroutine
!#######################################################################
subroutine div_grad_v (ps,qs)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = dV*div-[rho*coef]-grad P
! ******
! ****** at the internal points.
!
!-----------------------------------------------------------------------
!
! ****** This routine is for the semi-implicit momentum advance
! ****** and is only called once per solve to set up rhs.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : vvec
      use globals
      use mesh
      use fields, ONLY : rho
      use matrix_storage_v_solve
      use dissipation_profiles, ONLY : visc_rho_outside
      use cgcom
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: ps,qs
!
!-----------------------------------------------------------------------
!
      integer     :: i,j,k
      real(r_typ) :: dv,avrho
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Get the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        dv=fl_fac(i)*r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVGR(rho,i+1,j,k)
        end if
        qs%r(i,j,k)=-a_r( 1,i,j,k)*ps%r(i  ,j  ,k-1) &
                    -a_r( 2,i,j,k)*ps%r(i  ,j-1,k  ) &
                    -a_r( 3,i,j,k)*ps%r(i-1,j  ,k  ) &
         -(a_r( 4,i,j,k)-dv*avrho)*ps%r(i  ,j  ,k  ) &
                    -a_r( 5,i,j,k)*ps%r(i+1,j  ,k  ) &
                    -a_r( 6,i,j,k)*ps%r(i  ,j+1,k  ) &
                    -a_r( 7,i,j,k)*ps%r(i  ,j  ,k+1) &
                    -a_r( 8,i,j,k)*ps%t(i  ,j-1,k  ) &
                    -a_r( 9,i,j,k)*ps%t(i+1,j-1,k  ) &
                    -a_r(10,i,j,k)*ps%t(i  ,j  ,k  ) &
                    -a_r(11,i,j,k)*ps%t(i+1,j  ,k  ) &
                    -a_r(12,i,j,k)*ps%p(i  ,j  ,k-1) &
                    -a_r(13,i,j,k)*ps%p(i+1,j  ,k-1) &
                    -a_r(14,i,j,k)*ps%p(i  ,j  ,k  ) &
                    -a_r(15,i,j,k)*ps%p(i+1,j  ,k  )
      enddo
!
! ****** Get the t component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        dv=fl_fach(i)*rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVGT(rho,i,j+1,k)
        end if
        qs%t(i,j,k)=-a_t( 1,i,j,k)*ps%r(i-1,j  ,k  ) &
                    -a_t( 2,i,j,k)*ps%r(i  ,j  ,k  ) &
                    -a_t( 3,i,j,k)*ps%r(i-1,j+1,k  ) &
                    -a_t( 4,i,j,k)*ps%r(i  ,j+1,k  ) &
                    -a_t( 5,i,j,k)*ps%t(i  ,j  ,k-1) &
                    -a_t( 6,i,j,k)*ps%t(i  ,j-1,k  ) &
                    -a_t( 7,i,j,k)*ps%t(i-1,j  ,k  ) &
         -(a_t( 8,i,j,k)-dv*avrho)*ps%t(i  ,j  ,k  ) &
                    -a_t( 9,i,j,k)*ps%t(i+1,j  ,k  ) &
                    -a_t(10,i,j,k)*ps%t(i  ,j+1,k  ) &
                    -a_t(11,i,j,k)*ps%t(i  ,j  ,k+1) &
                    -a_t(12,i,j,k)*ps%p(i  ,j  ,k-1) &
                    -a_t(13,i,j,k)*ps%p(i  ,j+1,k-1) &
                    -a_t(14,i,j,k)*ps%p(i  ,j  ,k  ) &
                    -a_t(15,i,j,k)*ps%p(i  ,j+1,k  )
      enddo
!
! ****** Get the p component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
         dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
         if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
           avrho=one
         else
           avrho=AVGP(rho,i,j,k+1)
         end if
         qs%p(i,j,k)=-a_p( 1,i,j,k)*ps%r(i-1,j  ,k  ) &
                    -a_p( 2,i,j,k)*ps%r(i  ,j  ,k  ) &
                    -a_p( 3,i,j,k)*ps%r(i-1,j  ,k+1) &
                    -a_p( 4,i,j,k)*ps%r(i  ,j  ,k+1) &
                    -a_p( 5,i,j,k)*ps%t(i  ,j-1,k  ) &
                    -a_p( 6,i,j,k)*ps%t(i  ,j  ,k  ) &
                    -a_p( 7,i,j,k)*ps%t(i  ,j-1,k+1) &
                    -a_p( 8,i,j,k)*ps%t(i  ,j  ,k+1) &
                    -a_p( 9,i,j,k)*ps%p(i  ,j  ,k-1) &
                    -a_p(10,i,j,k)*ps%p(i  ,j-1,k  ) &
                    -a_p(11,i,j,k)*ps%p(i-1,j  ,k  ) &
         -(a_p(12,i,j,k)-dv*avrho)*ps%p(i  ,j  ,k  ) &
                    -a_p(13,i,j,k)*ps%p(i+1,j  ,k  ) &
                    -a_p(14,i,j,k)*ps%p(i  ,j+1,k  ) &
                    -a_p(15,i,j,k)*ps%p(i  ,j  ,k+1)
      enddo
!
end subroutine
!#######################################################################
subroutine div_grad_v_par (ps,qs)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = dV*div-[rho*coef]-grad P (parallel to B)
! ******
! ****** at the internal points.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields, ONLY : rho
      use matrix_storage_v_par_solve
      use dissipation_profiles, ONLY : visc_rho_outside
      use cgcom
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: ps,qs
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer     :: i,j,k
      real(r_typ) :: dv,avrho
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
        if (visc_rho_outside.and.equation_solved.eq.EQ_VISC) then
          avrho=one
        else
          avrho=AVG(rho,i,j,k)
        end if
        qs(i,j,k)=           -a_dia(1,i,j,k)*ps(i  ,j  ,k-1) &
                             -a_dia(2,i,j,k)*ps(i  ,j-1,k  ) &
                             -a_dia(3,i,j,k)*ps(i-1,j  ,k  ) &
                  -(a_dia(4,i,j,k)-dv*avrho)*ps(i  ,j  ,k  ) &
                             -a_dia(5,i,j,k)*ps(i+1,j  ,k  ) &
                             -a_dia(6,i,j,k)*ps(i  ,j+1,k  ) &
                             -a_dia(7,i,j,k)*ps(i  ,j  ,k+1)
      enddo
!
end subroutine
!#######################################################################
subroutine load_pot2d_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the matrices for the 2D potential field solves.
!        Since these matrices never change and are small,
!        this only needs to be done once for the entire
!        simulation.
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
      use matrix_storage_pot2d_solve
      use cgcom, ONLY : ifprec_pot2d
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      if (tb0) then
        j0=1
      else
        j0=2
      end if
!
      N_cgvec=(ntm1-j0+1)*(npm-2)
!
      if (ifprec_pot2d.ge.2) then
!
        a_dia_offsets(1)=   -(ntm1-j0+1) !    j-1
        a_dia_offsets(2)=-1          ! i-1
        a_dia_offsets(3)= 0          ! diag(i,j)
        a_dia_offsets(4)= 1          ! i+1
        a_dia_offsets(5)=    (ntm1-j0+1) !    j+1
!
        allocate (a_csr_ia(1+N_cgvec))
        call getM_nnz_pot2d (N_cgvec,a_dia_offsets,M_nnz,a_csr_ia)
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_POT2D_SOLVE:'
          write (9,*) '### pot2d preconditioner activated.'
          write (9,'(A,I17)') ' Matrix size per node (NxN) N: ' &
                                                               ,N_cgvec
          write (9,'(A,I13)') ' Matrix # of non-zeros per node M: ' &
                                                               ,M_nnz
          write (9,'(A,F8.2,A)') ' Estimated memory usage per node: ', &
          (8*(2*M_nnz+22*N_cgvec)+ &
           4*(2*M_nnz+4*N_cgvec+1))/1024./1024.,' MB'
          write (9,*)
        end if
      end if
!
! ****** Load matrices and preconditioners.
!
      call alloc_pot2d_matrix_coefs
!
      call load_matrix_pot2d_solve
!
      call load_preconditioner_pot2d_solve
!
end subroutine
!#######################################################################
subroutine load_pot2dh_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the matrices for the 2D half-mesh potential field solve.
!        Since these matrices never change and are small,
!        this only needs to be done once for the entire
!        simulation.
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
      use matrix_storage_pot2dh_solve
      use cgcom, ONLY : ifprec_pot2d
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      N_cgvec=ntm2*npm2
!
      if (ifprec_pot2d.ge.2) then
!
        a_dia_offsets(1)=   -(ntm2)  !    j-1
        a_dia_offsets(2)=-1          ! i-1
        a_dia_offsets(3)= 0          ! diag(i,j)
        a_dia_offsets(4)= 1          ! i+1
        a_dia_offsets(5)=    (ntm2)  !    j+1
!
        allocate (a_csr_ia(1+N_cgvec))
        call getM_nnz_pot2dh (N_cgvec,a_dia_offsets,M_nnz,a_csr_ia)
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_POT2DH_SOLVE:'
          write (9,*) '### pot2dh preconditioners activated.'
          write (9,'(A,I17)') ' Matrix size per node (NxN) N: ' &
                                                              ,N_cgvec
          write (9,'(A,I13)') ' Matrix # of non-zeros per node M: ' &
                                                              ,M_nnz
          write (9,'(A,F8.2,A)') ' Estimated memory usage per node: ', &
          (8*(2*M_nnz+22*N_cgvec)+ &
           4*(2*M_nnz+4*N_cgvec+1))/1024./1024.,' MB'
        end if
      end if
!
! ****** Load matrices and preconditioners.
!
      call alloc_pot2dh_matrix_coefs
!
      call load_matrix_pot2dh_solve
!
      call load_preconditioner_pot2dh_solve
!
end subroutine
!#######################################################################
subroutine alloc_pot3d_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays in which the matrix coefficients
! ****** for the pot3d solve are stored.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
      use matrix_storage_pot3d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Set limits in the theta direction including poles.
!
      if (tb0) then
        j0=1
      else
        j0=2
      end if
!
      if (tb1) then
        j1=ntm
      else
        j1=ntm-1
      end if
      N_cgvec=(nrm2)*(j1-j0+1)*(npm-2)
!
      allocate (a000(nr,ntm,npm))
      allocate (ap00(nr,ntm,npm))
      allocate (a0p0(nr,ntm,npm))
      allocate (a00p(nr,ntm,npm))
      allocate (a_dia_i(N_cgvec))
!$acc enter data create(a000,ap00,a0p0,a00p,a_dia_i)
!
      do concurrent (i=1:N_cgvec)
        a_dia_i(i)=0.
      enddo
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nr)
        a000(i,j,k)=0.
        ap00(i,j,k)=0.
        a0p0(i,j,k)=0.
        a00p(i,j,k)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine alloc_pot2d_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays in which the matrix coefficients
! ****** for the pot2d solve are stored.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use cgcom, ONLY : ifprec_pot2d,ifprec_32
      use matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      allocate (a_dia(5,j0:ntm1,2:npm-1))
      a_dia(:,:,:)=0.
!$acc enter data copyin(a_dia)
!
      if (ifprec_32) then
        allocate (a_dia_i_sp(N_cgvec))
        a_dia_i_sp(:)=0.
!$acc enter data copyin(a_dia_i_sp)
      else
        allocate (a_dia_i(N_cgvec))
        a_dia_i(:)=0.
!$acc enter data copyin(a_dia_i)
      end if

!
! ****** Allocate CSR storage of matrix and LU preconditioner:
!
      if (ifprec_pot2d.ge.2) then
        if (ifprec_32) then
          allocate (lu_csr_sp  (    M_nnz))
          allocate (a_csr_d_sp (    N_cgvec))
        end if
        allocate (a_csr   (    M_nnz))
        allocate (lu_csr  (    M_nnz))
        allocate (a_csr_d(     N_cgvec))
        allocate (lu_csr_ja(   M_nnz))
        allocate (a_csr_ja(    M_nnz))
        allocate (a_N1(        N_cgvec))
        allocate (a_N2(        N_cgvec))
        allocate (a_csr_dptr(  N_cgvec))
      end if
!
end subroutine
!#######################################################################
subroutine alloc_pot2dh_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays in which the matrix coefficients
! ****** for the pot2dh solve are stored.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use cgcom, ONLY : ifprec_pot2d,ifprec_32
      use matrix_storage_pot2dh_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      allocate (a_dia(5,2:ntm1,2:npm1))
      a_dia(:,:,:)=0.
!$acc enter data copyin(a_dia)
      if (ifprec_32) then
        allocate (a_dia_i_sp(N_cgvec))
        a_dia_i_sp(:)=0.
!$acc enter data copyin(a_dia_i_sp)
      else
        allocate (a_dia_i(N_cgvec))
        a_dia_i(:)=0.
!$acc enter data copyin(a_dia_i)
      end if
!
! ****** Allocate CSR storage of matrix and LU preconditioner:
!
      if (ifprec_pot2d.ge.2) then
        if (ifprec_32) then
          allocate (lu_csr_sp  (    M_nnz))
          allocate (a_csr_d_sp (    N_cgvec))
        end if
        allocate (a_csr   (    M_nnz))
        allocate (lu_csr  (    M_nnz))
        allocate (a_csr_d (    N_cgvec))
        allocate (lu_csr_ja(   M_nnz))
        allocate (a_csr_ja(    M_nnz))
        allocate (a_N1(        N_cgvec))
        allocate (a_N2(        N_cgvec))
        allocate (a_csr_dptr(  N_cgvec))
      end if
!
end subroutine
!#######################################################################
subroutine load_matrix_pot2d_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix for the 2D potential field solve for
! ****** the boundary potential at the lower radial boundary:
! ******
! ******   - dV * delsq_perp
! ******
! ****** at the internal points.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: a0m,am0,a00,ap0,a0p
!
!-----------------------------------------------------------------------
!
! ****** Define the matrix coefficients at the internal points.
!
      do k=2,npm-1
!
        if (tb0) then
          a00=sth(2)*dth_i(2)*dp(k)
          ap0=-sth(2)*dth_i(2)*dp(k)
!
          a_dia(3,1,k)=a00
          a_dia(4,1,k)=ap0
        end if
!
        do j=2,ntm-1
          a00=(sth(j+1)*dth_i(j+1) &
              +sth(j  )*dth_i(j  ) &
                                  )*dp(k) &
              +(dph_i(k+1) &
               +dph_i(k  ) &
                          )*dt(j)*st_i(j)
!
          ap0=-sth(j+1)*dth_i(j+1)*dp(k)
          am0=-sth(j  )*dth_i(j  )*dp(k)
!
          a0p=-dph_i(k+1)*dt(j)*st_i(j)
          a0m=-dph_i(k  )*dt(j)*st_i(j)
!
          a_dia(1,j,k)=a0m
          a_dia(2,j,k)=am0
          a_dia(3,j,k)=a00
          a_dia(4,j,k)=ap0
          a_dia(5,j,k)=a0p
!
        enddo
!
        if(tb1) then
          a00=sth(ntm1)*dth_i(ntm1)*dp(k)
          ap0=-sth(ntm1)*dth_i(ntm1)*dp(k)
!
          a_dia(3,ntm1,k)=a00
          a_dia(4,ntm1,k)=ap0
        end if
!
      enddo
!$acc update device(a_dia)
!
end subroutine
!#######################################################################
subroutine load_matrix_pot2dh_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix for the 2D potential field solve for
! ****** the boundary potential at the lower radial boundary:
! ******
! ******   - dV * delsq_perp
! ******
! ****** at the internal points. This is on the semi-integer mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot2dh_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** Define the matrix coefficients at the internal points.
!
      do k=2,npm1
        do j=2,ntm1
!
! ****** a0m:
!
          a_dia(1,j,k)=-dp_i(k-1)*dth(j)*sth_i(j)
!
! ****** am0:
!
          a_dia(2,j,k)=-st(j-1)*dt_i(j-1)*dph(k)
!
! ****** a00:
!
          a_dia(3,j,k)=(st(j)*dt_i(j)+st(j-1)*dt_i(j-1))*dph(k) &
                        +(dp_i(k)+dp_i(k-1))*dth(j)*sth_i(j)
!
! ****** ap0:
!
          a_dia(4,j,k)=-st(j)*dt_i(j)*dph(k)
!
! ****** a0p:
!
          a_dia(5,j,k)=-dp_i(k)*dth(j)*sth_i(j)
!
        enddo
      enddo
!$acc update device(a_dia)
!
end subroutine
!#######################################################################
subroutine load_preconditioner_pot2dh_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the preconditioner for the pot2dh solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_pot2d,ifprec_32
      use globals
      use matrix_storage_pot2dh_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,ll,ierr
!
!-----------------------------------------------------------------------
!
      if (ifprec_pot2d.eq.0) return
!
      if (ifprec_pot2d.eq.1) then
!
! ****** Diagonal scaling:
!
        ll=0
        if (ifprec_32) then
          do j=2,npm1
            do i=2,ntm1
              ll=ll+1
              a_dia_i_sp(ll)=real(one/a_dia(3,i,j),r_typ_sp)
            enddo
          enddo
!$acc update device(a_dia_i_sp)
        else
          do j=2,npm1
            do i=2,ntm1
              ll=ll+1
              a_dia_i(ll)=one/a_dia(3,i,j)
            enddo
          enddo
!$acc update device(a_dia_i)
        end if
!
      elseif (ifprec_pot2d.ge.2) then
!
! ****** Convert A matrix into CSR format:
!
        call diacsr_pot2dh (N_cgvec,M_nnz,a_dia,a_dia_offsets, &
                            a_csr,a_csr_ja,a_csr_ia,a_csr_dptr)
!
! ****** Overwrite CSR A with preconditioner L and U matrices:
!
        if (ifprec_pot2d.eq.2) then
!
! ****** Symmetric Gauss-Seidel (SGS)
!
          do i=1,N_cgvec
            do j=a_csr_ia(i),a_csr_dptr(i)-1
              a_csr(j)=a_csr(j)/a_csr(a_csr_dptr(a_csr_ja(j)))
            enddo
          enddo
!
        elseif (ifprec_pot2d.eq.3) then
!
! ****** Incomplete LU (ILU)
!
          ierr=0
          call ilu0 (N_cgvec,M_nnz,a_csr,a_csr_ja,a_csr_ia, &
                     a_csr_dptr,ierr)
!
          if (ierr.ne.0) then
            write(*,*) '### ERROR IN ILU FORMATION OF POT2DH'
          end if
!
          call check_error_on_any_proc (ierr)
!
        end if
!
! ****** Convert LU stored in A to LU matrix in optimized layout.
!
        call lu2luopt (N_cgvec,M_nnz,lu_csr,a_csr,a_csr_ia,a_csr_ja, &
                       lu_csr_ja,a_csr_dptr,a_N1,a_N2)
!
! ****** Store inverse of diagonal of LU matrix.
!
        do i=1,N_cgvec
          a_csr_d(i)=one/a_csr(a_csr_dptr(i))
        enddo
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            a_csr_d_sp(i)=real(a_csr_d(i),r_typ_sp)
          enddo
          do concurrent (i=1:M_nnz)
            lu_csr_sp(i)=real(lu_csr(i),r_typ_sp)
          enddo
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine load_preconditioner_pot3d_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the preconditioner for the pot3d solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_pot3d
      use globals
      use matrix_storage_pot3d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ii
!
!-----------------------------------------------------------------------
!
      if (ifprec_pot3d.eq.0) return
!
      if (ifprec_pot3d.eq.1) then
!
! ****** Diagonal scaling:
!
        do k=2,npm-1
          do j=j0,j1
            do i=2,nrm1
              ii=(j1-j0+1)*nrm2*(k-2)+nrm2*(j-j0)+(i-1)
              a_dia_i(ii)=one/a000(i,j,k)
            enddo
          enddo
        enddo
!
      end if
!
end subroutine
!#######################################################################
subroutine load_preconditioner_pot2d_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the preconditioner for the pot2d solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ifprec_pot2d,ifprec_32
      use globals
      use matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ll,ierr
!
!-----------------------------------------------------------------------
!
      if (ifprec_pot2d.eq.0) return
!
      if (ifprec_pot2d.eq.1) then
!
! ****** Diagonal scaling:
!
        ll=0
        if (ifprec_32) then
          do k=2,npm-1
            do j=j0,ntm1
              ll=ll+1
              a_dia_i_sp(ll)=real(one/a_dia(3,j,k),r_typ_sp)
            enddo
          enddo
!$acc update device(a_dia_i_sp)
        else
          do k=2,npm-1
            do j=j0,ntm1
              ll=ll+1
              a_dia_i(ll)=one/a_dia(3,j,k)
            enddo
          enddo
!$acc update device(a_dia_i)
        end if
!
      elseif (ifprec_pot2d.ge.2) then
!
! ****** Convert A matrix into CSR format:
!
        call diacsr_pot2d (N_cgvec,M_nnz,a_dia,a_dia_offsets, &
                           a_csr,a_csr_ja,a_csr_ia,a_csr_dptr)
!
! ****** Overwrite CSR A with preconditioner L and U matrices:
!
        if (ifprec_pot2d.eq.2) then
!
! ****** Symmetric Gauss-Seidel (SGS)
!
          do i=1,N_cgvec
            do j=a_csr_ia(i),a_csr_dptr(i)-1
              a_csr(j)=a_csr(j)/a_csr(a_csr_dptr(a_csr_ja(j)))
            enddo
          enddo
!
        elseif (ifprec_pot2d.eq.3) then
!
! ****** Incomplete LU (ILU)
!
          ierr=0
          call ilu0 (N_cgvec,M_nnz,a_csr,a_csr_ja,a_csr_ia, &
                     a_csr_dptr,ierr)
!
          if (ierr.ne.0) then
            write(*,*) '### ERROR IN ILU FORMATION OF POT2D'
          end if
!
          call check_error_on_any_proc (ierr)
!
        end if
!
! ****** Convert LU stored in A to LU matrix in optimized layout.
!
        call lu2luopt (N_cgvec,M_nnz,lu_csr,a_csr,a_csr_ia,a_csr_ja, &
                       lu_csr_ja,a_csr_dptr,a_N1,a_N2)
!
! ****** Store inverse of diagonal of LU matrix.
!
        do i=1,N_cgvec
          a_csr_d(i)=one/a_csr(a_csr_dptr(i))
        enddo
!
        if (ifprec_32) then
          do concurrent (i=1:N_cgvec)
            a_csr_d_sp(i)=real(a_csr_d(i),r_typ_sp)
          enddo
          do concurrent (i=1:M_nnz)
            lu_csr_sp(i)=real(lu_csr(i),r_typ_sp)
          enddo
        end if
!
!
      end if
!
end subroutine
!#######################################################################
subroutine diacsr_pot2d (N,M,Adia,ioff,Acsr,JA,IA,Adptr)
!
!-----------------------------------------------------------------------
!
! *** DIACSR_POT2D converts MAS local pot2d matrix in
!     diagonal format to standard compressed sparse row (CSR).
!
!     Author of original diacsr: Youcef Saad
!     Modifications for MAS:     RM Caplan
!
!     Input:
!                     N: Size of the matrix (NxN)
!                     M: Number of non-zero entries in matrix
!                        (computed with getM_nnz_pot2d())
!            Adia(N,5): The pot2d matrix in MAS "DIA" format
!              ioff(5): Offsets of the diagonals in A.
!
!     Output:
!            Acsr(M), JA(M), IA(N+1): The matrix A in CSR.
!                           Adptr(N): Pointers to diag elements in A,
!                                     [e.g. A(i,i) == A(Adptr(i))]
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=5
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      real (r_typ) :: Acsr(M)
      real (r_typ) :: Adia(IDIAG,N)
      integer :: Adptr(N)
      integer :: IA(N+1)
      integer :: JA(M)
      integer :: ioff(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mj,mk,ko,j0
      integer :: ioffok(IDIAG)
!
!-----------------------------------------------------------------------
!
      if (tb0) then
        j0=1
      else
        j0=2
      end if
!
      do mk=2,npm-1
        do mj=j0,ntm1
! ***** Set index of value and column indicies array:
          i = (mk-2)*(ntm1-j0+1)+(mj-j0)+1
          ko = IA(i)
!
! ******* Do not add coefs that multiply boundaries:
!         For each boundary, there is a sub-set of coefs in the
!         matrix row that should not be added.
!         This makes "local" matrices have no bc info
!
          ioffok(:)=1
!
          if (mj.eq.1.and.tb0) then
            ioffok(1)=0;
            ioffok(2)=0;
            ioffok(4)=0;
            ioffok(5)=0;
          end if
!
          if (mj.eq.ntm1.and.tb1) then
            ioffok(1)=0;
            ioffok(2)=0;
            ioffok(4)=0;
            ioffok(5)=0;
          end if
!
          if (mj.eq.2) then
            ioffok(2)=0;
          end if
!
          if (mj.eq.ntm-1) then
            ioffok(4)=0;
          end if
!
          if (mk.eq.2) then
            ioffok(1)=0;
          end if
!
          if (mk.eq.npm-1) then
            ioffok(5)=0;
          end if
!
          do jj=1,IDIAG
            if (ioffok(jj).eq.1) then
              j=i+ioff(jj)
              if(j.ge.1.and.j.le.N) then
!               Store pointer to diagonal elements in A:
                if (jj.eq.3) Adptr(i)=ko
                Acsr(ko)=Adia(jj,i)
                JA(ko)=j
                ko=ko+1
              end if
            end if
          enddo
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine getM_nnz_pot2d (N,ioff,M,IA)
!
!-----------------------------------------------------------------------
!
! *** This routine computes the number of non-zeros in the
!     pot2d coeff matrix for use with allocating the
!     matrices.
!
!     Output:  M  # of nonzeros.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=5
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      integer :: ioff(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mj,mk,ko,j0
      integer :: ioffok(IDIAG)
      integer :: IA(N+1)
!
!-----------------------------------------------------------------------
!
      IA(1)=1
!
      if (tb0) then
        j0=1
      else
        j0=2
      end if
!
      do mk=2,npm-1
        do mj=j0,ntm1
! ******* Set index of value and column indicies array:
          i = (mk-2)*(ntm1-j0+1)+(mj-j0)+1
!
          ioffok(:)=1
!
          if (mj.eq.1.and.tb0) then
            ioffok(1)=0;
            ioffok(2)=0;
            ioffok(4)=0;
            ioffok(5)=0;
          end if
!
          if (mj.eq.ntm1.and.tb1) then
            ioffok(1)=0;
            ioffok(2)=0;
            ioffok(4)=0;
            ioffok(5)=0;
          end if
!
          if (mj.eq.2) then
            ioffok(2)=0;
          end if
!
          if (mj.eq.ntm-1) then
            ioffok(4)=0;
          end if
!
          if (mk.eq.2) then
            ioffok(1)=0;
          end if
!
          if (mk.eq.npm-1) then
            ioffok(5)=0;
          end if
!
          ko=0
          do jj=1,IDIAG
            if (ioffok(jj).eq.1) then
              j=i+ioff(jj)
              if(j.ge.1.and.j.le.N) then
                ko=ko+1
              end if
            end if
          enddo
          IA(i+1)=IA(i)+ko
!
        enddo
      enddo
!
! *** Save number of non-zeros of matrix:
!
      M=IA(N+1)-1
!
end subroutine
!#######################################################################
subroutine diacsr_pot2dh (N,M,Adia,ioff,Acsr,JA,IA,Adptr)
!
!-----------------------------------------------------------------------
!
! *** DIACSR_POT2DH converts MAS local pot2dh matrix in
!     diagonal format to standard compressed sparse row (CSR).
!
!     Author of original diacsr: Youcef Saad
!     Modifications for MAS:     RM Caplan
!
!     Input:
!                     N: Size of the matrix (NxN)
!                     M: Number of non-zero entries in matrix
!                        (computed with getM_nnz_pot2dh())
!            Adia(N,5): The pot2dh matrix in MAS "DIA" format
!              ioff(5): Offsets of the diagonals in A.
!
!     Output:
!            Acsr(M), JA(M), IA(N+1): The matrix A in CSR.
!                           Adptr(N): Pointers to diag elements in A,
!                                     [e.g. A(i,i) == A(Adptr(i))]
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=5
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      real (r_typ) :: Acsr(M)
      real (r_typ) :: Adia(IDIAG,N)
      integer :: Adptr(N)
      integer :: IA(N+1)
      integer :: JA(M)
      integer :: ioff(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mj,mk,ko
      integer :: ioffok(IDIAG)
!
!-----------------------------------------------------------------------
!
      do mk=2,npm1
        do mj=2,ntm1
! ******* Set index of value and column indicies array:
          i = (mk-2)*(ntm1-1)+(mj-2)+1
          ko = IA(i)
!
! ******* Do not add coefs that multiply boundaries:
!         For each boundary, there is a sub-set of coefs in the
!         matrix row that should not be added.
!         This makes "local" matrices have no bc info
!
          ioffok(:)=1
!
          if (mj.eq.2) then
            ioffok(2)=0;
          end if
!
          if (mj.eq.ntm1) then
            ioffok(4)=0;
          end if
!
          if (mk.eq.2) then
            ioffok(1)=0;
          end if
!
          if (mk.eq.npm1) then
            ioffok(5)=0;
          end if
          do jj=1,IDIAG
            if (ioffok(jj).eq.1) then
            j=i+ioff(jj)
              if(j.ge.1.and.j.le.N) then
!             Store pointer to diagonal elements in A:
                if (jj.eq.3) Adptr(i)=ko
                Acsr(ko)=Adia(jj,i)
                JA(ko)=j
                ko=ko+1
              end if
            end if
          enddo
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine getM_nnz_pot2dh (N,ioff,M,IA)
!
!-----------------------------------------------------------------------
!
! *** This routine computes the number of non-zeros in the
!     pot2d coeff matrix for use with allocating the
!     matrices.
!
!     Output:  M  # of nonzeros.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter :: IDIAG=5
!
!-----------------------------------------------------------------------
!
      integer :: N,M
      integer :: ioff(IDIAG)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jj,mj,mk,ko
      integer :: ioffok(IDIAG)
      integer :: IA(N+1)
!
!-----------------------------------------------------------------------
!
      i=0
      IA(1)=1
!
      do mk=2,npm1
        do mj=2,ntm1
! ******* Set index of value and column indicies array:
          i=i+1
!
          ioffok(:)=1
!
          if (mj.eq.2) then
            ioffok(2)=0;
          end if
!
          if (mj.eq.ntm1) then
            ioffok(4)=0;
          end if
!
          if (mk.eq.2) then
            ioffok(1)=0;
          end if
!
          if (mk.eq.npm1) then
            ioffok(5)=0;
          end if
!
          ko=0
          do jj=1,IDIAG
            if (ioffok(jj).eq.1) then
              j=i+ioff(jj)
              if(j.ge.1.and.j.le.N) then
                ko=ko+1
              end if
            end if
          enddo
          IA(i+1)=IA(i)+ko
!
        enddo
      enddo
!
! *** Save number of non-zeros of matrix:
!
      M=IA(N+1)-1
!
end subroutine
!#######################################################################
subroutine delsq_perp_pot2d (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = - dV * delsq_perp P
! ******
! ****** at the internal points, and set all other points
! ****** of Q to zero.
!
!-----------------------------------------------------------------------
!
! ****** This routine is used for the 2D potential field solve for
! ****** the boundary potential at the lower radial boundary.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: ps
      real(r_typ), dimension(j0:ntm1,2:npm-1) :: q
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ), dimension(2) :: psi0,psi1
      real(r_typ) :: psi0_1,psi1_1,psi0_2,psi1_2
!
!-----------------------------------------------------------------------
!
! ****** Get the axisymmetric component of psi adjacent to the poles.
!
      psi0_1=0.
      psi1_1=0.
      psi0_2=0.
      psi1_2=0.
!
      if (tb0) then
!$acc parallel loop default(present) reduction(+:psi0_1,psi0_2)
!$omp parallel do default(shared) reduction(+:psi0_1,psi0_2)
        do k=2,npm1
          psi0_1=psi0_1+ps(1,k)*dp(k)*pl_i
          psi0_2=psi0_2+ps(2,k)*dp(k)*pl_i
        enddo
!$omp end parallel do
      end if
!
      if (tb1) then
!$acc parallel loop default(present) reduction(+:psi1_1,psi1_2)
!$omp parallel do default(shared) reduction(+:psi1_1,psi1_2)
        do k=2,npm1
          psi1_1=psi1_1+ps(ntm1,k)*dp(k)*pl_i
          psi1_2=psi1_2+ps(ntm2,k)*dp(k)*pl_i
        enddo
!$omp end parallel do
      end if
!
! ****** Sum over all processors.
!
      psi0(1)=psi0_1
      psi0(2)=psi0_2
      psi1(1)=psi1_1
      psi1(2)=psi1_2
      call sum_over_phi (2,psi0,psi1)
      psi0_1=psi0(1)
      psi0_2=psi0(2)
      psi1_1=psi1(1)
      psi1_2=psi1(2)
!
! ****** Set the internal and polar points of Q.
!
      do concurrent (k=2:npm-1, j=2:ntm-1)
        if (tb0.and.j.eq.2) then
!
! ****** Set 1 pole to be 0 for solver uniqueness.
! ****** but keep pole average in j=2 equation.
!
          q(1,k)=a_dia(3,1,k)*0 &
                +a_dia(4,1,k)*psi0_2
!
          q(j,k)=a_dia(1,j,k)*ps(j  ,k-1) &
                +a_dia(2,j,k)*psi0_1 &
                +a_dia(3,j,k)*ps(j  ,k  ) &
                +a_dia(4,j,k)*ps(j+1,k  ) &
                +a_dia(5,j,k)*ps(j  ,k+1)
        else if (tb1.and.j.eq.ntm2) then
          q(j,k)=a_dia(1,j,k)*ps(j  ,k-1) &
                +a_dia(2,j,k)*ps(j-1,k  ) &
                +a_dia(3,j,k)*ps(j  ,k  ) &
                +a_dia(4,j,k)*psi1_1 &
                +a_dia(5,j,k)*ps(j  ,k+1)
!
          q(ntm1,k)=a_dia(3,ntm1,k)*ps(ntm1,k) &
                     +a_dia(4,ntm1,k)*psi1_2
        else
          q(j,k)=a_dia(1,j,k)*ps(j  ,k-1) &
                +a_dia(2,j,k)*ps(j-1,k  ) &
                +a_dia(3,j,k)*ps(j  ,k  ) &
                +a_dia(4,j,k)*ps(j+1,k  ) &
                +a_dia(5,j,k)*ps(j  ,k+1)
        end if
      enddo
!
end subroutine
!#######################################################################
subroutine pot2d_solver (x,rhs,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Perform the POT2D solve (A*x=rhs).
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use cgcom
      use mpidefs
      use debug
      use timing
      use vars
      use matrix_storage_pot2d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: x,rhs
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: tiny_value=1.e-20_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i
      character(32) :: capt,fname
      real(r_typ) :: normrhs
!
! ****** CG dot.
!
      real(r_typ) :: cgdot
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_POT2D)
!
      allocate(x_cg(N_cgvec))
      allocate(rhs_cg(N_cgvec))
!$acc enter data create(x_cg,rhs_cg)
!
      do concurrent (i=1:N_cgvec)
        x_cg(i)=0.
        rhs_cg(i)=0.
      enddo
!
      solve_type=ST_POT2D
!
      select case (equation_solved)
      case (EQ_POT2D)
        capt='Initial boundary potential'
        epscg_desired=epscg_potfld
      case (EQ_POT2D_NEWFLUX)
        capt='Evolving boundary potential'
        epscg_desired=epscg_newflux
      end select
!
      N_CG=N_cgvec
!
      call pack_pot2d (rhs,rhs_cg)
      call pack_pot2d (x,x_cg)
!
! ****** If solving an evolving potential, check
! ****** if the right hand side is noise.  If so,
! ****** set it to zero to facilitate convergence.
! ****** (This should probably be done with some kind of
! ****** unit-independent relative norm.)
!
      if (equation_solved.eq.EQ_POT2D_NEWFLUX) then
        normrhs=cgdot(rhs_cg,rhs_cg)
        if (normrhs.le.tiny_value) then
          do concurrent (i=1:N_cgvec)
            rhs_cg(i)=0.
          enddo
        end if
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from POT2D_SOLVER:'
          write (9,*) '### CG solution of '//trim(capt)//':'
          write (9,*) 'NTIME = ',ntime
          write (9,*) 'TIME = ',time
        end if
      end if
!
      call solve (x_cg,rhs_cg,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in POT2D_SOLVER:'
          write (*,*) '### CG solution of '//trim(capt)//':'
          write (*,*) '### CG solution did not converge.'
        end if
        if (use_timer) call timer (TIME_POT2D)
        return
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,900) '### Potential field ['//trim(capt)//']:', &
                        ncg,bnrm,rnrm
        end if
      end if
!
      call unpack_pot2d (x,x_cg)
!
! ****** Seam the result.
!
      call seam_2d_tp (x,ntm,npm,.true.,.true.)
!
      if (print_matrix_pot2d) then
        select case (equation_solved)
        case (EQ_POT2D)
          fname='amat_pot2d_ic.h5'
        case (EQ_POT2D_NEWFLUX)
          fname='amat_pot2d_evolve.h5'
        end select
        call write_matrix_pot2d (fname)
      end if
!
!$acc exit data delete(x_cg,rhs_cg)
      deallocate(x_cg)
      deallocate(rhs_cg)
!
      if (use_timer) call timer (TIME_POT2D)
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
end subroutine
!#######################################################################
subroutine pot2dh_solver (x,rhs,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Perform the POT2DH solve (A*x=rhs).
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use cgcom
      use mpidefs
      use debug
      use timing
      use vars
      use matrix_storage_pot2dh_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: x,rhs
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
      integer :: ierr, i
      character(40) :: capt
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_POT2DH)
!
      allocate(x_cg(N_cgvec))
      allocate(rhs_cg(N_cgvec))
!$acc enter data create(x_cg,rhs_cg)
!
      do concurrent (i=1:N_cgvec)
        x_cg(i)=0.
        rhs_cg(i)=0.
      enddo
!
      solve_type=ST_POT2DH
!
      capt='Evolving boundary potential (phi)'
      epscg_desired=epscg_newflux
!
      N_CG=N_cgvec
!
      call pack_pot2dh (rhs,rhs_cg)
      call pack_pot2dh (x,x_cg)
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from POT2DH_SOLVER:'
          write (9,*) '### CG solution of '//trim(capt)//':'
          write (9,*) 'NTIME = ',ntime
          write (9,*) 'TIME = ',time
        end if
      end if
!
      call solve (x_cg,rhs_cg,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in POT2DH_SOLVER:'
          write (*,*) '### CG solution of '//trim(capt)//':'
          write (*,*) '### CG solution did not converge.'
        end if
        if (use_timer) call timer (TIME_POT2DH)
        return
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,900) '### Potential field ['//trim(capt)//']:', &
                        ncg,bnrm,rnrm
        end if
      end if
!
      call unpack_pot2dh (x,x_cg)
!
! ****** Seam the result.
!
      call seam_2d_tp (x,nt,np,.true.,.true.)
!
!$acc exit data delete(x_cg,rhs_cg)
      deallocate(x_cg)
      deallocate(rhs_cg)
!
      if (use_timer) call timer (TIME_POT2DH)
!
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
!
end subroutine
!#######################################################################
subroutine pot3d_solver (x,rhs)
!
!-----------------------------------------------------------------------
!
! ****** Perform a POT3D solve (A*x=rhs).
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use cgcom
      use mpidefs
      use debug
      use timing
      use vars
      use seam_interface
      use matrix_storage_pot3d_solve
      use potential_field
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,ntm,npm) :: x,rhs
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: x_cg,rhs_cg
      real(r_typ), dimension(:,:,:), allocatable :: xbc
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_POT3D)
!
! ****** Load the matrix and preconditioner for the solve.
!
      call alloc_pot3d_matrix_coefs
      call load_matrix_pot3d_solve
      call load_preconditioner_pot3d_solve
!
      allocate(x_cg(N_cgvec))
      allocate(rhs_cg(N_cgvec))
!$acc enter data create(x_cg,rhs_cg)
!
      do concurrent (i=1:N_cgvec)
        x_cg(i)=0.
        rhs_cg(i)=0.
      enddo
!$acc update device(a000,ap00,a0p0,a00p,a_dia_i)
!
      solve_type=ST_POT3D
!
! ****** Set the tolerance for the solve.
!
      epscg_desired=epscg_potfld
!
      N_CG=N_cgvec
!
! ****** Pack RHS array into 1D CG vector.
!
      call pack_pot3d (rhs,rhs_cg)
!
! ****** Use a trick to accumulate the contribution of the
! ****** boundary conditions (i.e., the inhomogenous part).
! ****** x_cg is used here as a dummy array (overwritten below).
!
      allocate(xbc(nr,ntm,npm))
!$acc enter data create(xbc)
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nr)
        xbc(i,j,k)=0.
      enddo
!
      call set_bc_pot3d (xbc,one)
      call seam_scalar (xbc,nr,ntm,npm)
      call delsq_mod_pot3d (xbc,x_cg)
!$acc exit data delete(xbc)
      deallocate(xbc)
!
      do concurrent (i=1:N_cgvec)
        rhs_cg(i)=rhs_cg(i)-x_cg(i)
      enddo
!
! ****** Pack X array into 1D CG vector.
!
      call pack_pot3d (x,x_cg)
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from POT3D_SOLVER:'
          write (IO_OUT,*) 'NTIME = ',ntime
          write (IO_OUT,*) 'TIME = ',time
          FLUSH (IO_OUT)
        end if
      end if
!
      call solve (x_cg,rhs_cg,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in POT3D_SOLVER:'
          write (*,*) '### CG solution did not converge.'
        end if
        ifabort=.true.
        call final_diags
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,900) '### Potential field 3D:', &
                        ncg,bnrm,rnrm
        end if
      end if
!
! ****** Unpack result into 3D array.
!
      call unpack_pot3d (x,x_cg)
!
! ****** Set the boundary values.
!
      call set_bc_pot3d (x,one)
!
! ****** Seam the result.
!
      call seam_scalar (x,nr,ntm,npm)
!
      if (print_matrix_pot3d) call write_matrix_pot3d
!
! ****** Deallocate the temporary arrays and solver matrix.
!
!$acc exit data delete(x_cg,rhs_cg)
      call dealloc_pot3d_matrix_coefs
      deallocate(x_cg)
      deallocate(rhs_cg)
!
      if (use_timer) call timer (TIME_POT3D)
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
end subroutine
!#######################################################################
subroutine divb_solver (x,rhs)
!
!-----------------------------------------------------------------------
!
! ****** Perform a DIVB solve (A*x=rhs).
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use cgcom
      use mpidefs
      use debug
      use timing
      use vars
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: x,rhs
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix and preconditioner for the solve.
!
      call alloc_divb_matrix_coefs
      call load_matrix_divb_solve
      call load_preconditioner_divb_solve
!
      allocate(x_cg(N_cgvec))
      allocate(rhs_cg(N_cgvec))
!$acc enter data create(x_cg,rhs_cg)
!
      do concurrent (i=1:N_cgvec)
        x_cg(i)=0.
        rhs_cg(i)=0.
      enddo
!
      solve_type=ST_DIVB
      equation_solved=EQ_DIVB
!
! ****** Set the tolerance for the solve.
!
      epscg_desired=epscg_divb
!
      N_CG=N_cgvec
!
! ****** Pack RHS array into 1D CG vector.
!
      call pack_divb (rhs,rhs_cg)
!
! ****** Pack X array into 1D CG vector.
!
      call pack_divb (x,x_cg)
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from DIVB_SOLVER:'
          write (9,*) 'NTIME = ',ntime
          write (9,*) 'TIME = ',time
        end if
      end if
!
      call solve (x_cg,rhs_cg,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in DIVB_SOLVER:'
          write (*,*) '### CG solution did not converge.'
        end if
        ifabort=.true.
        call final_diags
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,900) '### Divergence Cleaner', &
                        ncg,bnrm,rnrm
        end if
      end if
!
! ****** Unpack result into 3D array.
!
      call unpack_divb (x,x_cg)
!
! ****** Set the boundary values.
!
      call set_pole_bc_divb_phi (x)
!
! ****** Seam the result.
!
      call seam_scalar (x,nrm,ntm,npm)
!
! ****** Deallocate the temporary arrays and solver matrix.
!
      call dealloc_divb_matrix_coefs
!$acc exit data delete(x_cg,rhs_cg)
      deallocate(x_cg)
      deallocate(rhs_cg)
!
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
end subroutine
!#######################################################################
subroutine load_matrix_pot3d_solve
!
!-----------------------------------------------------------------------
!
! ****** Load the matrix for the 3D potential field solve:
! ******
! ******   - dV * delsq_mod
! ******
! ****** at the internal points.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot3d_solve
      use potential_field
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Define the matrix coefficients at the internal points.
!
      do k=2,npm-1
        do j=2,ntm-1
          do i=2,nrm1
            if (rh(i).ge.r_ss) then
              a000(i,j,k)= ( dr_i(i  ) &
                            +dr_i(i-1) &
                           )*dt(j)*st(j)*dp(k)
            else
              a000(i,j,k)= ( dr_i(i  ) &
                            +dr_i(i-1) &
                           )*dt(j)*st(j)*dp(k) &
                          +( sth(j+1)*dth_i(j+1) &
                            +sth(j  )*dth_i(j  ) &
                           )*drh(i)*fl_fach_i(i)*rh_i(i)**2*dp(k) &
                          +( dph_i(k+1) &
                            +dph_i(k  ) &
                           )*drh(i)*fl_fach_i(i)*rh_i(i)**2*dt(j)* &
                             st_i(j)
            end if
          enddo
        enddo
      enddo
!
      do k=2,npm-1
        do j=2,ntm-1
          do i=1,nrm1
            ap00(i,j,k)=-( dr_i(i  ) &
                         )*dt(j)*st(j)*dp(k)
          enddo
        enddo
      enddo
!
      do k=2,npm-1
        do j=1,ntm-1
          do i=2,nrm1
            if (rh(i).ge.r_ss) then
              a0p0(i,j,k)=0.
            else
              a0p0(i,j,k)=-( sth(j+1)*dth_i(j+1) &
                           )*drh(i)*fl_fach_i(i)*rh_i(i)**2*dp(k)
            end if
          enddo
        enddo
      enddo
!
      do k=1,npm-1
        do j=2,ntm-1
          do i=2,nrm1
            if (rh(i).ge.r_ss) then
              a00p(i,j,k)=0.
            else
              a00p(i,j,k)=-( dph_i(k+1) )*drh(i)*fl_fach_i(i)* &
              rh_i(i)**2*dt(j)*st_i(j)
            end if
          enddo
        enddo
      enddo
!
! ****** Define the matrix coefficients at the poles.
!
      if (tb0) then
        j=1
        do k=2,npm-1
          do i=2,nrm1
            if (rh(i).ge.r_ss) then
              a000(i,j,k)= ( dr_i(i  ) &
                            +dr_i(i-1) &
                           )*quarter*dt(j)*sth(j+1)*dp(k)
              a0p0(i,j,k)=0.
            else
              a000(i,j,k)= ( dr_i(i  ) &
                            +dr_i(i-1) &
                           )*quarter*dt(j)*sth(j+1)*dp(k) &
                          +( sth(j+1)*dth_i(j+1) &
                           )*drh(i)*fl_fach_i(i)*rh_i(i)**2*dp(k)
              a0p0(i,j,k)=-( sth(j+1)*dth_i(j+1) &
                           )*drh(i)*fl_fach_i(i)*rh_i(i)**2*dp(k)
            end if
          enddo
          do i=1,nrm1
            ap00(i,j,k)=-( dr_i(i  ) &
                         )*quarter*dt(j)*sth(j+1)*dp(k)
          enddo
        enddo
      end if
!
      if (tb1) then
        j=ntm1
        do k=2,npm-1
          do i=2,nrm1
            if (rh(i).ge.r_ss) then
              a000(i,j,k)= ( dr_i(i  ) &
                            +dr_i(i-1) &
                           )*quarter*dt(j)*sth(j  )*dp(k)
              a0p0(i,j,k)=0.
            else
              a000(i,j,k)= ( dr_i(i  ) &
                            +dr_i(i-1) &
                           )*quarter*dt(j)*sth(j  )*dp(k) &
                          +( sth(j  )*dth_i(j  ) &
                           )*drh(i)*fl_fach_i(i)*rh_i(i)**2*dp(k)
              a0p0(i,j,k)=-( sth(j  )*dth_i(j  ) &
                           )*drh(i)*fl_fach_i(i)*rh_i(i)**2*dp(k)
            end if
          enddo
          do i=1,nrm1
            ap00(i,j,k)=-( dr_i(i  ) &
                         )*quarter*dt(j)*sth(j  )*dp(k)
          enddo
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine dealloc_pot3d_matrix_coefs
!
!-----------------------------------------------------------------------
!
! ****** Deallocate the matrix for the 3D potential field solve.
!
!-----------------------------------------------------------------------
!
      use matrix_storage_pot3d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
!$acc exit data delete(a000,ap00,a0p0,a00p,a_dia_i)
      deallocate (a000)
      deallocate (ap00)
      deallocate (a0p0)
      deallocate (a00p)
      deallocate (a_dia_i)
!
end subroutine
!#######################################################################
subroutine delsq_mod_pot3d (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = - dV * delsq_mod P
! ******
! ****** at the internal points.
!
!-----------------------------------------------------------------------
!
! ****** This routine is used for the 3D potential field solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot3d_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,ntm,npm) :: ps
      real(r_typ), dimension(2:nrm1,j0:j1,2:npm-1) :: q
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: temp_sum1,temp_sum2
      real(r_typ), dimension(nr,2) :: psi0,psi1
!
!-----------------------------------------------------------------------
!
!$acc enter data create(psi0,psi1)
      do concurrent (k=1:2, i=1:nr)
        psi0(i,k)=0.
        psi1(i,k)=0.
      enddo
!
! ****** Get the axisymmetric component of psi adjacent to the
! ****** poles.
!
      if (tb0) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+ps(i,1,k)*dp(k)*pl_i
            temp_sum2=temp_sum2+ps(i,2,k)*dp(k)*pl_i
          enddo
          psi0(i,1)=temp_sum1
          psi0(i,2)=temp_sum2
        enddo
      end if
!
      if (tb1) then
        do concurrent (i=1:nr)
          temp_sum1=0.
          temp_sum2=0.
          do k=2,npm1
            temp_sum1=temp_sum1+ps(i,ntm1,k)*dp(k)*pl_i
            temp_sum2=temp_sum2+ps(i,ntm2,k)*dp(k)*pl_i
          enddo
          psi1(i,1)=temp_sum1
          psi1(i,2)=temp_sum2
        enddo
      end if
!
! ****** Sum over all processors.
!
      call sum_over_phi (2*nr,psi0,psi1)
!
! ****** Set the internal points of Q.
!
      do concurrent (k=2:npm-1, j=2:ntm-1)
        if (tb0.and.j.eq.2) then
          !j=1
!
          do concurrent (i=2:nrm1)
            q(i,1,k)= a000(i  ,1  ,k  )*ps(i  ,1  ,k  ) &
                  +ap00(i  ,1  ,k  )*ps(i+1,1  ,k  ) &
                  +ap00(i-1,1  ,k  )*ps(i-1,1  ,k  ) &
                  +a0p0(i  ,1  ,k  )*psi0(i,2)
          enddo
!
          do concurrent (i=2:nrm1)
            q(i,j,k)= a000(i  ,j  ,k  )*ps(i  ,j  ,k  ) &
                  +ap00(i  ,j  ,k  )*ps(i+1,j  ,k  ) &
                  +ap00(i-1,j  ,k  )*ps(i-1,j  ,k  ) &
                  +a0p0(i  ,j  ,k  )*ps(i  ,j+1,k  ) &
                  +a0p0(i  ,j-1,k  )*psi0(i,1) &
                  +a00p(i  ,j  ,k  )*ps(i  ,j  ,k+1) &
                  +a00p(i  ,j  ,k-1)*ps(i  ,j  ,k-1)
          enddo
        else if (tb1.and.j.eq.ntm2) then
!
          do concurrent (i=2:nrm1)
            q(i,j,k)= a000(i  ,j  ,k  )*ps(i  ,j  ,k  ) &
                     +ap00(i  ,j  ,k  )*ps(i+1,j  ,k  ) &
                     +ap00(i-1,j  ,k  )*ps(i-1,j  ,k  ) &
                     +a0p0(i  ,j  ,k  )*psi1(i,1) &
                     +a0p0(i  ,j-1,k  )*ps(i  ,j-1,k  ) &
                     +a00p(i  ,j  ,k  )*ps(i  ,j  ,k+1) &
                     +a00p(i  ,j  ,k-1)*ps(i  ,j  ,k-1)
          enddo
          !j=ntm1
!
          do concurrent (i=2:nrm1)
            q(i,ntm1,k)= a000(i  ,ntm1  ,k  )*ps(i  ,ntm1  ,k  ) &
                        +ap00(i  ,ntm1  ,k  )*ps(i+1,ntm1  ,k  ) &
                        +ap00(i-1,ntm1  ,k  )*ps(i-1,ntm1  ,k  ) &
                        +a0p0(i  ,ntm1  ,k  )*psi1(i,2)
          enddo
        else
!
          do concurrent (i=2:nrm1)
            q(i,j,k)= a000(i  ,j  ,k  )*ps(i  ,j  ,k  ) &
                     +ap00(i  ,j  ,k  )*ps(i+1,j  ,k  ) &
                     +ap00(i-1,j  ,k  )*ps(i-1,j  ,k  ) &
                     +a0p0(i  ,j  ,k  )*ps(i  ,j+1,k  ) &
                     +a0p0(i  ,j-1,k  )*ps(i  ,j-1,k  ) &
                     +a00p(i  ,j  ,k  )*ps(i  ,j  ,k+1) &
                     +a00p(i  ,j  ,k-1)*ps(i  ,j  ,k-1)
          enddo
        end if
      enddo
!$acc exit data delete(psi0,psi1)
!
end subroutine
!#######################################################################
subroutine set_bc_a (ab,a,bcmask)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on A at the boundaries.
!
! ****** BCMASK is used to "mask" the inhomogenous part of
! ****** the boundary values.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec_bc) :: ab
      type(avec) :: a
      real(r_typ) :: bcmask
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: facr0a,facr0b,facr1,bcm2
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      facr0a=bcmask*two*rh(1)/r0
      facr0b=rh(1)/rh(2)
      facr1=rh(nrm1)*rh_i(nr)
      bcm2=bcmask*two
!
      if (rb0) then
        do concurrent (k=1:np, j=jm0:jm1)
          a%t( 1,j,k)=facr0a*ab%r0%t(j,k)-facr0b*a%t( 2,j,k)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          a%p( 1,j,k)=facr0a*ab%r0%p(j,k)-facr0b*a%p( 2,j,k)
        enddo
      end if
!
      if (rb1) then
        if (potential_field_bc.eq.'MHDSS') then
          do concurrent (k=1:np, j=jm0:jm1)
            a%t(nr,j,k)=facr1*a%t(nrm1,j,k)
          enddo
!
          do concurrent (k=1:npm1, j=2:ntm1)
            a%p(nr,j,k)=facr1*a%p(nrm1,j,k)
          enddo
        else
          do concurrent (k=1:np, j=jm0:jm1)
            a%t(nr,j,k)=bcm2*ab%r1%t(j,k)-a%t(nrm1,j,k)
          enddo
!
          do concurrent (k=1:npm1, j=2:ntm1)
            a%p(nr,j,k)=bcm2*ab%r1%p(j,k)-a%p(nrm1,j,k)
          enddo
        end if
      end if
!
! ****** Set A at the poles.
!
      call set_pole_bc_avec (a)
!
end subroutine
!#######################################################################
subroutine set_bc_v (vv,bcmask)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on v at the boundaries.
!
! ****** BCMASK is used to "mask" the inhomogenous part of
! ****** the boundary values.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use characteristics
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vv
      real(r_typ) :: bcmask
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ),dimension(:,:,:),pointer,contiguous :: vv_r,vv_t,vv_p
      real(r_typ),dimension(:,:),pointer,contiguous :: vb_r0_r, &
                                                       vb_r0_t,vb_r0_p
      real(r_typ),dimension(:,:),pointer,contiguous :: vb_r1_r, &
                                                       vb_r1_t,vb_r1_p
!
!-----------------------------------------------------------------------
!
! ****** Optimization: use ptrs to avoid type hopping within GPU kernel.
!
      vv_r=>vv%r
      vv_t=>vv%t
      vv_p=>vv%p
!
      vb_r0_r=>vb%r0%r
      vb_r0_t=>vb%r0%t
      vb_r0_p=>vb%r0%p
!
      vb_r1_r=>vb%r1%r
      vb_r1_t=>vb%r1%t
      vb_r1_p=>vb%r1%p
!
! ****** Boundary at r=R0.
!
      if (rb0) then
!
        do concurrent (k=2:npm1, j=2:ntm1)
          vv_r(1,j,k)=bcmask*vb_r0_r(j,k)
        enddo
!
        do concurrent (k=2:npm1, j=2:ntm-1)
          vv_t(1,j,k)=bcmask*two*vb_r0_t(j,k)-vv_t(2,j,k)
        enddo
!
        do concurrent (k=2:npm-1, j=2:ntm1)
          vv_p(1,j,k)=bcmask*two*vb_r0_p(j,k)-vv_p(2,j,k)
        enddo
!
      end if
!
! ****** Boundary at r=R1.
!
      if (rb1) then
!
        do concurrent (k=2:npm1, j=2:ntm1)
          vv_r(nrm1,j,k)=bcmask*vb_r1_r(j,k)
        enddo
!
        do concurrent (k=2:npm1, j=2:ntm-1)
          vv_t(nr,j,k)=bcmask*vb_r1_t(j,k)
        enddo
!
        do concurrent (k=2:npm-1, j=2:ntm1)
          vv_p(nr,j,k)=bcmask*vb_r1_p(j,k)
        enddo
!
      end if
!
! ****** Set v at the poles.
!
      call set_pole_bc_vvec (vv)
!
end subroutine
!#######################################################################
subroutine set_bc_v_par (vv_par,bcmask)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on v parallel at the boundaries.
!
! ****** BCMASK is used to "mask" the inhomogenous part of
! ****** the boundary values.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use characteristics
      use bhat_storage
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: vv_par
      real(r_typ) :: bcmask
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** Boundary at r=R0.
!
      if (rb0) then
!
        do concurrent (k=2:npm1, j=2:ntm1)
          vv_par(1,j,k)=bcmask*two*vb%r0%par(j,k)-vv_par(2,j,k)
        enddo
!
      end if
!
! ****** Boundary at r=R1.
!
      if (rb1) then
!
        do concurrent (k=2:npm1, j=2:ntm1)
          vv_par(nr,j,k)=bcmask*two*vb%r1%par(j,k)-vv_par(nrm1,j,k)
        enddo
!
      end if
!
! ****** Set v parallel at the poles.
!
      call set_pole_bc_scalar_hhh (vv_par)
!
end subroutine
!#######################################################################
subroutine set_bc_pot3d (psi,bcmask)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on PSI at the radial boundaries
! ****** for the 3D potential field solve.
!
! ****** BCMASK is used to "mask" the inhomogenous part of
! ****** the boundary values.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use potential_field
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,ntm,npm) :: psi
      real(r_typ) :: bcmask
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
        do concurrent (k=1:npm, j=1:ntm)
          psi(1,j,k)= psi_bcfac0_n*psi(2,j,k) &
                   +bcmask*psi_bcfac0_v*psi_r0(j,k)
        enddo
      end if
!
      if (rb1) then
        do concurrent (k=1:npm, j=1:ntm)
          psi(nr,j,k)=psi_bcfac1_n*psi(nrm1,j,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine advv
!
!-----------------------------------------------------------------------
!
! ****** Advance the velocity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use cgcom
      use timing
      use coef_storage
      use dissipation_profiles
      use sts
      use matrix_storage_v_solve, ONLY : N_cgvec
      use mpidefs
      use emerging_flux_params
      use alfven_wave_pressure
      use wtd
      use debug
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Temporary storage.
!
      type(vvec) :: vp,jxb,dgv,vdgv,rhs
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: avrho,dv,vistmp,dtime_local2
      real(r_typ) :: dtime_exp,time_stepped
      integer :: i,j,k,i_ssvisc
      real(r_typ), dimension(N_cgvec) :: x_cg
      logical :: we_are_done
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVV)
!
! ****** Allocate the temporary vectors.
!
      call alloc_vvec (vp)
      call alloc_vvec (jxb)
      call alloc_vvec (dgv)
      call alloc_vvec (vdgv)
      call alloc_vvec (rhs)
!
! ****** Allocate storage for the v solve matrix coefficients.
!
      call alloc_v_matrix_coefs
!
! ****** Save the velocity in V_OLD, since we need to store the
! ****** velocity at the previous time step.
!
      call copy_vvec (v,v_old)
!
! ****** Load the boundary conditions on v.
!
      call load_bc_v
!
! ****** Call VISCDISS to compute viscous dissipation.
!
!cc      call viscdiss
!
! ****** Get J x B.
!
      if (use_old_jxb) then
        call jcrossb_old (fj,b,jxb)
      else
        call jcrossb (fj,b,jxb)
      end if
!
! ****** Add Coriolis and centrifugal force in the corotating frame
!
      if (calculation_frame.eq."COROTATING") then
        call add_inertial_force (jxb,v)
      end if
!
! ****** Calculate the wave pressure.
!
      if (advance_pw.or.(advance_zw.and.wtd_add_zw_pressure)) then
        call get_fpw (fpw)
      end if
!
! ****** Add in the pressure force and gravity.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        avrho=AVGR(rho,i+1,j,k)
        jxb%r(i,j,k)= jxb%r(i,j,k) &
                     -(pres(i+1,j,k)-pres(i,j,k))*dr_i(i) &
                     +pw_rcut_main(i)*fpw%r(i,j,k) &
                     -avrho*grav(i)*r_true_i(i)**2
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        jxb%t(i,j,k)= jxb%t(i,j,k) &
                     -(pres(i,j+1,k)-pres(i,j,k))*rh_i(i)*dt_i(j) &
                     +pw_rcut_half(i)*fpw%t(i,j,k)
      enddo
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        jxb%p(i,j,k)= jxb%p(i,j,k) &
                     -(pres(i,j,k+1)-pres(i,j,k)) &
                      *rh_i(i)*sth_i(j)*dp_i(k)*dp_mult &
                      +pw_rcut_half(i)*fpw%p(i,j,k)
      enddo
!
!-----------------------------------------------------------------------
! ****** Predictor step.
!-----------------------------------------------------------------------
!
      if (.not.pred_v) then
        call copy_vvec (v,vp)
      else
!
        if (ifvdgv.eq.0) then
          call zero_vvec (vdgv)
        else
          if (use_old_vdgv) then
            call getvdgv_old (v,vdgv)
          else
            call getvdgv (v,vdgv)
          end if
        end if
!
! ****** Use the semi-implicit term in the predictor.
!
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          coef(i,j,k)=betapc_si*dtime**2*sifac(i,j,k)
        enddo
!
! ****** Load the v solve matrix coefficients and preconditioner.
!
        equation_solved=EQ_SI_PREDICTOR
!
        call load_matrix_v_solve_implicit
        call load_preconditioner_v_solve
!
! ****** Get the explicit contribution of the semi-implicit term.
!
        call div_grad_v (v,dgv)
!
! ****** Calculate the right-hand-side in RHS and the guess in VP.
! ****** The guess is the explicit part of the predictor advance.
!
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
          avrho=AVGR(rho,i+1,j,k)
          dv=fl_fac(i)*r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
          vp%r(i,j,k)= v%r(i,j,k) &
                      +dtime*(-betapc_v_flow*vdgv%r(i,j,k) &
                              +betapc_v_wave*jxb%r(i,j,k)/avrho)
          rhs%r(i,j,k)=dv*avrho*vp%r(i,j,k)-dgv%r(i,j,k)
        enddo
!
        do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
          avrho=AVGT(rho,i,j+1,k)
          dv=fl_fach(i)*rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
          vp%t(i,j,k)= v%t(i,j,k) &
                      +dtime*(-betapc_v_flow*vdgv%t(i,j,k) &
                              +betapc_v_wave*jxb%t(i,j,k)/avrho)
          rhs%t(i,j,k)=dv*avrho*vp%t(i,j,k)-dgv%t(i,j,k)
        enddo
!
        do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
          avrho=AVGP(rho,i,j,k+1)
          dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
          vp%p(i,j,k)= v%p(i,j,k) &
                      +dtime*(-betapc_v_flow*vdgv%p(i,j,k) &
                              +betapc_v_wave*jxb%p(i,j,k)/avrho)
          rhs%p(i,j,k)=dv*avrho*vp%p(i,j,k)-dgv%p(i,j,k)
        enddo
!
! ****** Solve the implicit equations.
!
        call v_solver (rhs,vp)
!
      end if
!
!-----------------------------------------------------------------------
! ****** Corrector step.
!-----------------------------------------------------------------------
!
      if (ifvdgv.eq.0) then
        call zero_vvec (vdgv)
      else
        if (use_old_vdgv) then
          call getvdgv_old (vp,vdgv)
        else
          call getvdgv (vp,vdgv)
        end if
      end if
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
        coef(i,j,k)=dtime**2*sifac(i,j,k)
      enddo
!
! ****** Load the v solve matrix coefficients and preconditioner.
!
      equation_solved=EQ_SI_CORRECTOR
!
      call load_matrix_v_solve_implicit
      call load_preconditioner_v_solve
!
! ****** Get the explicit contribution of the semi-implicit term.
!
      call div_grad_v (v,dgv)
!
! ****** Get the RHS and the guess (in V).  The guess is the
! ****** explicit part of the corrector advance.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        avrho=AVGR(rho,i+1,j,k)
        dv=fl_fac(i)*r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
        v%r(i,j,k)= v%r(i,j,k) &
                   +dtime*(-vdgv%r(i,j,k)+jxb%r(i,j,k)/avrho)
        rhs%r(i,j,k)=dv*avrho*v%r(i,j,k)-dgv%r(i,j,k)
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        avrho=AVGT(rho,i,j+1,k)
        dv=fl_fach(i)*rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
        v%t(i,j,k)= v%t(i,j,k) &
                   +dtime*(-vdgv%t(i,j,k)+jxb%t(i,j,k)/avrho)
        rhs%t(i,j,k)=dv*avrho*v%t(i,j,k)-dgv%t(i,j,k)
      enddo
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        avrho=AVGP(rho,i,j,k+1)
        dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
        v%p(i,j,k)= v%p(i,j,k) &
                   +dtime*(-vdgv%p(i,j,k)+jxb%p(i,j,k)/avrho)
        rhs%p(i,j,k)=dv*avrho*v%p(i,j,k)-dgv%p(i,j,k)
      enddo
!
! ****** Solve the implicit equations.
!
      call v_solver (rhs,v)
!
!-----------------------------------------------------------------------
! ****** Viscous dissipation advance.
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVVISC)
!
! ****** Setup the solver (only needed once since visc doesn't change
! ****** with the solution).
!
      equation_solved=EQ_VISC
      solve_type=ST_V
!
! ****** Set up viscosity subcycles.
!
      i_ssvisc=1
      time_stepped=0.
      we_are_done=.false.
!
      if (visc_auto_subcycle) then
        dtime_local2=dtime
      else
        dtime_local2=dtime/REAL(visc_subcycles,r_typ)
      end if
!
      if (.not.use_exp_visc.and..not.use_sts_visc) then
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          coef(i,j,k)=dtime_local2*vis(i,j,k)
        enddo
        call load_matrix_v_solve_implicit
        call load_preconditioner_v_solve
      else
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          coef(i,j,k)=vis(i,j,k)
        enddo
        call load_matrix_v_solve_explicit
      end if
!$acc enter data create(x_cg)
!
! ****** Reset the time step to start the autocycle dt correctly.
!
      if (visc_auto_subcycle) dtime_local2=0.
!
! ****** Start the subcycle loop.
!
      do
!
! ****** Compute and set the practical time-step if requested.
!
        if (visc_auto_subcycle) then
!
          call get_dtptl_visc (dtime_local2)
!
! ****** Lower time step to reach the end time exactly if
! ****** it would otherwise go too far.
!
          if (time_stepped+dtime_local2.ge.dtime) then
            dtime_local2=dtime-time_stepped
            we_are_done=.true.
          end if
!
! ****** Take one last big step if hitting max # cycles.
! ****** Note: This not the same as having that number from the start.
!
          if (i_ssvisc.eq.visc_subcycles_max) then
            dtime_local2=dtime-time_stepped
            we_are_done=.true.
          end if
!
! ****** Need to re-load the matrix due to change in dtime if using pcg.
!
          if (.not.use_exp_visc.and..not.use_sts_visc) then
            do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
              coef(i,j,k)=dtime_local2*vis(i,j,k)
            enddo
            call load_matrix_v_solve_implicit
            call load_preconditioner_v_solve
          end if
!
          visc_subcycles = CEILING((dtime-time_stepped)/dtime_local2)
!
        end if
!
! ****** Take the viscosity step based on the method chosen.
!
        if (use_exp_visc) then
!
! ****** Explicit Forward Euler
!
          call get_dtexp_visc (dtime_exp)
          sts_s=ceiling(dtime_local2/dtime_exp)
          dtime_exp=dtime_local2/REAL(sts_s,r_typ)
          call pack_vvec (v,x_cg)
          call alloc_cg_ax_tmp
          call take_exp_step (x_cg,sts_s,dtime_exp)
          call dealloc_cg_ax_tmp
          call unpack_vvec (v,x_cg)
          call set_bc_v (v,one)
          call seam_vvec (v)
!
        elseif (use_sts_visc) then
!
! ****** Explicit Super Time Stepping
!
          call load_sts (dtime_local2)
          call pack_vvec (v,x_cg)
          if (sts_type.eq.3) then
            call take_sts_step_rk2 (x_cg,dtime_local2)
          elseif (sts_type.eq.2) then
            call take_sts_step_rk2 (x_cg,dtime_local2)
          elseif(sts_type.eq.1) then
            call take_sts_step_rkl1 (x_cg,dtime_local2)
          end if
          call unpack_vvec (v,x_cg)
          call set_bc_v (v,one)
          call seam_vvec (v)
          call unload_sts
!
        else
!
! ****** Implicit Backward Euler (PCG)
!
! ****** Get explicit part of the viscous advance for the guess.
!
          call div_grad_v (v,dgv)
!
! ****** Get the RHS and the guess (in V).  The guess is the
! ****** explicit part of the viscous advance.
!
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
            if (visc_rho_outside) then
              avrho=one
            else
              avrho=AVGR(rho,i+1,j,k)
            end if
            dv=r(i)**2*dr(i)*dth(j)*sth(j)*dph(k)
            rhs%r(i,j,k)=dv*avrho*v%r(i,j,k)
            v%r(i,j,k)=v%r(i,j,k)+dgv%r(i,j,k)/(dv*avrho)
          enddo
!
          do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
            if (visc_rho_outside) then
              avrho=one
            else
              avrho=AVGT(rho,i,j+1,k)
            end if
            dv=rh(i)**2*drh(i)*dt(j)*st(j)*dph(k)
            rhs%t(i,j,k)=dv*avrho*v%t(i,j,k)
            v%t(i,j,k)=v%t(i,j,k)+dgv%t(i,j,k)/(dv*avrho)
          enddo
!
          do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
            if (visc_rho_outside) then
              avrho=one
            else
              avrho=AVGP(rho,i,j,k+1)
            end if
            dv=rh(i)**2*drh(i)*dth(j)*sth(j)*dp(k)
            rhs%p(i,j,k)=dv*avrho*v%p(i,j,k)
            v%p(i,j,k)=v%p(i,j,k)+dgv%p(i,j,k)/(dv*avrho)
          enddo
!
! ****** Solve the implicit equations with PCG.
!
          call v_solver (rhs,v)
!
        end if
!
! ****** Update the amount of the large time step that has been stepped.
!
        time_stepped=time_stepped+dtime_local2
!
        if (iamp0.and.idebug.gt.0) then
          write(*,*) '--> VISC Subcycle #',i_ssvisc,' SC: ', &
                          visc_subcycles,' dtcycle:',dtime_local2, &
                          ' time_stepped: ',time_stepped
        end if
!
! ****** If we are using a set number of subcycles, check if done.
!
        if (.not.visc_auto_subcycle.and.i_ssvisc.eq.visc_subcycles) then
          we_are_done=.true.
        end if
!
! ****** Exit the loop if the full time step is complete.
!
        if (we_are_done) exit
!
        i_ssvisc=i_ssvisc+1
!
      enddo
!
      if (use_timer) call timer (TIME_ADVVISC)
!
! ****** Deallocate storage for the v solve.
!
      call dealloc_v_matrix_coefs
!$acc exit data delete(x_cg)
!
! ****** Set the parallel part of the flow to zero if requested.
!
      if (zero_v_parallel) then
        call zero_parallel_flow (v)
      end if
!
! ****** Remove eflux from vb, if needed
!
      if (evolve_flux.and.time_dependent_corona) then
        call remove_eflux_v_from_vb
      end if
!
! ****** Filter vr at the poles if requested.
!
      if (pole_filter_vr) then
        call smooth_poles_vr (v%r)
      end if
!
! ****** Deallocate the temporary vectors.
!
      call dealloc_vvec (vp)
      call dealloc_vvec (jxb)
      call dealloc_vvec (dgv)
      call dealloc_vvec (vdgv)
      call dealloc_vvec (rhs)
!
      if (use_timer) call timer (TIME_ADVV)
!
end subroutine
!#######################################################################
subroutine advv_par
!
!-----------------------------------------------------------------------
!
! ****** Advance the parallel velocity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use cgcom
      use timing
      use coef_storage
      use dissipation_profiles
      use mpidefs
      use debug
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Temporary storage.
!
      type(vvec) :: force
      real(r_typ), dimension(nr,nt,np) :: f_par
      real(r_typ), dimension(nr,nt,np) :: vp_par
      real(r_typ), dimension(nr,nt,np) :: vdgv_par
      real(r_typ), dimension(nr,nt,np) :: dgv_par
      real(r_typ), dimension(nr,nt,np) :: rhs
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: avrho,dv,dtime_local2,time_stepped
      integer :: i,j,k,i_ssvisc
      logical :: we_are_done
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVV)
!$acc enter data create(f_par,vp_par,vdgv_par,dgv_par,rhs)
!
! ****** Allocate the temporary vectors.
!
      call alloc_vvec (force)
!
! ****** Allocate storage for the v parallel solve matrix coefficients.
!
      call alloc_v_par_matrix_coefs
!
! ****** Save the velocity in V_OLD and V_PAR_OLD, since we need
! ****** to store the velocity at the previous time step.
!
      call copy_vvec (v,v_old)
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        v_par_old(i,j,k)=v_par(i,j,k)
      enddo
!
! ****** Load the boundary conditions on v.
!
      call load_bc_v
!
! ****** Get the force.
!
      call zero_vvec (force)
!
! ****** Add Coriolis and centrifugal force in the corotating frame
!
      if (calculation_frame.eq."COROTATING") then
        call add_inertial_force (force,v)
      end if
!
! ****** Add the pressure force and gravity.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        avrho=AVGR(rho,i+1,j,k)
        force%r(i,j,k)= force%r(i,j,k) &
                       -(pres(i+1,j,k)-pres(i,j,k))*dr_i(i) &
                       -half*( (ep(i+1,j,k)+em(i+1,j,k)) &
                              -(ep(i  ,j,k)+em(i  ,j,k)))*dr_i(i) &
                       -avrho*grav(i)*r_true_i(i)**2
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        force%t(i,j,k)= force%t(i,j,k) &
                       -(pres(i,j+1,k)-pres(i,j,k))*rh_i(i)*dt_i(j) &
                       -half*( (ep(i,j+1,k)+em(i,j+1,k)) &
                              -(ep(i,j  ,k)+em(i,j  ,k))) &
                             *rh_i(i)*dt_i(j)
      enddo
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        force%p(i,j,k)= force%p(i,j,k) &
                       -(pres(i,j,k+1)-pres(i,j,k)) &
                        *rh_i(i)*sth_i(j)*dp_i(k)*dp_mult &
                      -half*dp_mult*( (ep(i,j,k+1)+em(i,j,k+1)) &
                                     -(ep(i,j,k  )+em(i,j,k  ))) &
                                     *rh_i(i)*sth_i(j)*dp_i(k)
      enddo
!
! ****** Get the parallel part of the force.
!
      call get_parallel_force (force,f_par)
!
!-----------------------------------------------------------------------
! ****** Predictor step.
!-----------------------------------------------------------------------
!
      if (.not.pred_v) then
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          vp_par(i,j,k)=v_par(i,j,k)
        enddo
!
      else
!
        if (ifvdgv.eq.0) then
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            vdgv_par(i,j,k)=0.
          enddo
        else
          call getvdgv_par (v_par,vdgv_par)
        end if
!
! ****** Use the semi-implicit term in the predictor.
!
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          coef(i,j,k)=betapc_si*dtime**2*sifac(i,j,k)
        enddo
!
! ****** Load the v solve matrix coefficients and preconditioner.
!
        equation_solved=EQ_SI_PREDICTOR
!
        call load_matrix_v_par_solve
        call load_preconditioner_v_par_solve
!
! ****** Get the explicit contribution of the semi-implicit term.
!
        call div_grad_v_par (v_par,dgv_par)
!
! ****** Calculate the right-hand-side in RHS and the guess in VP_PAR.
! ****** The guess is the explicit part of the predictor advance.
!
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          avrho=AVG(rho,i,j,k)
          dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
          vp_par(i,j,k)= v_par(i,j,k) &
                        +dtime*(-betapc_v_flow*vdgv_par(i,j,k) &
                                +betapc_v_wave*f_par(i,j,k)/avrho)
          rhs(i,j,k)=dv*avrho*vp_par(i,j,k)-dgv_par(i,j,k)
        enddo
!
! ****** Solve the implicit equations.
!
        call v_par_solver (rhs,vp_par)
!
      end if
!
!-----------------------------------------------------------------------
! ****** Corrector step.
!-----------------------------------------------------------------------
!
      if (ifvdgv.eq.0) then
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          vdgv_par(i,j,k)=0.
        enddo
      else
        call getvdgv_par (vp_par,vdgv_par)
      end if
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
        coef(i,j,k)=dtime**2*sifac(i,j,k)
      enddo
!
! ****** Load the v solve matrix coefficients and preconditioner.
!
      equation_solved=EQ_SI_CORRECTOR
!
      call load_matrix_v_par_solve
      call load_preconditioner_v_par_solve
!
! ****** Get the explicit contribution of the semi-implicit term.
!
      call div_grad_v_par (v_par,dgv_par)
!
! ****** Get the RHS and the guess (in V_PAR).  The guess is the
! ****** explicit part of the corrector advance.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        avrho=AVG(rho,i,j,k)
        dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
        v_par(i,j,k)= v_par(i,j,k) &
                     +dtime*(-vdgv_par(i,j,k)+f_par(i,j,k)/avrho)
        rhs(i,j,k)=dv*avrho*v_par(i,j,k)-dgv_par(i,j,k)
      enddo
!
! ****** Solve the implicit equations.
!
      call v_par_solver (rhs,v_par)
!
!-----------------------------------------------------------------------
! ****** Viscous dissipation advance.
!-----------------------------------------------------------------------
!
! ****** Setup the solver (only needed once since visc doesn't change
! ****** with the solution).
!
      equation_solved=EQ_VISC
      solve_type=ST_V
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
        coef(i,j,k)=dtime*vis(i,j,k)
      enddo
!
      call load_matrix_v_par_solve
      call load_preconditioner_v_par_solve
!
! ****** Set up viscosity subcycles.
!
      i_ssvisc=1
      time_stepped=0.
      we_are_done=.false.
!
      dtime_local2=dtime/REAL(visc_subcycles,r_typ)
!
! ****** Subcycle viscosity advance.
!
      do
!
! ****** Implicit Backward Euler (PCG)
!
! ****** Get the explicit part of the viscous advance for the
! ****** guess.
!
        call div_grad_v_par (v_par,dgv_par)
!
! ****** Get the RHS and the guess (in V_PAR).  The guess is the
! ****** explicit part of the viscous advance.
!
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          if (visc_rho_outside) then
            avrho=one
          else
            avrho=AVG(rho,i,j,k)
          end if
          dv=rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
          rhs(i,j,k)=dv*avrho*v_par(i,j,k)
          v_par(i,j,k)=v_par(i,j,k)+dgv_par(i,j,k)/(dv*avrho)
        enddo
!
! ****** Solve the implicit equations.
!
        call v_par_solver (rhs,v_par)
!
! ****** Update the amount of the large time step that has been stepped.
!
        time_stepped=time_stepped+dtime_local2
!
        if (iamp0.and.idebug.gt.0) then
          write(*,*) '--> VISCPAR Subcycle #',i_ssvisc,' SC: ', &
                      visc_subcycles,' dtcycle:',dtime_local2, &
                     ' time_stepped: ',time_stepped
        end if
!
! ****** If we are using a set number of subcycles, check if done.
!
        if (i_ssvisc.eq.visc_subcycles) then
          we_are_done=.true.
        end if
!
! ****** Exit the loop if the full time step is complete.
!
        if (we_are_done) exit
!
        i_ssvisc=i_ssvisc+1
!
      enddo
!
! ****** Project the parallel velocity to the full vector velocity.
!
      call project_v_par_to_v (v_par,v)
!
! ****** Deallocate storage for the v solve.
!
      call dealloc_v_par_matrix_coefs
!
! ****** Deallocate the temporary vectors.
!
      call dealloc_vvec (force)
!
!$acc exit data delete(f_par,vp_par,vdgv_par,dgv_par,rhs)
      if (use_timer) call timer (TIME_ADVV)
!
end subroutine
!#######################################################################
subroutine advparticles
!
!-----------------------------------------------------------------------
!
! ****** Advance tracer particles.
!
!-----------------------------------------------------------------------
!
      use number_types
      use diagnostics
      use mesh
      use globals
      use vars
      use timing
      use constants
      use fields
      use interp_interface
      use sv2cv_interface
      use c2s_interface
      use s2c_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,ierr
!
      real(r_typ) :: r_max,r_min,t_max,t_min,p_max,p_min
      real(r_typ) :: v_r,v_t,v_p,v_x,v_y,v_z
      real(r_typ) :: r_tmp0,t_tmp0,p_tmp0
      real(r_typ) :: p_x0,p_y0,p_z0,p_x1,p_y1,p_z1,ds
!
      logical :: freeze_tp
      logical :: particle_outside_domain
!
      integer :: im_v,imp1_v,ih_v,ihp1_v
      integer :: jm_v,jmp1_v,jh_v,jhp1_v
      integer :: km_v,kmp1_v,kh_v,khp1_v
!
      real(r_typ) :: amr_v,amt_v,amp_v,ahr_v,aht_v,ahp_v
      real(r_typ) :: f00,f01,f10,f11
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVPARTICLES)
!
! ****** Get max and min of the local domain.
!
      r_min=r(1)
      if (rb1) then
        r_max=r(nrm)
      else
        r_max=r(nrm-1)
      end if
!
      t_min=t(1)
      if (tb1) then
        t_max=t(ntm)
      else
        t_max=t(ntm-1)
      end if
!
      p_min=p(1)
      p_max=p(npm-1)
!
! ****** Loop over particles, update those in the local domain.
!
      do concurrent (i=1:tracers%n)
!
        particle_outside_domain=.false.
!
        if(rb1) then
          if(tracers%r(i).lt.r_min.or. &
             tracers%r(i).gt.r_max) particle_outside_domain=.true.
        else
          if(tracers%r(i).lt.r_min.or. &
             tracers%r(i).ge.r_max) particle_outside_domain=.true.
        end if
!
        if(tb1) then
          if(tracers%t(i).lt.t_min.or. &
             tracers%t(i).gt.t_max) particle_outside_domain=.true.
        else
          if(tracers%t(i).lt.t_min.or. &
             tracers%t(i).ge.t_max) particle_outside_domain=.true.
        end if
!
        if(tracers%p(i).lt.p_min.or. &
           tracers%p(i).ge.p_max) particle_outside_domain=.true.
!
        if(particle_outside_domain) then
!
! ****** If particle is outside of the local domain,
! ****** zero-out all quantities so that the (global) tracers arrays
! ****** can be easily synched using a global sum.
!
          tracers%r(i)=0.
          tracers%t(i)=0.
          tracers%p(i)=0.
          if (trace_track_ds) then
            tracers%ds(i)=0.
          end if
!
        else
!
! ***** Interpolate velocity to the particle's position.
!
          call interp (nrm1, r,tracers%r(i),im_v,imp1_v,amr_v,ierr)
          call interp (ntm1, t,tracers%t(i),jm_v,jmp1_v,amt_v,ierr)
          call interp (  np, p,tracers%p(i),km_v,kmp1_v,amp_v,ierr)
!
          call interp (  nr,rh,tracers%r(i),ih_v,ihp1_v,ahr_v,ierr)
          call interp (  nt,th,tracers%t(i),jh_v,jhp1_v,aht_v,ierr)
          call interp (  np,ph,tracers%p(i),kh_v,khp1_v,ahp_v,ierr)
!
! ****** Interpolate the vr value.
!
          f00=(one-ahp_v)*v%r(  im_v,  jh_v,  kh_v) &
                   +ahp_v*v%r(  im_v,  jh_v,khp1_v)
          f01=(one-ahp_v)*v%r(  im_v,jhp1_v,  kh_v) &
                   +ahp_v*v%r(  im_v,jhp1_v,khp1_v)
          f10=(one-ahp_v)*v%r(imp1_v,  jh_v,  kh_v) &
                   +ahp_v*v%r(imp1_v,  jh_v,khp1_v)
          f11=(one-ahp_v)*v%r(imp1_v,jhp1_v,  kh_v) &
                   +ahp_v*v%r(imp1_v,jhp1_v,khp1_v)
!
          v_r=(one-amr_v)*((one-aht_v)*f00+aht_v*f01) &
             +     amr_v *((one-aht_v)*f10+aht_v*f11)
!
! ****** Interpolate the vt value.
!
          f00=(one-ahp_v)*v%t(  ih_v,  jm_v,  kh_v) &
                   +ahp_v*v%t(  ih_v,  jm_v,khp1_v)
          f01=(one-ahp_v)*v%t(  ih_v,jmp1_v,  kh_v) &
                   +ahp_v*v%t(  ih_v,jmp1_v,khp1_v)
          f10=(one-ahp_v)*v%t(ihp1_v,  jm_v,  kh_v) &
                   +ahp_v*v%t(ihp1_v,  jm_v,khp1_v)
          f11=(one-ahp_v)*v%t(ihp1_v,jmp1_v,  kh_v) &
                   +ahp_v*v%t(ihp1_v,jmp1_v,khp1_v)
!
          v_t=(one-ahr_v)*((one-amt_v)*f00+amt_v*f01) &
             +     ahr_v *((one-amt_v)*f10+amt_v*f11)
!
! ****** Interpolate the vp value.
!
          f00=(one-amp_v)*v%p(  ih_v,  jh_v,  km_v) &
                   +amp_v*v%p(  ih_v,  jh_v,kmp1_v)
          f01=(one-amp_v)*v%p(  ih_v,jhp1_v,  km_v) &
                   +amp_v*v%p(  ih_v,jhp1_v,kmp1_v)
          f10=(one-amp_v)*v%p(ihp1_v,  jh_v,  km_v) &
                   +amp_v*v%p(ihp1_v,  jh_v,kmp1_v)
          f11=(one-amp_v)*v%p(ihp1_v,jhp1_v,  km_v) &
                   +amp_v*v%p(ihp1_v,jhp1_v,kmp1_v)
!
          v_p=(one-ahr_v)*((one-aht_v)*f00+aht_v*f01) &
             +     ahr_v *((one-aht_v)*f10+aht_v*f11)
!
! ****** Save original particle location.
!
          r_tmp0=tracers%r(i)
          t_tmp0=tracers%t(i)
          p_tmp0=tracers%p(i)
!
! ****** Convert current position and velocity vector to Cartesian.
!
          call sv2cv (v_r,v_t,v_p,t_tmp0,p_tmp0,v_x,v_y,v_z)
!
          call s2c (r_tmp0,t_tmp0,p_tmp0,p_x0,p_y0,p_z0)
!
! ****** Advect the particle.
!
          p_x1=p_x0+dtime*v_x
          p_y1=p_y0+dtime*v_y
          p_z1=p_z0+dtime*v_z
!
!
! ****** Compute ds and add it to total if requested.
!
          if (trace_track_ds) then
            ds=sqrt((p_x1-p_x0)*(p_x1-p_x0) &
                   +(p_y1-p_y0)*(p_y1-p_y0) &
                   +(p_z1-p_z0)*(p_z1-p_z0))
!
            tracers%ds(i)=tracers%ds(i)+ds
          end if
!
! ****** Convert new position back to spherical coordinates.
!
          call c2s (p_x1,p_y1,p_z1, &
                    tracers%r(i),tracers%t(i),tracers%p(i))
!
! ****** Handle the situation if the particle has left the domain.
!
          freeze_tp=.false.
!
          if (tracers%r(i).ge.r1) then
            if (trace_reseed_index.eq.TRACER_RESEED_R_PERIODIC) then
              tracers%r(i)=r0+(tracers%r(i)-r1)+trace_reseed_r0
            else if (trace_reseed_index.eq.TRACER_RESEED_NONE) then
              tracers%r(i)=r1
              freeze_tp=.true.
            end if
          end if
!
          if (tracers%r(i).le.r0) then
            if (trace_reseed_index.eq.TRACER_RESEED_R_PERIODIC) then
              tracers%r(i)=r1-(r0-tracers%r(i))
            else if (trace_reseed_index.eq.TRACER_RESEED_NONE) then
              tracers%r(i)=r0
              freeze_tp=.true.
            end if
          end if
!
! ****** Do not update t and p if the particle has left the domain.
!
          if (freeze_tp) then
            tracers%t(i)=t_tmp0
            tracers%p(i)=p_tmp0
          end if
!
        end if
!
      enddo
!
! ****** Synchronize all processors to get updated values.
!
      call global_sum_v(tracers%n,tracers%r)
      call global_sum_v(tracers%n,tracers%t)
      call global_sum_v(tracers%n,tracers%p)
      if (trace_track_ds) then
        call global_sum_v(tracers%n,tracers%ds)
      end if
!
      if (use_timer) call timer (TIME_ADVPARTICLES)
!
end subroutine
!#######################################################################
subroutine zero_parallel_flow (vv)
!
!-----------------------------------------------------------------------
!
! ****** Set the parallel part of the flow in VV to zero.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vv
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vp
      integer :: i,j,k
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: vdotb,bsq
      real(r_typ) :: vperp_r,vperp_t,vperp_p
!
!-----------------------------------------------------------------------
!
! ****** Allocate VP to hold the perpendicular component of V
! ****** temporarily.
!
      call alloc_vvec (vp)
!
! ****** Do the internal points.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        av_vr=AVG   (vv%r,i  ,j,k)
        av_vt=AVGRT (vv%t,i+1,j,k)
        av_vp=AVGRP (vv%p,i+1,j,k)
        av_br=AVGRTP(b%r ,i+1,j,k)
        av_bt=AVGP  (b%t ,i  ,j,k)
        av_bp=AVGT  (b%p ,i  ,j,k)
        vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
        bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
        bsq=max(bsq,small_value)
        vperp_r=av_vr-vdotb*av_br/bsq
        vp%r(i,j,k)=vperp_r
      enddo
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        av_vr=AVGRT (vv%r,i,j+1,k)
        av_vt=AVG   (vv%t,i,j  ,k)
        av_vp=AVGTP (vv%p,i,j+1,k)
        av_br=AVGP  (b%r ,i,j  ,k)
        av_bt=AVGRTP(b%t ,i,j+1,k)
        av_bp=AVGR  (b%p ,i,j  ,k)
        vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
        bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
        bsq=max(bsq,small_value)
        vperp_t=av_vt-vdotb*av_bt/bsq
        vp%t(i,j,k)=vperp_t
      enddo
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        av_vr=AVGRP (vv%r,i,j,k+1)
        av_vt=AVGTP (vv%t,i,j,k+1)
        av_vp=AVG   (vv%p,i,j,k  )
        av_br=AVGT  (b%r ,i,j,k  )
        av_bt=AVGR  (b%t ,i,j,k  )
        av_bp=AVGRTP(b%p ,i,j,k+1)
        vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
        bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
        bsq=max(bsq,small_value)
        vperp_p=av_vp-vdotb*av_bp/bsq
        vp%p(i,j,k)=vperp_p
      enddo
!
! ****** Do the radial boundary points.
!
      if (rb0) then
        i=1
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr=AVGT  (vv%r,i  ,j+1,k)
          av_vt=AVGR  (vv%t,i+1,j  ,k)
          av_vp=AVGRTP(vv%p,i+1,j+1,k)
          av_br=AVGRP (b%r ,i+1,j  ,k)
          av_bt=AVGTP (b%t ,i  ,j+1,k)
          av_bp=AVG   (b%p ,i  ,j  ,k)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          vperp_t=av_vt-vdotb*av_bt/bsq
          vp%t(1,j,k)=two*vperp_t-vp%t(2,j,k)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr=AVGP  (vv%r,i  ,j,k+1)
          av_vt=AVGRTP(vv%t,i+1,j,k+1)
          av_vp=AVGR  (vv%p,i+1,j,k  )
          av_br=AVGRT (b%r ,i+1,j,k  )
          av_bt=AVG   (b%t ,i  ,j,k  )
          av_bp=AVGTP (b%p ,i  ,j,k+1)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          vperp_p=av_vp-vdotb*av_bp/bsq
          vp%p(1,j,k)=two*vperp_p-vp%p(2,j,k)
        enddo
      end if
!
      if (rb1) then
        i=nrm1
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr=AVGT  (vv%r,i  ,j+1,k)
          av_vt=AVGR  (vv%t,i+1,j  ,k)
          av_vp=AVGRTP(vv%p,i+1,j+1,k)
          av_br=AVGRP (b%r ,i+1,j  ,k)
          av_bt=AVGTP (b%t ,i  ,j+1,k)
          av_bp=AVG   (b%p ,i  ,j  ,k)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          vperp_t=av_vt-vdotb*av_bt/bsq
          vp%t(nr,j,k)=two*vperp_t-vp%t(nrm1,j,k)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr=AVGP  (vv%r,i  ,j,k+1)
          av_vt=AVGRTP(vv%t,i+1,j,k+1)
          av_vp=AVGR  (vv%p,i+1,j,k  )
          av_br=AVGRT (b%r ,i+1,j,k  )
          av_bt=AVG   (b%t ,i  ,j,k  )
          av_bp=AVGTP (b%p ,i  ,j,k+1)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          vperp_p=av_vp-vdotb*av_bp/bsq
          vp%p(nr,j,k)=two*vperp_p-vp%p(nrm1,j,k)
        enddo
      end if
!
! ****** Set v at the poles.
!
      call set_pole_bc_vvec (vp)
!
! ****** Seam the velocity.
!
      call seam_vvec (vp)
!
! ****** Update VV with VP.
!
      call copy_vvec (vp,vv)
!
! ****** Deallocate the temporary vector.
!
      call dealloc_vvec (vp)
!
end subroutine
!#######################################################################
subroutine get_bhat
!
!-----------------------------------------------------------------------
!
! ****** Get the value of b-hat on the HHH mesh.
!
! ****** This is used in the parallel flow algorithm (when
! ****** FREEZE_B=.true.).  The alignment of b-hat to B is
! ****** controlled by the b-hat mask.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use mesh
      use vars
      use bhat_storage
      use seam_interface
      use write_field_interface
      use field_table
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0._r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ), dimension(nrm,ntm,npm) :: fac
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: bsq,bmag
      real(r_typ) :: bhat_orig_r,bhat_orig_t,bhat_orig_p
      real(r_typ) :: bhat_tp_mag,sin_fac
      real(r_typ) :: bhf
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays that hold b-hat.
!
      allocate (bhat_r(nr,nt,np))
      allocate (bhat_t(nr,nt,np))
      allocate (bhat_p(nr,nt,np))
!
! ****** Load the b-hat mask.
!
      call load_bhat_mask
!
! ****** If a b-hat mask is being used, apply it.  Otherwise,
! ****** simply use b-hat as-is.
!
      if (use_bhat_mask) then
        fac=bhat_mask
      else
        fac=one
      end if
!
! ****** Get b-hat on the HHH mesh.
!
      bhat_r(:,:,:)=zero
      bhat_t(:,:,:)=zero
      bhat_p(:,:,:)=zero
!
! ****** Get b-hat the internal points.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            av_br=AVGTP(b%r,i,j,k)
            av_bt=AVGRP(b%t,i,j,k)
            av_bp=AVGRT(b%p,i,j,k)
            bhf=AVGRTP(fac,i,j,k)
            bhf=max(bhf,zero)
            bhf=min(bhf,one)
            bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
            bsq=max(bsq,small_value)
            bmag=sqrt(bsq)
            bhat_orig_r=av_br/bmag
            bhat_orig_t=av_bt/bmag
            bhat_orig_p=av_bp/bmag
            bhat_tp_mag=sqrt( bhat_orig_t**2 &
                             +bhat_orig_p**2)
            bhat_tp_mag=max(bhat_tp_mag,small_value)
            bhat_r(i,j,k)= bhf*bhat_orig_r &
                          +(one-bhf)*sign(one,bhat_orig_r)
            sin_fac=sqrt(one-bhat_r(i,j,k)**2)
            bhat_t(i,j,k)=sin_fac*bhat_orig_t/bhat_tp_mag
            bhat_p(i,j,k)=sin_fac*bhat_orig_p/bhat_tp_mag
          enddo
        enddo
      enddo
!
! ****** Do the radial boundary points.  These are evaluated on
! ****** the actual radial boundaries, even if they are stored
! ****** in the HHH arrays.
!
      if (rb0) then
        i=1
        do k=2,npm1
          do j=2,ntm1
            av_br=AVGRTP(b%r,i+1,j,k)
            av_bt=AVGP  (b%t,i  ,j,k)
            av_bp=AVGT  (b%p,i  ,j,k)
            bhf=AVGTP(fac,i,j,k)
            bhf=max(bhf,zero)
            bhf=min(bhf,one)
            bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
            bsq=max(bsq,small_value)
            bmag=sqrt(bsq)
            bhat_orig_r=av_br/bmag
            bhat_orig_t=av_bt/bmag
            bhat_orig_p=av_bp/bmag
            bhat_tp_mag=sqrt( bhat_orig_t**2 &
                             +bhat_orig_p**2)
            bhat_tp_mag=max(bhat_tp_mag,small_value)
            bhat_r(i,j,k)= bhf*bhat_orig_r &
                          +(one-bhf)*sign(one,bhat_orig_r)
            sin_fac=sqrt(one-bhat_r(i,j,k)**2)
            bhat_t(i,j,k)=sin_fac*bhat_orig_t/bhat_tp_mag
            bhat_p(i,j,k)=sin_fac*bhat_orig_p/bhat_tp_mag
          enddo
        enddo
      end if
!
      if (rb1) then
        i=nr
        do k=2,npm1
          do j=2,ntm1
            av_br=AVGRTP(b%r,i  ,j,k)
            av_bt=AVGP  (b%t,i-1,j,k)
            av_bp=AVGT  (b%p,i-1,j,k)
            bhf=AVGTP(fac,i-1,j,k)
            bhf=max(bhf,zero)
            bhf=min(bhf,one)
            bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
            bsq=max(bsq,small_value)
            bmag=sqrt(bsq)
            bhat_orig_r=av_br/bmag
            bhat_orig_t=av_bt/bmag
            bhat_orig_p=av_bp/bmag
            bhat_tp_mag=sqrt( bhat_orig_t**2 &
                             +bhat_orig_p**2)
            bhat_tp_mag=max(bhat_tp_mag,small_value)
            bhat_r(i,j,k)= bhf*bhat_orig_r &
                          +(one-bhf)*sign(one,bhat_orig_r)
            sin_fac=sqrt(one-bhat_r(i,j,k)**2)
            bhat_t(i,j,k)=sin_fac*bhat_orig_t/bhat_tp_mag
            bhat_p(i,j,k)=sin_fac*bhat_orig_p/bhat_tp_mag
          enddo
        enddo
      end if
!
! ****** Seam the arrays.
!
      call seam (bhat_r)
      call seam (bhat_t)
      call seam (bhat_p)
!
! ****** Deallocate the b-hat mask, since it is not needed any more.
!
      if (use_bhat_mask) then
        deallocate (bhat_mask)
      end if
!
! ****** Write the b-hat vector to files for debugging purposes.
!
      if (.true.) then
        call write_field ('bhat_r.h5',IFLD_RHO,bhat_r)
        call write_field ('bhat_t.h5',IFLD_RHO,bhat_t)
        call write_field ('bhat_p.h5',IFLD_RHO,bhat_p)
      end if
!
end subroutine
!#######################################################################
subroutine load_bhat_mask
!
!-----------------------------------------------------------------------
!
! ****** Load the profile that controls the transition of b-hat
! ****** between a vector aligned along B to a vector aligned along
! ****** the radial direction.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use fields
      use mpidefs
      use global_to_local_interface
      use bhat_storage
      use write_field_interface
      use field_table
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      real(r_typ), dimension(nrm1_g,ntm1_g,npm1_g) :: bhat_mask_g
!
!-----------------------------------------------------------------------
!
! ****** Check if a mask was requested.
!
      if (bhat_mask_file.eq.' ') then
        use_bhat_mask=.false.
        return
      else
        use_bhat_mask=.true.
      end if
!
! ****** Allocate memory for the mask.
!
      allocate (bhat_mask(nrm,ntm,npm))
!
! ****** Interpolate the profile from the specified file.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from LOAD_BHAT_MASK:'
        write (9,*) '### Reading the (r,t,p) mask'// &
                    ' from file: ', &
                    trim(bhat_mask_file)
        call read_rtp_interp_mmm (bhat_mask_file, &
                                  bhat_mask_g,1,ierr)
      end if
      call check_error_on_p0 (ierr)
      call global_to_local (bhat_mask_g,bhat_mask)
!
! ****** Write the interpolated b-hat mask for debugging purposes.
!
      if (.true.) then
        call write_field ('bhat_mask.h5',IFLD_VIS,bhat_mask)
      end if
!
end subroutine
!#######################################################################
subroutine project_v_to_v_par (vv,vv_par)
!
!-----------------------------------------------------------------------
!
! ****** Set the parallel part of the flow in array VV_PAR
! ****** from the full velocity vector in structure VV.
!
!-----------------------------------------------------------------------
!
! ****** This routine assumes that the velocity VV has already been
! ****** seamed.  If this is not the case, the results will not be
! ****** correct.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use fields
      use bhat_storage
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec):: vv
      real(r_typ), dimension(nr,nt,np) :: vv_par
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vr,av_vt,av_vp
!
!-----------------------------------------------------------------------
!
! ****** Do the internal points.
!
      do concurrent (k=2:npm1,j=2:ntm1,i=2:nrm1)
        av_vr=AVGR(vv%r,i,j,k)
        av_vt=AVGT(vv%t,i,j,k)
        av_vp=AVGP(vv%p,i,j,k)
        vv_par(i,j,k)= av_vr*bhat_r(i,j,k) &
                      +av_vt*bhat_t(i,j,k) &
                      +av_vp*bhat_p(i,j,k)
      enddo
!
! ****** Do the radial boundary points.
!
      if (rb0) then
        i=1
        do concurrent (k=2:npm1,j=2:ntm1)
          av_vr=AVG  (vv%r,i  ,j,k)
          av_vt=AVGRT(vv%t,i+1,j,k)
          av_vp=AVGRP(vv%p,i+1,j,k)
          vv_par( 1,j,k)= av_vr*bhat_r(i,j,k) &
                         +av_vt*bhat_t(i,j,k) &
                         +av_vp*bhat_p(i,j,k)
          vv_par( 1,j,k)=two*vv_par( 1,j,k)-vv_par(   2,j,k)
        enddo
      end if
!
      if (rb1) then
        i=nr
        do concurrent (k=2:npm1,j=2:ntm1)
          av_vr=AVG  (vv%r,i-1,j,k)
          av_vt=AVGRT(vv%t,i  ,j,k)
          av_vp=AVGRP(vv%p,i  ,j,k)
          vv_par(nr,j,k)= av_vr*bhat_r(i,j,k) &
                         +av_vt*bhat_t(i,j,k) &
                         +av_vp*bhat_p(i,j,k)
          vv_par(nr,j,k)=two*vv_par(nr,j,k)-vv_par(nrm1,j,k)
        enddo
      end if
!
! ****** Set v parallel at the poles.
!
      call set_pole_bc_scalar_hhh (vv_par)
!
! ****** Seam the parallel velocity.
!
      call seam_scalar (vv_par,nr,nt,np)
!
end subroutine
!#######################################################################
subroutine project_v_par_to_v (vv_par,vv)
!
!-----------------------------------------------------------------------
!
! ****** Project the parallel velocity in array VV_PAR to the full
! ****** velocity vector in structure VV.
!
!-----------------------------------------------------------------------
!
! ****** This routine assumes that the velocity VV_PAR has already
! ****** been seamed.  If this is not the case, the results will
! ****** not be correct.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use bhat_storage
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: vv_par
      type(vvec):: vv
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ), dimension(nr,nt,np) :: v_tmp
!
!-----------------------------------------------------------------------
!$acc enter data create(v_tmp)
!
! ****** Do the internal points.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        v_tmp(i,j,k)=bhat_r(i,j,k)*vv_par(i,j,k)
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        av_vr=AVGR(v_tmp,i+1,j,k)
        vv%r(i,j,k)=av_vr
      enddo
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        v_tmp(i,j,k)=bhat_t(i,j,k)*vv_par(i,j,k)
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        av_vt=AVGT(v_tmp,i,j+1,k)
        vv%t(i,j,k)=av_vt
      enddo
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        v_tmp(i,j,k)=bhat_p(i,j,k)*vv_par(i,j,k)
      enddo
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        av_vp=AVGP(v_tmp,i,j,k+1)
        vv%p(i,j,k)=av_vp
      enddo
!
! ****** Set the boundary conditions on v.
!
      call set_bc_v (vv,one)
!
! ****** Seam the velocity.
!
      call seam_vvec (vv)
!
!$acc exit data delete(v_tmp)
end subroutine
!#######################################################################
subroutine get_parallel_force (f,f_par)
!
!-----------------------------------------------------------------------
!
! ****** Return the parallel part of the force in array F_PAR, as
! ****** obtained from the force in vector F, defined on the
! ****** velocity mesh.
!
!-----------------------------------------------------------------------
!
! ****** The parallel part of the force is defined on the same mesh
! ****** as the parallel velocity.
!
! ****** This routine does not seam the F_PAR array, nor does
! ****** it set BCs.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use fields
      use vars
      use bhat_storage
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: f
      real(r_typ), dimension(nr,nt,np) :: f_par
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_fr,av_ft,av_fp
!
!-----------------------------------------------------------------------
!
! ****** Seam the force.  This is required because the force is
! ****** being averaged.
!
      call seam_vvec (f)
!
! ****** Do the internal points.
!
      do concurrent(k=2:npm1, j=2:ntm1, i=2:nrm1)
        av_fr=AVGR(f%r,i,j,k)
        av_ft=AVGT(f%t,i,j,k)
        av_fp=AVGP(f%p,i,j,k)
        f_par(i,j,k)=( av_fr*bhat_r(i,j,k) &
                      +av_ft*bhat_t(i,j,k) &
                      +av_fp*bhat_p(i,j,k))
      enddo
!
end subroutine
!#######################################################################
subroutine v_solver (rhs,vg)
!
!-----------------------------------------------------------------------
!
! ****** Perform the momentum equation solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use vars
      use debug
      use cgcom
      use mpidefs
      use timing
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: rhs,vg
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Temporary storage.
!
      type(vvec) :: vp
!
!-----------------------------------------------------------------------
!
      integer       :: ierr,i
      character(32) :: capt
!
!-----------------------------------------------------------------------
!
! ****** Structures for the CG solve.
!
      real(r_typ), dimension(N_cgvec) :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_V_SOLVER)
!
!$acc enter data create(x_cg,rhs_cg)
      do concurrent (i=1:N_cgvec)
        x_cg(i)=0.
        rhs_cg(i)=0.
      enddo
!
      N_CG=N_cgvec
!
! ****** Allocate the temporary vector.
!
      call alloc_vvec (vp)
!
! ****** Pack rhs into 1D rhs_cg array.
!
      call pack_vvec (rhs,rhs_cg)
!
! ****** Use a trick to accumulate the contribution of the
! ****** boundary conditions (i.e., the inhomogenous part)
! ****** to the RHS.  x_cg is used as a temporary array here.
!
      call set_bc_v (vp,one)
!
      call seam_vvec (vp)
!
      call one_minus_div_grad_v (vp,x_cg)
!
      do concurrent (i=1:N_cgvec)
        rhs_cg(i)=rhs_cg(i)-x_cg(i)
      enddo
!
! ****** Pack vg into 1D x_cg array.
!
      call pack_vvec (vg,x_cg)
!
! ****** Deallocate the temporary vector.
!
      call dealloc_vvec (vp)
!
      select case (equation_solved)
      case (EQ_SI_PREDICTOR)
        capt='SI predictor'
      case (EQ_SI_CORRECTOR)
        capt='SI corrector'
      case (EQ_VISC)
        capt='implicit viscosity equations'
      end select
!
! ****** Solve the implicit momentum equation.
!
      solve_type=ST_V
!
! ****** Set the tolerance for the solve.
!
      epscg_desired=epscg_v
!
      call solve (x_cg,rhs_cg,ierr)
!
      if (ierr.ne.0) go to 900
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,100) '### V solve ['//trim(capt)//']:',ncg,bnrm,rnrm
  100     format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
        end if
      end if
!
! ***** Unpack result array into vg vvec.
!
      call unpack_vvec (vg,x_cg)
!
! ****** Set the boundary values.
!
      call set_bc_v (vg,one)
!
! ****** Seam the result.
!
      call seam_vvec (vg)
!
      go to 950
!
! ****** Error exit.
!
  900 continue
!
      if (iamp0) then
        write (*,*)
        write (*,*) '### ERROR in V_SOLVER:'
        write (*,*) '### CG solution of '//trim(capt)//' for v:'
        write (*,*) '### The field solver did not converge.'
        write (*,*) 'NTIME = ',ntime
        write (*,*) 'TIME = ',time
      end if
      ifabort=.true.
      call final_diags
!
  950 continue
!
! ****** Write the matrix if requested (useful for debugging).
!
      if (print_matrix_advv) then
        if (equation_solved.eq.EQ_SI_CORRECTOR) then
          call write_matrix_advv ('amat_advv_sicorr.h5')
        else if (equation_solved.eq.EQ_SI_PREDICTOR) then
          call write_matrix_advv ('amat_advv_sipred.h5')
        else if (equation_solved.eq.EQ_VISC) then
          call write_matrix_advv ('amat_advv_visc.h5')
        end if
      end if
!
      if (use_timer) call timer (TIME_V_SOLVER)
!
!$acc exit data delete(x_cg,rhs_cg)
end subroutine
!#######################################################################
subroutine v_par_solver (rhs,vg)
!
!-----------------------------------------------------------------------
!
! ****** Perform the parallel momentum equation solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars
      use debug
      use cgcom
      use mpidefs
      use timing
      use matrix_storage_v_par_solve
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: rhs
      real(r_typ), dimension(nr,nt,np) :: vg
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Temporary storage.
!
      real(r_typ), dimension(nr,nt,np) :: vp_par
!
!-----------------------------------------------------------------------
!
      integer       :: ierr,i,j,k
      character(32) :: capt
!
!-----------------------------------------------------------------------
!
! ****** Structures for the CG solve.
!
      real(r_typ), dimension(N_cgvec) :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_V_SOLVER)
!
!$acc enter data create(x_cg,rhs_cg,vp_par)
      do concurrent (i=1:N_cgvec)
        x_cg(i)=0.
        rhs_cg(i)=0.
      enddo
!
      N_CG=N_cgvec
!
! ****** Pack rhs into 1D rhs_cg array.
!
      call pack_scalar (rhs,rhs_cg)
!
! ****** Use a trick to accumulate the contribution of the
! ****** boundary conditions (i.e., the inhomogenous part)
! ****** to the RHS.  x_cg is used as a temporary array here.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        vp_par(i,j,k)=0.
      enddo
!
      call set_bc_v_par (vp_par,one)
!
      call seam_scalar (vp_par,nr,nt,np)
!
      call one_minus_div_grad_v_par (vp_par,x_cg)
!
      do concurrent (i=1:N_cgvec)
        rhs_cg(i)=rhs_cg(i)-x_cg(i)
      enddo
!
! ****** Pack vg into 1D x_cg array.
!
      call pack_scalar (vg,x_cg)
!
      select case (equation_solved)
      case (EQ_SI_PREDICTOR)
        capt='SI predictor'
      case (EQ_SI_CORRECTOR)
        capt='SI corrector'
      case (EQ_VISC)
        capt='viscosity'
      end select
!
! ****** Solve the implicit parallel momentum equation.
!
      solve_type=ST_V_PAR
!
! ****** Set the tolerance for the solve.
!
      epscg_desired=epscg_v
!
      call solve (x_cg,rhs_cg,ierr)
!
      if (ierr.ne.0) go to 900
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,100) '### V solve ['//trim(capt)//']:',ncg,bnrm,rnrm
  100     format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
        end if
      end if
!
! ***** Unpack result array into VG.
!
      call unpack_scalar (vg,x_cg)
!
! ****** Set the boundary values.
!
      call set_bc_v_par (vg,one)
!
      call seam_scalar (vg,nr,nt,np)
!
      go to 950
!
! ****** Error exit.
!
  900 continue
!
      if (iamp0) then
        write (*,*)
        write (*,*) '### ERROR in V_PAR_SOLVER:'
        write (*,*) '### CG solution of '//trim(capt)//' for v:'
        write (*,*) '### The field solver did not converge.'
        write (*,*) 'NTIME = ',ntime
        write (*,*) 'TIME = ',time
      end if
      ifabort=.true.
      call final_diags
!
  950 continue
!
!$acc exit data delete(x_cg,rhs_cg,vp_par)
      if (use_timer) call timer (TIME_V_SOLVER)
!
end subroutine
!#######################################################################
subroutine a_solver (rhs,x,ab)
!
!-----------------------------------------------------------------------
!
! ****** Perform the resistivity equation solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use vars
      use debug
      use cgcom
      use mpidefs
      use globals
      use matrix_storage_a_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: rhs,x
      type(avec_bc) :: ab
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Temporary storage.
!
      type(avec) :: xbc
!
!-----------------------------------------------------------------------
!
      integer       :: ierr,i
      character(32) :: capt
!
!-----------------------------------------------------------------------
!
! ****** Structures for the CG solve.
!
      real(r_typ), dimension(N_cgvec) :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
!$acc enter data create(x_cg,rhs_cg)
      do concurrent (i=1:N_cgvec)
        x_cg(i)=0.
        rhs_cg(i)=0.
      enddo
!
      N_CG=N_cgvec
!
! ****** Allocate the temporary vectors.
!
      call alloc_avec (xbc)
!
      call alloc_a_matrix_coefs
      call load_preconditioner_a
!
! ****** Pack rhs into 1D rhs_cg array.
!
      call pack_avec (rhs,rhs_cg)
!
! ****** Use a trick to accumulate the contribution of the
! ****** boundary conditions (i.e., the inhomogenous part)
! ****** to the RHS.  x_cg is used as a temporary array here.
!
      call set_bc_a (ab,xbc,one)
!
      call seam_avec (xbc)
!
      call one_plus_curl_curl_a (xbc,x_cg)
!
      do concurrent (i=1:N_cgvec)
        rhs_cg(i)=rhs_cg(i)-x_cg(i)
      enddo
!
! ****** Pack x into 1D x_cg array.
!
      call pack_avec (x,x_cg)
!
! ****** Deallocate the temporary arrays and solver matrix.
!
      call dealloc_avec (xbc)
!
      capt='implicit resistivity equations'
!
! ****** Solve the implicit momentum equation.
!
      solve_type=ST_A
!
! ****** Set the tolerance for the solve.
!
      epscg_desired=epscg_a
!
      call solve (x_cg,rhs_cg,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in A_SOLVER:'
          write (*,*) '### CG solution of '//trim(capt)//' for a:'
          write (*,*) '### The field solver did not converge.'
          write (*,*) 'NTIME = ',ntime
          write (*,*) 'TIME = ',time
        end if
        ifabort=.true.
        call final_diags
      end if
!
      if (idebug.gt.0.or.ncghist.gt.0) then
        if (iamp0) then
          write (9,900) '### A solve ['//trim(capt)//']:',ncg,bnrm,rnrm
        end if
      end if
!
! ***** Unpack result array into x avec.
!
      call unpack_avec (x,x_cg)
!
! ****** Set the boundary values.
!
      call set_bc_a (ab,x,one)
!
! ****** Seam the result.
!
      call seam_avec (x)
!
      if (print_matrix_adva) call write_matrix_a
!
      call dealloc_a_matrix_coefs
!
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
!
!$acc exit data delete(x_cg,rhs_cg)
end subroutine
!#######################################################################
subroutine write_matrix_advv (fname)
!
!-----------------------------------------------------------------------
!
! ****** Write the matrix for the momentum equation solve to a file.
! ****** This can be useful for debugging.
! ****** This writes the matrix excluding boundary conditions.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types
      use mpidefs
      use cgcom
      use vars
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: xvec,yvec,dummy
      real(r_typ), dimension(:,:), allocatable :: amat
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k,ll
!
!-----------------------------------------------------------------------
!
! ****** Write the 3D matrix to a file.
!
      if (nproc.ne.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from WRITE_MATRIX_ADVV:'
          write (*,*) '### Could not write the matrix.'
          write (*,*) '### For this diagnostic you must run'// &
                      ' on only 1 processor.'
        end if
        return
      end if
!
      N_CG=N_cgvec
      call alloc_cg_ax_tmp
!
! ****** Allocate storage.
!
      allocate (xvec(N_cgvec))
      allocate (yvec(N_cgvec))
      xvec=0.
      yvec=0.
      allocate (dummy(1))
!
      allocate (amat(N_cgvec,N_cgvec))
      amat=0.
!
! ****** Process the r component.
!
      ll=0
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm2
            ll=ll+1
            xvec(ll)=one
            call ax_v (xvec,yvec)
            amat(:,ll)=yvec(:)
            xvec(ll)=0.
          enddo
        enddo
      enddo
!
! ****** Process the theta component.
!
      do k=2,npm1
        do j=2,ntm2
          do i=2,nrm1
            ll=ll+1
            xvec(ll)=one
            call ax_v (xvec,yvec)
            amat(:,ll)=yvec(:)
            xvec(ll)=0.
          enddo
        enddo
      enddo
!
! ****** Process the phi component.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            ll=ll+1
            xvec(ll)=one
            call ax_v (xvec,yvec)
            amat(:,ll)=yvec(:)
            xvec(ll)=0.
          enddo
        enddo
      enddo
!
      call wrhdf_2d (fname,.false.,N_cgvec,N_cgvec,amat,dummy,dummy, &
                     hdf32,ierr)
!
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### WARNING from WRITE_MATRIX_ADVV:'
        write (*,*) '### Could not write the matrix.'
        write (*,*) 'IERR (from WRHDF_2D) = ',ierr
      else
        write (*,*)
        write (*,*) '### COMMENT from WRITE_MATRIX_ADVV:'
        write (*,*) 'Wrote the matrix for the momentum'// &
                    ' solve to file: ',trim(fname)
      end if
!
      deallocate (xvec)
      deallocate (yvec)
      deallocate (amat)
      deallocate (dummy)
      call dealloc_cg_ax_tmp
!
end subroutine
!#######################################################################
subroutine vvec_to_1d (v,n,xvec)
!
!-----------------------------------------------------------------------
!
! ****** Pack the velocity vector in structure V into
! ****** one-dimensional array XVEC.
!
! ****** This routine is used by WRITE_MATRIX_ADVV.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      integer :: n
      real(r_typ), dimension(n) :: xvec
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,l
!
!-----------------------------------------------------------------------
!
! ****** Load the r component.
!
      l=0
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm2
            l=l+1
            xvec(l)=v%r(i,j,k)
          enddo
        enddo
      enddo
!
! ****** Load the theta component.
!
      do k=2,npm1
        do j=2,ntm2
          do i=2,nrm1
            l=l+1
            xvec(l)=v%t(i,j,k)
          enddo
        enddo
      enddo
!
! ****** Load the phi component.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            l=l+1
            xvec(l)=v%p(i,j,k)
          enddo
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine load_bc_v
!
!-----------------------------------------------------------------------
!
! ****** Determine the boundary conditions on v at the boundaries,
! ****** and load them into the v-boundary arrays (in structure VB).
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use characteristics
      use vars
      use shear_profile
      use flow_profile
      use drive_profile
      use emerging_flux_params
      use interplanetary_vars
      use prescribe_b_v_at_r0_vars
      use bhat_storage
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: avvr,avvt,avvp,fac
!
!-----------------------------------------------------------------------
!
! ****** Load the BCs at r=R0.
!
      if (interplanetary_run) then
        if (rb0) then
          do concurrent (k=1:np, j=1:nt)
            vb%r0%r(j,k)=vr_ip(j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            vb%r0%t(j,k)=vt_ip(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r0%p(j,k)=vp_ip(j,k)
          enddo
        end if
      else
!
! ****** Get the characteristic boundary conditions.
!
        if (char_bc0) then
!
! ****** Get the characteristic boundary conditions at r=R0.
!
          call char_bc_0
!
        else
!
! ****** Set v to zero at r0 boundary.
!
          if (rb0) then
            do concurrent (k=1:np, j=1:nt)
              vb%r0%r(j,k)=0.
            enddo
!
            do concurrent (k=1:np, j=1:ntm)
              vb%r0%t(j,k)=0.
            enddo
!
            do concurrent (k=1:npm, j=1:nt)
              vb%r0%p(j,k)=0.
            enddo
!
            if (freeze_b) then
              do concurrent (k=1:np, j=1:nt)
                vb%r0%par(j,k)=0.
              enddo
            end if
          end if
!
        end if
!
      end if
!
      if (char_bc1) then
!
! ****** Get the characteristic boundary conditions at r=R1.
!
        call char_bc_1
!
! ****** Load the VB structure at r=R1.
!
        if (rb1) then
!
          do concurrent (k=1:np, j=1:nt)
            vb%r1%r(j,k)=0.
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            vb%r1%t(j,k)=0.
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r1%p(j,k)=0.
          enddo
!
          do concurrent (k=2:npm1, j=2:ntm1)
            vb%r1%r(j,k)=cbc1_ub(j,k)
          enddo
!
! ****** Use (old) vr to advect vt and vp.
!
! ****** Note that vb%r1%t and vb%r1%p are computed for
! ****** an expanded t and p range, respectively, so that
! ****** the parallel flow velocity, which involves averages
! ****** of these quantities, can be computed properly.
!
          do concurrent (k=2:npm1, j=1:ntm1)
            avvr=AVGT(v%r,nrm1,j+1,k)
            avvr=max(avvr,zero)
            fac=avvr*dtime*dr_i(nrm1)
            vb%r1%t(j,k)= (one-fac)*v%t(nr  ,j,k) &
                         +     fac *v%t(nrm1,j,k)
          enddo
!
          do concurrent (k=1:npm1, j=2:ntm1)
            avvr=AVGP(v%r,nrm1,j,k+1)
            avvr=max(avvr,zero)
            fac=avvr*dtime*dr_i(nrm1)
            vb%r1%p(j,k)= (one-fac)*v%p(nr  ,j,k) &
                         +     fac *v%p(nrm1,j,k)
          enddo
!
! ****** Load the parallel velocity into the VB structure at r=R1.
!
          if (freeze_b) then
            do concurrent (k=1:np, j=1:nt)
              vb%r1%par(j,k)=0.
            enddo
            do concurrent(k=2:npm1, j=2:ntm1)
              avvr=vb%r1%r(j,k)
              avvt=half*(vb%r1%t(j,k)+vb%r1%t(j-1,k))
              avvp=half*(vb%r1%p(j,k)+vb%r1%p(j,k-1))
              vb%r1%par(j,k)= avvr*bhat_r(nr,j,k) &
                             +avvt*bhat_t(nr,j,k) &
                             +avvp*bhat_p(nr,j,k)
            enddo
          end if
!
        end if
!
      else
!
! ****** Set v to zero at the r=R1 boundary.
!
        if (rb1) then
          do concurrent (k=1:np, j=1:nt)
            vb%r1%r(j,k)=0.
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            vb%r1%t(j,k)=0.
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r1%p(j,k)=0.
          enddo
!
          if (freeze_b) then
            do concurrent (k=1:np, j=1:nt)
              vb%r1%par(j,k)=0.
            enddo
          end if
        end if
!
      end if
!
! ****** Note that the parallel velocity does not get
! ****** contributions from the effects below.
!
      if (rb0) then
!
! ****** Add in the newflux psi/phi driven velocity (and leave!).
!
        if (evolve_flux.and.time_dependent_corona) then
          do concurrent (k=1:np, j=1:nt)
            vb%r0%r(j,k)=vb%r0%r(j,k)+eflux_vr(j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            vb%r0%t(j,k)=vb%r0%t(j,k)+eflux_vt(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r0%p(j,k)=vb%r0%p(j,k)+eflux_vp(j,k)
          enddo
!
          return
        end if
!
! ****** Add in the shear flow at r=R0.
!
        if (shear%active) then
          do concurrent (k=1:np, j=1:ntm)
            vb%r0%t(j,k)=vb%r0%t(j,k)+v_drive_mag*v_shear_t(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r0%p(j,k)=vb%r0%p(j,k)+v_drive_mag*v_shear_p(j,k)
          enddo
        end if
!
! ****** Add in the flow at r=R0.
!
        if (flow%active) then
          do concurrent (k=1:np, j=1:nt)
            vb%r0%r(j,k)=vb%r0%r(j,k)+v_flow_norm_mag*v_flow_r(j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            vb%r0%t(j,k)=vb%r0%t(j,k)+v_flow_trans_mag*v_flow_t(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r0%p(j,k)=vb%r0%p(j,k)+v_flow_trans_mag*v_flow_p(j,k)
          enddo
        end if
!
! ****** Add in the prescribed v (pbv) at r=R0.
!
        if (prescribe_bv) then
          do concurrent (k=1:np, j=1:nt)
            vb%r0%r(j,k)=vb%r0%r(j,k)+pbv_bcvfac*vr_pbv(j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            vb%r0%t(j,k)=vb%r0%t(j,k)+pbv_bcvfac*vt_pbv(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r0%p(j,k)=vb%r0%p(j,k)+pbv_bcvfac*vp_pbv(j,k)
          enddo
        end if
!
! ****** Add in the emerging flux velocity at r=R0.
!
        if (emerging_flux.and.ef%vr_set) then
          do concurrent (k=1:np, j=1:nt)
            vb%r0%r(j,k)=vb%r0%r(j,k)+ef%vr_v0*ef%vr(j,k)
          enddo
        end if
!
! ****** Add in the electric-field-driven velocity at r=R0.
!
        if (emerging_flux.and.ef%edrive%active) then
          do concurrent (k=1:np, j=1:nt)
            vb%r0%r(j,k)=vb%r0%r(j,k)+ef%edrive%e0*ef%edrive%vr(j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            vb%r0%t(j,k)=vb%r0%t(j,k)+ef%edrive%e0*ef%edrive%vt(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vb%r0%p(j,k)=vb%r0%p(j,k)+ef%edrive%e0*ef%edrive%vp(j,k)
          enddo
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine check_time_profiles
!
!-----------------------------------------------------------------------
!
! ****** Check the specified time profiles and link them to the
! ****** time-profile-controlled variables.
!
!-----------------------------------------------------------------------
!
      use number_types
      use time_profiles
      use flint_interface
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k,nprofs
      real(r_typ) :: dummy
      logical, dimension(mx_tp_vars) :: tprof_set=.false.
!
! ****** Temporary array to hold time profile variable names.
!
      character(len(tp_vars(1)%name)), dimension(mx_tp_vars) :: &
                                                        tp_vars_names
!
!-----------------------------------------------------------------------
!
      integer, external :: match
!
!-----------------------------------------------------------------------
!
! ****** Determine how many time profiles have been specified.
!
      do i=1,mx_tp_profs
        do j=1,mx_tp_nodes
          if (tprofile(i)%t(j).eq.NULL_VALUE_TP) exit
        enddo
        tprofile(i)%nodes=j-1
      enddo
!
! ****** Use a temporary array to hold the time profile variable names.
!
      tp_vars_names(:)=tp_vars(:)%name
!
! ****** Check the specified time profiles.
!
      do i=1,mx_tp_profs
        if (tprofile(i)%nodes.gt.0) then
          dummy=flint(.true.,zero,tprofile(i)%nodes, &
                      tprofile(i)%t,tprofile(i)%f, &
                      ierr,silent=.true.)
          if (ierr.ne.0) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in CHECK_TIME_PROFILES:'
              write (*,*) '### The time values specified for a'// &
                          ' time profile are not monotonically'
              write (*,*) '### increasing:'
              write (*,*) 'Time profile # ',i
              write (*,*) 'Time values = ', &
                          (tprofile(i)%t(j),j=1,tprofile(i)%nodes)
            end if
            call endrun (.true.)
          end if
        end if
      enddo
!
! ****** Check that the specified time profiles are linked to
! ****** valid variables.
!
      do i=1,mx_tp_profs
        if (tprofile(i)%nodes.gt.0) then
          do j=1,mx_tp_vars
            if (tprofile(i)%vars(j).eq.' ') exit
          enddo
          tprofile(i)%nvars=j-1
        else
          tprofile(i)%nvars=0
        end if
      enddo
!
      do i=1,mx_tp_profs
        do j=1,tprofile(i)%nvars
          k=match(tprofile(i)%vars(j),mx_tp_vars, &
                  tp_vars_names,.false.)
          if (k.gt.0) then
            if (tprof_set(k)) then
              if (iamp0) then
                write (*,*)
                write (*,*) '### ERROR in CHECK_TIME_PROFILES:'
                if (i.eq.tp_vars(k)%index) then
                  write (*,*) '### Attempt to link a variable'// &
                              ' multiple times to a time profile:'
                  write (*,*) 'Time profile # ',i
                  write (*,*) 'Variable requested: ', &
                              trim(tprofile(i)%vars(j))
                else
                  write (*,*) '### Attempt to link a variable to'// &
                              ' more than one time profile:'
                  write (*,*) 'Variable requested: ', &
                              trim(tprofile(i)%vars(j))
                  write (*,*) 'First linked to profile # ', &
                              tp_vars(k)%index
                  write (*,*) 'Also attempting to link to'// &
                              ' profile # ',i
                end if
              end if
              call endrun (.true.)
            end if
            tprof_set(k)=.true.
            tp_vars(k)%index=i
          else
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in CHECK_TIME_PROFILES:'
              write (*,*) '### Attempt to link a time profile to'// &
                          ' an invalid variable:'
              write (*,*) 'Time profile # ',i
              write (*,*) 'Variable requested: ', &
                          trim(tprofile(i)%vars(j))
              write (*,*) 'Variables allowed: '
              do k=1,mx_tp_vars
                write (*,*) trim(tp_vars(k)%name)
              enddo
            end if
            call endrun (.true.)
          end if
        enddo
      enddo
!
! ****** Write diagnostics about active time profiles.
!
      nprofs=0
      do i=1,mx_tp_profs
        if (tprofile(i)%nodes.gt.0) then
          nprofs=nprofs+1
        end if
      enddo
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from CHECK_TIME_PROFILES:'
        if (nprofs.gt.0) then
          write (9,*) '### The following time profiles are active:'
        else
          write (9,*) '### There are no active time profiles.'
        end if
        do i=1,mx_tp_profs
          if (tprofile(i)%nodes.gt.0) then
            write (9,*)
            write (9,*) '### Time profile # ',i
            write (9,*) 'Time values = ', &
                        (tprofile(i)%t(j),j=1,tprofile(i)%nodes)
            write (9,*) 'Profile values = ', &
                        (tprofile(i)%f(j),j=1,tprofile(i)%nodes)
            write (9,*) 'Controlled variables:'
            do j=1,mx_tp_vars
              if (tp_vars(j)%index.eq.i) then
                write (9,*) trim(tp_vars(j)%name)
              end if
            enddo
          end if
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine evaluate_time_profiles (tv)
!
!-----------------------------------------------------------------------
!
! ****** Evaluate the active time profiles at time TV.
!
!-----------------------------------------------------------------------
!
      use number_types
      use time_profiles
      use flint_interface
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: tv
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i
!
!-----------------------------------------------------------------------
!
! ****** Evaluate the active time profiles at time TV.
!
      do i=1,mx_tp_profs
        if (tprofile(i)%nodes.gt.0) then
          tprofile(i)%value=flint(.false.,tv,tprofile(i)%nodes, &
                                  tprofile(i)%t,tprofile(i)%f, &
                                  ierr,silent=.false.)
          if (ierr.ne.0) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in EVALUATE_TIME_PROFILES:'
              write (*,*) '### Anomaly in interpolating a time'// &
                          ' profile.'
              write (*,*) 'Time profile # ',i
              write (*,*) 'Requested time value = ',tv
            end if
            call endrun (.true.)
          end if
        else
!
        end if
      enddo
!
! ****** Set the current value of the time-profile-controlled
! ****** variables.
!
! ****** Note that the default value for variables that have not
! ****** been linked to a time profile is 1.
!
      do i=1,mx_tp_vars
        if (tp_vars(i)%index.gt.0) then
          tp_vars(i)%value=tprofile(tp_vars(i)%index)%value
        else
          tp_vars(i)%value=one
        end if
      enddo
!
end subroutine
!#######################################################################
subroutine set_time_profile_variables
!
!-----------------------------------------------------------------------
!
! ****** Set the values of the variables controlled by time profiles.
!
!-----------------------------------------------------------------------
!
      use number_types
      use time_profiles
      use drive_profile
      use dissipation_profiles
      use emerging_flux_params
      use eta_photosphere
      use fields
      use vars
      use globals, ONLY : nrm,ntm,npm
      use diagnostics
      use heating_parameters, ONLY: ohmic_heating_factor
      use wtd, ONLY : zw_heat_factor,zw_pressure_factor
      use prescribe_tdc_from_file_r0, ONLY : tdc_phi
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ), save :: tpltxint0,trace_txint0,slice_txint0
      logical, save :: first=.true.
!
!-----------------------------------------------------------------------
!
! ****** Set the drive velocity.
!
      v_drive_factor=tp_vars(TP_INDEX_V0)%value
      v_drive_mag=v_drive*v_drive_factor
!
! ****** Set the flow velocity.
!
      v_flow_norm_factor=tp_vars(TP_INDEX_FLOW_NORM)%value
      v_flow_norm_mag=v_flow_norm*v_flow_norm_factor
!
      v_flow_trans_factor=tp_vars(TP_INDEX_FLOW_TRANS)%value
      v_flow_trans_mag=v_flow_trans*v_flow_trans_factor
!
! ****** Set the resistivity.
!
      eta_factor=tp_vars(TP_INDEX_ETA)%value
      do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
        eta(i,j,k)=eta_prof(i,j,k)*eta_factor
      enddo
!
! ****** Set the photospheric diffusion.
!
      eta_phot_factor=tp_vars(TP_INDEX_ETA_PHOT)%value
      eta_phot_mag=eta_phot*eta_phot_factor
!
! ****** Set the viscosity.
!
      vis_factor=tp_vars(TP_INDEX_VISC)%value
      do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
        vis(i,j,k)=vis_prof(i,j,k)*vis_factor+visc_bg
      enddo
!
! ****** Set the emerging flux electric field amplitudes.
!
      ef%psi%e0=tp_vars(TP_INDEX_EFLUX_PSI)%value
      ef%phi%e0=tp_vars(TP_INDEX_EFLUX_PHI)%value
      ef%edrive%e0=tp_vars(TP_INDEX_EDRIVE_E0)%value
!
! ****** Set the emerging flux radial velocity magnitude.
!
      ef%vr_v0=tp_vars(TP_INDEX_EFLUX_VR)%value
!
! ****** Set the multiplier for the Alfven wave pressure.
!
      pw0_factor=tp_vars(TP_INDEX_PW)%value
!
! ****** Set the multiplier for the density limiter.
!
      rho_limit_tprof=tp_vars(TP_INDEX_RHO_LIMIT)%value
!
! ****** Set the output cadences.
!
      if (first) then
        tpltxint0=tpltxint
        trace_txint0=trace_txint
        slice_txint0=slice_txint
        first=.false.
      end if
!
      tpltxint=tpltxint0*tp_vars(TP_INDEX_IO_DUMP_3D)%value
      trace_txint=trace_txint0*tp_vars(TP_INDEX_IO_DUMP_TRACERS)%value
      slice_txint=slice_txint0*tp_vars(TP_INDEX_IO_DUMP_SLICES)%value
!
! ****** Set the multiplier for ohmic heating.
!
      ohmic_heating_factor=tp_vars(TP_INDEX_OHMIC)%value
!
! ****** Set the factors for zp,zm heating and pressure
!
      zw_heat_factor=tp_vars(TP_INDEX_ZW_HEAT)%value
      zw_pressure_factor=tp_vars(TP_INDEX_ZW_PRES)%value
!
! ****** Time profile for energization through phi potential
!
      tdc_phi=tp_vars(TP_INDEX_TDC_PHI)%value
!
!$acc update device(ef%psi%e0,ef%phi%e0, &
!$acc               ef%vr_v0,ef%edrive%e0) if_present
end subroutine
!#######################################################################
subroutine set_r0_bc
!
!-----------------------------------------------------------------------
!
! ****** Set the current values of the variables that control the
! ****** boundary conditions at r=R0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars
      use fields
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: fac
      integer :: k,j
!
!-----------------------------------------------------------------------
!
! ****** Set the current density and pressure boundary conditions
! ****** at r=R0.
!
      if (rb0) then
        if (time.le.hs%time0) then
          fac=0.
        else if (time.ge.hs%time1) then
          fac=one
        else
          fac=(time-hs%time0)/(hs%time1-hs%time0)
        end if
!
        do concurrent (k=1:np, j=1:nt)
          rho0v(j,k)=(one-fac)*rho0i(j,k)+fac*rho0f(j,k)
          tr0v(j,k)=tbc0/fn_t
          pr0v(j,k)=(he_p/he_rho)*rho0v(j,k)*tr0v(j,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine jcrossb (fj,b,jxb)
!
!-----------------------------------------------------------------------
!
! ****** Compute (J x B).
!
! ****** This version uses an averaging that behaves well near
! ****** current sheets and gives a self-adjoint algorithm.
!
!-----------------------------------------------------------------------
!
! ****** On input, FJ contains the current density and B contains
! ****** the magnetic field.
!
! ****** On return, the structure JXB contains (J x B).
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: fj
      type(bvec) :: b
      type(vvec) :: jxb
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avbr_pp,avbr_mp,avbr_pm,avbr_mm
      real(r_typ) :: avbt_pp,avbt_mp,avbt_pm,avbt_mm
      real(r_typ) :: avbp_pp,avbp_mp,avbp_pm,avbp_mm
      real(r_typ) :: avjr_pp,avjr_mp,avjr_pm,avjr_mm
      real(r_typ) :: avjt_pp,avjt_mp,avjt_pm,avjt_mm
      real(r_typ) :: avjp_pp,avjp_mp,avjp_pm,avjp_mm
      real(r_typ) :: dv_pp,dv_mp,dv_pm,dv_mm,dv_i
      real(r_typ) :: avjtbp,avjpbt
      real(r_typ) :: avjpbr,avjrbp
      real(r_typ) :: avjrbt,avjtbr
!
!-----------------------------------------------------------------------
!
! ****** Zero out the J x B array.
!
      call zero_vvec (jxb)
!
! ****** R component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        avbp_pp=AVGR(b%p,i+1,j  ,k)
        avbp_mp=AVGR(b%p,i  ,j  ,k)
        avbp_pm=AVGR(b%p,i+1,j-1,k)
        avbp_mm=AVGR(b%p,i  ,j-1,k)
        avjt_pp=fj%t(i+1,j  ,k)
        avjt_mp=fj%t(i  ,j  ,k)
        avjt_pm=fj%t(i+1,j-1,k)
        avjt_mm=fj%t(i  ,j-1,k)
        dv_pp=rh(i+1)**2*drh(i+1)*st(j  )*dt(j  )
        dv_mp=rh(i  )**2*drh(i  )*st(j  )*dt(j  )
        dv_pm=rh(i+1)**2*drh(i+1)*st(j-1)*dt(j-1)
        dv_mm=rh(i  )**2*drh(i  )*st(j-1)*dt(j-1)
        dv_i=r_i(i)**2*dr_i(i)*sth_i(j)*dth_i(j)
        avjtbp=quarter*dv_i*( dv_pp*avjt_pp*avbp_pp &
                             +dv_mp*avjt_mp*avbp_mp &
                             +dv_pm*avjt_pm*avbp_pm &
                             +dv_mm*avjt_mm*avbp_mm)
        avbt_pp=AVGR(b%t,i+1,j,k  )
        avbt_mp=AVGR(b%t,i  ,j,k  )
        avbt_pm=AVGR(b%t,i+1,j,k-1)
        avbt_mm=AVGR(b%t,i  ,j,k-1)
        avjp_pp=fj%p(i+1,j,k  )
        avjp_mp=fj%p(i  ,j,k  )
        avjp_pm=fj%p(i+1,j,k-1)
        avjp_mm=fj%p(i  ,j,k-1)
        dv_pp=rh(i+1)**2*drh(i+1)*dp(k  )
        dv_mp=rh(i  )**2*drh(i  )*dp(k  )
        dv_pm=rh(i+1)**2*drh(i+1)*dp(k-1)
        dv_mm=rh(i  )**2*drh(i  )*dp(k-1)
        dv_i=r_i(i)**2*dr_i(i)*dph_i(k)
        avjpbt=quarter*dv_i*( dv_pp*avjp_pp*avbt_pp &
                             +dv_mp*avjp_mp*avbt_mp &
                             +dv_pm*avjp_pm*avbt_pm &
                             +dv_mm*avjp_mm*avbt_mm)
        jxb%r(i,j,k)=avjtbp-avjpbt
      enddo
!
! ****** Theta component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        avbr_pp=AVGT(b%r,i,j+1,k  )
        avbr_mp=AVGT(b%r,i,j  ,k  )
        avbr_pm=AVGT(b%r,i,j+1,k-1)
        avbr_mm=AVGT(b%r,i,j  ,k-1)
        avjp_pp=fj%p(i,j+1,k  )
        avjp_mp=fj%p(i,j  ,k  )
        avjp_pm=fj%p(i,j+1,k-1)
        avjp_mm=fj%p(i,j  ,k-1)
        dv_pp=sth(j+1)*dth(j+1)*dp(k  )
        dv_mp=sth(j  )*dth(j  )*dp(k  )
        dv_pm=sth(j+1)*dth(j+1)*dp(k-1)
        dv_mm=sth(j  )*dth(j  )*dp(k-1)
        dv_i=st_i(j)*dt_i(j)*dph_i(k)
        avjpbr=quarter*dv_i*( dv_pp*avjp_pp*avbr_pp &
                             +dv_mp*avjp_mp*avbr_mp &
                             +dv_pm*avjp_pm*avbr_pm &
                             +dv_mm*avjp_mm*avbr_mm)
        avbp_pp=AVGT(b%p,i  ,j+1,k)
        avbp_mp=AVGT(b%p,i-1,j+1,k)
        avbp_pm=AVGT(b%p,i  ,j  ,k)
        avbp_mm=AVGT(b%p,i-1,j  ,k)
        avjr_pp=fj%r(i  ,j+1,k)
        avjr_mp=fj%r(i-1,j+1,k)
        avjr_pm=fj%r(i  ,j  ,k)
        avjr_mm=fj%r(i-1,j  ,k)
        dv_pp=r(i  )**2*dr(i  )*sth(j+1)*dth(j+1)
        dv_mp=r(i-1)**2*dr(i-1)*sth(j+1)*dth(j+1)
        dv_pm=r(i  )**2*dr(i  )*sth(j  )*dth(j  )
        dv_mm=r(i-1)**2*dr(i-1)*sth(j  )*dth(j  )
        dv_i=rh_i(i)**2*drh_i(i)*st_i(j)*dt_i(j)
        avjrbp=quarter*dv_i*( dv_pp*avjr_pp*avbp_pp &
                             +dv_mp*avjr_mp*avbp_mp &
                             +dv_pm*avjr_pm*avbp_pm &
                             +dv_mm*avjr_mm*avbp_mm)
        jxb%t(i,j,k)=avjpbr-avjrbp
      enddo
!
! ****** Phi component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
         avbt_pp=AVGP(b%t,i  ,j,k+1)
         avbt_mp=AVGP(b%t,i-1,j,k+1)
         avbt_pm=AVGP(b%t,i  ,j,k  )
         avbt_mm=AVGP(b%t,i-1,j,k  )
         avjr_pp=fj%r(i  ,j,k+1)
         avjr_mp=fj%r(i-1,j,k+1)
         avjr_pm=fj%r(i  ,j,k  )
         avjr_mm=fj%r(i-1,j,k  )
         dv_pp=r(i  )**2*dr(i  )*dph(k+1)
         dv_mp=r(i-1)**2*dr(i-1)*dph(k+1)
         dv_pm=r(i  )**2*dr(i  )*dph(k  )
         dv_mm=r(i-1)**2*dr(i-1)*dph(k  )
         dv_i=rh_i(i)**2*drh_i(i)*dp_i(k)
         avjrbt=quarter*dv_i*( dv_pp*avjr_pp*avbt_pp &
                              +dv_mp*avjr_mp*avbt_mp &
                              +dv_pm*avjr_pm*avbt_pm &
                              +dv_mm*avjr_mm*avbt_mm)
         avbr_pp=AVGP(b%r,i,j  ,k+1)
         avbr_mp=AVGP(b%r,i,j-1,k+1)
         avbr_pm=AVGP(b%r,i,j  ,k  )
         avbr_mm=AVGP(b%r,i,j-1,k  )
         avjt_pp=fj%t(i,j  ,k+1)
         avjt_mp=fj%t(i,j-1,k+1)
         avjt_pm=fj%t(i,j  ,k  )
         avjt_mm=fj%t(i,j-1,k  )
         dv_pp=st(j  )*dt(j  )*dph(k+1)
         dv_mp=st(j-1)*dt(j-1)*dph(k+1)
         dv_pm=st(j  )*dt(j  )*dph(k  )
         dv_mm=st(j-1)*dt(j-1)*dph(k  )
         dv_i=sth_i(j)*dth_i(j)*dp_i(k)
         avjtbr=quarter*dv_i*( dv_pp*avjt_pp*avbr_pp &
                              +dv_mp*avjt_mp*avbr_mp &
                              +dv_pm*avjt_pm*avbr_pm &
                              +dv_mm*avjt_mm*avbr_mm)
        jxb%p(i,j,k)=avjrbt-avjtbr
      enddo
!
end subroutine
!#######################################################################
subroutine jcrossb_old (fj,b,jxb)
!
!-----------------------------------------------------------------------
!
! ****** Compute (J x B).
!
! ****** This version uses the "old" averaging.
!
!-----------------------------------------------------------------------
!
! ****** On input, FJ contains the current density and B contains
! ****** the magnetic field.
!
! ****** On return, the structure JXB contains (J x B).
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: fj
      type(bvec) :: b
      type(vvec) :: jxb
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: av_jr,av_jt,av_jp
!
!-----------------------------------------------------------------------
!
! ****** Zero out the J x B array.
!
      call zero_vvec (jxb)
!
! ****** R component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        av_bt=AVGP (b%t ,i  ,j  ,k  )
        av_bp=AVGT (b%p ,i  ,j  ,k  )
        av_jt=AVGRT(fj%t,i+1,j  ,k  )
        av_jp=AVGRP(fj%p,i+1,j  ,k  )
        jxb%r(i,j,k)=(av_jt*av_bp-av_jp*av_bt)
      enddo
!
! ****** Theta component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        av_br=AVGP (b%r ,i  ,j  ,k  )
        av_bp=AVGR (b%p ,i  ,j  ,k  )
        av_jr=AVGRT(fj%r,i  ,j+1,k  )
        av_jp=AVGTP(fj%p,i  ,j+1,k  )
        jxb%t(i,j,k)=(av_jp*av_br-av_jr*av_bp)
      enddo
!
! ****** Phi component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        av_br=AVGT (b%r ,i  ,j  ,k  )
        av_bt=AVGR (b%t ,i  ,j  ,k  )
        av_jr=AVGRP(fj%r,i  ,j  ,k+1)
        av_jt=AVGTP(fj%t,i  ,j  ,k+1)
        jxb%p(i,j,k)=(av_jr*av_bt-av_jt*av_br)
      enddo
!
end subroutine
!#######################################################################
subroutine getvdgv_old (vp,vdgv)
!
!-----------------------------------------------------------------------
!
! ****** Set:
! ******
! ******   VDGV =  V-dot-grad-V
! ******
! ****** where V is the velocity from the VP structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vp,vdgv
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avvr,avvt,avvp,avvvt,avvvp,avvvr,cadvr,cadvt,cadvp, &
      dvrdrp,dvrdrm,dvrdtp,dvrdtm,dvrdpp,dvrdpm,dvtdrp,dvtdrm,dvtdtp, &
      dvtdtm,dvtdpp,dvtdpm,dvpdrp,dvpdrm,dvpdtp,dvpdtm,dvpdpp,dvpdpm
!
!-----------------------------------------------------------------------
!
! ****** Zero out the VDGV array.
!
      call zero_vvec (vdgv)
!
!-----------------------------------------------------------------------
! ****** R component.
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        avvr =AVG  (v%r ,i  ,j  ,k  )
        avvt =AVGRT(v%t ,i+1,j  ,k  )
        avvp =AVGRP(v%p ,i+1,j  ,k  )
        avvvt=AVGRT(vp%t,i+1,j  ,k  )
        avvvp=AVGRP(vp%p,i+1,j  ,k  )
        cadvr=sign(upwind_v,avvr)
        cadvt=sign(upwind_v,avvt)
        cadvp=sign(upwind_v,avvp)
        dvrdrp=(vp%r(i+1,j,k)-vp%r(i  ,j,k))*drh_i(i+1)
        dvrdrm=(vp%r(i  ,j,k)-vp%r(i-1,j,k))*drh_i(i  )
        dvrdtp=(vp%r(i,j+1,k)-vp%r(i,j  ,k))*(r_i(i)*dt_i(j  ))
        dvrdtm=(vp%r(i,j  ,k)-vp%r(i,j-1,k))*(r_i(i)*dt_i(j-1))
        dvrdpp=(vp%r(i,j,k+1)-vp%r(i,j,k  ))* &
        (dp_mult*dp_i(k  )*r_i(i)*sth_i(j))
        dvrdpm=(vp%r(i,j,k  )-vp%r(i,j,k-1))* &
        (dp_mult*dp_i(k-1)*r_i(i)*sth_i(j))
        vdgv%r(i,j,k)= avvr*ADVCT(dvrdrp,dvrdrm,cadvr) &
                      +avvt*ADVCT(dvrdtp,dvrdtm,cadvt) &
                      +avvp*ADVCT(dvrdpp,dvrdpm,cadvp) &
                      -(avvt*avvvt+avvp*avvvp)*r_i(i)
      enddo
!
!-----------------------------------------------------------------------
! ****** Theta component.
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        avvr =AVGRT(v%r ,i  ,j+1,k)
        avvt =AVG  (v%t ,i  ,j  ,k)
        avvp =AVGTP(v%p ,i  ,j+1,k)
        avvvr=AVGRT(vp%r,i  ,j+1,k)
        avvvp=AVGTP(vp%p,i  ,j+1,k)
        cadvr=sign(upwind_v,avvr)
        cadvt=sign(upwind_v,avvt)
        cadvp=sign(upwind_v,avvp)
        dvtdrp=(vp%t(i+1,j,k)-vp%t(i  ,j,k))*dr_i(i  )
        dvtdrm=(vp%t(i  ,j,k)-vp%t(i-1,j,k))*dr_i(i-1)
        dvtdtp=(vp%t(i,j+1,k)-vp%t(i,j  ,k))*(rh_i(i)*dth_i(j+1))
        dvtdtm=(vp%t(i,j  ,k)-vp%t(i,j-1,k))*(rh_i(i)*dth_i(j  ))
        dvtdpp=(vp%t(i,j,k+1)-vp%t(i,j,k  ))* &
        (dp_mult*dp_i(k  )*rh_i(i)*st_i(j))
        dvtdpm=(vp%t(i,j,k  )-vp%t(i,j,k-1))* &
        (dp_mult*dp_i(k-1)*rh_i(i)*st_i(j))
        vdgv%t(i,j,k)= avvr*ADVCT(dvtdrp,dvtdrm,cadvr) &
                      +avvt*ADVCT(dvtdtp,dvtdtm,cadvt) &
                      +avvp*ADVCT(dvtdpp,dvtdpm,cadvp) &
                      +(avvt*avvvr-ct(j)*avvp*avvvp*st_i(j))*rh_i(i)
      enddo
!
!-----------------------------------------------------------------------
! ****** Phi component.
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        avvr =AVGRP(v%r ,i  ,j  ,k+1)
        avvt =AVGTP(v%t ,i  ,j  ,k+1)
        avvp =AVG  (v%p ,i  ,j  ,k)
        avvvr=AVGRP(vp%r,i  ,j  ,k+1)
        avvvt=AVGTP(vp%t,i  ,j  ,k+1)
        cadvr=sign(upwind_v,avvr)
        cadvt=sign(upwind_v,avvt)
        cadvp=sign(upwind_v,avvp)
        dvpdrp=(vp%p(i+1,j,k)-vp%p(i  ,j,k))*dr_i(i  )
        dvpdrm=(vp%p(i  ,j,k)-vp%p(i-1,j,k))*dr_i(i-1)
        dvpdtp=(vp%p(i,j+1,k)-vp%p(i,j  ,k))*(rh_i(i)*dt_i(j  ))
        dvpdtm=(vp%p(i,j  ,k)-vp%p(i,j-1,k))*(rh_i(i)*dt_i(j-1))
        dvpdpp=(vp%p(i,j,k+1)-vp%p(i,j,k  ))* &
        (dp_mult*dph_i(k+1)*rh_i(i)*sth_i(j))
        dvpdpm=(vp%p(i,j,k  )-vp%p(i,j,k-1))* &
        (dp_mult*dph_i(k  )*rh_i(i)*sth_i(j))
        vdgv%p(i,j,k)= avvr*ADVCT(dvpdrp,dvpdrm,cadvr) &
                      +avvt*ADVCT(dvpdtp,dvpdtm,cadvt) &
                      +avvp*ADVCT(dvpdpp,dvpdpm,cadvp) &
                      +avvp*(avvvr+cth(j)*avvvt*sth_i(j))*rh_i(i)
      enddo
!
end subroutine
!#######################################################################
subroutine getvdgv_par (vp_par,vdgv_par)
!
!-----------------------------------------------------------------------
!
! ****** Set:
! ******
! ******   VDGV_PAR =  V-dot-grad-VP (parallel to B)
! ******
! ****** where V is the main parallel velocity in V_PAR,
! ****** and VP is the velocity from array VP_PAR.
!
!-----------------------------------------------------------------------
!
! ****** This is the equivalent of the GETVDGV_OLD routine for
! ****** parallel flow.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use vars
      use bhat_storage
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: vp_par
      real(r_typ), dimension(nr,nt,np) :: vdgv_par
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: cadvr,cadvt,cadvp
      real(r_typ) :: dvdrp,dvdrm,dvdtp,dvdtm,dvdpp,dvdpm
!
!-----------------------------------------------------------------------
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        vdgv_par(i,j,k)=0.
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        av_vr=vp_par(i,j,k)*bhat_r(i,j,k)
        av_vt=vp_par(i,j,k)*bhat_t(i,j,k)
        av_vp=vp_par(i,j,k)*bhat_p(i,j,k)
        cadvr=sign(upwind_v,av_vr)
        cadvt=sign(upwind_v,av_vt)
        cadvp=sign(upwind_v,av_vp)
        dvdrp=(vp_par(i+1,j,k)-vp_par(i  ,j,k))*dr_i(i  )
        dvdrm=(vp_par(i  ,j,k)-vp_par(i-1,j,k))*dr_i(i-1)
        dvdtp=(vp_par(i,j+1,k)-vp_par(i,j  ,k)) &
              *(rh_i(i)*dt_i(j  ))
        dvdtm=(vp_par(i,j  ,k)-vp_par(i,j-1,k)) &
              *(rh_i(i)*dt_i(j-1))
        dvdpp=(vp_par(i,j,k+1)-vp_par(i,j,k  )) &
              *(dp_mult*dp_i(k  )*rh_i(i)*sth_i(j))
        dvdpm=(vp_par(i,j,k  )-vp_par(i,j,k-1)) &
              *(dp_mult*dp_i(k-1)*rh_i(i)*sth_i(j))
        vdgv_par(i,j,k)= av_vr*ADVCT(dvdrp,dvdrm,cadvr) &
                        +av_vt*ADVCT(dvdtp,dvdtm,cadvt) &
                        +av_vp*ADVCT(dvdpp,dvdpm,cadvp)
      enddo
!
end subroutine
!#######################################################################
subroutine getvdgv (vp,vdgv)
!
!-----------------------------------------------------------------------
!
! ****** Set:
! ******
! ******   VDGV =  V-dot-grad-V
! ******
! ****** where V is the velocity from the VP structure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use vars
      use seam_r_interface
      use seam_t_interface
      use seam_p_interface
      use seam_rt_interface
      use seam_rp_interface
      use seam_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vp,vdgv
!
!-----------------------------------------------------------------------
!
      type(vvec) :: m
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), allocatable :: mr_av
      real(r_typ), dimension(:,:,:), allocatable :: mt_av
      real(r_typ), dimension(:,:,:), allocatable :: mp_av
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avrho
      real(r_typ) :: vrp,vrm,vtp,vtm,vpp,vpm
      real(r_typ) :: crp,crm,ctp,ctm,cpp,cpm
      real(r_typ) :: mr0,mrp,mrm,mt0,mtp,mtm,mp0,mpp,mpm
!
!-----------------------------------------------------------------------
!
! ****** Allocate the temporary vectors.
!
      call alloc_vvec (m)
!
! ****** Zero out the VDGV array.
!
      vdgv%r=0.
      vdgv%t=0.
      vdgv%p=0.
!
! ****** Get the momentum from the velocity.
!
      do k=1,np
        do j=1,nt
          do i=1,nrm1
            avrho=AVGR(rho,i+1,j,k)
            m%r(i,j,k)=avrho*vp%r(i,j,k)
          enddo
        enddo
      enddo
!
      do k=1,np
        do j=1,ntm1
          do i=1,nr
            avrho=AVGT(rho,i,j+1,k)
            m%t(i,j,k)=avrho*vp%t(i,j,k)
          enddo
        enddo
      enddo
!
      do k=1,npm1
        do j=1,nt
          do i=1,nr
            avrho=AVGP(rho,i,j,k+1)
            m%p(i,j,k)=avrho*vp%p(i,j,k)
          enddo
        enddo
      enddo
!
      call seam_r (m%r)
      call seam_t (m%t)
      call seam_p (m%p)
!
!-----------------------------------------------------------------------
! ****** R component.
!-----------------------------------------------------------------------
!
! ****** Get the theta and phi components of the momentum averaged
! ****** onto the vr mesh.
!
      allocate (mt_av(nrm,nt,np))
      allocate (mp_av(nrm,nt,np))
!
      mt_av=0.
      mp_av=0.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm-1
            mt_av(i,j,k)=AVGRT(m%t,i+1,j,k)
            mp_av(i,j,k)=AVGRP(m%p,i+1,j,k)
          enddo
        enddo
      enddo
!
      call seam_rt (mt_av)
      call seam_rp (mp_av)
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm-1
!
            vrp=AVGR(vp%r,i+1,j  ,k  )
            vrm=AVGR(vp%r,i  ,j  ,k  )
            crp=sign(upwind_v,vrp)
            crm=sign(upwind_v,vrm)
            mr0=m%r(i  ,j,k)
            mrp=m%r(i+1,j,k)
            mrm=m%r(i-1,j,k)
!
            vtp=AVGR(vp%t,i+1,j  ,k  )
            vtm=AVGR(vp%t,i+1,j-1,k  )
            ctp=sign(upwind_v,vtp)
            ctm=sign(upwind_v,vtm)
            mt0=m%r(i,j  ,k)
            mtp=m%r(i,j+1,k)-dt(j  )*mt_av(i,j+1,k)
            mtm=m%r(i,j-1,k)+dt(j-1)*mt_av(i,j-1,k)
!
            vpp=AVGR(vp%p,i+1,j  ,k  )
            vpm=AVGR(vp%p,i+1,j  ,k-1)
            cpp=sign(upwind_v,vpp)
            cpm=sign(upwind_v,vpm)
            mp0=m%r(i,j  ,k)
            mpp=m%r(i,j,k+1)-dp(k  )*sth(j)*mp_av(i,j,k+1)
            mpm=m%r(i,j,k-1)+dp(k-1)*sth(j)*mp_av(i,j,k-1)
!
            vdgv%r(i,j,k)= ( vrp*fl_fach(i+1)*rh(i+1)**2 &
                                *ADVCT(mrp,mr0,crp) &
                            -vrm*fl_fach(i  )*rh(i  )**2 &
                                *ADVCT(mr0,mrm,crm) &
                           )*fl_fac_i(i)*r_i(i)**2*dr_i(i) &
                          +( vtp*st(j  )*ADVCT(mtp,mt0,ctp) &
                            -vtm*st(j-1)*ADVCT(mt0,mtm,ctm) &
                           )*r_i(i)*sth_i(j)*dth_i(j) &
                          +( vpp*ADVCT(mpp,mp0,cpp) &
                            -vpm*ADVCT(mp0,mpm,cpm) &
                           )*r_i(i)*sth_i(j)*dp_mult*dph_i(k)
!
          enddo
        enddo
      enddo
!
      deallocate (mt_av)
      deallocate (mp_av)
!
!-----------------------------------------------------------------------
! ****** Theta component.
!-----------------------------------------------------------------------
!
! ****** Get the r and phi components of the momentum averaged
! ****** onto the vt mesh.
!
      allocate (mr_av(nr,ntm,np))
      allocate (mp_av(nr,ntm,np))
!
      mr_av=0.
      mp_av=0.
!
      do k=2,npm1
        do j=2,ntm-1
          do i=2,nrm1
            mr_av(i,j,k)=AVGRT(m%r,i,j+1,k)
            mp_av(i,j,k)=AVGTP(m%p,i,j+1,k)
          enddo
        enddo
      enddo
!
      call seam_rt (mr_av)
      call seam_tp (mp_av)
!
      do k=2,npm1
        do j=2,ntm-1
          do i=2,nrm1
!
            vrp=AVGT(vp%r,i  ,j+1,k  )
            vrm=AVGT(vp%r,i-1,j+1,k  )
            crp=sign(upwind_v,vrp)
            crm=sign(upwind_v,vrm)
            mr0=m%t(i  ,j,k)
            mrp=m%t(i+1,j,k)
            mrm=m%t(i-1,j,k)
!
            vtp=AVGT(vp%t,i  ,j+1,k  )
            vtm=AVGT(vp%t,i  ,j  ,k  )
            ctp=sign(upwind_v,vtp)
            ctm=sign(upwind_v,vtm)
            mt0=m%t(i,j  ,k)
            mtp=m%t(i,j+1,k)+dth(j+1)*mr_av(i,j+1,k)
            mtm=m%t(i,j-1,k)-dth(j  )*mr_av(i,j-1,k)
!
            vpp=AVGT(vp%p,i  ,j+1,k  )
            vpm=AVGT(vp%p,i  ,j+1,k-1)
            cpp=sign(upwind_v,vpp)
            cpm=sign(upwind_v,vpm)
            mp0=m%t(i,j,k  )
            mpp=m%t(i,j,k+1)-dp(k  )*ct(j)*mp_av(i,j,k+1)
            mpm=m%t(i,j,k-1)+dp(k-1)*ct(j)*mp_av(i,j,k-1)
!
            vdgv%t(i,j,k)= ( vrp*fl_fac(i  )*r(i  )**2 &
                               *ADVCT(mrp,mr0,crp) &
                            -vrm*fl_fac(i-1)*r(i-1)**2 &
                               *ADVCT(mr0,mrm,crm) &
                           )*fl_fach_i(i)*rh_i(i)**2*drh_i(i) &
                          +( vtp*sth(j+1)*ADVCT(mtp,mt0,ctp) &
                            -vtm*sth(j  )*ADVCT(mt0,mtm,ctm) &
                           )*rh_i(i)*st_i(j)*dt_i(j) &
                          +( vpp*ADVCT(mpp,mp0,cpp) &
                            -vpm*ADVCT(mp0,mpm,cpm) &
                           )*rh_i(i)*st_i(j)*dp_mult*dph_i(k)
!
          enddo
        enddo
      enddo
!
      deallocate (mr_av)
      deallocate (mp_av)
!
!-----------------------------------------------------------------------
! ****** Phi component.
!-----------------------------------------------------------------------
!
! ****** Get the r and theta components of the momentum averaged
! ****** onto the vp mesh.
!
      allocate (mr_av(nr,nt,npm))
      allocate (mt_av(nr,nt,npm))
!
      mr_av=0.
      mt_av=0.
!
      do k=2,npm-1
        do j=2,ntm1
          do i=2,nrm1
            mr_av(i,j,k)=AVGRP(m%r,i,j,k+1)
            mt_av(i,j,k)=AVGTP(m%t,i,j,k+1)
          enddo
        enddo
      enddo
!
      call seam_rp (mr_av)
      call seam_tp (mt_av)
!
      do k=2,npm-1
        do j=2,ntm1
          do i=2,nrm1
!
            vrp=AVGP(vp%r,i  ,j  ,k+1)
            vrm=AVGP(vp%r,i-1,j  ,k+1)
            crp=sign(upwind_v,vrp)
            crm=sign(upwind_v,vrm)
            mr0=m%p(i  ,j,k)
            mrp=m%p(i+1,j,k)
            mrm=m%p(i-1,j,k)
!
            vtp=AVGP(vp%t,i  ,j  ,k+1)
            vtm=AVGP(vp%t,i  ,j-1,k+1)
            ctp=sign(upwind_v,vtp)
            ctm=sign(upwind_v,vtm)
            mt0=m%p(i,j  ,k)
            mtp=m%p(i,j+1,k)
            mtm=m%p(i,j-1,k)
!
            vpp=AVGP(vp%p,i  ,j  ,k+1)
            vpm=AVGP(vp%p,i  ,j  ,k  )
            cpp=sign(upwind_v,vpp)
            cpm=sign(upwind_v,vpm)
            mp0=m%p(i,j,k  )
            mpp=m%p(i,j,k+1)+dph(k+1)*( sth(j)*mr_av(i,j,k+1) &
                                       +cth(j)*mt_av(i,j,k+1))
            mpm=m%p(i,j,k-1)-dph(k  )*( sth(j)*mr_av(i,j,k-1) &
                                       +cth(j)*mt_av(i,j,k-1))
!
            vdgv%p(i,j,k)= ( vrp*fl_fac(i  )*r(i  )**2 &
                              *ADVCT(mrp,mr0,crp) &
                            -vrm*fl_fac(i-1)*r(i-1)**2 &
                              *ADVCT(mr0,mrm,crm) &
                           )*fl_fach_i(i)*rh_i(i)**2*drh_i(i) &
                          +( vtp*st(j  )*ADVCT(mtp,mt0,ctp) &
                            -vtm*st(j-1)*ADVCT(mt0,mtm,ctm) &
                           )*rh_i(i)*sth_i(j)*dth_i(j) &
                          +( vpp*ADVCT(mpp,mp0,cpp) &
                            -vpm*ADVCT(mp0,mpm,cpm) &
                           )*rh_i(i)*sth_i(j)*dp_mult*dp_i(k)
!
          enddo
        enddo
      enddo
!
      deallocate (mr_av)
      deallocate (mt_av)
!
! ****** Add in the [-v*div(rho*v)] term.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm-1
            mrp=AVGR(m%r,i+1,j  ,k  )
            mrm=AVGR(m%r,i  ,j  ,k  )
            mtp=AVGR(m%t,i+1,j  ,k  )
            mtm=AVGR(m%t,i+1,j-1,k  )
            mpp=AVGR(m%p,i+1,j  ,k  )
            mpm=AVGR(m%p,i+1,j  ,k-1)
            vdgv%r(i,j,k)= vdgv%r(i,j,k) &
                          -vp%r(i,j,k)*( ( fl_fach(i+1)*rh(i+1)**2*mrp &
                                          -fl_fach(i  )*rh(i  )**2*mrm &
                                       )*fl_fac_i(i)*r_i(i)**2*dr_i(i) &
                                        +( st(j  )*mtp &
                                          -st(j-1)*mtm &
                                         )*r_i(i)*sth_i(j)*dth_i(j) &
                                        +( mpp &
                                          -mpm &
                                     )*r_i(i)*sth_i(j)*dp_mult*dph_i(k) &
                                       )
          enddo
        enddo
      enddo
!
      do k=2,npm1
        do j=2,ntm-1
          do i=2,nrm1
            mrp=AVGT(m%r,i  ,j+1,k  )
            mrm=AVGT(m%r,i-1,j+1,k  )
            mtp=AVGT(m%t,i  ,j+1,k  )
            mtm=AVGT(m%t,i  ,j  ,k  )
            mpp=AVGT(m%p,i  ,j+1,k  )
            mpm=AVGT(m%p,i  ,j+1,k-1)
            vdgv%t(i,j,k)= vdgv%t(i,j,k) &
                          -vp%t(i,j,k)*( ( fl_fac(i  )*r(i  )**2*mrp &
                                          -fl_fac(i-1)*r(i-1)**2*mrm &
                                      )*fl_fach_i(i)*rh_i(i)**2*drh_i(i) &
                                        +( sth(j+1)*mtp &
                                          -sth(j  )*mtm &
                                         )*rh_i(i)*st_i(j)*dt_i(j) &
                                        +( mpp &
                                          -mpm &
                                      )*rh_i(i)*st_i(j)*dp_mult*dph_i(k) &
                                       )
          enddo
        enddo
      enddo
!
      do k=2,npm-1
        do j=2,ntm1
          do i=2,nrm1
            mrp=AVGP(m%r,i  ,j  ,k+1)
            mrm=AVGP(m%r,i-1,j  ,k+1)
            mtp=AVGP(m%t,i  ,j  ,k+1)
            mtm=AVGP(m%t,i  ,j-1,k+1)
            mpp=AVGP(m%p,i  ,j  ,k+1)
            mpm=AVGP(m%p,i  ,j  ,k  )
            vdgv%p(i,j,k)= vdgv%p(i,j,k) &
                          -vp%p(i,j,k)*( ( fl_fac(i  )*r(i  )**2*mrp &
                                          -fl_fac(i-1)*r(i-1)**2*mrm &
                                    )*fl_fach_i(i)*rh_i(i)**2*drh_i(i) &
                                        +( st(j  )*mtp &
                                          -st(j-1)*mtm &
                                         )*rh_i(i)*sth_i(j)*dth_i(j) &
                                        +( mpp &
                                          -mpm &
                                     )*rh_i(i)*sth_i(j)*dp_mult*dp_i(k) &
                                       )
          enddo
        enddo
      enddo
!
! ****** Divide by the density.
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm-1
            avrho=AVGR(rho,i+1,j,k)
            vdgv%r(i,j,k)=vdgv%r(i,j,k)/avrho
          enddo
        enddo
      enddo
!
      do k=2,npm1
        do j=2,ntm-1
          do i=2,nrm1
            avrho=AVGT(rho,i,j+1,k)
            vdgv%t(i,j,k)=vdgv%t(i,j,k)/avrho
          enddo
        enddo
      enddo
!
      do k=2,npm-1
        do j=2,ntm1
          do i=2,nrm1
            avrho=AVGP(rho,i,j,k+1)
            vdgv%p(i,j,k)=vdgv%p(i,j,k)/avrho
          enddo
        enddo
      enddo
!
! ****** Deallocate the temporary vectors.
!
      call dealloc_vvec (m)
!
end subroutine
!#######################################################################
subroutine char_bc_0
!
!-----------------------------------------------------------------------
!
! ****** Get the boundary values at r=R0 using the characteristics.
! ****** This version solves the "parallel characteristics".
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use characteristics
      use vars
      use mpidefs
      use seam_tp_2d_interface
      use emerging_flux_params
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Temporary storage for BC arrays.
!
      real(r_typ), dimension(nt,np) :: brhat,bthat,bphat,vee
      real(r_typ), dimension(nt,np) :: vpar_t,vpar_p,cs,dir,dirvee_cs
      logical, dimension(nt,np) :: mask
      real(r_typ), dimension(2,ntm1,npm1) :: vee_mm
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: br,bt,bp
      real(r_typ) :: brh,bth,bph
      real(r_typ) :: bsq,bmag,bmag_i
      real(r_typ) :: fac
      real(r_typ) :: ps,rhos
      real(r_typ) :: qp,qm
      real(r_typ) :: dvdr,dvdt,dvdp
      real(r_typ) :: dpdr,dpdt,dpdp
      real(r_typ) :: dvds,dpds,vr,vt,vp,dveedt,dirvee_cs_max
!
      integer :: ierr
      integer :: ierr2
      integer, save :: iseq=0
      character(3) :: seq
      character(16) :: fname
      logical, parameter :: debug=.false.
      logical, save :: first=.true.,ss=.true.
!
!-----------------------------------------------------------------------
!
      ierr=0
      ierr2=0
!
! ****** The boundary velocity is determined only on processors
! ****** that include the lower radial boundary.
!
      if (rb0) then
!$acc enter data create(brhat,bthat,bphat,vpar_t,vpar_p,vee_mm, &
!$acc                   vee,cs,dir,dirvee_cs,mask)
!
      do concurrent (k=1:np, j=1:nt)
        vpar_t(j,k)=0.
        vpar_p(j,k)=0.
        vee(j,k)=0.
        brhat(j,k)=0.
        bthat(j,k)=0.
        bphat(j,k)=0.
        cs(j,k)=0.
        dir(j,k)=0.
        dirvee_cs(j,k)=0.
        mask(j,k)=.false.
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm1)
        mask(j,k)=.true.
      enddo
!
      do concurrent (k=1:npm1, j=1:ntm1, i=1:2)
        vee_mm(i,j,k)=0.
      enddo
!
      if (debug.and.iamp0) then
        iseq=iseq+1
        write (seq,'(i3.3)') iseq
        fname='char'//seq//'.dat'
        call ffopen (IO_TEMP,trim(fname),'rw',ierr2)
      end if
      if (debug) call check_error_on_p0 (ierr2)
!
      if (debug.and.iamp0) then
        write (IO_TEMP,'(100(a,a))') &
                              'th', &
                     achar(9),'V', &
                     achar(9),'br', &
                     achar(9),'bt', &
                     achar(9),'brhat', &
                     achar(9),'bthat', &
                     achar(9),'p', &
                     achar(9),'rho', &
                     achar(9),'c', &
                     achar(9),'dV/ds', &
                     achar(9),'dp/ds', &
                     achar(9),'dV/dt'
      end if
!
! ****** Get the parallel velocity.
!
      do concurrent (k=1:npm1, j=1:ntm1)
        br=AVGR  (b%r,2,j  ,k  )
        bt=AVGT  (b%t,1  ,j+1,k  )
        bp=AVGP  (b%p,1  ,j  ,k+1)
        vr=AVGTP2(vb%r0%r,j+1,k+1)
        vt=AVGP2 (vb%r0%t,j  ,k+1)
        vp=AVGT2 (vb%r0%p,j+1,k  )
        bsq=br**2+bt**2+bp**2
        bmag=sqrt(bsq)
        if (bmag.eq.0.) then
          brh=one
          bth=0.
          bph=0.
        else
          bmag_i=one/bmag
          brh=br*bmag_i
          bth=bt*bmag_i
          bph=bp*bmag_i
        end if
        vee_mm(1,j,k)=vr*brh+vt*bth+vp*bph
!
        i=2
        br=AVGR  (b%r,i+1,j  ,k  )
        bt=AVGT  (b%t,i  ,j+1,k  )
        bp=AVGP  (b%p,i  ,j  ,k+1)
        vr=AVGTP (v%r,i  ,j+1,k+1)
        vt=AVGRP (v%t,i+1,j  ,k+1)
        vp=AVGRT (v%p,i+1,j+1,k  )
        bsq=br**2+bt**2+bp**2
        bmag=sqrt(bsq)
        if (bmag.eq.0.) then
          brh=one
          bth=0.
          bph=0.
        else
          bmag_i=one/bmag
          brh=br*bmag_i
          bth=bt*bmag_i
          bph=bp*bmag_i
        end if
        vee_mm(i,j,k)=vr*brh+vt*bth+vp*bph
      enddo
!
! ****** Loop over all theta and phi points.
!
      do concurrent (k=2:npm1, j=2:ntm1)
!
! ****** Get the direction of B.
!
        br=AVGRTP(b%r,2,j,k)
        bt=AVGP  (b%t,1,j,k)
        bp=AVGT  (b%p,1,j,k)
        bmag=sqrt(br**2+bt**2+bp**2)
        if (bmag.eq.0.) then
          brhat(j,k)=one
          bthat(j,k)=0.
          bphat(j,k)=0.
        else
          bmag_i=one/bmag
          brhat(j,k)=br*bmag_i
          bthat(j,k)=bt*bmag_i
          bphat(j,k)=bp*bmag_i
        end if
!
! ****** Project along B in the inward radial direction.
!
        dir(j,k)=sign(one,brhat(j,k))
!
! ****** Initialize the variables.
!
        ps=AVGR(pres,2,j,k)
        rhos=AVGR(rho,2,j,k)
        cs(j,k)=sqrt(gamma*ps/rhos)
!
        vr=AVG2 (vb%r0%r,j,k)
        vt=AVGT2(vb%r0%t,j,k)
        vp=AVGP2(vb%r0%p,j,k)
!
        vee(j,k)=brhat(j,k)*vr+bthat(j,k)*vt+bphat(j,k)*vp
!
! ****** Get derivatives for projecting along the characteristic.
!
        qp=AVG(pres,2,j,k)
        qm=AVG(pres,1,j,k)
        dpdr=(qp-qm)*drh_i(2)
        qp=AVGRT(pres,2,j+1,k)
        qm=AVGRT(pres,2,j  ,k)
        dpdt=(qp-qm)*dth_i(j)*r_i(1)
        qp=AVGRP(pres,2,j,k+1)
        qm=AVGRP(pres,2,j,k  )
        dpdp=(qp-qm)*dp_mult*dph_i(k)*r_i(1)*sth_i(j)
!
        dpds=brhat(j,k)*dpdr+bthat(j,k)*dpdt+bphat(j,k)*dpdp
!
! ****** Get dV/ds.
!
        qp=AVGTP (vee_mm,2,j  ,k  )
        qm=AVGTP (vee_mm,1,j  ,k  )
        dvdr=(qp-qm)*drh_i(2)
!
        qp=AVGP  (vee_mm,1,j  ,k  )
        qm=AVGP  (vee_mm,1,j-1,k  )
        dvdt=(qp-qm)*dth_i(j)*r_i(1)
!
        qp=AVGT  (vee_mm,1,j  ,k  )
        qm=AVGT  (vee_mm,1,j  ,k-1)
        dvdp=(qp-qm)*dp_mult*dph_i(k)*r_i(1)*sth_i(j)
!
        dvds=(brhat(j,k)*dvdr+bthat(j,k)*dvdt+bphat(j,k)*dvdp)
!
!cc          dveedt=-dpds/rhos
!cc     &           -vee(j,k)*dvds
!cc     &           -g0*brhat(j,k)*r_i(1)**2
!
!cc *JL* Use characterisic formulation instead of momentum
!cc      equation above.
!
        fac=(dir(j,k)*vee(j,k)-cs(j,k))
        dveedt=fac*dir(j,k)*dpds/(rhos*cs(j,k)) &
               -fac*dvds &
               -grav(1)*dir(j,k)*brhat(j,k)*r_true_i(1)**2 &
           +2.*vee(j,k)*dir(j,k)*cs(j,k)/r(1)
!
!          if (debug.and.iamp0.and.k.eq.2) then
!            write (IO_TEMP,'(100(1pe12.5,a))')
!     &                            th(j),
!     &                   achar(9),vee(j,k),
!     &                   achar(9),br,
!     &                   achar(9),bt,
!     &                   achar(9),brhat(j,k),
!     &                   achar(9),bthat(j,k),
!     &                   achar(9),ps,
!     &                   achar(9),rhos,
!     &                   achar(9),cs(j,k),
!     &                   achar(9),dvds,
!     &                   achar(9),dpds,
!     &                   achar(9),dveedt
!          end if
!
!cc *JL*          vee(j,k)=vee(j,k)+dveedt*dtime
!cc *JL* Need dir with use of characteristic equation above.
!
        vee(j,k)=vee(j,k)+dir(j,k)*dveedt*dtime
!
!cc          if (eflux%active) then
!cc            if (eflux_factor*eflux_vr(j,k).gt.eflux%vr_max)
!cc     &        vee(j,k)=0.
!cc          end if
!
! ****** When UBZERO=.true., set the inward flow to zero if
! ****** it is negative.
!
        if (ubzero.and.dir(j,k)*vee(j,k).lt.0.) then
          vee(j,k)=0.
        end if
!
      enddo
!
! ****** Check for supersonic inflow (outward flow from the surface).
! ****** If there is supersonic inflow, stop the code unless overridden.
!
      do concurrent (k=2:npm1, j=2:ntm1)
        dirvee_cs(j,k)=dir(j,k)*vee(j,k)/cs(j,k)
      enddo
!
      dirvee_cs_max = 0.
!$acc parallel loop collapse(2) default(present) &
!$acc               reduction(max:dirvee_cs_max)
!$omp parallel do collapse(2) default(shared) &
!$omp               reduction(max:dirvee_cs_max)
      do k=1,np
        do j=1,nt
          if (mask(j,k)) then
            dirvee_cs_max=MAX(dirvee_cs_max,dirvee_cs(j,k))
          endif
        enddo
      enddo
!$omp end parallel do
!
      if (dirvee_cs_max.ge.one) then
!
! ****** There was supersonic inflow, so write out locations.
!
        if (first) then
          call ffopen (IO_TEMP2,'ssinflow_p'//trim(iproc_str),'rw',ierr)
          first=.false.
        else
          call ffopen (IO_TEMP2,'ssinflow_p'//trim(iproc_str),'a',ierr)
        end if
!
!$acc parallel loop collapse(2) default(present) copy(ierr)
!$omp parallel do collapse(2) default(shared)
        do k=2,npm1
          do j=2,ntm1
            if (dir(j,k)*vee(j,k).ge.cs(j,k)) then
              if (ss) write (IO_TEMP2,*)
              if (expert_user_override%limit_supersonic_inflow) then
!
! ****** Override error and instead set v to the sound speed.
!
                if (ss) write (IO_TEMP2,*) '### WARNING in CHAR_BC_0:'
                vee(j,k)=cs(j,k)*dir(j,k)
              else
                write (IO_TEMP2,*) '### ERROR in CHAR_BC_0:'
!$omp atomic write
!$acc atomic write
                ierr=1
              end if
              if (ss) then
                write (IO_TEMP2,*) '### Supersonic inflow at r=R0.'
                write (IO_TEMP2,*) 'NTIME  = ',ntime
                write (IO_TEMP2,*) 'TIME  = ',time
                write (IO_TEMP2,*) 'CS  = ',cs(j,k)
                write (IO_TEMP2,*) 'DIR*VEE = ',dir(j,k)*vee(j,k)
                write (IO_TEMP2,*) 'theta = ',th(j)
                write (IO_TEMP2,*) 'phi = ',ph(k)
                write (IO_TEMP2,*) 'This is the first instance and '// &
       'more occurences will not be reported.'
                ss=.false.
              end if
            end if
          enddo
        enddo
!$omp end parallel do
!
        close(IO_TEMP2)
      end if
!
      end if
!
! ****** Check whether to terminate the code.
! ****** The rb0 conditional is seperated here
! ****** because this check needs all ranks to call it.
!
      call check_error_on_any_proc (ierr)
!
! ****** The boundary velocity is determined only on processors
! ****** that include the lower radial boundary.
!
      if (rb0) then
!
! ****** Filter the parallel velocity.
!
        do i=1,nfiltub
          call filter_tp_hh (vee)
        enddo
!
! ****** If we are using the parallel flow model, save the BC
! ****** on the parallel velocity.
!
        if (freeze_b) then
          do concurrent (k=1:np, j=1:nt)
            vb%r0%par(j,k)=0.
          enddo
          do concurrent (k=2:npm1, j=2:ntm1)
            vb%r0%par(j,k)=vee(j,k)
          enddo
        end if
!
! ****** Set the BC velocity to be parallel to B.  This is done
! ****** even when using the parallel flow model because we still
! ****** set BCs on the vector velocity.
!
        do concurrent (k=2:npm1, j=2:ntm1)
          vb%r0%r(j,k)=vee(j,k)*brhat(j,k)
          vpar_t (j,k)=vee(j,k)*bthat(j,k)
          vpar_p (j,k)=vee(j,k)*bphat(j,k)
        enddo
!
! ****** Seam the vt and vp BC arrays.
!
        call seam_2d_tp (vpar_t,nt,np,.true.,.false.)
        call seam_2d_tp (vpar_p,nt,np,.false.,.true.)
!
! ****** Average the theta and phi components to the
! ****** appropriate mesh.
!
        do concurrent (k=2:npm1, j=2:ntm-1)
          vb%r0%t(j,k)=half*(vpar_t(j,k)+vpar_t(j+1,k))
        enddo
!
        do concurrent (k=2:npm-1, j=2:ntm1)
          vb%r0%p(j,k)=half*(vpar_p(j,k)+vpar_p(j,k+1))
        enddo
!
! ****** Seam the VB arrays.
!
        call set_pole_bc_vvec_tp (vb%r0%t,vb%r0%p)
        call set_pole_bc_scalar_tp_hh (vb%r0%r)
!
        call seam_2d_tp (vb%r0%r,nt,np,.true.,.true.)
        call seam_2d_tp (vb%r0%t,ntm,np,.true.,.true.)
        call seam_2d_tp (vb%r0%p,nt,npm,.true.,.true.)
!
        if (debug.and.iamp0) then
          close(IO_TEMP)
        end if
!
!$acc exit data delete(brhat,bthat,bphat,vpar_t,vpar_p,vee_mm, &
!$acc                  vee,cs,dir,dirvee_cs,mask)
      end if !rb0
!
end subroutine
!#######################################################################
subroutine char_bc_1
!
!-----------------------------------------------------------------------
!
! ****** Get the boundary values at r=R1 using the characteristics.
! ****** This version solves the "radial gas characteristics".
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use characteristics
      use vars
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: j,k
      real(r_typ) :: pb,ub,rhob
      real(r_typ) :: rs,rs_i,us,ps,rhos,cssq,cs
      real(r_typ) :: dudr,drhodr,dpdr
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** The boundary velocity is determined only on processors
! ****** that include the upper radial boundary.
!
      if (rb1) then
!
! ****** Initialize the result arrays.
!
      do concurrent (k=1:np, j=1:nt)
        cbc1_ub(j,k)=0.
        cbc1_rhob(j,k)=0.
        cbc1_pb(j,k)=0.
      enddo
!
! ****** Loop over all theta and phi points.
!
!$acc parallel loop collapse(2) default(present) copy(ierr)
!$omp parallel do collapse(2) default(shared)
      do k=2,npm1
        do j=2,ntm1
!
          rs=r_true(nrm1)
          rs_i=one/rs
          us=v%r(nrm1,j,k)
          ps=AVGR(pres,nr,j,k)
          rhos=AVGR(rho,nr,j,k)
!
          ub=us
          pb=ps
          rhob=rhos
!
          cssq=gamma*ps/rhos
          cs=sqrt(cssq)
!
! ****** Get the values of the variables at the boundary.
!
          dudr=(v%r(nrm1,j,k)-v%r(nrm2,j,k))*drh_i(nrm1)
          drhodr=(rho(nr,j,k)-rho(nrm1,j,k))*dr_i(nrm1)
          dpdr=(pres(nr,j,k)-pres(nrm1,j,k))*dr_i(nrm1)
!
          if (us.gt.cs) then
!
! ****** Supersonic outflow boundary.
!
            pb=ps-dtime*(us*dpdr+rhos*cssq*(dudr+two*us*rs_i))
            ub=us-dtime*(dpdr/rhos+dudr*us+grav(nrm1)*rs_i**2)
            rhob=rhos-dtime*drhodr*us+(pb-ps+dtime*dpdr*us)/cssq
!
          else if (us.gt.0.) then
!
! ****** Subsonic outflow boundary.
!
            pb=ps-dtime*(half*(dpdr+rhos*cs*dudr)*(us+cs) &
                  +rhos*cs*(half*grav(nrm1)*rs_i+us*cs)*rs_i)
            ub=us+(pb-ps)/(rhos*cs)
            rhob=rhos-dtime*drhodr*us+(pb-ps+dtime*dpdr*us)/cssq
!
          else if (us.gt.-cs) then
!
! ****** Subsonic inflow boundary.
!
            pb=ps-dtime*(half*(dpdr+rhos*cs*dudr)*(us+cs) &
                  +rhos*cs*(half*grav(nrm1)*rs_i+us*cs)*rs_i)
            ub=us+(pb-ps)/(rhos*cs)
            rhob=rhos+(pb-ps)/cssq
!
          else
!
! ****** Supersonic inflow: set IERR=1 and exit the (j,k) loops.
!
            write (*,*)
            write (*,*) '### ERROR in CHAR_BC_1:'
            write (*,*) '### Anomaly in characteristic BCs:'
            write (*,*) 'Supersonic inflow at the upper boundary.'
            write (*,*)
            write (*,*) 'NTIME = ',ntime
            write (*,*) 'TIME = ',time
            write (*,*) 'CS = ',cs
            write (*,*) 'US = ',us
            write (*,*) 'theta = ',th(j)
            write (*,*) 'phi = ',ph(k)
!$omp atomic write
!$acc atomic write
            ierr=1
!
          end if
!
! ****** Load the result arrays.
!
          cbc1_ub(j,k)=ub
          cbc1_rhob(j,k)=rhob
          cbc1_pb(j,k)=pb
!
        enddo
      enddo
!$omp end parallel do
!
      end if
!
! ****** Check whether to terminate the code.
! ****** This check needs all ranks to call it.
!
      call check_error_on_any_proc (ierr)
!
end subroutine
!#######################################################################
subroutine filter_tp_hh (f)
!
!-----------------------------------------------------------------------
!
! ****** Filter a 2D field defined on the (th,ph) mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: f
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: i16=.0625_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Temporary arrays.
!
      real(r_typ), dimension(nt,np) :: ff
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
!$acc enter data create(ff)
! ****** Seam the field.
!
      call seam_2d_tp (f,nt,np,.true.,.true.)
!
! ****** Apply the boundary conditions at the poles.
!
      call set_pole_bc_scalar_tp_hh (f)
!
! ****** Apply a "(1,2,1)/4" digital filter in theta and phi.
!
      do concurrent (k=1:np, j=1:nt)
        ff(j,k)=f(j,k)
      enddo
!
      do concurrent (k=2:npm1, j=2:ntm1)
        f(j,k)=i16*( (ff(j-1,k-1)+two*ff(j-1,k  )+ff(j-1,k+1)) &
                +two*(ff(j  ,k-1)+two*ff(j  ,k  )+ff(j  ,k+1)) &
                    +(ff(j+1,k-1)+two*ff(j+1,k  )+ff(j+1,k+1)))
      enddo
!
!$acc exit data delete(ff)
end subroutine
!#######################################################################
subroutine advrho
!
!-----------------------------------------------------------------------
!
! ****** Advance the mass density.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Temporary fields.
!
      real(r_typ), dimension(nr,nt,np) :: rhop,vdg,divv
      character(32) :: FNAME='DENSITY', RNAME='ADVRHO'
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVRHO)
!$acc enter data create(rhop,vdg,divv)
!
      if (advance_fcs) then
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          rhoold(i,j,k)=rho(i,j,k)
        enddo
      end if
!
! ****** Predictor step.
!
      if (pred_rho) then
!
        call divqv (upwind_rho,rho,v,vdg)
        call get_divv (v,divv)
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          vdg(i,j,k)=vdg(i,j,k)-rho(i,j,k)*divv(i,j,k)
!
          rhop(i,j,k)=rho(i,j,k) &
                  -dtime*( betapc_rho_flow*vdg(i,j,k) &
                          +betapc_rho_wave*rho(i,j,k)*divv(i,j,k))
        enddo
!
! ****** Set boundary conditions.
!
        call set_bc_rho (rhop,rho0v)
!
        call seam_scalar (rhop,nr,nt,np)
!
      else
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          rhop(i,j,k)=rho(i,j,k)
        enddo
!
      end if
!
! ****** Corrector step.
!
      call divqv (upwind_rho,rhop,v,vdg)
!
! ****** Advance the density.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        rho(i,j,k)=rho(i,j,k)-dtime*vdg(i,j,k)
      enddo
!
! ****** Limit the density (if desired).
!
      if (ifrholimit) then
        call floor_field_v (rho,rho_limit, &
          rho_limit_factor*rho_limit_tprof,nr,nt,np,FNAME,RNAME)
      end if
!
! ****** Check for negative density.
!
      if (ifcheck0rho) then
        call check_negative_field (rho,nr,nt,np,FNAME,RNAME)
      end if
!
! ****** Modify density to limit alfven speed.
!
      if (max_alfven_speed_rho_mod.gt.0.) then
        call limit_alfven_speed_rho_mod
      end if
!
! ****** Set boundary conditions and seam.
!
      call set_bc_rho (rho,rho0v)
!
      call seam_scalar (rho,nr,nt,np)
!
      if (pole_filter_rho) then
        call smooth_poles_scalars (rho)
      end if
!
!$acc exit data delete(rhop,vdg,divv)
      if (use_timer) call timer (TIME_ADVRHO)
!
end subroutine
!#######################################################################
subroutine limit_alfven_speed_rho_mod
!
!-----------------------------------------------------------------------
!
! ****** Routine to modify density to limit alfven speed.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use seam_interface
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: va,brav,btav,bpav,bsq,rho_added,rho_new
      real(r_typ) :: rho_added_tmp
!
!-----------------------------------------------------------------------
!
      rho_added=0.
!
! *** Check Alfven speed on internal points and modify rho accordingly.
!
!$acc parallel loop collapse(3) default(present) &
!$acc              reduction(+:rho_added) copy(rho_added)
!$omp parallel do collapse(3) default(shared) reduction(+:rho_added)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
!
! ****** Compute Alfven speed.
!
            brav=AVGTP(b%r,i,j,k)
            btav=AVGRP(b%t,i,j,k)
            bpav=AVGRT(b%p,i,j,k)
            bsq=brav**2+btav**2+bpav**2
            va=sqrt(bsq/rho(i,j,k))
!
            rho_added_tmp=0.
!
            if (va.gt.max_alfven_speed_rho_mod) then
!
! ****** Get new rho value.
!
              rho_new=rho(i,j,k)*(va**2)/ &
                                 (max_alfven_speed_rho_mod**2)
!
! ****** Add to running added-rho value.
!
              rho_added_tmp=rho_new-rho(i,j,k)
!
! ****** Set new rho value.
!
              rho(i,j,k)=rho_new
!
            end if
!
            rho_added=rho_added+rho_added_tmp
!
          enddo
        enddo
      enddo
!$omp end parallel do
!
! *** Get global sum of rho_added to check if rho was limited or not.
!
      call global_sum (rho_added)
!
! *** Print message to warning file.
!
      if (rho_added.gt.0) then
        if (iamp0) then
          write (13,*)
          write (13,*) '### WARNING: The density was ', &
                      ' modified by requested max alfven speed.'
          write (13,'(A,E23.3E3)') ' ### Total density added = ' &
                                                      ,rho_added
          write (13,'(A,I23)') ' ### NTIME               = ',ntime
          write (13,'(A,E23.3E3)') ' ### TIME                = ',time
        end if
!
! ****** Seam rho so all processors have new values.
!
        call seam_scalar (rho,nr,nt,np)
      end if
!
end subroutine
!#######################################################################
subroutine advt
!
!-----------------------------------------------------------------------
!
! *** Advance the temperature fields. Apply 2T coupling if needed.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Advance the electron temperature.
!
      call advte
!
! ****** Advance the proton+alpha temperature.
!
      if (advance_tp) then
!
        call advtp
!
! ****** Update te and tp based on the frictional heating.
!
        call solve_2t_coupling
!
      end if
!
      if (pole_filter_t) then
        call smooth_poles_scalars (temp_e)
        if (advance_tp) then
          call smooth_poles_scalars (temp_p)
        end if
      end if
!
end subroutine
!#######################################################################
subroutine advte
!
!-----------------------------------------------------------------------
!
! *** Advance the electron temperature.
!     This routine uses a first-order explicit advance with a
!     predictor-corrector for advection terms.
!     The thermal conduction (if selected)
!     is solved implicitly using the CG solver.
!
!     Basic equations:
!     (T**-T)/dt = A(T,T*) + R(T)
!
!     dV*(Tnew-T**)/dt = dV*D(T**)
!
!     A(T)     = Awave(T) + Aflow(T)
!       Awave(T) = T Div(v) terms
!       Aflow(T) = v Grad(T) terms
!
!     The `reaction' terms are heating (H) and radiative loss (Q)
!     R(T) = H - Q(T)
!
!     Given initial T0, the scheme is described as:
!     T*  = T0 + dt*(Bw*Awave(T0) + Bf*Aflow(T0))    (Predictor)
!     T** = T0 + dt*(A(T,T*) + R(T0))                (Corrector)
!
!     Collisionless thermal conduction,
!     [(1/(gamma-1))alpha kboltz Div(ne T (v-Om x r))bb ) ], given as in
!     [Hollweg. J. Geophys. Res., vol. 91, #A4, pgs. 4111-4125 (1986)],
!     modified for 3D by Roberto to go along field lines.
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use timing
      use seam_interface
      use radiative_loss_parameters
      use sts
      use heating_parameters, ONLY: use_chromo_heat, heat_chromo
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: qpar,tp_heat_fac
      character(32) :: FNAME='E-TEMPERATURE', RNAME='ADVTE'
!
!-----------------------------------------------------------------------
!
! *** Temporary fields.
!
      real(r_typ), dimension(nr,nt,np) :: Aflow,Awave,f_rho_t,div_tv
      real(r_typ), dimension(nr,nt,np) :: tempp,div_tvbb,div_v,div_vbb
      real(r_typ), dimension(nr,nt,np) :: Rreact
      real(r_typ), dimension(:,:,:), allocatable :: temp_e0k,qrad,dqrad
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVTE)
!
! *** Initialize/reset arrays to zero
!
!$acc enter data create(Aflow,Awave,f_rho_t,div_tv,tempp,div_tvbb, &
!$acc                   div_v,div_vbb,Rreact)
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        Aflow(i,j,k)=0.
        Awave(i,j,k)=0.
        f_rho_t(i,j,k)=0.
        tempp(i,j,k)=0.
        div_tv(i,j,k)=0.
        div_tvbb(i,j,k)=0.
        div_v(i,j,k)=0.
        div_vbb(i,j,k)=0.
        Rreact(i,j,k)=0.
      enddo
!
! ****** Set heating factor for two-temperature model.
!
      if (advance_tp) then
        tp_heat_fac=one-f_heating
      else
        tp_heat_fac=one
      end if
!
! *** Load boundary conditions for T (sets tr0v and tr1v).
!
      call load_bc_temp_e
!
! *** Save old temperature.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        temp_e0(i,j,k)=temp_e(i,j,k)
      enddo
!
! *** Compute Div(v) (used in both predictor and corrector)
!
      call get_divv (v,div_v)
!
      if (alpha_nocoll.ne.0..or.alpha_nocoll_p.ne.0.) then
        if (use_radial_nocoll) then
          call copy_vvec (v,vmoxrbb)
        else
          call v_minus_omegaxr_bb (vmoxrbb)
        end if
        call get_divv (vmoxrbb,div_vbb)
      end if
!
! **********************************************************************
! *** Predictor step for advective terms. ***
! *******************************************
!
      if (pred_t) then
!
! ***** Compute Div(T v)
!
        call divqv (upwind_t,temp_e,v,div_tv)
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
! ***** Compute v Grad(T)=Div(T v)-T Div(v), and store result in Aflow
          Aflow(i,j,k)=div_tv(i,j,k)-temp_e(i,j,k)*div_v(i,j,k)
! ***** Compute T Div(v) term and store result in Awave
          Awave(i,j,k)=(gamma-one)*temp_e(i,j,k)*div_v(i,j,k)
        enddo
!
! ***** Add collisonless regime terms if selected
!
        if (alpha_nocoll.ne.0.) then
!
          do concurrent (k=1:np, j=1:nt, i=1:nr)
!             Compute alpha f rho T (fpT):
            f_rho_t(i,j,k)=alpha_nocoll*prof_nocoll(i) &
                           *(rho(i,j,k)/he_rho)*temp_e(i,j,k)
          enddo
!
! ******* Compute Div(fpT vbb):
!
          call divqv (upwind_t,f_rho_t,vmoxrbb,div_tvbb)
!
! ******* Compute vbb Grad(fpT) term and add it to Aflow:
!
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            Aflow(i,j,k)=Aflow(i,j,k)+ &
                     (he_rho/(rho(i,j,k)*he_p_x))* &
                     (div_tvbb(i,j,k)-f_rho_t(i,j,k)*div_vbb(i,j,k))
          enddo
!
! ******* Compute (fpT) Div(vbb) term and add it to Awave:
!
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            Awave(i,j,k)=Awave(i,j,k)+(he_rho/(rho(i,j,k)*he_p_x))* &
                                      f_rho_t(i,j,k)*div_vbb(i,j,k)
          enddo
!
        end if
!
! ***** Advance to get predictor T*
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          tempp(i,j,k)=temp_e(i,j,k) &
                           -dtime*(betapc_t_flow*Aflow(i,j,k) &
                                  +betapc_t_wave*Awave(i,j,k))
        enddo
!
! ***** Set boundary conditions.
!
        call set_bc_temp_e (tempp,one)
!
        call seam_scalar (tempp,nr,nt,np)
!
      else
!
! ***** If no predictor step, just set T* to T:
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          tempp(i,j,k)=temp_e(i,j,k)
        enddo
!
      end if
!
! **********************************************************************
! *** Corrector step ***
! **********************
!
! ### Advection terms ###
!
! *** Compute Div(T* v)
!
      call divqv (upwind_t,tempp,v,div_tv)
!
! *** Store full advective terms (flow and wave) into array Aflow:
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        Aflow(i,j,k)=div_tv(i,j,k)+ &
                     (gamma-two)*temp_e(i,j,k)*div_v(i,j,k)
      enddo
!
! *** Add in collisonless thermal conduction term (if desired)
!
      if (alpha_nocoll.ne.0.) then
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
!         Compute alpha fnocoll rho T* (fpT*):
          f_rho_t(i,j,k)=alpha_nocoll*prof_nocoll(i) &
                         *(rho(i,j,k)/he_rho)*tempp(i,j,k)
        enddo
!
! ***** Compute Div(fpT* vbb)
!
        call divqv (upwind_t,f_rho_t,vmoxrbb,div_tvbb)
!
! ***** Add to advection array
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          Aflow(i,j,k)=Aflow(i,j,k)+ &
                       he_rho*div_tvbb(i,j,k)/(rho(i,j,k)*he_p_x)
        enddo
!
      end if
!
! ### Reaction terms ###
!
! *** Calculate the heating (H), stored in 'heat' array
!
      call heating
!
! *** Store [(gamma-1)/(c_alpha*ne)]*H into Rreact array
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        Rreact(i,j,k)=tp_heat_fac*heat(i,j,k)* &
                      (gamma-one)*he_rho/(he_p_x*rho(i,j,k))
      enddo
!
! ****** Add the chromospheric heating if needed.
! ****** (I do not want to store it in the heat array)
!
      if (use_chromo_heat) then
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          Rreact(i,j,k)=Rreact(i,j,k)+heat_chromo(i,j,k)* &
                        (gamma-one)*he_rho/(he_p_x*rho(i,j,k))
        enddo
      end if
!
! *** Calculate radiation loss and add to reaction terms array.
!
      if (radloss.gt.0) then
!
        allocate(temp_e0k(nr,nt,np))
        allocate(qrad(nr,nt,np))
!$acc enter data create(temp_e0k,qrad)
!
! ***** Set pre-factor for radiation loss.
!
        qpar=radloss*(gamma-one)*he_np/(he_rho*he_p_x*fn_qrad)
!
! ***** Get initial temperature in Kelvin.
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          temp_e0k(i,j,k)=temp_e0(i,j,k)*fn_t
        enddo
!
! ***** Get radiative loss.
!
        call get_qrad (qrad,temp_e0k,nr*nt*np)
!
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          Rreact(i,j,k)=Rreact(i,j,k)-qpar*rho(i,j,k)*qrad(i,j,k)
        enddo
!
! *********** Calculate dQdT term for use in implicit radiation loss.
!
        if (ifimplrad.ne.0) then
!
          allocate(dqrad(nr,nt,np))
!$acc enter data create(dqrad)
!
          call get_dqrad (dqrad,temp_e0k,nr*nt*np)
!
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            dqdt(i,j,k)=dtime*fn_t*qpar*rho(i,j,k)*dqrad(i,j,k)
          enddo
!
!$acc exit data delete(dqrad)
          deallocate(dqrad)
!
        end if
!
!$acc exit data delete(temp_e0k,qrad)
        deallocate(temp_e0k)
        deallocate(qrad)
!
      end if !radloss
!
! *** Advance the temperature
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        temp_e(i,j,k)=temp_e(i,j,k) &
                      -dtime*(Aflow(i,j,k)-Rreact(i,j,k))
      enddo
!
! *** Set boundary conditions and seam.
!
      call set_bc_temp_e (temp_e,one)
!
      call seam_scalar (temp_e,nr,nt,np)
!
! *** Advance thermal conductivity.
!
      if (advance_tc) call advtce
!
! *** Floor temperature.
!
      if (iftfloor) then
        call floor_field (temp_e,nr,nt,np,FNAME,RNAME,tfloor)
      end if
!
! *** Check for negative temperatures.
!
      if (ifcheck0temp) then
        call check_negative_field (temp_e,nr,nt,np,FNAME,RNAME)
      end if
!$acc exit data delete(Aflow,Awave,f_rho_t,div_tv,tempp,div_tvbb, &
!$acc                  div_v,div_vbb,Rreact)
!
      if (use_timer) call timer (TIME_ADVTE)
!
end subroutine
!#######################################################################
subroutine advtp
!
!-----------------------------------------------------------------------
!
! *** Advance the proton + alpha temperature.
!     This routine uses a first-order explicit advance with a
!     predictor-corrector for advection terms.
!
!     Basic equations:
!     (T**-T)/dt = A(T,T*) + R(T)
!
!     dV*(Tnew-T**)/dt = dV*D(T**)
!
!     A(T)     = Awave(T) + Aflow(T)
!       Awave(T) = T Div(v) terms
!       Aflow(T) = v Grad(T) terms
!
!     The reaction terms are heating (H)
!     R(T) = H
!
!     Given initial T0, the scheme is described as:
!     T*  = T0 + dt*(Bw*Awave(T0) + Bf*Aflow(T0))    (Predictor)
!     T** = T0 + dt*(A(T,T*) + R(T0))                (Corrector)
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ) :: tmpp,tmpe,fac1,fac2
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      character(32) :: FNAME='P-TEMPERATURE', RNAME='ADVTP'
!
!-----------------------------------------------------------------------
!
! *** Temporary fields.
!
      real(r_typ), dimension(nr,nt,np) :: Aflow,Awave,f_rho_t,div_tv
      real(r_typ), dimension(nr,nt,np) :: tempp,div_tvbb,div_v,div_vbb
      real(r_typ), dimension(nr,nt,np) :: Rreact
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVTP)
!
! *** Initialize/reset arrays to zero
!
!$acc enter data create(Aflow,Awave,f_rho_t,div_tv,tempp,div_tvbb, &
!$acc                   div_v,div_vbb,Rreact)
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        Aflow(i,j,k)=0.
        Awave(i,j,k)=0.
        f_rho_t(i,j,k)=0.
        tempp(i,j,k)=0.
        div_tv(i,j,k)=0.
        div_tvbb(i,j,k)=0.
        div_v(i,j,k)=0.
        div_vbb(i,j,k)=0.
        Rreact(i,j,k)=0.
      enddo
!
! *** Load boundary conditions for T (sets tr0v and tr1v).
!
      call load_bc_temp_p
!
! *** Save old temperature.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        temp_p0(i,j,k)=temp_p(i,j,k)
      enddo
!
! *** Compute Div(v) (used in both predictor and corrector)
!
      call get_divv (v,div_v)
!
      if (alpha_nocoll.ne.0..or.alpha_nocoll_p.ne.0.) then
        if (use_radial_nocoll) then
          call copy_vvec (v,vmoxrbb)
        else
          call v_minus_omegaxr_bb (vmoxrbb)
        end if
        call get_divv (vmoxrbb,div_vbb)
      end if
!
!
! **********************************************************************
! *** Predictor step for advective terms. ***
! *******************************************
!
      if (pred_t) then
!
! ***** Compute Div(T v)
!
        call divqv (upwind_t,temp_p,v,div_tv)
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
! ***** Compute v Grad(T)=Div(T v)-T Div(v), and store result in Aflow
          Aflow(i,j,k)=div_tv(i,j,k)-temp_p(i,j,k)*div_v(i,j,k)
! ***** Compute T Div(v) term and store result in Awave
          Awave(i,j,k)=(gamma-one)*temp_p(i,j,k)*div_v(i,j,k)
        enddo
!
! ***** Add collisonless regime terms if selected
!
        if (alpha_nocoll_p.ne.0.) then
!
          do concurrent (k=1:np, j=1:nt, i=1:nr)
!           Compute alpha f rho T (fpT):
            f_rho_t(i,j,k)=alpha_nocoll_p*0.045_r_typ*prof_nocoll(i) &
                           *(rho(i,j,k)/he_rho)*temp_p(i,j,k)
          enddo
!
! ******* Compute Div(fpT vbb):
!
          call divqv (upwind_t,f_rho_t,vmoxrbb,div_tvbb)
!
! ******* Compute vbb Grad(fpT) term and add it to Aflow:
!
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            Aflow(i,j,k)=Aflow(i,j,k)+ &
                     (he_rho/(rho(i,j,k)*he_p_p))* &
                     (div_tvbb(i,j,k)-f_rho_t(i,j,k)*div_vbb(i,j,k))
          enddo
!
! ******* Compute (fpT) Div(vbb) term and add it to Awave:
!
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            Awave(i,j,k)=Awave(i,j,k)+(he_rho/(rho(i,j,k)*he_p_p))* &
                                      f_rho_t(i,j,k)*div_vbb(i,j,k)
          enddo
!
        end if
!
! ***** Advance to get predictor T*
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          tempp(i,j,k)=temp_p(i,j,k) &
                           -dtime*(betapc_t_flow*Aflow(i,j,k) &
                                  +betapc_t_wave*Awave(i,j,k))
        enddo
!
! ***** Set boundary conditions.
!
        call set_bc_temp_p (tempp,one)
!
        call seam_scalar (tempp,nr,nt,np)
!
      else
!
! ***** If no predictor step, just set T* to T:
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          tempp(i,j,k)=temp_p(i,j,k)
        enddo
!
      end if
!
! **********************************************************************
! *** Corrector step ***
! **********************
!
! ### Advection terms ###
!
! *** Compute Div(T* v)
!
      call divqv (upwind_t,tempp,v,div_tv)
!
! *** Store full advective terms (flow and wave) into array Aflow:
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        Aflow(i,j,k)=div_tv(i,j,k)+ &
                     (gamma-two)*temp_p(i,j,k)*div_v(i,j,k)
      enddo
!
! *** Add in collisonless thermal conduction term (if desired)
!
      if (alpha_nocoll_p.ne.0.) then
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
!         Compute alpha fnocoll rho T* (fpT*):
          f_rho_t(i,j,k)=alpha_nocoll_p*0.045_r_typ*prof_nocoll(i) &
                         *(rho(i,j,k)/he_rho)*tempp(i,j,k)
        enddo
!
! ***** Compute Div(fpT* vbb)
!
        call divqv (upwind_t,f_rho_t,vmoxrbb,div_tvbb)
!
! ***** Add to advection array
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          Aflow(i,j,k)=Aflow(i,j,k)+ &
                       he_rho*div_tvbb(i,j,k)/(rho(i,j,k)*he_p_p)
        enddo
!
      end if
!
! ### Reaction terms ###
!
! *** Store [(gamma-1)/(c_alpha*ne)]*H into Rreact array
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        Rreact(i,j,k)=heat(i,j,k)*(gamma-one)*he_rho &
                      /(he_p_p*rho(i,j,k))
        Rreact(i,j,k)=Rreact(i,j,k)*f_heating
      enddo
!
! *** Advance the temperature
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        temp_p(i,j,k)=temp_p(i,j,k) &
                      -dtime*(Aflow(i,j,k)-Rreact(i,j,k))
      enddo
!
! *** Set boundary conditions and seam.
!
      call set_bc_temp_p (temp_p,one)
!
      call seam_scalar (temp_p,nr,nt,np)
!
! *** Advance thermal conductivity.
!
      if (advance_tc.and.tcondp.gt.0) call advtcp
!
! *** Floor temperature.
!
      if (iftfloor) then
        call floor_field (temp_p,nr,nt,np,FNAME,RNAME,tfloor)
      end if
!
! *** Check for negative temperatures.
!
      if (ifcheck0temp) then
        call check_negative_field (temp_p,nr,nt,np,FNAME,RNAME)
      end if
!$acc exit data delete(Aflow,Awave,f_rho_t,div_tv,tempp,div_tvbb, &
!$acc                  div_v,div_vbb,Rreact)
!
      if (use_timer) call timer (TIME_ADVTP)
!
end subroutine
!#######################################################################
subroutine check_negative_field (field,n1,n2,n3,fname,call_loc)
!
!-----------------------------------------------------------------------
!
! ****** Check a given field for negative values and shut down the
! ****** simulation if one if found.
! ****** The routine will output all locations of negative field values
! ****** before shutting down.
! ****** The routine does not check boundary values.
!
!     INPUT:
!         field:     The field to check.
!         n1,n2,n3:  The dimensions of the field [field(n1,n2,n3)].
!         fname:     The field's name.
!         call_loc:  Name of routine where this routine is called from.
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
      use vars, ONLY : ifabort
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n1,n2,n3
      real(r_typ), dimension(n1,n2,n3) :: field
      character(32) :: fname,call_loc
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ierr
!
!-----------------------------------------------------------------------
!
! ****** Find any negative field values on local processor:
!
      ierr=0
!
!$acc parallel loop collapse(3) default(present) &
!$acc          copy(ierr) copyin(fname)
!$omp parallel do collapse(3) default(shared)
      do k=2,n3-1
        do j=2,n2-1
          do i=2,n1-1
            if (field(i,j,k).lt.0.) then
              write (*,*)
              write (*,*) '### ERROR from CHECK_NEGATIVE_FIELD:'
              write (*,*) '### The ',fname, &
                          ' is negative at location:'
              write (*,*) 'I,J,K =(',i-1+i0_g,',' &
                                    ,j-1+j0_g,',', &
                                     k-1+k0_g,')'
              write (*,*) fname,' = ',field(i,j,k)
              write (*,*)
!$omp atomic write
!$acc atomic write
              ierr=1
            end if
          enddo
        enddo
      enddo
!$omp end parallel do
!
! ****** Find out if field had a negative value on any processor
! ****** and shutdown simulation if one was found.
!
      call check_error_on_any_proc (ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in ',trim(call_loc),':'
          write (*,*) '### The ',trim(fname),' has become negative.'
          write (*,*) '### Aborting the run.'
          write (*,*)
        end if
        ifabort=.true.
        call final_diags
      end if
!
end subroutine
!#######################################################################
subroutine floor_field (field,n1,n2,n3,fname,call_loc,floor_val)
!
!-----------------------------------------------------------------------
!
! ****** Floor a given hhh field, if field value is less than floor_val,
! ****** set the value to floor_field and write info to warning file.
!
!     INPUT:
!            field:     The field to check.
!            n1,n2,n3:  The dimensions of the field [field(n1,n2,n3)].
!            fname:     The field name.
!            call_loc:  Name of routine where this routine called from.
!            floor_val: The floor value.
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars, ONLY : ntime,time
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n1,n2,n3
      real(r_typ), dimension(n1,n2,n3) :: field
      character(*) :: fname,call_loc
      integer :: min_indices(3)=0.
      real(r_typ) :: floor_val
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,min_i,min_j,min_k,ierr,rank_min
      integer :: number_of_floors=0
      integer :: did_floor_happen=0
      real(r_typ) :: min_field_val_local
!     integer :: req(6)
!      logical, dimension(n1,n2,n3) :: mask
!
!-----------------------------------------------------------------------
!
      number_of_floors=0
!
!      do concurrent (k=1:n3, j=1:n2, i=1:n1)
!        mask(i,j,k)=.false.
!      enddo
!
!      do concurrent (k=2:n3-1, j=2:n2-1, i=2:n1-1)
!        mask(i,j,k)=.true.
!      enddo
!
! ****** Find the minimum value of the field and get its local indices.
!
      min_field_val_local=HUGE(1._r_typ)
!$acc parallel loop collapse(3) default(present) &
!$acc          reduction(min:min_field_val_local)
!$omp parallel do collapse(3) default(shared) &
!$omp          reduction(min:min_field_val_local)
      do k=2,n3-1
        do j=2,n2-1
          do i=2,n1-1
            min_field_val_local=MIN(min_field_val_local,field(i,j,k))
          enddo
        enddo
      enddo
!$omp end parallel do
!
! ****** If minimum value is less than the floor, floor the field.
!
      if (min_field_val_local.lt.floor_val) then
!$acc parallel loop collapse(3) present(field) &
!$acc          reduction(+:number_of_floors) copy(number_of_floors)
!$omp parallel do collapse(3) default(shared) &
!$omp   reduction(+:number_of_floors)
        do k=2,n3-1
          do j=2,n2-1
            do i=2,n1-1
              did_floor_happen=0
              if (field(i,j,k).lt.floor_val) then
                field(i,j,k)=floor_val
                did_floor_happen=1
              end if
              number_of_floors=number_of_floors+did_floor_happen
            enddo
          enddo
        enddo
!$omp end parallel do
!
! ***** Get global position of min location.
!       RMC Note: MINLOC not supported with OpenACC and/or stdpar yet!
!        min_indices=MINLOC(field,mask)
!        min_i=min_indices(1)-1+i0_g
!        min_j=min_indices(2)-1+j0_g
!        min_k=min_indices(3)-1+k0_g
!
      end if
!
! ****** Get total number of floors over all ranks.
!
      call global_sum_int (number_of_floors)
!
      if (number_of_floors.gt.0) then
!
! ****** Seam the field to make sure floor values filled.
!
        call seam_scalar (field,n1,n2,n3)
!
! ***** Get MPI rank of proc containing minimum.
!
        rank_min=0
        call global_min_loc (min_field_val_local,rank_min)
!
! ***** Transfer value and location of minimum from rank to root.
!
!        if(iproc.eq.rank_min) then
!          call MPI_Isend(min_i,1,MPI_INTEGER,iproc0,1,
!     &                   comm_all,req(4),ierr)
!          call MPI_Isend(min_j,1,MPI_INTEGER,iproc0,2,
!     &                   comm_all,req(5),ierr)
!          call MPI_Isend(min_k,1,MPI_INTEGER,iproc0,3,
!     &                   comm_all,req(6),ierr)
!        end if
!        if(iamp0) then
!          call MPI_Irecv(min_i,1,MPI_INTEGER,rank_min,1,
!     &                   comm_all,req(1),ierr)
!          call MPI_Irecv(min_j,1,MPI_INTEGER,rank_min,2,
!     &                   comm_all,req(2),ierr)
!          call MPI_Irecv(min_k,1,MPI_INTEGER,rank_min,3,
!     &                   comm_all,req(3),ierr)
!
!          call MPI_Waitall (3,req(1:3),MPI_STATUSES_IGNORE,ierr)
!        end if
!
! ***** Print out warnings into warning file.
!
        if (iamp0) then
          ierr=0
          write (13,*)
          write (13,*) '### WARNING: The ',trim(fname), &
                      ' was floored in ',trim(call_loc)
          if (min_field_val_local.lt.0) then
            write(13,*) '### and was NEGATIVE!'
          end if
          write (13,'(A,A,A,E23.15E3,A)') ' ### Minimum ' &
                       ,trim(fname),' = ',min_field_val_local
!          write (13,'(A,A8,I4,A,I4,A,I4,A)')
!     &               ' ### at location (i,j,k) = ','(',min_i,','
!     &                                                ,min_j,','
!     &                                                ,min_k,')'
          write (13,'(A,I23)') ' ### Total # of floors   = ' &
                                                      ,number_of_floors
          write (13,'(A,E23.3E3)') ' ### # floors/(nr*nt*np) = ' &
                               ,float(number_of_floors)/(nr_g*nt_g*np_g)
          write (13,'(A,I23)') ' ### NTIME               = ',ntime
          write (13,'(A,E23.3E3)') ' ### TIME                = ',time
        end if
      end if
!
end subroutine
!#######################################################################
subroutine floor_field_v (field,field_limit, &
                                field_fac,n1,n2,n3,fname,call_loc)
!
!-----------------------------------------------------------------------
!
! ****** Limit a given hhh field based on a spatial limiter array.
! ****** If the field(i,j,k) is less than field_fac*field_limit(i,j,k),
! ****** set field(i,j,k) to that value and write info to warning file.
!
!     INPUT:
!       field:       The field to check.
!       field_limit: Array of field values to check against
!                    (size same as field).
!       field_fac: Multiplyer of field_limit.       .
!       n1,n2,n3:  The dimensions of the field [field(n1,n2,n3)].
!       fname:     The field name.
!       call_loc:  Name of routine where this routine is called from.
!    OUTPUT:
!       field:    The modified field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars, ONLY : ntime,time
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n1,n2,n3
      real(r_typ), dimension(n1,n2,n3) :: field,field_limit
      character(*) :: fname,call_loc
      integer :: min_indices(3)=0.
      real(r_typ) :: field_fac
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(n1,n2,n3) :: field_ratio
      integer :: i,j,k,min_i,min_j,min_k,number_of_floors,ierr,rank_min
      integer :: did_floor_happen=0
      real(r_typ) :: min_field_diff_local
      real(r_typ) :: field_diff
!      integer :: req(6)
!      logical, dimension(n1,n2,n3) :: mask
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Initialize values:
!
      number_of_floors=0
!
!$acc enter data create(field_ratio)
!
!      do concurrent (k=1:n3, j=1:n2, i=1:n1)
!        mask(i,j,k)=.false.
!      enddo
!
!      do concurrent (k=2:n3-1, j=2:n2-1, i=2:n1-1)
!        mask(i,j,k)=.true.
!      enddo
!
      do concurrent (k=2:n3-1, j=2:n2-1, i=2:n1-1)
        field_ratio(i,j,k)=field(i,j,k)/ &
                           (field_fac*field_limit(i,j,k))
      enddo
!
      min_field_diff_local = HUGE(1._r_typ)
!$acc parallel loop collapse(3) default(present) &
!$acc          reduction(min:min_field_diff_local)
!$omp parallel do collapse(3) default(shared) &
!$omp          reduction(min:min_field_diff_local)
      do k=2,n3-1
        do j=2,n2-1
          do i=2,n1-1
            min_field_diff_local=MIN(min_field_diff_local, &
                                     field_ratio(i,j,k))
          enddo
        enddo
      enddo
!$omp end parallel do
!
! ****** If minimum ratio is less than one, floor the field.
!
      if (min_field_diff_local.lt.one) then
!$acc parallel loop collapse(3) present(field) &
!$acc          reduction(+:number_of_floors) copy(number_of_floors)
!$omp parallel do collapse(3) default(shared) &
!$omp   reduction(+:number_of_floors)
        do k=2,n3-1
          do j=2,n2-1
            do i=2,n1-1
              did_floor_happen=0
              if (field(i,j,k).lt.field_fac*field_limit(i,j,k)) then
                field(i,j,k)=field_fac*field_limit(i,j,k)
                did_floor_happen=1
              end if
              number_of_floors=number_of_floors+did_floor_happen
            enddo
          enddo
        enddo
!$omp end parallel do
!
! ***** Get global position of min location.
!       RMC Note: MINLOC not supported with OpenACC and/or stdpar yet!
!        min_indices=MINLOC(field_ratio,mask)
!        min_i=min_indices(1)-1+i0_g
!        min_j=min_indices(2)-1+j0_g
!        min_k=min_indices(3)-1+k0_g
!
      end if
!$acc exit data delete(field_ratio)
!
! ****** Get total number of floors over all processors.
!
      call global_sum_int (number_of_floors)
!
      if (number_of_floors.gt.0) then
!
! ****** Seam the field to make sure floor values filled.
!
        call seam_scalar (field,n1,n2,n3)
!
! ***** Get MPI rank of proc containing minimum.
!
!        rank_min=0
!        call global_min_loc (min_field_diff_local,rank_min)
!
! ***** Detect negative field value.
!
        call global_min (min_field_diff_local)
!
! ***** Transfer location of minimum from rank to root.
!
!        if(iproc.eq.rank_min) then
!          call MPI_Isend(min_i,1,MPI_INTEGER,iproc0,1,
!     &                   comm_all,req(4),ierr)
!          call MPI_Isend(min_j,1,MPI_INTEGER,iproc0,2,
!     &                   comm_all,req(5),ierr)
!          call MPI_Isend(min_k,1,MPI_INTEGER,iproc0,3,
!     &                   comm_all,req(6),ierr)
!        end if
!        if(iamp0) then
!          call MPI_Irecv(min_i,1,MPI_INTEGER,rank_min,1,
!     &                   comm_all,req(1),ierr)
!          call MPI_Irecv(min_j,1,MPI_INTEGER,rank_min,2,
!     &                   comm_all,req(2),ierr)
!          call MPI_Irecv(min_k,1,MPI_INTEGER,rank_min,3,
!     &                   comm_all,req(3),ierr)
!
!          call MPI_Waitall (3,req(1:3),MPI_STATUSES_IGNORE,ierr)
!        end if
!
! ***** Print out warnings into warning file.
!
        if (iamp0) then
          ierr=0
          write (13,*)
          write (13,*) '### WARNING: The ',trim(fname), &
                      ' was floored in ',trim(call_loc)
          if (min_field_diff_local.lt.0) then
            write(13,*) '### and had a NEGATIVE value!'
          end if
          write (13,'(A,A,A,A,A,E23.15E3,A)') ' ### Minimum ' &
          ,trim(fname),'/(',trim(fname),'_LIMIT*LIMIT_FAC) = ', &
          min_field_diff_local
!          write (13,'(A,A8,I4,A,I4,A,I4,A)')
!     &               ' ### at location (i,j,k) = ','(',min_i,','
!     &                                                ,min_j,','
!     &                                                ,min_k,')'
          write (13,'(A,I23)') ' ### Total # of floors   = ' &
                                                      ,number_of_floors
          write (13,'(A,E23.3E3)') ' ### # floors/(nr*nt*np) = ' &
                               ,float(number_of_floors)/(nr_g*nt_g*np_g)
          write (13,'(A,I23)') ' ### NTIME               = ',ntime
          write (13,'(A,E23.3E3)') ' ### TIME                = ',time
        end if
      end if
!
end subroutine
!#######################################################################
subroutine set_bc_rho (rho,rho0v)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on rho at the physical
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use characteristics
      use vars
      use interplanetary_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: rho
      real(r_typ), dimension(nt,np) :: rho0v
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
!
! ****** Rho is always specified at rb0.
!
        if (interplanetary_run) then
          do concurrent (k=2:npm1, j=2:ntm1)
            rho(1,j,k)=two*rho_ip(j,k)-rho(2,j,k)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1)
            rho(1,j,k)=two*rho0v(j,k)-rho(2,j,k)
          enddo
        end if
      end if
!
      if (rb1) then
!
! ****** If char_bc1=.false.,the rb1 boundary value of rho is static.
!
        if (char_bc1) then
          do concurrent (k=2:npm1, j=2:ntm1)
            rho(nr,j,k)=MAX(two*cbc1_rhob(j,k)-rho(nrm1,j,k), &
                            rho(nrm1,j,k)*rhobc_maxfac_r1)
          enddo
        end if
      end if
!
! ****** Theta boundaries.
!
      call set_pole_bc_scalar_hhh (rho)
!
end subroutine
!#######################################################################
subroutine set_bc_pres
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on pressure at the physical
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use characteristics
      use vars
      use interplanetary_vars
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
!
! ****** Pressure is always specified at rb0.
!
        if (interplanetary_run) then
          do concurrent (k=2:npm1, j=2:ntm1)
            pres(1,j,k)=two*(he_p/he_rho)*rho_ip(j,k)*t_ip(j,k) &
                        -pres(2,j,k)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1)
            pres(1,j,k)=two*(he_p/he_rho)*rho0v(j,k)*tr0v(j,k) &
                        -pres(2,j,k)
          enddo
        end if
      end if
!
      if (rb1) then
!
! ****** If char_bc1=.false.,the rb1 boundary value of pres is static.
!
        if (char_bc1) then
          do concurrent (k=2:npm1, j=2:ntm1)
            pres(nr,j,k)=two*cbc1_pb(j,k)-pres(nrm1,j,k)
          enddo
        end if
      end if
!
! ****** Theta boundaries.
!
      call set_pole_bc_scalar_hhh (pres)
!
end subroutine
!#######################################################################
subroutine divqv (upwind_q,q,v,div)
!
!-----------------------------------------------------------------------
!
! ****** Compute div(q*v) and return it in array DIV.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : vvec
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: upwind_q
      real(r_typ), dimension(nr,nt,np) :: q,div
      type(vvec) :: v
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: vrm,vrp,crm,crp
      real(r_typ) :: vtm,vtp,ctm,ctp
      real(r_typ) :: vpm,vpp,cpm,cpp
!
!-----------------------------------------------------------------------
!
! ****** Zero out the DIV array.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        div(i,j,k)=0.
      enddo
!
! ****** Compute div(q*v).
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        vrp=AVG(v%r,i  ,j  ,k  )
        vrm=AVG(v%r,i-1,j  ,k  )
        vtp=AVG(v%t,i  ,j  ,k  )
        vtm=AVG(v%t,i  ,j-1,k  )
        vpp=AVG(v%p,i  ,j  ,k  )
        vpm=AVG(v%p,i  ,j  ,k-1)
        crp=sign(upwind_q,vrp)
        crm=sign(upwind_q,vrm)
        ctp=sign(upwind_q,vtp)
        ctm=sign(upwind_q,vtm)
        cpp=sign(upwind_q,vpp)
        cpm=sign(upwind_q,vpm)
        div(i,j,k)= ( fl_fac(i  )*r(i  )**2*vrp*ADVR(q,i+1,j,k,crp) &
                     -fl_fac(i-1)*r(i-1)**2*vrm*ADVR(q,i  ,j,k,crm) &
                    )*fl_fach_i(i)*rh_i(i)**2*drh_i(i) &
                   +( st(j  )*vtp*ADVT(q,i,j+1,k,ctp) &
                     -st(j-1)*vtm*ADVT(q,i,j  ,k,ctm) &
                    )*rh_i(i)*sth_i(j)*dth_i(j) &
                   +( vpp*ADVP(q,i,j,k+1,cpp) &
                     -vpm*ADVP(q,i,j,k  ,cpm) &
                    )*rh_i(i)*sth_i(j)*dp_mult*dph_i(k)
      enddo
!
end subroutine
!#######################################################################
subroutine get_divv (v,divv)
!
!-----------------------------------------------------------------------
!
! ****** Compute div(v) and return it in array DIVV.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      real(r_typ), dimension(nr,nt,np) :: divv
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Zero out the DIVV array.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        divv(i,j,k)=0.
      enddo
!
! ****** Compute div(v) at the internal points.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        divv(i,j,k)= ( fl_fac(i  )*r(i  )**2*v%r(i  ,j,k) &
                      -fl_fac(i-1)*r(i-1)**2*v%r(i-1,j,k) &
                     )*fl_fach_i(i)*rh_i(i)**2*drh_i(i) &
                    +( st(j  )*v%t(i,j  ,k) &
                      -st(j-1)*v%t(i,j-1,k) &
                     )*rh_i(i)*sth_i(j)*dth_i(j) &
                    +( v%p(i,j,k  ) &
                      -v%p(i,j,k-1) &
                     )*rh_i(i)*sth_i(j)*dp_mult*dph_i(k)
      enddo
!
end subroutine
!#######################################################################
subroutine get_divb (b,divb)
!
!-----------------------------------------------------------------------
!
! ****** Compute Div(B) and return it in mmm array DIVB.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use mpidefs
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
      real(r_typ), dimension(nrm,ntm,npm) :: divb
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Zero out the DIVB array.
!
      do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
        divb(i,j,k)=0.
      enddo
!
! ****** Compute div(b) on the mmm mesh.
!
      do concurrent (k=2:npm-1, j=2:ntm-1, i=i0:nrm1)
!
        divb(i,j,k)= ( rh(i+1)**2*b%r(i+1,j,k) &
                      -rh(i  )**2*b%r(i  ,j,k) &
                     )*r_i(i)**2*dr_i(i) &
                    +( sth(j+1)*b%t(i,j+1,k) &
                      -sth(j  )*b%t(i,j  ,k) &
                     )*r_i(i)*st_i(j)*dt_i(j) &
                    +( b%p(i,j,k+1) &
                      -b%p(i,j,k  ) &
                     )*dp_mult*r_i(i)*st_i(j)*dp_i(k)
!
      enddo
!
      call set_pole_bc_scalar_mmm (divb)
!
      call seam_scalar (divb,nrm,ntm,npm)
!
end subroutine
!#######################################################################
subroutine get_grad_phi (phi,gradphi)
!
!-----------------------------------------------------------------------
!
! ****** Compute gradphi=Grad(phi) where phi is on the mmm mesh.
! ****** assuming the boundary conditions phi(r=r0m)=phi(r=r1p)=0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: gradphi
      real(r_typ), dimension(nrm,ntm,npm) :: phi
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Zero out the gradphi vector.
!
      call zero_bvec (gradphi)
!
! ****** Compute gradphi=Grad(phi).
!
! ****** Calculate the r component.
!
      do concurrent (k=1:npm, j=1:ntm, i=2:nrm1)
        gradphi%r(i,j,k)=drh_i(i)*(phi(i,j,k)-phi(i-1,j,k))
      enddo
!
! ****** Handle radial boundary conditions.
!
      if (rb0) then
        do concurrent (k=1:npm, j=1:ntm)
          gradphi%r(1,j,k)=drh_i(1)*phi(1,j,k)
        enddo
      end if
!
      if (rb1) then
        do concurrent (k=1:npm, j=1:ntm)
          gradphi%r(nr,j,k)=-drh_i(nr)*phi(nrm,j,k)
        enddo
      end if
!
! ****** Calculate the theta component.
!
      do concurrent (k=1:npm, j=2:ntm1, i=1:nrm)
        gradphi%t(i,j,k)=r_i(i)*dth_i(j) &
                                              *(phi(i,j,k)-phi(i,j-1,k))
      enddo
!
! ****** Calculate the phi component.
!
      do concurrent (k=2:npm1, j=1:ntm, i=1:nrm)
        gradphi%p(i,j,k)=r_i(i)*st_i(j)*dph_i(k) &
                                              *(phi(i,j,k)-phi(i,j,k-1))
      enddo
!
      call set_pole_bc_bvec (gradphi)
!
      call seam_scalar (gradphi%r,nr,ntm,npm)
      call seam_scalar (gradphi%t,nrm,nt,npm)
      call seam_scalar (gradphi%p,nrm,ntm,np)
!
end subroutine
!#######################################################################
subroutine energy
!
!-----------------------------------------------------------------------
!
! ****** Calculate the various energies.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use fields
      use vars
      use energy_diagnostic
      use restart
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vav
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Allocate the structure to hold the velocity at the integral
! ****** time step.
!
      call alloc_vvec (vav)
!
! ****** Calculate the magnetic energy.
!
      call magnetic_energy (b,wr,wt,wp)
!
      ww=wr+wt+wp
!
! ****** Get the velocity at the integral time step.  This is used
! ****** to compute the kinetic energy.
!
      do concurrent (k=1:np, j=1:nt, i=1:nrm)
        vav%r(i,j,k)=half*(v_old%r(i,j,k)+v%r(i,j,k))
      enddo
!
      do concurrent (k=1:np, j=1:ntm, i=1:nr)
        vav%t(i,j,k)=half*(v_old%t(i,j,k)+v%t(i,j,k))
      enddo
!
      do concurrent (k=1:npm, j=1:nt, i=1:nr)
        vav%p(i,j,k)=half*(v_old%p(i,j,k)+v%p(i,j,k))
      enddo
!
! ****** Calculate the kinetic energy.
!
      call kinetic_energy (rho,vav,kr,kt,kp)
!
      kk=kr+kt+kp
!
! ****** Calculate the parallel and perpendicular kinetic energies.
!
      call kinetic_energy_pp (rho,vav,b,kparr,kpart,kparp, &
                              kperpr,kperpt,kperpp)
!
! ****** Calculate the thermal energy.
!
      call thermal_energy (pres,gamma,etherm)
!
! ****** Calculate the rate of resistive dissipation.
!
      rr_old=rr
      call resistive_dissipation (eta,fj,rr)
!
! ****** Calculate the rate of viscous dissipation.
!
      vv_old=vv
      call viscous_dissipation (vis,rho,vav,vv)
!
! ****** Calculate the Poynting flux across the boundaries.
!
      if (.not.(restart_run.and.ntime.eq.0)) then
!cc      call poynting_flux (eb,bb,poynt)
        poynt=0.
      end if
!
! ****** Deallocate VAV.
!
      call dealloc_vvec (vav)
!
end subroutine
!#######################################################################
subroutine energy_diag
!
!-----------------------------------------------------------------------
!
! ****** Calculate the total energy diagnostic to check energy
! ****** conservation.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars
      use energy_diagnostic
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ) :: rrh,vvh
!
!-----------------------------------------------------------------------
!
! ****** Calculate the amount of energy dissipated so far.
!
      rrh=half*(rr_old+rr)
      vvh=half*(vv_old+vv)
!
      e_dissipated=e_dissipated+(rrh+vvh)*dtime
!
! ****** Calculate the amount of energy that has flowed across the
! ****** boundaries into the domain.
!
      e_poynt=e_poynt+poynt*dtime
!
! ****** Calculate the total energy --- this ought to be constant in
! ****** an exact calculation.
!
      e_conserved=ww+kk+etherm+e_dissipated-e_poynt
!
end subroutine
!#######################################################################
subroutine energy_diag_init
!
!-----------------------------------------------------------------------
!
! ****** Initialize the total energy diagnostic.
!
!-----------------------------------------------------------------------
!
      use energy_diagnostic
      use restart
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      if (.not.restart_run) then
        e_dissipated=0.
        e_poynt=0.
      end if
!
      e_conserved=ww+kk+etherm+e_dissipated-e_poynt
!
end subroutine
!#######################################################################
subroutine load_resistivity
!
!-----------------------------------------------------------------------
!
! ****** Set the resistivity profile.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use dissipation_profiles
      use mpidefs
      use ucase_interface
      use global_to_local_tp_interface
      use global_to_local_interface
      use profile_value_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: i,j,k
      real(r_typ) :: prof
      real(r_typ), dimension(ntm,npm) :: eta_prof_tp
      real(r_typ), dimension(ntm1_g,npm1_g) :: eta_prof_tp_g
      real(r_typ), dimension(nrm,ntm,npm) :: eta_prof_rtp
      real(r_typ), dimension(nrm1_g,ntm1_g,npm1_g) :: eta_prof_rtp_g
!
!-----------------------------------------------------------------------
!
      if (ucase(eta_profile).eq.'UNIFORM') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_RESISTIVITY:'
          write (9,*) '### Using resistivity profile: ', &
                      trim(ucase(eta_profile))
        end if
!
        eta_prof=one/slund
!
      else if (ucase(eta_profile).eq.'RADIALLY_DEPENDENT') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_RESISTIVITY:'
          write (9,*) '### Using resistivity profile: ', &
                      trim(ucase(eta_profile))
        end if
!
        do i=1,nrm
          prof=half*(one+tanh((r(i)-r_eta_crit)/dr_eta_crit))
          eta_prof(i,:,:)=( eta_fac_0 &
                           +(eta_fac_1-eta_fac_0)*prof)/slund
        enddo
!
      else if (ucase(eta_profile).eq.'HIGH_SLUND_REGION') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_RESISTIVITY:'
          write (9,*) '### Using resistivity profile: ', &
                      trim(ucase(eta_profile))
        end if
!
        if (phi_0.le.phi_1) then
          do k=1,npm
            do j=1,ntm
              if (p(k).gt.phi_0.and.p(k).lt.phi_1.and. &
                  t(j).gt.theta_0.and.t(j).lt.theta_1) then
                eta_prof(:,j,k)=one/slund_high
              else
                eta_prof(:,j,k)=one/slund_low
              end if
            enddo
          enddo
        else
          do k=1,npm
            do j=1,ntm
              if ((p(k).gt.phi_0.or.p(k).lt.phi_1).and. &
                  t(j).gt.theta_0.and.t(j).lt.theta_1) then
                eta_prof(:,j,k)=one/slund_high
              else
                eta_prof(:,j,k)=one/slund_low
              end if
            enddo
          enddo
        end if
!
      else if (ucase(eta_profile).eq.'CUSTOM_TP+R_PROFILE') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_RESISTIVITY:'
          write (9,*) '### Using resistivity profile: ', &
                      trim(ucase(eta_profile))
        end if
!
! ****** Interpolate the (t,p) profile from the specified file.
!
        if (eta_profile_tp_file.eq.' ') then
          eta_prof_tp=one
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from LOAD_RESISTIVITY:'
            write (9,*) '### Reading the (t,p) resistivity'// &
                        ' profile from file: ', &
                        trim(eta_profile_tp_file)
            call read_tp_interp_mm (eta_profile_tp_file, &
                                    eta_prof_tp_g,1,ierr)
          end if
          call check_error_on_p0 (ierr)
          call global_to_local_tp (eta_prof_tp_g,eta_prof_tp)
        end if
!
! ****** Set the resistivity profile.
!
        do i=1,nrm
          prof=profile_value(eta_profile_r,r(i))
          do k=1,npm
            do j=1,ntm
              eta_prof(i,j,k)=prof*eta_prof_tp(j,k)/slund
            enddo
          enddo
        enddo
!
      else if (ucase(eta_profile).eq.'CUSTOM_PROFILE') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_RESISTIVITY:'
          write (9,*) '### Using resistivity profile: ', &
                      trim(ucase(eta_profile))
        end if
!
! ****** Interpolate the (r,t,p) profile from the specified file.
!
        if (eta_profile_file.eq.' ') then
          eta_prof_rtp=one
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from LOAD_RESISTIVITY:'
            write (9,*) '### Reading the (r,t,p) resistivity'// &
                        ' profile from file: ', &
                        trim(eta_profile_file)
            call read_rtp_interp_mmm (eta_profile_file, &
                                    eta_prof_rtp_g,1,ierr)
          end if
          call check_error_on_p0 (ierr)
          call global_to_local (eta_prof_rtp_g,eta_prof_rtp)
        end if
!
! ****** Set the resistivity profile.
!
        do i=1,nrm
          do k=1,npm
            do j=1,ntm
              eta_prof(i,j,k)=eta_prof_rtp(i,j,k)/slund
            enddo
          enddo
        enddo
!
      else
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_RESISTIVITY:'
          write (*,*) '### Invalid resistivity profile requested:'
          write (*,*) 'ETA_PROFILE = ',trim(eta_profile)
          write (*,*)
          write (*,*) '### The allowed options are:'
          write (*,*) '''UNIFORM'''
          write (*,*) '''RADIALLY_DEPENDENT'''
          write (*,*) '''HIGH_SLUND_REGION'''
          write (*,*) '''CUSTOM_TP+R_PROFILE'''
          write (*,*) '''CUSTOM_PROFILE'''
          write (*,*)
        end if
        call endrun (.true.)
      end if
!
end subroutine
!#######################################################################
subroutine load_viscosity
!
!-----------------------------------------------------------------------
!
! ****** Set the viscosity profile.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use dissipation_profiles
      use mpidefs
      use ucase_interface
      use global_to_local_tp_interface
      use global_to_local_interface
      use profile_value_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: i,j,k
      real(r_typ) :: prof
      real(r_typ), dimension(ntm,npm) :: visc_prof_tp
      real(r_typ), dimension(ntm1_g,npm1_g) :: visc_prof_tp_g
      real(r_typ), dimension(nrm,ntm,npm) :: visc_prof_rtp
      real(r_typ), dimension(nrm1_g,ntm1_g,npm1_g) :: visc_prof_rtp_g
!
!-----------------------------------------------------------------------
!
      if (ucase(visc_profile).eq.'UNIFORM') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_VISCOSITY:'
          write (9,*) '### Using viscosity profile: ', &
                      trim(ucase(visc_profile))
        end if
!
        vis_prof=visc
!
      else if (ucase(visc_profile).eq.'RADIALLY_DEPENDENT') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_VISCOSITY:'
          write (9,*) '### Using viscosity profile: ', &
                      trim(ucase(visc_profile))
        end if
!
        do i=1,nrm
          prof=half*(one+tanh((r(i)-r_visc_crit)/dr_visc_crit))
          vis_prof(i,:,:)=(visc_fac_0 &
                           +(visc_fac_1-visc_fac_0)*prof)*visc
        enddo
!
      else if (ucase(visc_profile).eq.'LOW_VISC_REGION') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_VISCOSITY:'
          write (9,*) '### Using viscosity profile: ', &
                      trim(ucase(visc_profile))
        end if
!
        if (phi_0.le.phi_1) then
          do k=1,npm
            do j=1,ntm
              if (p(k).gt.phi_0.and.p(k).lt.phi_1.and. &
                  t(j).gt.theta_0.and.t(j).lt.theta_1) then
                vis_prof(:,j,k)=visc_low
              else
                vis_prof(:,j,k)=visc_high
              end if
            enddo
          enddo
        else
          do k=1,npm
            do j=1,ntm
              if ((p(k).gt.phi_0.or.p(k).lt.phi_1).and. &
                  t(j).gt.theta_0.and.t(j).lt.theta_1) then
                vis_prof(:,j,k)=visc_low
              else
                vis_prof(:,j,k)=visc_high
              end if
            enddo
          enddo
        end if
!
      else if (ucase(visc_profile).eq.'CUSTOM_TP+R_PROFILE') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_VISCOSITY:'
          write (9,*) '### Using viscosity profile: ', &
                      trim(ucase(visc_profile))
        end if
!
! ****** Interpolate the (t,p) profile from the specified file.
!
        if (visc_profile_tp_file.eq.' ') then
          visc_prof_tp=one
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from LOAD_VISCOSITY:'
            write (9,*) '### Reading the (t,p) viscosity'// &
                        ' profile from file: ', &
                        trim(visc_profile_tp_file)
            call read_tp_interp_mm (visc_profile_tp_file, &
                                    visc_prof_tp_g,1,ierr)
          end if
          call check_error_on_p0 (ierr)
          call global_to_local_tp (visc_prof_tp_g,visc_prof_tp)
        end if
!
! ****** Set the viscosity profile.
!
        do i=1,nrm
          prof=profile_value(visc_profile_r,r(i))
          do k=1,npm
            do j=1,ntm
              vis_prof(i,j,k)=prof*visc_prof_tp(j,k)*visc
            enddo
          enddo
        enddo
!
      else if (ucase(visc_profile).eq.'CUSTOM_PROFILE') then
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from LOAD_VISCOSITY:'
          write (9,*) '### Using viscosity profile: ', &
                      trim(ucase(visc_profile))
        end if
!
! ****** Interpolate the profile from the specified file.
!
        if (visc_profile_file.eq.' ') then
          visc_prof_rtp=one
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from LOAD_VISCOSITY:'
            write (9,*) '### Reading the (r,t,p) viscosity'// &
                        ' profile from file: ', &
                        trim(visc_profile_file)
            call read_rtp_interp_mmm (visc_profile_file, &
                                    visc_prof_rtp_g,1,ierr)
          end if
          call check_error_on_p0 (ierr)
          call global_to_local (visc_prof_rtp_g,visc_prof_rtp)
        end if
!
! ****** Set the viscosity profile.
!
        do i=1,nrm
          do k=1,npm
            do j=1,ntm
              vis_prof(i,j,k)=visc_prof_rtp(i,j,k)*visc
            enddo
          enddo
        enddo
!
      else
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_VISCOSITY:'
          write (*,*) '### Invalid viscosity profile requested:'
          write (*,*) 'VISC_PROFILE = ',trim(visc_profile)
          write (*,*)
          write (*,*) '### The allowed options are:'
          write (*,*) '''UNIFORM'''
          write (*,*) '''RADIALLY_DEPENDENT'''
          write (*,*) '''LOW_VISC_REGION'''
          write (*,*) '''CUSTOM_TP+R_PROFILE'''
          write (*,*) '''CUSTOM_PROFILE'''
          write (*,*)
        end if
        call endrun (.true.)
      end if
!
end subroutine
!#######################################################################
subroutine load_helicity_pumping_profile
!
!-----------------------------------------------------------------------
!
! ****** Set the helicity pumping profile.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use helicity_pumping_params
      use mpidefs
      use ucase_interface
      use global_to_local_tp_interface
      use global_to_local_interface
      use io_units
      use profile_value_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: i,j,k
      real(r_typ) :: prof
      real(r_typ), dimension(ntm,npm) :: hpump_prof_tp
      real(r_typ), dimension(ntm1_g,npm1_g) :: hpump_prof_tp_g
      real(r_typ), dimension(nrm,ntm,npm) :: hpump_prof_rtp
      real(r_typ), dimension(nrm1_g,ntm1_g,npm1_g) :: hpump_prof_rtp_g
!
!-----------------------------------------------------------------------
!
      if (ucase(hpump_profile).eq.'UNIFORM') then
!
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from '// &
                      'LOAD_HELICITY_PUMPING_PROFILE'
          write (IO_OUT,*) '### Using hpump profile: ', &
                      trim(ucase(hpump_profile))
          FLUSH (IO_OUT)
        end if
!
        hpump_prof(:,:,:)=hpump_constant
!
      else if (ucase(hpump_profile).eq.'RADIALLY_DEPENDENT') then
!
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from '// &
                      'LOAD_HELICITY_PUMPING_PROFILE'
          write (IO_OUT,*) '### Using hpump profile: ', &
                      trim(ucase(hpump_profile))
          FLUSH (IO_OUT)
        end if
!
        do i=1,nrm
          prof=half*(one+tanh((r(i)-r_hpump_crit)/dr_hpump_crit))
          hpump_prof(i,:,:)=(hpump_fac_0 &
                           +(hpump_fac_1-hpump_fac_0)*prof) &
                           *hpump_constant
        enddo
!
      else if (ucase(hpump_profile).eq.'CUSTOM_TP+R_PROFILE') then
!
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from '// &
                      'LOAD_HELICITY_PUMPING_PROFILE'
          write (IO_OUT,*) '### Using hpump profile: ', &
                      trim(ucase(hpump_profile))
          FLUSH (IO_OUT)
        end if
!
! ****** Interpolate the (t,p) profile from the specified file.
!
        if (hpump_profile_tp_file.eq.' ') then
          hpump_prof_tp(:,:)=one
        else
          if (iamp0) then
            write (IO_OUT,*)
            write (IO_OUT,*) '### COMMENT from '// &
                        'LOAD_HELICITY_PUMPING_PROFILE'
            write (IO_OUT,*) '### Reading the (t,p) hpump'// &
                        ' profile from file: ', &
                        trim(hpump_profile_tp_file)
            call read_tp_interp_mm (hpump_profile_tp_file, &
                                    hpump_prof_tp_g,1,ierr)
          end if
          call check_error_on_p0 (ierr)
          call global_to_local_tp (hpump_prof_tp_g,hpump_prof_tp)
        end if
!
! ****** Set the helicity pumping profile.
!
        do i=1,nrm
          prof=profile_value(hpump_profile_r,r(i))
          do k=1,npm
            do j=1,ntm
              hpump_prof(i,j,k)=prof*hpump_prof_tp(j,k)*hpump_constant
            enddo
          enddo
        enddo
!
      else if (ucase(hpump_profile).eq.'CUSTOM_PROFILE') then
!
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from '// &
                      'LOAD_HELICITY_PUMPING_PROFILE'
          write (IO_OUT,*) '### Using hpump profile: ', &
                      trim(ucase(hpump_profile))
        end if
!
! ****** Interpolate the profile from the specified file.
!
        if (hpump_profile_file.eq.' ') then
          hpump_prof_rtp(:,:,:)=one
        else
          if (iamp0) then
            write (IO_OUT,*)
            write (IO_OUT,*) '### COMMENT from '// &
                        'LOAD_HELICITY_PUMPING_PROFILE'
            write (IO_OUT,*) '### Reading the (r,t,p) hpump '// &
                        ' profile from file: ', &
                        trim(hpump_profile_file)
            FLUSH (IO_OUT)
            call read_rtp_interp_mmm (hpump_profile_file, &
                                    hpump_prof_rtp_g,1,ierr)
          end if
          call check_error_on_p0 (ierr)
          call global_to_local (hpump_prof_rtp_g,hpump_prof_rtp)
        end if
!
! ****** Set the helicity pumping profile.
!
        do i=1,nrm
          do k=1,npm
            do j=1,ntm
              hpump_prof(i,j,k)=hpump_prof_rtp(i,j,k)*hpump_constant
            enddo
          enddo
        enddo
!
      else
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in '// &
                      'LOAD_HELICITY_PUMPING_PROFILE'
          write (*,*) '### Invalid helicity pumping profile requested:'
          write (*,*) 'HPUMP_PROFILE = ',trim(hpump_profile)
          write (*,*)
          write (*,*) '### The allowed options are:'
          write (*,*) '''UNIFORM'''
          write (*,*) '''RADIALLY_DEPENDENT'''
          write (*,*) '''CUSTOM_TP+R_PROFILE'''
          write (*,*) '''CUSTOM_PROFILE'''
          write (*,*)
        end if
        call endrun (.true.)
      end if
!
end subroutine
!#######################################################################
subroutine setdt
!
!-----------------------------------------------------------------------
!
! ****** Set the time step and compute semi-implicit term.
!
!-----------------------------------------------------------------------
!
! ****** If the semi-implicit term is being used (ISITYPE.ne.0),
! ****** the time step is set to the smaller of DTMAX and
! ****** the fraction CFL of the advective time step limit.
!
! ****** Otherwise (i.e., fully explicit), the time step is
! ****** set to the smaller of DTMAX and the fraction
! ****** CFL of the explicit time step limit.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use dtinfo
      use debug
      use seam_interface
      use radiative_loss_parameters
      use restart
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: cflv(nrm1,ntm1,npm1)
!
!-----------------------------------------------------------------------
!
! ****** Safety factor for the radiative limit on the time step.
! ****** This factor should not exceed 1.
!
      real(r_typ), parameter :: rad_limit_safety_factor=.9_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avp,avrho,avvr,avvt,avvp,avbr,avbt,avbp
      real(r_typ) :: bsq,vsq,cssq,vasq
      real(r_typ) :: k1dotv,k2sq,st_inv
      real(r_typ) :: vasq_max,cssq_max,vsq_max
      real(r_typ) :: ffac
      real(r_typ) :: total_cfl
      real(r_typ) :: flow_cfl_max,wave_cfl_max,total_cfl_max
      real(r_typ) :: fne,radterm,dqdtemp,dummy
      real(r_typ) :: dt_rad,dt_wave
      real(r_typ) :: dt_rad_used
      real(r_typ) :: dt_cfl_used
      real(r_typ) :: dt_init_used
      real(r_typ) :: dt_mxup
      real(r_typ) :: va_mult
!
      real(r_typ), dimension(6) :: buf
!
      real(r_typ), dimension(:,:,:), allocatable :: qrad,temp_ek,dqrad
!
!-----------------------------------------------------------------------
!
!$acc enter data create(cflv)
      do concurrent (k=1:npm1, j=1:ntm1, i=1:nrm1)
        cflv(i,j,k)=0.
      enddo
!
! *** Save current dt.
!
      dtime_old=dtime
!
! ****** Ignore the Alfven speed if the parallel dynamics model
! ****** was requested.  (Since the magnetic field is frozen in
! ****** this model, we can ignore the Alfven speed in the time
! ****** step limit.)
!
      if (freeze_b) then
        va_mult=0.
      else
        va_mult=one
      end if
!
      if (isitype.eq.0) then
!
!-----------------------------------------------------------------------
! ****** Fully explicit algorithm.
!-----------------------------------------------------------------------
!
! ****** Find the explicit time step limit.
!
        vasq_max=0.
        cssq_max=0.
        vsq_max=0.
        flow_cfl_max=0.
        wave_cfl_max=0.
        total_cfl_max=0.
!$acc parallel loop collapse(3) default(present) &
!$acc  reduction(max:flow_cfl_max,wave_cfl_max,total_cfl_max, &
!$acc                vasq_max,cssq_max,vsq_max)
!$omp parallel do collapse(3) default(shared) &
!$omp reduction(max:flow_cfl_max,wave_cfl_max,total_cfl_max) &
!$omp reduction(max:vasq_max,cssq_max,vsq_max)
        do k=1,npm1
          do j=1,ntm1
            do i=1,nrm1
              avp  =AVGRTP(pres,i+1,j+1,k+1)
              avrho=AVGRTP(rho ,i+1,j+1,k+1)
              avvr =AVGTP (v%r ,i  ,j+1,k+1)
              avvt =AVGRP (v%t ,i+1,j  ,k+1)
              avvp =AVGRT (v%p ,i+1,j+1,k  )
              avbr =AVGR  (b%r ,i+1,j  ,k  )
              avbt =AVGT  (b%t ,i  ,j+1,k  )
              avbp =AVGP  (b%p ,i  ,j  ,k+1)
              bsq=avbr**2+avbt**2+avbp**2
              vsq=avvr**2+avvt**2+avvp**2
              cssq=gamma*avp/avrho
              vasq=bsq/avrho
              if (tb0.and.j.eq.1) then
                st_inv=sth_i(2)
              else if (tb1.and.j.eq.ntm1) then
                st_inv=sth_i(ntm1)
              else
                st_inv=st_i(j)
              end if
              k1dotv= dr_i(i)*abs(avvr) &
                     +r_i(i)*dt_i(j)*abs(avvt) &
                     +r_i(i)*st_inv*dp_mult*dp_i(k)*abs(avvp)
              k2sq=four*( dr_i(i)**2 &
                         +(r_i(i)*dt_i(j))**2 &
                         +(r_i(i)*st_inv*dp_mult*dp_i(k))**2)
              flow_cfl=k1dotv
              wave_cfl=half*sqrt(k2sq*(cssq+va_mult*vasq))
              total_cfl=flow_cfl+wave_cfl
              flow_cfl_max=max(flow_cfl_max,flow_cfl)
              wave_cfl_max=max(wave_cfl_max,wave_cfl)
              total_cfl_max=max(total_cfl_max,total_cfl)
              vasq_max=max(vasq_max,vasq)
              cssq_max=max(cssq_max,cssq)
              vsq_max=max(vsq_max,vsq)
            enddo
          enddo
        enddo
!$omp end parallel do
!
        va_max=sqrt(vasq_max)
        cs_max=sqrt(cssq_max)
        v_max=sqrt(vsq_max)
!
! ****** Get the maxima over all processors.
! ****** (Combine all quantities into a buffer for efficiency.)
!
        buf(1)=flow_cfl_max
        buf(2)=wave_cfl_max
        buf(3)=total_cfl_max
        buf(4)=va_max
        buf(5)=cs_max
        buf(6)=v_max
        call global_max_v (6,buf)
        flow_cfl_max=buf(1)
        wave_cfl_max=buf(2)
        total_cfl_max=buf(3)
        va_max=buf(4)
        cs_max=buf(5)
        v_max=buf(6)
!
! ****** Set the time step to the smaller of DTMAX or CFL times
! ****** the explicit time step limit.
!
        dtcfl=one/max(total_cfl_max,small_value)
        dtime=min(cfl*dtcfl,dtmax)
!
! ****** Set the CFL numbers for diagnostic purposes.
!
        flow_cfl=flow_cfl_max*dtime
        wave_cfl=wave_cfl_max*dtime
!
! ****** Set the semi-implicit coefficient to zero.
!
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          sifac(i,j,k)=0.
        enddo
        si_max=0.
!
      else
!
!-----------------------------------------------------------------------
! ****** Semi-implicit algorithm.
!-----------------------------------------------------------------------
!
! ****** Initialize the semi-implicit coefficient to zero.
!
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          sifac(i,j,k)=0.
        enddo
!
! ****** First, find the advective limit.
!
        vsq_max=0.
        flow_cfl_max=0.
!$acc parallel loop collapse(3) default(present) &
!$acc  reduction(max:flow_cfl_max,vsq_max)
!$omp parallel do collapse(3) default(shared) &
!$omp reduction(max:flow_cfl_max,vsq_max)
        do k=1,npm1
          do j=1,ntm1
            do i=1,nrm1
              avvr=AVGTP(v%r,i  ,j+1,k+1)
              avvt=AVGRP(v%t,i+1,j  ,k+1)
              avvp=AVGRT(v%p,i+1,j+1,k  )
              vsq=avvr**2+avvt**2+avvp**2
              if (tb0.and.j.eq.1) then
                st_inv=sth_i(2)
              else if (tb1.and.j.eq.ntm1) then
                st_inv=sth_i(ntm1)
              else
                st_inv=st_i(j)
              end if
              k1dotv= dr_i(i)*abs(avvr) &
                     +r_i(i)*dt_i(j)*abs(avvt) &
                     +r_i(i)*st_inv*dp_mult*dp_i(k)*abs(avvp)
              flow_cfl=k1dotv
              flow_cfl_max=max(flow_cfl_max,flow_cfl)
              vsq_max=max(vsq_max,vsq)
              cflv(i,j,k)=k1dotv
            enddo
          enddo
        enddo
!$omp end parallel do
!
        v_max=sqrt(vsq_max)
!
! ****** Get the maxima over all processors.
! ****** (Combine all quantities into a buffer for efficiency.)
!
        buf(1)=flow_cfl_max
        buf(2)=v_max
        call global_max_v (2,buf)
        flow_cfl_max=buf(1)
        v_max=buf(2)
!
! ****** Set the advective time step limit and apply selected flow CFL.
!
        dtcfl=one/max(flow_cfl_max,small_value)
        dt_cfl_used=cfl*dtcfl
!
!-----------------------------------------------------------------------
! ****** Radiative loss time step limit so T>0.
!-----------------------------------------------------------------------
!
        dt_rad=huge(one)
        dt_rad_used=huge(one)
!
        if (radloss.ne.0) then
          allocate(temp_ek(nr,nt,np))
          allocate(qrad(nr,nt,np))
          allocate(dqrad(nr,nt,np))
!$acc enter data create(temp_ek,qrad,dqrad)
!
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            temp_ek(i,j,k)=fn_t*temp_e(i,j,k)
            dqrad(i,j,k)=0.
          enddo
!
          call get_qrad (qrad,temp_ek,nr*nt*np)
!
          if (ifimplrad.ne.0) then
            call get_dqrad (dqrad,temp_ek,nr*nt*np)
          end if
!
!$acc parallel loop collapse(3) default(present) &
!$acc  reduction(min:dt_rad)
!$omp parallel do collapse(3) default(shared) reduction(min:dt_rad)
          do k=2,npm1
            do j=2,ntm1
              do i=2,nrm1
                fne=rho(i,j,k)/he_rho
                radterm=(gamma-one)*radloss*(fne*he_np/he_p_x) &
                        *qrad(i,j,k)/fn_qrad
                dqdtemp=ifimplrad*radloss*(gamma-one) &
                        *(fne*he_np/he_p_x)*fn_t*dqrad(i,j,k)/fn_qrad
                dummy=max(1.e-20_r_typ,radterm-dqdtemp*temp_e(i,j,k))
                dt_rad=min(dt_rad,temp_e(i,j,k)/dummy)
              enddo
            enddo
          enddo
!$omp end parallel do
!
! ****** Get the minima over all processors and apply safety factor.
!
          call global_min (dt_rad)
          dt_rad_used=rad_limit_safety_factor*dt_rad
!
!$acc exit data delete(temp_ek,qrad,dqrad)
          deallocate(temp_ek)
          deallocate(qrad)
          deallocate(dqrad)
!
        end if
!
!-----------------------------------------------------------------------
! ****** Get the time step set by the maximum wave cfl limit.
!-----------------------------------------------------------------------
!
        wave_cfl_max=0.
!$acc parallel loop collapse(3) default(present) &
!$acc  reduction(max:wave_cfl_max)
!$omp parallel do collapse(3) default(shared) &
!$omp reduction(max:wave_cfl_max)
        do k=1,npm1
          do j=1,ntm1
            do i=1,nrm1
              avp  =AVGRTP(pres,i+1,j+1,k+1)
              avrho=AVGRTP(rho ,i+1,j+1,k+1)
              avbr =AVGR  (b%r ,i+1,j  ,k  )
              avbt =AVGT  (b%t ,i  ,j+1,k  )
              avbp =AVGP  (b%p ,i  ,j  ,k+1)
              bsq=avbr**2+avbt**2+avbp**2
              cssq=gamma*avp/avrho
              vasq=bsq/avrho
              if (tb0.and.j.eq.1) then
                st_inv=sth_i(2)
              else if (tb1.and.j.eq.ntm1) then
                st_inv=sth_i(ntm1)
              else
                st_inv=st_i(j)
              end if
              k2sq=four*( dr_i(i)**2 &
                         +(r_i(i)*dt_i(j))**2 &
                         +(r_i(i)*st_inv*dp_mult*dp_i(k))**2)
              wave_cfl=quarter*k2sq*(cssq+va_mult*vasq)
              wave_cfl_max=max(wave_cfl_max,wave_cfl)
            enddo
          enddo
        enddo
!$omp end parallel do
!
        wave_cfl_max=sqrt(wave_cfl_max)
!
        call global_max (wave_cfl_max)
!
        dt_wave=dt_max_wave_cfl/wave_cfl_max
!
! ****** If this is the first time setting the time step,
! ****** activate dt_init.
        if (ntime.eq.0.and. &
            (.not.restart_run.or.use_dt_init_on_restart).and. &
            dt_init.gt.0) then
          dt_init_used=dt_init
        else
          dt_init_used=huge(one)
        end if
!
! ****** Limit how much larger than the previous time step
! ****** the time step is allowed to be set.
!
        if (dt_max_increase_fac.gt.0) then
          dt_mxup=(one+dt_max_increase_fac)*dtime_old
        else
          dt_mxup=huge(one)
        end if
!
! ****** Set the time step to smallest of the various time step limits.
!
        dtime=min(dtmax,dt_cfl_used,dt_rad_used, &
                  dt_wave,dt_init_used,dt_mxup)
!
! ****** Determine the reason of the time step choice.
!
        if (dtime.eq.dt_cfl_used) then
          dtime_set_reason=' (flow)'
        elseif (dtime.eq.dt_rad_used) then
          dtime_set_reason=' (qrad)'
        elseif (dtime.eq.dtmax) then
          dtime_set_reason=' (dtmx)'
        elseif (dtime.eq.dt_init) then
          dtime_set_reason=' (init)'
        elseif (dtime.eq.dt_wave) then
          dtime_set_reason=' (mxwv)'
        elseif (dtime.eq.dt_mxup) then
          dtime_set_reason=' (mxup)'
        end if
!
! ****** Set the flow modification to the semi-implicit term
! ****** based on the flag SI_LOCAL_KV.
!
        if (si_local_kv) then
          do concurrent (k=1:npm1, j=1:ntm1, i=1:nrm1)
            cflv(i,j,k)=dtime*cflv(i,j,k)
          enddo
        else
          do concurrent (k=1:npm1, j=1:ntm1, i=1:nrm1)
            cflv(i,j,k)=flow_cfl_max*dtime
          enddo
        end if
!
! ****** Compute the semi-implicit coefficient based on
! ****** this time step.
!
        si_max=0.
        vasq_max=0.
        cssq_max=0.
        wave_cfl_max=0.
!$acc parallel loop collapse(3) default(present) &
!$acc  reduction(max:wave_cfl_max,si_max,vasq_max,cssq_max)
!$omp parallel do collapse(3) default(shared) &
!$omp reduction(max:wave_cfl_max,si_max,vasq_max,cssq_max)
        do k=1,npm1
          do j=1,ntm1
            do i=1,nrm1
              avp  =AVGRTP(pres,i+1,j+1,k+1)
              avrho=AVGRTP(rho ,i+1,j+1,k+1)
              avbr =AVGR  (b%r ,i+1,j  ,k  )
              avbt =AVGT  (b%t ,i  ,j+1,k  )
              avbp =AVGP  (b%p ,i  ,j  ,k+1)
              bsq=avbr**2+avbt**2+avbp**2
              cssq=gamma*avp/avrho
              vasq=bsq/avrho
              if (tb0.and.j.eq.1) then
                st_inv=sth_i(2)
              else if (tb1.and.j.eq.ntm1) then
                st_inv=sth_i(ntm1)
              else
                st_inv=st_i(j)
              end if
              k2sq=four*( dr_i(i)**2 &
                         +(r_i(i)*dt_i(j))**2 &
                         +(r_i(i)*st_inv*dp_mult*dp_i(k))**2)
              wave_cfl=quarter*k2sq*(cssq+va_mult*vasq)*dtime**2
              ffac=one/max((one-fac_cflv*cflv(i,j,k))**2,small_value)
              sifac(i,j,k)=max(wave_cfl*ffac-one,zero) &
                           /(dtime**2*k2sq)
              wave_cfl_max=max(wave_cfl_max,wave_cfl)
              si_max=max(si_max,sifac(i,j,k))
              vasq_max=max(vasq_max,vasq)
              cssq_max=max(cssq_max,cssq)
            enddo
          enddo
        enddo
!$omp end parallel do
!
        wave_cfl_max=sqrt(wave_cfl_max)
        va_max=sqrt(vasq_max)
        cs_max=sqrt(cssq_max)
!
! ****** Get the maxima over all processors.
! ****** (Combine all quantities into a buffer for efficiency.)
!
        buf(1)=wave_cfl_max
        buf(2)=si_max
        buf(3)=va_max
        buf(4)=cs_max
        call global_max_v (4,buf)
        wave_cfl_max=buf(1)
        si_max=buf(2)
        va_max=buf(3)
        cs_max=buf(4)
!
! ****** Set the CFL numbers for diagnostic purposes.
!
        flow_cfl=flow_cfl_max*dtime
        wave_cfl=wave_cfl_max
!
! ****** When SI_AGGRESSIVE=.false., set the semi-implicit
! ****** coefficient to be uniform and equal to its maximum value.
! ****** When SI_AGGRESSIVE=.true., set a non-uniform
! ****** semi-implicit coefficient.
!
        if (.not.si_aggressive) then
          do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
            sifac(i,j,k)=si_max
          enddo
        end if
!
! ****** The factor SIMULT multiplies the computed value of the
! ****** semi-implicit factor.
!
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          sifac(i,j,k)=simult*sifac(i,j,k)
        enddo
        si_max=simult*si_max
!
        call seam_scalar (sifac,nrm,ntm,npm)
!
      end if
!
! ****** Check that DTIME exceeds DTMIN.
! ****** If it does not, print a message and set the
! ****** abort flag, IFABORT.
!
      if (dtime.le.dtmin) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from SETDT:'
          write (*,*) '### Time step is smaller than DTMIN.'
          write (*,*) 'DTIME = ',dtime
          write (*,*) 'DTMIN = ',dtmin
          write (*,*) 'NTIME = ',ntime
          write (*,*) 'TIME = ',time
          write (9,*)
          write (9,*) '### WARNING from SETDT:'
          write (9,*) '### Time step is smaller than DTMIN.'
          write (9,*) 'DTIME = ',dtime
          write (9,*) 'DTMIN = ',dtmin
          write (9,*) 'NTIME = ',ntime
          write (9,*) 'TIME = ',time
        end if
        ifabort=.true.
      end if
!
! ****** Print diagnostics if requested.
!
      if (idebug.gt.0) then
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from SETDT:'
          write (9,*) 'NTIME    = ',ntime
          write (9,*) 'TIME     = ',time
          write (9,*) 'DTIME    = ',dtime
          write (9,*) 'DTCFL    = ',dtcfl
          write (9,*) 'DT_RAD   = ',dt_rad
          write (9,*) 'DT_WAVE  = ',dt_wave
          write (9,*) 'FLOW_CFL = ',flow_cfl
          write (9,*) 'WAVE_CFL = ',wave_cfl
          write (9,*) 'SI_MAX   = ',si_max
          write (9,*) 'V_MAX    = ',v_max
          write (9,*) 'VA_MAX   = ',va_max
          write (9,*) 'CS_MAX   = ',cs_max
          write (9,*) 'DT_SET_R = ',dtime_set_reason
        end if
      end if
!
!$acc exit data delete(cflv)
end subroutine
!#######################################################################
subroutine celleta
!
!-----------------------------------------------------------------------
!
! ****** Compute a resistivity at each cell based on local parameters.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use dissipation_profiles
      use mpidefs
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: avvr,avvt,avvp,eta_r,eta_t,eta_p,eta_max
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      if (dynamic_eta) then
!
! ****** Compute ETACEL based on upwind diffusion.  RMCELL specifies
! ****** the cell magnetic Reynolds number.  RMCELL=2 is standard
! ****** upwind.  RMCELL_ETAMAX is the maximum allowed value for
! ****** ETACEL.
!
        if (rmcell.gt.0.) then
          do k=1,npm1
            do j=1,ntm1
              do i=1,nrm1
                avvr=AVGTP(v%r,i  ,j+1,k+1)
                avvt=AVGRP(v%t,i+1,j  ,k+1)
                avvp=AVGRT(v%p,i+1,j+1,k  )
                eta_r=abs(avvr)*dr(i)
                eta_t=abs(avvt)*r(i)*dt(j)
                eta_p=abs(avvp)*r(i)*st(j)*dp(k)
                eta_max=max(eta_r,eta_t,eta_p)/rmcell
                etacel(i,j,k)=min(eta_max,rmcell_etamax)
              enddo
            enddo
          enddo
        else
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in CELLETA:'
            write (*,*) '### Cell Reynolds number is not positive.'
            write (*,*) 'RMCELL = ',rmcell
            write (*,*)
          end if
          call endrun (.true.)
        end if
!
        call seam (etacel)
!
      else
        etacel(:,:,:)=0.
      end if
!$acc update device(etacel)
!
end subroutine
!#######################################################################
subroutine seam_avec (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of an A vector between adjacent
! ****** processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : avec
      use globals
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ),dimension(nrm1,np) :: sbuf21r,rbuf21r,sbuf22r,rbuf22r
      real(r_typ),dimension(ntm1,np) :: sbuf11t,rbuf11t,sbuf12t,rbuf12t
      real(r_typ),dimension(nt,npm1) :: sbuf11p,rbuf11p,sbuf12p,rbuf12p
      real(r_typ),dimension(nr,npm1) :: sbuf21p,rbuf21p,sbuf22p,rbuf22p
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tags for MPI_ISEND and MPI_IRECV.
!
      integer :: tagr=0
      integer :: tagt=1
      integer :: tagp=2
!
!-----------------------------------------------------------------------
!
      integer :: lbuf3r,lbuf3t,lbuf3p
      integer :: lbuf1r,lbuf1t,lbuf1p
      integer :: lbuf2r,lbuf2t,lbuf2p
      integer :: n1r,n2r,n3r,n1t,n2t,n3t,n1p,n2p,n3p
      integer :: req(8)
!
      if (use_timer) call timer (TIME_SEAM)
!
!-----------------------------------------------------------------------
! ****** Get the dimensions of the arrays and buffer sizes:
      n1r=nrm1; n2r=nt;   n3r=np
      n1t=nr;   n2t=ntm1; n3t=np
      n1p=nr;   n2p=nt;   n3p=npm1
!
      lbuf3r=n1r*n2r;    lbuf3t=n1t*n2t;    lbuf3p=n1p*n2p
      lbuf1r=n2r*n3r;    lbuf1t=n2t*n3t;    lbuf1p=n2p*n3p
      lbuf2r=n1r*n3r;    lbuf2t=n1t*n3t;    lbuf2p=n1p*n3p
!
! ****** Seam the third (periodic) dimension. Since seam data
!        is stride-1 in this case, no buffers are needed.
!
! ****** Launch async receives.
!
!$acc host_data use_device(a%r,a%t)
      call MPI_Irecv (a%r(:,:,  1),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(1),ierr)
      call MPI_Irecv (a%r(:,:,n3r),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(2),ierr)
      call MPI_Irecv (a%t(:,:,  1),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(3),ierr)
      call MPI_Irecv (a%t(:,:,n3t),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
      call MPI_Isend (a%r(:,:,n3r-1),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(5),ierr)
      call MPI_Isend (a%r(:,:,    2),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(6),ierr)
      call MPI_Isend (a%t(:,:,n3t-1),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(7),ierr)
      call MPI_Isend (a%t(:,:,    2),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
      call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Seam the first dimension.
!
      if (nproc_r.gt.1) then
!
! ****** Load buffers.
!
!$acc enter data create(sbuf11t,sbuf12t,sbuf11p,sbuf12p, &
!$acc                   rbuf11t,rbuf12t,rbuf11p,rbuf12p)
        do concurrent (j=1:n3t, i=1:n2t)
          sbuf11t(i,j)=a%t(n1t-1,i,j)
          sbuf12t(i,j)=a%t(    2,i,j)
        enddo
!
        do concurrent (j=1:n3p, i=1:n2p)
          sbuf11p(i,j)=a%p(n1p-1,i,j)
          sbuf12p(i,j)=a%p(    2,i,j)
        enddo
!
!$acc host_data use_device(sbuf11t,sbuf12t,sbuf11p,sbuf12p, &
!$acc                      rbuf11t,rbuf12t,rbuf11p,rbuf12p)
        call MPI_Irecv (rbuf11t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf12t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf11p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf12p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf11t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(5),ierr)
        call MPI_Isend (sbuf12t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(6),ierr)
        call MPI_Isend (sbuf11p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf12p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_rm.ne.MPI_PROC_NULL) then
          do concurrent (j=1:n3t, i=1:n2t)
            a%t(1,i,j)=rbuf11t(i,j)
          enddo
!
          do concurrent (j=1:n3p, i=1:n2p)
            a%p(1,i,j)=rbuf11p(i,j)
          enddo
        end if
!
        if (iproc_rp.ne.MPI_PROC_NULL) then
          do concurrent (j=1:n3t, i=1:n2t)
            a%t(n1t,i,j)=rbuf12t(i,j)
          enddo
!
          do concurrent (j=1:n3p, i=1:n2p)
            a%p(n1p,i,j)=rbuf12p(i,j)
          enddo
        end if
!$acc exit data delete(sbuf11t,sbuf12t,sbuf11p,sbuf12p, &
!$acc                  rbuf11t,rbuf12t,rbuf11p,rbuf12p)
!
      end if
!
! ****** Seam the second dimension.
!
      if (nproc_t.gt.1) then
!$acc enter data create(sbuf21r,sbuf22r,sbuf21p,sbuf22p, &
!$acc                   rbuf21r,rbuf22r,rbuf21p,rbuf22p)
!
        do concurrent (k=1:n3r, j=1:n1r)
          sbuf21r(j,k)=a%r(j,n2r-1,k)
          sbuf22r(j,k)=a%r(j,    2,k)
        enddo
!
        do concurrent (k=1:n3p, j=1:n1p)
          sbuf21p(j,k)=a%p(j,n2p-1,k)
          sbuf22p(j,k)=a%p(j,    2,k)
        enddo
!
!$acc host_data use_device(sbuf21r,sbuf22r,sbuf21p,sbuf22p, &
!$acc                      rbuf21r,rbuf22r,rbuf21p,rbuf22p)
        call MPI_Irecv (rbuf21r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf22r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf21p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf22p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf21r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(5),ierr)
        call MPI_Isend (sbuf22r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(6),ierr)
        call MPI_Isend (sbuf21p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf22p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_tm.ne.MPI_PROC_NULL) then
!
          do concurrent (k=1:n3r, j=1:n1r)
            a%r(j,1,k)=rbuf21r(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n1p)
            a%p(j,1,k)=rbuf21p(j,k)
          enddo
        end if
!
        if (iproc_tp.ne.MPI_PROC_NULL) then
!
          do concurrent (k=1:n3r, j=1:n1r)
            a%r(j,n2r,k)=rbuf22r(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n1p)
            a%p(j,n2p,k)=rbuf22p(j,k)
          enddo
        end if
!$acc exit data delete(sbuf21r,sbuf22r,sbuf21p,sbuf22p, &
!$acc                  rbuf21r,rbuf22r,rbuf21p,rbuf22p)
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_avec_cpu (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of an A vector between adjacent
! ****** processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : avec
      use globals
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(avec) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ),dimension(nrm1,np) :: sbuf21r,rbuf21r,sbuf22r,rbuf22r
      real(r_typ),dimension(ntm1,np) :: sbuf11t,rbuf11t,sbuf12t,rbuf12t
      real(r_typ),dimension(nt,npm1) :: sbuf11p,rbuf11p,sbuf12p,rbuf12p
      real(r_typ),dimension(nr,npm1) :: sbuf21p,rbuf21p,sbuf22p,rbuf22p
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tags for MPI_ISEND and MPI_IRECV.
!
      integer :: tagr=0
      integer :: tagt=1
      integer :: tagp=2
!
!-----------------------------------------------------------------------
!
      integer :: lbuf3r,lbuf3t,lbuf3p
      integer :: lbuf1r,lbuf1t,lbuf1p
      integer :: lbuf2r,lbuf2t,lbuf2p
      integer :: n1r,n2r,n3r,n1t,n2t,n3t,n1p,n2p,n3p
      integer :: req(8)
!
      if (use_timer) call timer (TIME_SEAM)
!
!-----------------------------------------------------------------------
! ****** Get the dimensions of the arrays and buffer sizes:
      n1r=nrm1; n2r=nt;   n3r=np
      n1t=nr;   n2t=ntm1; n3t=np
      n1p=nr;   n2p=nt;   n3p=npm1
!
      lbuf3r=n1r*n2r;    lbuf3t=n1t*n2t;    lbuf3p=n1p*n2p
      lbuf1r=n2r*n3r;    lbuf1t=n2t*n3t;    lbuf1p=n2p*n3p
      lbuf2r=n1r*n3r;    lbuf2t=n1t*n3t;    lbuf2p=n1p*n3p
!
! ****** Seam the third (periodic) dimension. Since seam data
!        is stride-1 in this case, no buffers are needed.
!
! ****** Launch async receives.
!
      call MPI_Irecv (a%r(:,:,  1),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(1),ierr)
      call MPI_Irecv (a%r(:,:,n3r),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(2),ierr)
      call MPI_Irecv (a%t(:,:,  1),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(3),ierr)
      call MPI_Irecv (a%t(:,:,n3t),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
      call MPI_Isend (a%r(:,:,n3r-1),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(5),ierr)
      call MPI_Isend (a%r(:,:,    2),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(6),ierr)
      call MPI_Isend (a%t(:,:,n3t-1),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(7),ierr)
      call MPI_Isend (a%t(:,:,    2),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
      call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!
! ****** Seam the first dimension.
!
      if (nproc_r.gt.1) then
!
! ****** Load buffers.
!
        sbuf11t(:,:)=a%t(n1t-1,:,:)
        sbuf12t(:,:)=a%t(    2,:,:)
        sbuf11p(:,:)=a%p(n1p-1,:,:)
        sbuf12p(:,:)=a%p(    2,:,:)
!
        call MPI_Irecv (rbuf11t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf12t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf11p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf12p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf11t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(5),ierr)
        call MPI_Isend (sbuf12t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(6),ierr)
        call MPI_Isend (sbuf11p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf12p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!
! ****** Unload buffers.
!
        if (iproc_rm.ne.MPI_PROC_NULL) then
           a%t(1,:,:)=rbuf11t(:,:)
           a%p(1,:,:)=rbuf11p(:,:)
        end if
        if (iproc_rp.ne.MPI_PROC_NULL) then
           a%t(n1t,:,:)=rbuf12t(:,:)
           a%p(n1p,:,:)=rbuf12p(:,:)
        end if
!
      end if
!
! ****** Seam the second dimension.
!
      if (nproc_t.gt.1) then
!
        sbuf21r(:,:)=a%r(:,n2r-1,:)
        sbuf22r(:,:)=a%r(:,    2,:)
        sbuf21p(:,:)=a%p(:,n2p-1,:)
        sbuf22p(:,:)=a%p(:,    2,:)
!
        call MPI_Irecv (rbuf21r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf22r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf21p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf22p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf21r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(5),ierr)
        call MPI_Isend (sbuf22r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(6),ierr)
        call MPI_Isend (sbuf21p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf22p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!
! ****** Unload buffers.
!
        if (iproc_tm.ne.MPI_PROC_NULL) then
           a%r(:,1,:)=rbuf21r(:,:)
           a%p(:,1,:)=rbuf21p(:,:)
        end if
        if (iproc_tp.ne.MPI_PROC_NULL) then
           a%r(:,n2r,:)=rbuf22r(:,:)
           a%p(:,n2p,:)=rbuf22p(:,:)
        end if
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_bvec (b)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of a b-vector between adjacent
! ****** processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : bvec
      use globals
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
!
!-----------------------------------------------------------------------
!
      real(r_typ),dimension(nr,npm) :: sbuf21r,rbuf21r,sbuf22r,rbuf22r
      real(r_typ),dimension(nt,npm) :: sbuf11t,rbuf11t,sbuf12t,rbuf12t
      real(r_typ),dimension(ntm,np) :: sbuf11p,rbuf11p,sbuf12p,rbuf12p
      real(r_typ),dimension(nrm,np) :: sbuf21p,rbuf21p,sbuf22p,rbuf22p
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tags for MPI_ISEND and MPI_IRECV.
!
      integer :: tagr=0
      integer :: tagt=1
      integer :: tagp=2
!
!-----------------------------------------------------------------------
!
      integer :: lbuf3r,lbuf3t,lbuf3p
      integer :: lbuf1r,lbuf1t,lbuf1p
      integer :: lbuf2r,lbuf2t,lbuf2p
      integer :: n1r,n2r,n3r,n1t,n2t,n3t,n1p,n2p,n3p
      integer :: req(8)
      integer :: j,k
!
      if (use_timer) call timer (TIME_SEAM)
!
!-----------------------------------------------------------------------
! ****** Get the dimensions of the arrays and buffer sizes:
      n1r=nr;   n2r=ntm;  n3r=npm
      n1t=nrm;  n2t=nt;   n3t=npm
      n1p=nrm;  n2p=ntm;  n3p=np
!
      lbuf3r=n1r*n2r;    lbuf3t=n1t*n2t;    lbuf3p=n1p*n2p
      lbuf1r=n2r*n3r;    lbuf1t=n2t*n3t;    lbuf1p=n2p*n3p
      lbuf2r=n1r*n3r;    lbuf2t=n1t*n3t;    lbuf2p=n1p*n3p
!
! ****** Seam the third (periodic) dimension. Since seam data
!        is stride-1 in this case, no buffers are needed.
!
! ****** Launch async receives.
!
!$acc host_data use_device(b%r,b%t)
      call MPI_Irecv (b%r(:,:,  1),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(1),ierr)
      call MPI_Irecv (b%r(:,:,n3r),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(2),ierr)
      call MPI_Irecv (b%t(:,:,  1),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(3),ierr)
      call MPI_Irecv (b%t(:,:,n3t),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
      call MPI_Isend (b%r(:,:,n3r-1),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(5),ierr)
      call MPI_Isend (b%r(:,:,    2),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(6),ierr)
      call MPI_Isend (b%t(:,:,n3t-1),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(7),ierr)
      call MPI_Isend (b%t(:,:,    2),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
      call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Seam the first dimension.
!
      if (nproc_r.gt.1) then
!
! ****** Load buffers.
!
!$acc enter data create(sbuf11t,sbuf12t,sbuf11p,sbuf12p, &
!$acc                   rbuf11t,rbuf12t,rbuf11p,rbuf12p)
        do concurrent (k=1:n3t, j=1:n2t)
          sbuf11t(j,k)=b%t(n1t-1,j,k)
          sbuf12t(j,k)=b%t(    2,j,k)
        enddo
!
        do concurrent (k=1:n3p, j=1:n2p)
          sbuf11p(j,k)=b%p(n1p-1,j,k)
          sbuf12p(j,k)=b%p(    2,j,k)
        enddo
!
!$acc host_data use_device(sbuf11t,sbuf12t,sbuf11p,sbuf12p, &
!$acc                      rbuf11t,rbuf12t,rbuf11p,rbuf12p)
        call MPI_Irecv (rbuf11t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf12t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf11p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf12p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf11t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(5),ierr)
        call MPI_Isend (sbuf12t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(6),ierr)
        call MPI_Isend (sbuf11p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf12p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_rm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3t, j=1:n2t)
            b%t(1,j,k)=rbuf11t(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n2p)
            b%p(1,j,k)=rbuf11p(j,k)
          enddo
        end if
!
        if (iproc_rp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3t, j=1:n2t)
            b%t(n1t,j,k)=rbuf12t(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n2p)
            b%p(n1p,j,k)=rbuf12p(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf11t,sbuf12t,sbuf11p,sbuf12p, &
!$acc                  rbuf11t,rbuf12t,rbuf11p,rbuf12p)
!
      end if
!
! ****** Seam the second dimension.
!
      if (nproc_t.gt.1) then
!
!$acc enter data create(sbuf21r,sbuf22r,sbuf21p,sbuf22p, &
!$acc                   rbuf21r,rbuf22r,rbuf21p,rbuf22p)
!
        do concurrent (k=1:n3r, j=1:n1r)
          sbuf21r(j,k)=b%r(j,n2r-1,k)
          sbuf22r(j,k)=b%r(j,    2,k)
        enddo
!
        do concurrent (k=1:n3p, j=1:n1p)
          sbuf21p(j,k)=b%p(j,n2p-1,k)
          sbuf22p(j,k)=b%p(j,    2,k)
        enddo
!
!$acc host_data use_device(sbuf21r,sbuf22r,sbuf21p,sbuf22p, &
!$acc                      rbuf21r,rbuf22r,rbuf21p,rbuf22p)
        call MPI_Irecv (rbuf21r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf22r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf21p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf22p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(4),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf21r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(5),ierr)
        call MPI_Isend (sbuf22r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(6),ierr)
        call MPI_Isend (sbuf21p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf22p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(8),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (8,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_tm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3r, j=1:n1r)
            b%r(j,1,k)=rbuf21r(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n1p)
            b%p(j,1,k)=rbuf21p(j,k)
          enddo
        end if
!
        if (iproc_tp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3r, j=1:n1r)
            b%r(j,n2r,k)=rbuf22r(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n1p)
            b%p(j,n2p,k)=rbuf22p(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf21r,sbuf22r,sbuf21p,sbuf22p, &
!$acc                  rbuf21r,rbuf22r,rbuf21p,rbuf22p)
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_vvec (v)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of a v vector between adjacent
! ****** processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types, ONLY : vvec
      use mpidefs
      use timing
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      real(r_typ), dimension(:,:,:), pointer, contiguous :: vr,vt,vp
!
!-----------------------------------------------------------------------
!
      real(r_typ),dimension(:,:),allocatable :: sbuf1r,rbuf1r
      real(r_typ),dimension(:,:),allocatable :: sbuf2r,rbuf2r
      real(r_typ),dimension(:,:),allocatable :: sbuf1t,rbuf1t
      real(r_typ),dimension(:,:),allocatable :: sbuf2t,rbuf2t
      real(r_typ),dimension(:,:),allocatable :: sbuf1p,rbuf1p
      real(r_typ),dimension(:,:),allocatable :: sbuf2p,rbuf2p
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tags for MPI_ISEND and MPI_IRECV.
!
      integer :: tagr=0
      integer :: tagt=1
      integer :: tagp=2
!
!-----------------------------------------------------------------------
!
      integer :: lbuf3r,lbuf3t,lbuf3p
      integer :: lbuf1r,lbuf1t,lbuf1p
      integer :: lbuf2r,lbuf2t,lbuf2p
      integer :: n1r,n2r,n3r,n1t,n2t,n3t,n1p,n2p,n3p
      integer :: req(12)
      integer :: i,j,k
!
      if (use_timer) call timer (TIME_SEAM)
!
!-----------------------------------------------------------------------
!
      vr=>v%r
      vt=>v%t
      vp=>v%p
!
! ****** Get the dimensions of the arrays and buffer sizes:
!
      n1r=nrm;  n2r=nt;   n3r=np
      n1t=nr;   n2t=ntm;  n3t=np
      n1p=nr;   n2p=nt;   n3p=npm
!
      lbuf3r=n1r*n2r;    lbuf3t=n1t*n2t;    lbuf3p=n1p*n2p
      lbuf1r=n2r*n3r;    lbuf1t=n2t*n3t;    lbuf1p=n2p*n3p
      lbuf2r=n1r*n3r;    lbuf2t=n1t*n3t;    lbuf2p=n1p*n3p
!
! ****** Seam the third (periodic) dimension. Since seam data
!        is stride-1 in this case, no buffers are needed.
!
! ****** Launch async receives.
!
!$acc host_data use_device(vr,vt,vp)
      call MPI_Irecv (vr(:,:,  1),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(1),ierr)
      call MPI_Irecv (vr(:,:,n3r),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(2),ierr)
      call MPI_Irecv (vt(:,:,  1),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(3),ierr)
      call MPI_Irecv (vt(:,:,n3t),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(4),ierr)
      call MPI_Irecv (vp(:,:,  1),lbuf3p,ntype_real,iproc_pm,tagp, &
                      comm_all,req(5),ierr)
      call MPI_Irecv (vp(:,:,n3p),lbuf3p,ntype_real,iproc_pp,tagp, &
                      comm_all,req(6),ierr)
!
! ****** Launch async sends.
!
      call MPI_Isend (vr(:,:,n3r-1),lbuf3r,ntype_real,iproc_pp,tagr, &
                      comm_all,req(7),ierr)
      call MPI_Isend (vr(:,:,    2),lbuf3r,ntype_real,iproc_pm,tagr, &
                      comm_all,req(8),ierr)
      call MPI_Isend (vt(:,:,n3t-1),lbuf3t,ntype_real,iproc_pp,tagt, &
                      comm_all,req(9),ierr)
      call MPI_Isend (vt(:,:,    2),lbuf3t,ntype_real,iproc_pm,tagt, &
                      comm_all,req(10),ierr)
      call MPI_Isend (vp(:,:,n3p-1),lbuf3p,ntype_real,iproc_pp,tagp, &
                      comm_all,req(11),ierr)
      call MPI_Isend (vp(:,:,    2),lbuf3p,ntype_real,iproc_pm,tagp, &
                      comm_all,req(12),ierr)
!
! ****** Wait for all seams to complete.
!
      call MPI_Waitall (12,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Seam the first dimension.
!
      if (nproc_r.gt.1) then
!
! ****** Load buffers.
!
        allocate (sbuf1r(n2r,n3r),rbuf1r(n2r,n3r), &
                  sbuf2r(n2r,n3r),rbuf2r(n2r,n3r), &
                  sbuf1t(n2t,n3t),rbuf1t(n2t,n3t), &
                  sbuf2t(n2t,n3t),rbuf2t(n2t,n3t), &
                  sbuf1p(n2p,n3p),rbuf1p(n2p,n3p), &
                  sbuf2p(n2p,n3p),rbuf2p(n2p,n3p))
!$acc enter data create(sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
!$acc                   rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
!
        do concurrent (k=1:n3r, j=1:n2r)
          sbuf1r(j,k)=vr(n1r-1,j,k)
          sbuf2r(j,k)=vr(    2,j,k)
        enddo
!
        do concurrent (k=1:n3t, j=1:n2t)
          sbuf1t(j,k)=vt(n1t-1,j,k)
          sbuf2t(j,k)=vt(    2,j,k)
        enddo
!
        do concurrent (k=1:n3p, j=1:n2p)
          sbuf1p(j,k)=vp(n1p-1,j,k)
          sbuf2p(j,k)=vp(    2,j,k)
        enddo
!
!$acc host_data use_device(sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
!$acc                      rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
        call MPI_Irecv (rbuf1r,lbuf1r,ntype_real,iproc_rm,tagr, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf2r,lbuf1r,ntype_real,iproc_rp,tagr, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf1t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf2t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(4),ierr)
        call MPI_Irecv (rbuf1p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(5),ierr)
        call MPI_Irecv (rbuf2p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(6),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf1r,lbuf1r,ntype_real,iproc_rp,tagr, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf2r,lbuf1r,ntype_real,iproc_rm,tagr, &
                        comm_all,req(8),ierr)
        call MPI_Isend (sbuf1t,lbuf1t,ntype_real,iproc_rp,tagt, &
                        comm_all,req(9),ierr)
        call MPI_Isend (sbuf2t,lbuf1t,ntype_real,iproc_rm,tagt, &
                        comm_all,req(10),ierr)
        call MPI_Isend (sbuf1p,lbuf1p,ntype_real,iproc_rp,tagp, &
                        comm_all,req(11),ierr)
        call MPI_Isend (sbuf2p,lbuf1p,ntype_real,iproc_rm,tagp, &
                        comm_all,req(12),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (12,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_rm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3r, j=1:n2r)
            vr(1,j,k)=rbuf1r(j,k)
          enddo
!
          do concurrent (k=1:n3t, j=1:n2t)
            vt(1,j,k)=rbuf1t(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n2p)
            vp(1,j,k)=rbuf1p(j,k)
          enddo
        end if
!
        if (iproc_rp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3r, j=1:n2r)
            vr(n1r,j,k)=rbuf2r(j,k)
          enddo
!
          do concurrent (k=1:n3t, j=1:n2t)
            vt(n1t,j,k)=rbuf2t(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n2p)
            vp(n1p,j,k)=rbuf2p(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
!$acc                  rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
        deallocate (sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
                    rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
!
      end if
!
! ****** Seam the second dimension.
!
      if (nproc_t.gt.1) then
!
        allocate (sbuf1r(n1r,n3r),rbuf1r(n1r,n3r), &
                  sbuf2r(n1r,n3r),rbuf2r(n1r,n3r), &
                  sbuf1t(n1t,n3t),rbuf1t(n1t,n3t), &
                  sbuf2t(n1t,n3t),rbuf2t(n1t,n3t), &
                  sbuf1p(n1p,n3p),rbuf1p(n1p,n3p), &
                  sbuf2p(n1p,n3p),rbuf2p(n1p,n3p))
!$acc enter data create(sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
!$acc                   rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
!
        do concurrent (k=1:n3r, j=1:n1r)
          sbuf1r(j,k)=vr(j,n2r-1,k)
          sbuf2r(j,k)=vr(j,    2,k)
        enddo
!
        do concurrent (k=1:n3t, j=1:n1t)
          sbuf1t(j,k)=vt(j,n2t-1,k)
          sbuf2t(j,k)=vt(j,    2,k)
        enddo
!
        do concurrent (k=1:n3p, j=1:n1p)
          sbuf1p(j,k)=vp(j,n2p-1,k)
          sbuf2p(j,k)=vp(j,    2,k)
        enddo
!
!$acc host_data use_device(sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
!$acc                      rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
        call MPI_Irecv (rbuf1r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf2r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(2),ierr)
        call MPI_Irecv (rbuf1t,lbuf2t,ntype_real,iproc_tm,tagt, &
                        comm_all,req(3),ierr)
        call MPI_Irecv (rbuf2t,lbuf2t,ntype_real,iproc_tp,tagt, &
                        comm_all,req(4),ierr)
        call MPI_Irecv (rbuf1p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(5),ierr)
        call MPI_Irecv (rbuf2p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(6),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf1r,lbuf2r,ntype_real,iproc_tp,tagr, &
                        comm_all,req(7),ierr)
        call MPI_Isend (sbuf2r,lbuf2r,ntype_real,iproc_tm,tagr, &
                        comm_all,req(8),ierr)
        call MPI_Isend (sbuf1t,lbuf2t,ntype_real,iproc_tp,tagt, &
                        comm_all,req(9),ierr)
        call MPI_Isend (sbuf2t,lbuf2t,ntype_real,iproc_tm,tagt, &
                        comm_all,req(10),ierr)
        call MPI_Isend (sbuf1p,lbuf2p,ntype_real,iproc_tp,tagp, &
                        comm_all,req(11),ierr)
        call MPI_Isend (sbuf2p,lbuf2p,ntype_real,iproc_tm,tagp, &
                        comm_all,req(12),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (12,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_tm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3r, j=1:n1r)
            vr(j,1,k)=rbuf1r(j,k)
          enddo
!
          do concurrent (k=1:n3t, j=1:n1t)
            vt(j,1,k)=rbuf1t(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n1p)
            vp(j,1,k)=rbuf1p(j,k)
          enddo
        end if
!
        if (iproc_tp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3r, j=1:n1r)
            vr(j,n2r,k)=rbuf2r(j,k)
          enddo
!
          do concurrent (k=1:n3t,j=1:n1t)
            vt(j,n2t,k)=rbuf2t(j,k)
          enddo
!
          do concurrent (k=1:n3p, j=1:n1p)
            vp(j,n2p,k)=rbuf2p(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
!$acc                  rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
        deallocate (sbuf1r,sbuf2r,sbuf1t,sbuf2t,sbuf1p,sbuf2p, &
                    rbuf1r,rbuf2r,rbuf1t,rbuf2t,rbuf1p,rbuf2p)
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_scalar (x,n1,n2,n3)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of a 3D scalar field between adjacent
! ****** processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n1,n2,n3
      real(r_typ), dimension(n1,n2,n3) :: x
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:), allocatable :: sbuf1,rbuf1
      real(r_typ), dimension(:,:), allocatable :: sbuf2,rbuf2
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tags for MPI_ISEND and MPI_IRECV.
!
      integer :: tag=0
!
!-----------------------------------------------------------------------
!
      integer :: lbuf3,lbuf1,lbuf2
      integer :: req(4)
      integer :: j,k
!
      if (use_timer) call timer (TIME_SEAM)
!
!-----------------------------------------------------------------------
!
! ****** Get the buffer sizes:
!
      lbuf3=n1*n2
      lbuf1=n2*n3
      lbuf2=n1*n3
!
! ****** Seam the third (periodic) dimension. Since seam data
!        is stride-1 in this case, no buffers are needed.
!
! ****** Launch async receives.
!
!$acc host_data use_device(x)
      call MPI_Irecv (x(:,:, 1),lbuf3,ntype_real,iproc_pm,tag, &
                      comm_all,req(1),ierr)
      call MPI_Irecv (x(:,:,n3),lbuf3,ntype_real,iproc_pp,tag, &
                      comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
      call MPI_Isend (x(:,:,n3-1),lbuf3,ntype_real,iproc_pp,tag, &
                      comm_all,req(3),ierr)
      call MPI_Isend (x(:,:,   2),lbuf3,ntype_real,iproc_pm,tag, &
                      comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
      call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Seam the first dimension.
!
      if (nproc_r.gt.1) then
!
! ****** Load buffers.
!
        allocate (sbuf1(n2,n3),rbuf1(n2,n3),sbuf2(n2,n3),rbuf2(n2,n3))
!$acc enter data create(sbuf1,sbuf2,rbuf1,rbuf2)
!
        do concurrent (k=1:n3, j=1:n2)
          sbuf1(j,k)=x(n1-1,j,k)
          sbuf2(j,k)=x(   2,j,k)
        enddo
!
!$acc host_data use_device(sbuf1,sbuf2,rbuf1,rbuf2)
        call MPI_Irecv (rbuf1,lbuf1,ntype_real,iproc_rm,tag, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf2,lbuf1,ntype_real,iproc_rp,tag, &
                        comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf1,lbuf1,ntype_real,iproc_rp,tag, &
                        comm_all,req(3),ierr)
        call MPI_Isend (sbuf2,lbuf1,ntype_real,iproc_rm,tag, &
                        comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_rm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n2)
            x(1,j,k)=rbuf1(j,k)
          enddo
        end if
        if (iproc_rp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n2)
            x(n1,j,k)=rbuf2(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf1,sbuf2,rbuf1,rbuf2)
        deallocate (sbuf1,rbuf1,sbuf2,rbuf2)
!
      end if
!
! ****** Seam the second dimension.
!
      if (nproc_t.gt.1) then
!
        allocate (sbuf1(n1,n3),rbuf1(n1,n3),sbuf2(n1,n3),rbuf2(n1,n3))
!$acc enter data create(sbuf1,sbuf2,rbuf1,rbuf2)
!
        do concurrent (k=1:n3, j=1:n1)
          sbuf1(j,k)=x(j,n2-1,k)
          sbuf2(j,k)=x(j,   2,k)
        enddo
!
!$acc host_data use_device(sbuf1,sbuf2,rbuf1,rbuf2)
        call MPI_Irecv (rbuf1,lbuf2,ntype_real,iproc_tm,tag, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf2,lbuf2,ntype_real,iproc_tp,tag, &
                        comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf1,lbuf2,ntype_real,iproc_tp,tag, &
                        comm_all,req(3),ierr)
        call MPI_Isend (sbuf2,lbuf2,ntype_real,iproc_tm,tag, &
                        comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_tm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n1)
            x(j,1,k)=rbuf1(j,k)
          enddo
        end if
        if (iproc_tp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n1)
            x(j,n2,k)=rbuf2(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf1,sbuf2,rbuf1,rbuf2)
        deallocate (sbuf1,sbuf2,rbuf1,rbuf2)
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_scalar_xd (x,n1,n2,n3,seam_r,seam_t,seam_p)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of a 3D scalar field between adjacent
! ****** processors.  Allows user to specify which directions to seam.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n1,n2,n3
      real(r_typ), dimension(n1,n2,n3) :: x
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:), allocatable :: sbuf1,rbuf1
      real(r_typ), dimension(:,:), allocatable :: sbuf2,rbuf2
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tags for MPI_ISEND and MPI_IRECV.
!
      integer :: tag=0
!
!-----------------------------------------------------------------------
!
      integer :: lbuf3,lbuf1,lbuf2
      logical :: seam_r,seam_t,seam_p
      integer :: req(4)
      integer :: j,k
!
      if (use_timer) call timer (TIME_SEAM)
!
!-----------------------------------------------------------------------
!
! ****** Get the buffer sizes:
!
      lbuf3=n1*n2
      lbuf1=n2*n3
      lbuf2=n1*n3
!
! ****** Seam the third (periodic) dimension. Since seam data
!        is stride-1 in this case, no buffers are needed.
      if (seam_p) then
!
! ****** Launch async receives.
!
!$acc host_data use_device(x)
        call MPI_Irecv (x(:,:, 1),lbuf3,ntype_real,iproc_pm,tag, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (x(:,:,n3),lbuf3,ntype_real,iproc_pp,tag, &
                        comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (x(:,:,n3-1),lbuf3,ntype_real,iproc_pp,tag, &
                        comm_all,req(3),ierr)
        call MPI_Isend (x(:,:,   2),lbuf3,ntype_real,iproc_pm,tag, &
                        comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Seam the first dimension.
!
      end if
!
      if (nproc_r.gt.1.and.seam_r) then
!
! ****** Load buffers.
!
        allocate (sbuf1(n2,n3),rbuf1(n2,n3),sbuf2(n2,n3),rbuf2(n2,n3))
!$acc enter data create(sbuf1,sbuf2,rbuf1,rbuf2)
!
        do concurrent (k=1:n3, j=1:n2)
          sbuf1(j,k)=x(n1-1,j,k)
          sbuf2(j,k)=x(   2,j,k)
        enddo
!
!$acc host_data use_device(rbuf1,sbuf1,rbuf2,sbuf2)
        call MPI_Irecv (rbuf1,lbuf1,ntype_real,iproc_rm,tag, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf2,lbuf1,ntype_real,iproc_rp,tag, &
                        comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf1,lbuf1,ntype_real,iproc_rp,tag, &
                        comm_all,req(3),ierr)
        call MPI_Isend (sbuf2,lbuf1,ntype_real,iproc_rm,tag, &
                        comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_rm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n2)
            x(1,j,k)=rbuf1(j,k)
          enddo
        end if
        if (iproc_rp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n2)
            x(n1,j,k)=rbuf2(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf1,sbuf2,rbuf1,rbuf2)
        deallocate (sbuf1,rbuf1,sbuf2,rbuf2)
!
      end if
!
! ****** Seam the second dimension.
!
      if (nproc_t.gt.1.and.seam_t) then
!
        allocate (sbuf1(n1,n3),rbuf1(n1,n3),sbuf2(n1,n3),rbuf2(n1,n3))
!$acc enter data create(sbuf1,sbuf2,rbuf1,rbuf2)
!
        do concurrent (k=1:n3, j=1:n1)
          sbuf1(j,k)=x(j,n2-1,k)
          sbuf2(j,k)=x(j,   2,k)
        enddo
!
!$acc host_data use_device(rbuf1,sbuf1,rbuf2,sbuf2)
        call MPI_Irecv (rbuf1,lbuf2,ntype_real,iproc_tm,tag, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf2,lbuf2,ntype_real,iproc_tp,tag, &
                        comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf1,lbuf2,ntype_real,iproc_tp,tag, &
                        comm_all,req(3),ierr)
        call MPI_Isend (sbuf2,lbuf2,ntype_real,iproc_tm,tag, &
                        comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_tm.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n1)
            x(j,1,k)=rbuf1(j,k)
          enddo
        end if
        if (iproc_tp.ne.MPI_PROC_NULL) then
          do concurrent (k=1:n3, j=1:n1)
            x(j,n2,k)=rbuf2(j,k)
          enddo
        end if
!
!$acc exit data delete(sbuf1,sbuf2,rbuf1,rbuf2)
        deallocate (sbuf1,sbuf2,rbuf1,rbuf2)
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_3d (seam1,seam2,seam3,a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D (r,t,p) array A between
! ****** adjacent processors.
!
! ****** The logical flags SEAM1, SEAM2, and SEAM3 indicate which
! ****** dimensions are to be seamed.
!
! ****** This routine assumes that there is a two-point
! ****** overlap between processors in each dimension.
!
!-----------------------------------------------------------------------
!
! ****** This version uses non-blocking MPI sends and receives
! ****** whenever possible in order to overlap communications.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: seam1,seam2,seam3
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(size(a,2),size(a,3)) :: sbuf11,rbuf11
      real(r_typ), dimension(size(a,2),size(a,3)) :: sbuf12,rbuf12
      real(r_typ), dimension(size(a,1),size(a,3)) :: sbuf21,rbuf21
      real(r_typ), dimension(size(a,1),size(a,3)) :: sbuf22,rbuf22
      real(r_typ), dimension(size(a,1),size(a,2)) :: sbuf31,rbuf31
      real(r_typ), dimension(size(a,1),size(a,2)) :: sbuf32,rbuf32
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tag for MPI_ISEND and MPI_IRECV (not tagged).
!
      integer :: tag=0
!
!-----------------------------------------------------------------------
!
      integer :: lbuf
      integer :: n1,n2,n3
      integer :: req(4)
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_SEAM)
!
! ****** Get the dimensions of the array.
!
      n1=size(a,1)
      n2=size(a,2)
      n3=size(a,3)
!
! ****** Seam the third (periodic) dimension.
!
      if (seam3) then
!
        lbuf=n1*n2
!
        sbuf31(:,:)=a(:,:,n3-1)
        sbuf32(:,:)=a(:,:,   2)
!
        call MPI_Irecv (rbuf31,lbuf,ntype_real,iproc_pm,tag, &
                        comm_all,req(1),ierr)
!
        call MPI_Irecv (rbuf32,lbuf,ntype_real,iproc_pp,tag, &
                        comm_all,req(2),ierr)
!
        call MPI_Isend (sbuf31,lbuf,ntype_real,iproc_pp,tag, &
                        comm_all,req(3),ierr)
!
        call MPI_Isend (sbuf32,lbuf,ntype_real,iproc_pm,tag, &
                        comm_all,req(4),ierr)
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!
        a(:,:, 1)=rbuf31(:,:)
        a(:,:,n3)=rbuf32(:,:)
!
      end if
!
! ****** Seam the first dimension.
!
      if (seam1.and.nproc_r.gt.1) then
!
        lbuf=n2*n3
!
        sbuf11(:,:)=a(n1-1,:,:)
        sbuf12(:,:)=a(   2,:,:)
!
        call MPI_Irecv (rbuf11,lbuf,ntype_real,iproc_rm,tag, &
                        comm_all,req(1),ierr)
!
        call MPI_Irecv (rbuf12,lbuf,ntype_real,iproc_rp,tag, &
                        comm_all,req(2),ierr)
!
        call MPI_Isend (sbuf11,lbuf,ntype_real,iproc_rp,tag, &
                        comm_all,req(3),ierr)
!
        call MPI_Isend (sbuf12,lbuf,ntype_real,iproc_rm,tag, &
                        comm_all,req(4),ierr)
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!
        if (iproc_rm .ne. MPI_PROC_NULL) then
          a( 1,:,:)=rbuf11(:,:)
        end if
!
        if (iproc_rp .ne. MPI_PROC_NULL) then
          a(n1,:,:)=rbuf12(:,:)
        end if
!
      end if
!
! ****** Seam the second dimension.
!
      if (seam2.and.nproc_t.gt.1) then
!
        lbuf=n1*n3
!
        sbuf21(:,:)=a(:,n2-1,:)
        sbuf22(:,:)=a(:,   2,:)
!
        call MPI_Irecv (rbuf21,lbuf,ntype_real,iproc_tm,tag, &
                        comm_all,req(1),ierr)
!
        call MPI_Irecv (rbuf22,lbuf,ntype_real,iproc_tp,tag, &
                        comm_all,req(2),ierr)
!
        call MPI_Isend (sbuf21,lbuf,ntype_real,iproc_tp,tag, &
                        comm_all,req(3),ierr)
!
        call MPI_Isend (sbuf22,lbuf,ntype_real,iproc_tm,tag, &
                        comm_all,req(4),ierr)
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!
        if (iproc_tm .ne. MPI_PROC_NULL) then
          a(:, 1,:)=rbuf21(:,:)
        end if
!
        if (iproc_tp .ne. MPI_PROC_NULL) then
          a(:,n2,:)=rbuf22(:,:)
        end if
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_2d (seam1,seam2,a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 2D (t,p) array A between
! ****** adjacent processors.
!
! ****** The logical flags SEAM1 and SEAM2 indicate which
! ****** dimensions are to be seamed.
!
! ****** This routine assumes that there is a two-point
! ****** overlap between processors in each dimension.
!
!-----------------------------------------------------------------------
!
! ****** This version uses non-blocking MPI sends and receives
! ****** whenever possible in order to overlap communications.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: seam1,seam2
      real(r_typ), dimension(:,:) :: a
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(size(a,2)) :: sbuf11,rbuf11
      real(r_typ), dimension(size(a,2)) :: sbuf12,rbuf12
      real(r_typ), dimension(size(a,1)) :: sbuf21,rbuf21
      real(r_typ), dimension(size(a,1)) :: sbuf22,rbuf22
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tag for MPI_ISEND and MPI_IRECV (not tagged).
!
      integer :: tag=0
!
!-----------------------------------------------------------------------
!
      integer :: lbuf
      integer :: n1,n2
      integer :: req(4)
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_SEAM)
!
! ****** Get the dimensions of the array.
!
      n1=size(a,1)
      n2=size(a,2)
!
! ****** Seam the second (periodic) dimension.
!
      if (seam2) then
!
        lbuf=n1
!
        sbuf21(:)=a(:,n2-1)
        sbuf22(:)=a(:,   2)
!
        call MPI_Irecv (rbuf21,lbuf,ntype_real,iproc_pm,tag, &
                        comm_all,req(1),ierr)
!
        call MPI_Irecv (rbuf22,lbuf,ntype_real,iproc_pp,tag, &
                        comm_all,req(2),ierr)
!
        call MPI_Isend (sbuf21,lbuf,ntype_real,iproc_pp,tag, &
                        comm_all,req(3),ierr)
!
        call MPI_Isend (sbuf22,lbuf,ntype_real,iproc_pm,tag, &
                        comm_all,req(4),ierr)
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!
        a(:, 1)=rbuf21(:)
        a(:,n2)=rbuf22(:)
!
      end if
!
! ****** Seam the first dimension.
!
      if (seam1.and.nproc_t.gt.1) then
!
        lbuf=n2
!
        sbuf11(:)=a(n1-1,:)
        sbuf12(:)=a(   2,:)
!
        call MPI_Irecv (rbuf11,lbuf,ntype_real,iproc_tm,tag, &
                        comm_all,req(1),ierr)
!
        call MPI_Irecv (rbuf12,lbuf,ntype_real,iproc_tp,tag, &
                        comm_all,req(2),ierr)
!
        call MPI_Isend (sbuf11,lbuf,ntype_real,iproc_tp,tag, &
                        comm_all,req(3),ierr)
!
        call MPI_Isend (sbuf12,lbuf,ntype_real,iproc_tm,tag, &
                        comm_all,req(4),ierr)
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!
        if (iproc_tm .ne. MPI_PROC_NULL) then
          a( 1,:)=rbuf11(:)
        end if
!
        if (iproc_tp .ne. MPI_PROC_NULL) then
          a(n1,:)=rbuf12(:)
        end if
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam_2d_tp (x,n1,n2,seam1,seam2)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of a 2D (t,p) scalar
! ****** field between adjacent processors.
!
! ****** The logical flags SEAM1 and SEAM2 indicate which
! ****** dimensions are to be seamed.
!
! ****** This routine assumes that there is a two-point
! ****** overlap between processors in each dimension.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n1,n2
      real(r_typ), dimension(n1,n2) :: x
      logical :: seam1,seam2
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: sbuf1,sbuf2,rbuf1,rbuf2
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
! ****** MPI tags for MPI_ISEND and MPI_IRECV.
!
      integer :: tag=0
!
!-----------------------------------------------------------------------
!
      integer :: i
      integer :: req(4)
!
      if (use_timer) call timer (TIME_SEAM)
!
!-----------------------------------------------------------------------
!
! ****** Get the buffer sizes:
!
      if (seam2) then
!
! ****** Seam the phi dimension. Since seam data
!        is stride-1 in this case, no buffers are needed.
!
! ****** Launch async receives.
!
!$acc host_data use_device(x)
        call MPI_Irecv (x(:, 1),n1,ntype_real,iproc_pm,tag, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (x(:,n2),n1,ntype_real,iproc_pp,tag, &
                        comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (x(:,n2-1),n1,ntype_real,iproc_pp,tag, &
                        comm_all,req(3),ierr)
        call MPI_Isend (x(:,   2),n1,ntype_real,iproc_pm,tag, &
                        comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
      end if
!
! ****** Seam the first dimension.
!
      if (seam1.and.nproc_t.gt.1) then
!
! ****** Load buffers.
!
        allocate (sbuf1(n2),sbuf2(n2),rbuf1(n2),rbuf2(n2))
!$acc enter data create(sbuf1,sbuf2,rbuf1,rbuf2)
!
        do concurrent (i=1:n2)
          sbuf1(i)=x(n1-1,i)
          sbuf2(i)=x(   2,i)
        enddo
!
!$acc host_data use_device(sbuf1,sbuf2,rbuf1,rbuf2)
        call MPI_Irecv (rbuf1,n2,ntype_real,iproc_tm,tag, &
                        comm_all,req(1),ierr)
        call MPI_Irecv (rbuf2,n2,ntype_real,iproc_tp,tag, &
                        comm_all,req(2),ierr)
!
! ****** Launch async sends.
!
        call MPI_Isend (sbuf1,n2,ntype_real,iproc_tp,tag, &
                        comm_all,req(3),ierr)
        call MPI_Isend (sbuf2,n2,ntype_real,iproc_tm,tag, &
                        comm_all,req(4),ierr)
!
! ****** Wait for all seams to complete.
!
        call MPI_Waitall (4,req,MPI_STATUSES_IGNORE,ierr)
!$acc end host_data
!
! ****** Unload buffers.
!
        if (iproc_tm.ne.MPI_PROC_NULL) then
          do concurrent (i=1:n2)
            x(1,i)=rbuf1(i)
          enddo
        end if
!
        if (iproc_tp.ne.MPI_PROC_NULL) then
          do concurrent (i=1:n2)
            x(n1,i)=rbuf2(i)
          enddo
        end if
!
!$acc exit data delete(sbuf1,sbuf2,rbuf1,rbuf2)
        deallocate (sbuf1,sbuf2,rbuf1,rbuf2)
!
      end if
!
      if (use_timer) call timer (TIME_SEAM)
!
end subroutine
!#######################################################################
subroutine seam (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D array A between adjacent
! ****** processors along all three dimensions.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_3d (.true.,.true.,.true.,a)
!
end subroutine
!#######################################################################
subroutine seam_rp (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D array A between adjacent
! ****** processors along the r and phi dimensions.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_3d (.true.,.false.,.true.,a)
!
end subroutine
!#######################################################################
subroutine seam_tp (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D array A between adjacent
! ****** processors along the theta and phi dimensions.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_3d (.false.,.true.,.true.,a)
!
end subroutine
!#######################################################################
subroutine seam_rt (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D array A between adjacent
! ****** processors along the r and theta dimensions.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_3d (.true.,.true.,.false.,a)
!
end subroutine
!#######################################################################
subroutine seam_r (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D array A between adjacent
! ****** processors along the r dimension.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_3d (.true.,.false.,.false.,a)
!
end subroutine
!#######################################################################
subroutine seam_t (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D array A between adjacent
! ****** processors along the theta dimension.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_3d (.false.,.true.,.false.,a)
!
end subroutine
!#######################################################################
subroutine seam_p (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 3D array A between adjacent
! ****** processors along the phi dimension.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_3d (.false.,.false.,.true.,a)
!
end subroutine
!#######################################################################
subroutine seam_tp_2d (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 2D array A between adjacent
! ****** processors along the theta and phi dimensions.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_2d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_2d (.true.,.true.,a)
!
end subroutine
!#######################################################################
subroutine seam_t_2d (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 2D array A between adjacent
! ****** processors along the theta dimension.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_2d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_2d (.true.,.false.,a)
!
end subroutine
!#######################################################################
subroutine seam_p_2d (a)
!
!-----------------------------------------------------------------------
!
! ****** Seam the boundary points of 2D array A between adjacent
! ****** processors along the phi dimension.
!
!-----------------------------------------------------------------------
!
      use number_types
      use seam_2d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:) :: a
!
!-----------------------------------------------------------------------
!
      call seam_2d (.false.,.true.,a)
!
end subroutine
!#######################################################################
subroutine global_min (x)
!
!-----------------------------------------------------------------------
!
! ****** Overwrite X by the its minimum over all processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the minimum over all processors.
!
      if (use_timer) call timer (TIME_MINMAX)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,1,ntype_real, &
                          MPI_MIN,comm_all,ierr)
!
      if (use_timer) call timer (TIME_MINMAX)
!
end subroutine
!#######################################################################
subroutine global_min_loc (x,idx)
!
!-----------------------------------------------------------------------
!
! ****** Return MPI rank (idx) in comm_all which contains the minimum x.
! ****** The value of x is not changed.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x
      integer :: idx
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      real(4), dimension(2) :: x_idx_local
      real(4), dimension(2) :: x_idx_global
!
!-----------------------------------------------------------------------
!
      x_idx_local(2)=real(iproc,4)
      x_idx_local(1)=real(x,4)
!
! ****** Take the minimum over all processors.
!
      if (use_timer) call timer (TIME_MINMAX)
!
      call MPI_Allreduce (x_idx_local,x_idx_global,1,MPI_2REAL, &
                          MPI_MINLOC,comm_all,ierr);
!
      if (use_timer) call timer (TIME_MINMAX)
!
      idx=int(x_idx_global(2))
end subroutine
!#######################################################################
subroutine global_min_v (n,x)
!
!-----------------------------------------------------------------------
!
! ****** Return the minimum of each element of the array X
! ****** over all processors.
!
! ****** Each element of the array X is overwritten by its minimum
! ****** over all processors upon return.
!
!-----------------------------------------------------------------------
!
! ****** This routine is used for efficiency in communication
! ****** when multiple min operations are needed (rather than
! ****** calling GLOBAL_MIN multiple times in sequence).
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: x
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the minimum over all processors.
!
      if (use_timer) call timer (TIME_MINMAX)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,n,ntype_real, &
                          MPI_MIN,comm_all,ierr)
!
      if (use_timer) call timer (TIME_MINMAX)
!
end subroutine
!#######################################################################
subroutine global_max (x)
!
!-----------------------------------------------------------------------
!
! ****** Overwrite X by the its maximum over all processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the maximum over all processors.
!
      if (use_timer) call timer (TIME_MINMAX)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,1,ntype_real, &
                          MPI_MAX,comm_all,ierr)
!
      if (use_timer) call timer (TIME_MINMAX)
!
end subroutine
!#######################################################################
subroutine global_max_v (n,x)
!
!-----------------------------------------------------------------------
!
! ****** Return the maximum of each element of the array X
! ****** over all processors.
!
! ****** Each element of the array X is overwritten by its maximum
! ****** over all processors upon return.
!
!-----------------------------------------------------------------------
!
! ****** This routine is used for efficiency in communication
! ****** when multiple max operations are needed (rather than
! ****** calling GLOBAL_MAX multiple times in sequence).
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: x
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the maximum over all processors.
!
      if (use_timer) call timer (TIME_MINMAX)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,n,ntype_real, &
                          MPI_MAX,comm_all,ierr)
!
      if (use_timer) call timer (TIME_MINMAX)
!
end subroutine
!#######################################################################
subroutine global_min_v_tp (n,x)
!
!-----------------------------------------------------------------------
!
! ****** Return the minimum of each element of the array X
! ****** over all processors in communicator COMM_TP.
!
! ****** Each element of the array X is overwritten by its minimum
! ****** over all processors upon return.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: x
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the minimum over all the processors in
! ****** communicator COMM_TP.
!
      if (use_timer) call timer (TIME_MINMAX)
!
!$acc host_data use_device(x) if_present
      call MPI_Allreduce (MPI_IN_PLACE,x,n,ntype_real, &
                          MPI_MIN,comm_tp,ierr)
!$acc end host_data
!
      if (use_timer) call timer (TIME_MINMAX)
!
end subroutine
!#######################################################################
subroutine global_sum (x)
!
!-----------------------------------------------------------------------
!
! ****** Overwrite X by the its sum over all processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the sum over all the processors.
!
      if (use_timer) call timer (TIME_SUM)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,1,ntype_real, &
                          MPI_SUM,comm_all,ierr)
!
      if (use_timer) call timer (TIME_SUM)
!
end subroutine
!#######################################################################
subroutine global_sum_int (x)
!
!-----------------------------------------------------------------------
!
! ****** Overwrite X by the its sum over all processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: x
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the sum over all the processors.
!
      if (use_timer) call timer (TIME_SUM)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,1,MPI_INTEGER, &
                          MPI_SUM,comm_all,ierr)
!
      if (use_timer) call timer (TIME_SUM)
!
end subroutine
!#######################################################################
subroutine global_sum_v (n,x)
!
!-----------------------------------------------------------------------
!
! ****** Return the sum of each element of the array X
! ****** over all processors.
!
! ****** Each element of the array X is overwritten by its sum
! ****** over all processors upon return.
!
!-----------------------------------------------------------------------
!
! ****** This routine is used for efficiency in communication
! ****** when multiple sum operations are needed (rather than
! ****** calling GLOBAL_SUM multiple times in sequence).
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: x
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the sum over all the processors.
!
      if (use_timer) call timer (TIME_SUM)
!
!$acc host_data use_device(x) if_present
      call MPI_Allreduce (MPI_IN_PLACE,x,n,ntype_real, &
                          MPI_SUM,comm_all,ierr)
!$acc end host_data
!
      if (use_timer) call timer (TIME_SUM)
!
end subroutine
!#######################################################################
subroutine global_sum_v_r (n,x)
!
!-----------------------------------------------------------------------
!
! ****** Return the sum of each element of the array X over all
! ****** processors in communicator COMM_R.
!
! ****** Each element of the array X is overwritten by its sum
! ****** over all processors upon return.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: x
!
!-----------------------------------------------------------------------
!
! ****** MPI error return.
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the sum over all the processors.
!
      if (use_timer) call timer (TIME_SUM)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,n,ntype_real, &
                          MPI_SUM,comm_r,ierr)
!
      if (use_timer) call timer (TIME_SUM)
!
end subroutine
!#######################################################################
subroutine global_sum_tp (x)
!
!-----------------------------------------------------------------------
!
! ****** Return the extended precision sum of X over the
! ****** processors in communicator COMM_TP.
!
! ****** X is overwritten by its sum over all processors upon return.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: x
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Take the sum over the processors in communicator COMM_TP.
!
      if (use_timer) call timer (TIME_SUM)
!
      call MPI_Allreduce (MPI_IN_PLACE,x,1,ntype_real, &
                          MPI_SUM,comm_tp,ierr)
!
      if (use_timer) call timer (TIME_SUM)
!
end subroutine
!#######################################################################
subroutine global_to_local (f_g,f)
!
!-----------------------------------------------------------------------
!
! ****** Load the 3D local array F from the global 3D array F_G
! ****** that is defined on processor IPROC0.
!
! ****** This routine must be called by all the processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:) :: f_g
      real(r_typ), dimension(:,:,:) :: f
!
!-----------------------------------------------------------------------
!
      integer :: n_r_g,n_t_g,n_p_g
      integer :: n_r,n_t,n_p
      integer :: i,j,k,i_g,j_g,k_g,ierr
      integer, dimension(3) :: ibuf
      real(r_typ), dimension(:,:,:), allocatable :: g_g
!
!-----------------------------------------------------------------------
!
! ****** Get the dimensions of the global array on IPROC0,
! ****** and send them to all processors.
!
      if (iamp0) then
        n_r_g=size(f_g,1)
        n_t_g=size(f_g,2)
        n_p_g=size(f_g,3)
        ibuf=(/n_r_g,n_t_g,n_p_g/)
      end if
!
      call MPI_Bcast (ibuf,3,MPI_INTEGER,iproc0,comm_all,ierr)
!
      n_r_g=ibuf(1)
      n_t_g=ibuf(2)
      n_p_g=ibuf(3)
!
      n_r=size(f,1)
      n_t=size(f,2)
      n_p=size(f,3)
!
! ****** Allocate G_G on all processors.  This array holds a copy
! ****** of F_G on all processors.  This is done in case F_G was
! ****** not allocated on processors other than IPROC0.
!
      allocate (g_g(n_r_g,n_t_g,n_p_g))
!
      if (iamp0) then
        g_g=f_g
      end if
!
! ****** Broadcast G_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (g_g,n_r_g*n_t_g*n_p_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
! ****** Load the local array F from the global array F_G.
!
! ****** Note that, for a periodic case, for an array defined on the
! ****** main mesh, for the local array on the rightmost processor
! ****** in the phi dimension, the last point in the phi dimension
! ****** does not map directly from the global array, but is loaded
! ****** from the cell with k_g=2.
!
      do k=1,n_p
        k_g=k0_g+k-1
        if (k_g.gt.n_p_g) k_g=k_g-n_p_g+1
        do j=1,n_t
          j_g=j0_g+j-1
          do i=1,n_r
            i_g=i0_g+i-1
            f(i,j,k)=g_g(i_g,j_g,k_g)
          enddo
        enddo
      enddo
!
! ****** Deallocate temporary storage.
!
      deallocate (g_g)
!
end subroutine
!#######################################################################
subroutine global_to_local_tp (f_g,f)
!
!-----------------------------------------------------------------------
!
! ****** Load the 2D local array F in the (t,p) plane from the
! ****** global 2D array F_G that is defined on processor IPROC0.
!
! ****** This routine must be called by all the processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:) :: f_g
      real(r_typ), dimension(:,:) :: f
!
!-----------------------------------------------------------------------
!
      integer :: n_t_g,n_p_g
      integer :: n_t,n_p
      integer :: j,k,j_g,k_g,ierr
      integer, dimension(2) :: ibuf
      real(r_typ), dimension(:,:), allocatable :: g_g
!
!-----------------------------------------------------------------------
!
! ****** Get the dimensions of the global array on IPROC0,
! ****** and send them to all processors.
!
      if (iamp0) then
        n_t_g=size(f_g,1)
        n_p_g=size(f_g,2)
        ibuf=(/n_t_g,n_p_g/)
      end if
!
      call MPI_Bcast (ibuf,2,MPI_INTEGER,iproc0,comm_all,ierr)
!
      n_t_g=ibuf(1)
      n_p_g=ibuf(2)
!
      n_t=size(f,1)
      n_p=size(f,2)
!
! ****** Allocate G_G on all processors.  This array holds a copy
! ****** of F_G on all processors.  This is done in case F_G was
! ****** not allocated on processors other than IPROC0.
!
      allocate (g_g(n_t_g,n_p_g))
!
      if (iamp0) then
        g_g=f_g
      end if
!
! ****** Broadcast G_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (g_g,n_t_g*n_p_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
! ****** Load the local array F from the global array G_G.
!
! ****** Note that, for a periodic case, for an array defined on the
! ****** main mesh, for the local array on the rightmost processor
! ****** in the phi dimension, the last point in the phi dimension
! ****** does not map directly from the global array, but is loaded
! ****** from the cell with k_g=2.
!
      do k=1,n_p
        k_g=k0_g+k-1
        if (k_g.gt.n_p_g) k_g=k_g-n_p_g+1
        do j=1,n_t
          j_g=j0_g+j-1
          f(j,k)=g_g(j_g,k_g)
        enddo
      enddo
!
! ****** Deallocate temporary storage.
!
      deallocate (g_g)
!
end subroutine
!#######################################################################
subroutine write_field (fname,ix,a)
!
!-----------------------------------------------------------------------
!
! ****** Write the 3D field A into HDF file FNAME.
! ****** IX is the index of the field in the field table.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use mpidefs
      use debug
      use assemble_array_interface
      use vars
      use field_table
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: ix
      real(r_typ), dimension(:,:,:) :: a
!
!-----------------------------------------------------------------------
!
! ****** Declaration for the global field array.  This array is only
! ****** allocated on processor IPROC0.
!
      real(r_typ), dimension(:,:,:), allocatable :: a_g
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: n1,n2,n3
!
!-----------------------------------------------------------------------
!$acc update self(a) if_present
!
      ierr=0
!
! ****** Allocate global array A_G (on processor IPROC0 only).
! ****** [An array with a single element is allocated on other
! ****** processors because some compilers (e.g., Lahey/Fujitsu
! ****** Fortran) do not like unallocated arrays as arguments.]
!
      n1=fldtab(ix)%n1_g
      n2=fldtab(ix)%n2_g
      n3=fldtab(ix)%n3_g
!
      if (iamp0) then
        allocate (a_g(n1,n2,n3))
      else
        allocate (a_g(1,1,1))
      end if
!
! ****** Assemble the local arrays A into the global array A_G
! ****** on processor IPROC0.
!
      call assemble_array (fldtab(ix)%map_r,fldtab(ix)%map_t, &
                           fldtab(ix)%map_p,a,a_g)
!
! ****** Write the field to an HDF file.
!
      if (idebug.gt.1) then
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from WRITE_FIELD:'
          write (9,*) 'Writing to file: ',trim(fname)
        end if
      end if
!
! ****** If this is a 2D run, write the field to a 2D HDF file.
!
      if (iamp0) then
        if (axisymmetric) then
          call wrhdf_2d (fname,.true.,n1,n2, &
                         a_g(:,:,2),fldtab(ix)%r_g,fldtab(ix)%t_g, &
                         hdf32,ierr)
          if (ierr.ne.0) then
            write (*,*)
            write (*,*) '### ERROR in WRITE_FIELD:'
            write (*,*) '### Error in WRHDF_2D while writing'// &
                        ' to file: ',trim(fname)
            write (*,*) 'IERR = ',ierr
          end if
        else
          call wrhdf_3d (fname,.true.,n1,n2,n3, &
                         a_g,fldtab(ix)%r_g,fldtab(ix)%t_g, &
                         fldtab(ix)%p_g,hdf32,ierr)
          if (ierr.ne.0) then
            write (*,*)
            write (*,*) '### ERROR in WRITE_FIELD:'
            write (*,*) '### Error in WRHDF_3D while writing'// &
                        ' to file: ',trim(fname)
            write (*,*) 'IERR = ',ierr
          end if
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Deallocate the global array.
!
      deallocate (a_g)
!
end subroutine
!#######################################################################
subroutine write_field_tp (fname,ix,a,iproc_r2use)
!
!-----------------------------------------------------------------------
!
! ****** Write the 2D field in local array A in the (t,p) plane
! ****** into HDF file FNAME.  The 2D field is collected and output
! ****** along the IPROC_R2USE r rank slice.
!
! ****** IX is the index of a field in the field table that has
! ****** the same structure as the field in the (t,p) plane.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use mpidefs
      use decomposition
      use field_table
      use assemble_array_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: ix,iproc_r2use
      real(r_typ), dimension(:,:) :: a
!
!-----------------------------------------------------------------------
!
      integer :: i,ierr
!
      real(r_typ), dimension(:,:),   allocatable :: a_g
!
!-----------------------------------------------------------------------
!
!$acc update self(a) if_present
      ierr=0
!
      if (iproc_r.eq.iproc_r2use) then
!
! ****** Assemble the local arrays A into the global
! ****** array A_G on processor iproc2d_tp=0.
!
        if (iproc2d_tp.eq.0) then
          allocate (a_g(fldtab(ix)%n2_g,fldtab(ix)%n3_g))
        else
          allocate (a_g(1,1))
        end if
!
        call assemble_array_tp (fldtab(ix)%maptp_t, &
                                fldtab(ix)%maptp_p, &
                                a,a_g)
!
! ****** Write a_g to an HDF file (on processor IPROC_TP=0) only.
!
        if (iproc2d_tp.eq.0) then
!
          call wrhdf_2d (fname,.true., &
                         fldtab(ix)%n2_g, &
                         fldtab(ix)%n3_g, &
                         a_g, &
                         fldtab(ix)%t_g, &
                         fldtab(ix)%p_g, &
                         hdf32,ierr)
!
          if (ierr.ne.0) then
            write (*,*)
            write (*,*) '### ERROR in WRITE_FIELD_TP:'
            write (*,*) '### Could not write the 2D HDF array.'
            write (*,*) '### Error in WRHDF_2D while writing'// &
                        ' to file: ',trim(fname)
            write (*,*) 'IERR = ',ierr
          end if
!
        end if
!
! ****** Deallocate temporary arrays.
!
        deallocate (a_g)
!
      end if
!
      call check_error_on_any_proc (ierr)
!
end subroutine
!#######################################################################
subroutine assemble_array (map_r,map_t,map_p,a,a_g)
!
!-----------------------------------------------------------------------
!
! ****** Assemble a global array (into A_G) on processor IPROC0 by
! ****** fetching the local sections (A) from all the processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use decomposition
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(map_struct), dimension(0:nproc-1) :: map_r,map_t,map_p
      real(r_typ), dimension(:,:,:) :: a,a_g
!
!-----------------------------------------------------------------------
!
! ****** Storage for the buffers.
!
      integer, dimension(0:nproc-1) :: lbuf,displ
      real(r_typ), dimension(:), allocatable :: sbuf
      real(r_typ), dimension(:), allocatable :: rbuf
      real(r_typ), dimension(:,:,:), allocatable :: a_l
!
!-----------------------------------------------------------------------
!
      integer :: lsbuf
      integer :: ierr,irank,l1,l2,l3,len_tot,m0,m1,i,j,k
      integer :: i0,j0,k0,i1,j1,k1
!
!-----------------------------------------------------------------------
!
! ****** Get the length of the local data array on each processor.
!
      do irank=0,nproc-1
        l1=map_r(irank)%n
        l2=map_t(irank)%n
        l3=map_p(irank)%n
        lbuf(irank)=l1*l2*l3
      enddo
!
! ****** Get the displacements for copying the local data array
! ****** on each processor to the receive buffer.
!
      displ(0)=0
      do irank=1,nproc-1
        displ(irank)=displ(irank-1)+lbuf(irank-1)
      enddo
!
! ****** Get the total memory required for the receive buffer.
!
      len_tot=displ(nproc-1)+lbuf(nproc-1)
!
! ****** Allocate the receive buffer array (only on processor IPROC0).
! ****** [An array with a single element is allocated on other
! ****** processors because some compilers (e.g., Lahey/Fujitsu
! ****** Fortran) do not like unallocated arrays as arguments.]
!
      if (iamp0) then
        allocate (rbuf(0:len_tot-1))
      else
        allocate (rbuf(0:0))
      end if
!
! ****** Copy the data from the local array into the send buffer.
!
      lsbuf=map_r(iproc)%n*map_t(iproc)%n*map_p(iproc)%n
!
      allocate (sbuf(lsbuf))
!
      i0=map_r(iproc)%i0
      i1=map_r(iproc)%i1
      j0=map_t(iproc)%i0
      j1=map_t(iproc)%i1
      k0=map_p(iproc)%i0
      k1=map_p(iproc)%i1
!
      sbuf=reshape(a(i0:i1,j0:j1,k0:k1),(/lsbuf/))
!
! ****** Gather the local arrays on each processor into the buffer
! ****** on processor IPROC0.
!
      if (use_timer) call timer (TIME_CIO)
      call MPI_Gatherv (sbuf,lsbuf,ntype_real,rbuf,lbuf,displ, &
                        ntype_real,iproc0,comm_all,ierr)
      if (use_timer) call timer (TIME_CIO)
!
! ****** Deallocate the send buffer.
!
      deallocate (sbuf)
!
! ****** Fill the global array from the buffer of local arrays
! ****** (only on processor IPROC0).
!
      if (iamp0) then
!
        do irank=0,nproc-1
!
          l1=map_r(irank)%n
          l2=map_t(irank)%n
          l3=map_p(irank)%n
!
! ****** Allocate the local array.
!
          allocate (a_l(l1,l2,l3))
!
! ****** Copy the section of the array for the processor with rank
! ****** IRANK from the receive buffer into the local array.
!
          m0=displ(irank)
          m1=displ(irank)+lbuf(irank)-1
          a_l=reshape(rbuf(m0:m1),(/l1,l2,l3/))
!
! ****** Fill the global array from the local array section.
!
          i0=map_r(irank)%offset
          j0=map_t(irank)%offset
          k0=map_p(irank)%offset
!
          do k=1,l3
            do j=1,l2
              do i=1,l1
                a_g(i0+i-1,j0+j-1,k0+k-1)=a_l(i,j,k)
              enddo
            enddo
          enddo
!
! ****** Deallocate the local array.
!
          deallocate (a_l)
!
        enddo
!
      end if
!
! ****** Deallocate the receive buffer.
!
      deallocate (rbuf)
!
end subroutine
!#######################################################################
subroutine assemble_array_tp (map_t,map_p,a,a_g)
!
!-----------------------------------------------------------------------
!
! ****** Assemble a global 2D tp array (into A_G) by
! ****** fetching the local sections (A) from all the processors
! ****** on the comm_tp communicator to MPI rank IPROCTP_2D=0.
! ****** MUST USE MAPTP_T and MAPTP_P MAPS!
!
!-----------------------------------------------------------------------
!
      use number_types
      use decomposition
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(map_struct), dimension(0:nproc_tp-1) :: map_t,map_p
      real(r_typ), dimension(:,:) :: a,a_g
!
!-----------------------------------------------------------------------
!
! ****** Storage for the buffers.
!
      integer, dimension(0:nproc_tp-1) :: lbuf,displ
      real(r_typ), dimension(:), allocatable :: sbuf
      real(r_typ), dimension(:), allocatable :: rbuf
      real(r_typ), dimension(:,:), allocatable :: a_l
!
!-----------------------------------------------------------------------
!
      integer :: lsbuf
      integer :: ierr,irank,l1,l2,l3,len_tot,m0,m1,i,j,k
      integer :: i0,j0,k0,i1,j1,k1
!
!-----------------------------------------------------------------------
!
! ****** Get the length of the local data array on each processor.
!
      do irank=0,nproc_tp-1
        l2=map_t(irank)%n
        l3=map_p(irank)%n
        lbuf(irank)=l2*l3
      enddo
!
! ****** Get the displacements for copying the local data array
! ****** on each processor to the receive buffer.
!
      displ(0)=0
      do irank=1,nproc_tp-1
        displ(irank)=displ(irank-1)+lbuf(irank-1)
      enddo
!
! ****** Get the total memory required for the receive buffer.
!
      len_tot=displ(nproc_tp-1)+lbuf(nproc_tp-1)
!
! ****** Allocate the receive buffer array.
!
      allocate (rbuf(0:len_tot-1))
!
! ****** Copy the data from the local array into the send buffer.
!
      lsbuf=map_t(iproc2d_tp)%n*map_p(iproc2d_tp)%n
!
      allocate (sbuf(lsbuf))
!
      j0=map_t(iproc2d_tp)%i0
      j1=map_t(iproc2d_tp)%i1
      k0=map_p(iproc2d_tp)%i0
      k1=map_p(iproc2d_tp)%i1
!
      sbuf=reshape(a(j0:j1,k0:k1),(/lsbuf/))
!
! ****** Gather the local arrays on each processor into the buffer
! ****** on processor 0 in COMM_TP.
!
      if (use_timer) call timer (TIME_CIO)
      call MPI_Gatherv (sbuf,lsbuf,ntype_real,rbuf,lbuf,displ, &
                        ntype_real,0,comm_tp,ierr)
      if (use_timer) call timer (TIME_CIO)
!
! ****** Deallocate the send buffer.
!
      deallocate (sbuf)
!
! ****** Fill the global array from the buffer of local arrays
! ****** (only on processor IPROC2D_TP==0).
!
      if (iproc2d_tp.eq.0) then
!
        do irank=0,nproc_tp-1
!
          l2=map_t(irank)%n
          l3=map_p(irank)%n
!
! ****** Allocate the local array.
!
          allocate (a_l(l2,l3))
!
! ****** Copy the section of the array for the processor with rank
! ****** IRANK from the receive buffer into the local array.
!
          m0=displ(irank)
          m1=displ(irank)+lbuf(irank)-1
          a_l=reshape(rbuf(m0:m1),(/l2,l3/))
!
! ****** Fill the global array from the local array section.
!
          j0=map_t(irank)%offset
          k0=map_p(irank)%offset
!
          do k=1,l3
            do j=1,l2
              a_g(j0+j-1,k0+k-1)=a_l(j,k)
            enddo
          enddo
!
! ****** Deallocate the local array.
!
          deallocate (a_l)
!
        enddo
!
      end if
!
! ****** Deallocate the receive buffer.
!
      deallocate (rbuf)
!
end subroutine
!#######################################################################
subroutine distribute_array (n1,n2,n3,a_g,a)
!
!-----------------------------------------------------------------------
!
! ****** Distribute the global array A_G on processor IPROC0 to
! ****** the local 3D arrays A by scattering to all processors.
!
!-----------------------------------------------------------------------
!
! ****** The arrays N1, N2, and N3 need to have the dimensions of the
! ****** local arrays on every processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use decomposition
      use mpidefs
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, dimension(0:nproc-1) :: n1,n2,n3
      real(r_typ), dimension(:,:,:) :: a_g,a
!
!-----------------------------------------------------------------------
!
! ****** Storage for the buffer.
!
      integer, dimension(0:nproc-1) :: lbuf,displ
      real(r_typ), dimension(:), allocatable :: buf
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k,m,n,i_g,j_g,k_g
      integer :: len_tot,irank,n_p_g,i0,j0,k0
!
!-----------------------------------------------------------------------
!
! ****** Get the length of the local data array on each processor.
!
      lbuf=n1*n2*n3
!
! ****** Get the total memory required for the buffer.
!
      len_tot=sum(lbuf(0:nproc-1))
!
! ****** Allocate the send buffer and fill it from the global
! ****** array (only on processor IPROC0).
! ****** [An array with a single element is allocated on other
! ****** processors because some compilers (e.g., Lahey/Fujitsu
! ****** Fortran) do not like unallocated arrays as arguments.]
!
! ****** Note that, for a periodic case, for an array defined on the
! ****** main mesh, for the local array on the rightmost processor
! ****** in the phi dimension, the last point in the phi dimension
! ****** does not map directly from the global array, but is loaded
! ****** from the cell with k_g=2.
!
      if (iamp0) then
        n_p_g=size(a_g,3)
        allocate (buf(0:len_tot-1))
        m=0
        do irank=0,nproc-1
          i0=decomp(irank)%i0_g
          j0=decomp(irank)%j0_g
          k0=decomp(irank)%k0_g
          displ(irank)=m
          do k=1,n3(irank)
            k_g=k0+k-1
            if (k_g.gt.n_p_g) k_g=k_g-n_p_g+1
            do j=1,n2(irank)
              j_g=j0+j-1
              do i=1,n1(irank)
                i_g=i0+i-1
                buf(m)=a_g(i_g,j_g,k_g)
                m=m+1
              enddo
            enddo
          enddo
        enddo
      else
        allocate (buf(0:0))
      end if
!
! ****** Scatter the buffer to the local arrays on each processor.
!
      n=size(a)
!
      if (use_timer) call timer (TIME_CIO)
      call MPI_Scatterv (buf,lbuf,displ,ntype_real, &
                         a,n,ntype_real,iproc0,comm_all,ierr)
      if (use_timer) call timer (TIME_CIO)
!
! ****** Deallocate the send buffer.
!
      deallocate (buf)
!
end subroutine
!#######################################################################
subroutine set_diagnostics
!
!-----------------------------------------------------------------------
!
! ****** Set switches for diagnostic quantities and fields to plot.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use field_table
      use diagnostics
      use decomposition
      use vars
      use mpidefs
      use ucase_interface
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, dimension(mxdiagp) :: dp_indx
      real(r_typ), dimension(mxdiagp) :: dp_rval,dp_tval,dp_pval
      character(8), dimension(mxdiagp) :: dp_type
      character(3) :: ch3seq
!
      integer :: ndq
      integer, dimension(mxdiagq) :: dq_indx
!
      integer :: i,j,k,n
      logical :: rin,tin,pin
!
      integer :: irank
      real(r_typ) :: rv,tv,pv
      real(r_typ) :: r_0,r_1
      real(r_typ) :: t_0,t_1
      real(r_typ) :: p_0,p_1
!
      integer :: ierr
!
      integer :: im_v,imp1_v
      integer :: ih_v,ihp1_v
      integer :: jm_v,jmp1_v
      integer :: jh_v,jhp1_v
      integer :: km_v,kmp1_v
      integer :: kh_v,khp1_v
      real(r_typ) :: amr_v,amt_v,amp_v
      real(r_typ) :: ahr_v,aht_v,ahp_v
!
! ****** Temporary array to hold field table names.
!
      character(len(fldtab(1)%name)), dimension(nfields) :: &
                                                         fldtab_names
!
!-----------------------------------------------------------------------
!
      integer, external :: match
!
!-----------------------------------------------------------------------
!
!-----------------------------------------------------------------------
! ****** Fields to plot (i.e., HDF dumps).
!-----------------------------------------------------------------------
!
! ****** Determine the requested number of fields to plot.
!
      do i=1,mxplot
        if (plotlist(i).eq.' ') exit
      enddo
      n=i-1
!
! ****** Use a temporary array to hold the field table names.
!
      fldtab_names(:)=fldtab(:)%name
!
! ****** Set the indices of the requested fields to plot.
!
      nplot=0
      if (n.eq.1.and.ucase(plotlist(1)).eq.'ALL') then
        do j=1,nfields
          nplot=nplot+1
          plot_index(nplot)=j
        enddo
      else
        do i=1,n
          j=match(plotlist(i),nfields,fldtab_names,.false.)
          if (j.gt.0) then
!
! ****** Check whether the requested field is available.
!
            if (.not.freeze_b.and.j.eq.IFLD_V_PAR) then
!
! ****** Skip plotting of v parallel if we are not using the
! ****** parallel flow model.
!
              if (iamp0) then
                write (*,*)
                write (*,*) '### WARNING from SET_DIAGNOSTICS:'
                write (*,*) '### An invalid plot field was requested.'
                write (*,*) '### You requested to plot the'// &
                            ' parallel flow velocity (V_PAR), but you'
                write (*,*) '### are not running the parallel'// &
                            ' flow model.'
                write (*,*) '### This field will be ignored.'
              end if
!
            else
!
! ****** Add the field to the plot list.
!
              nplot=nplot+1
              plot_index(nplot)=j
!
            end if
!
          else
            if (iamp0) then
              write (*,*)
              write (*,*) '### WARNING from SET_DIAGNOSTICS:'
              write (*,*) '### An invalid plot field was requested.'
              write (*,*) '### This field will be ignored.'
              write (*,*) 'Field requested: ',trim(plotlist(i))
            end if
          end if
        enddo
      end if
!
! ****** Write the names of the requested fields to plot.
!
      if (iamp0) then
        write (9,*)
        write (9,*) repeat('-',72)
        write (9,*)
        write (9,*) '### COMMENT from SET_DIAGNOSTICS:'
        write (9,*) 'Number of fields to plot = ',nplot
        if (nplot.gt.0) then
          write (9,*)
          write (9,*) 'Fields to plot:'
        end if
        do i=1,nplot
          write (9,*) trim(fldtab(plot_index(i))%name)
        enddo
      end if
!
!-----------------------------------------------------------------------
! ****** Fields to plot for slices.
!-----------------------------------------------------------------------
!
! ****** Determine the requested number of fields to plot.
!
      do i=1,mxplot
        if (slice_plotlist(i).eq.' ') exit
      enddo
      n=i-1
!
! ****** Use a temporary array to hold the field table names.
!
      fldtab_names(:)=fldtab(:)%name
!
! ****** Set the indices of the requested fields to plot.
!
      nplot_slices=0
      if (n.eq.1.and.ucase(slice_plotlist(1)).eq.'ALL') then
        do j=1,nfields
          nplot_slices=nplot_slices+1
          slice_plot_index(nplot_slices)=j
        enddo
      else
        do i=1,n
          j=match(slice_plotlist(i),nfields,fldtab_names,.false.)
          if (j.gt.0) then
!
! ****** Check whether the requested field is available.
!
            if (.not.freeze_b.and.j.eq.IFLD_V_PAR) then
!
! ****** Skip plotting of v parallel if we are not using the
! ****** parallel flow model.
!
              if (iamp0) then
                write (*,*)
                write (*,*) '### WARNING from SET_DIAGNOSTICS:'
                write (*,*) '### An invalid plot field was requested.'
                write (*,*) '### You requested to plot the'// &
                            ' parallel flow velocity (V_PAR), but you'
                write (*,*) '### are not running the parallel'// &
                            ' flow model.'
                write (*,*) '### This field will be ignored.'
              end if
!
            else
!
! ****** Add the field to the plot list.
!
              nplot_slices=nplot_slices+1
              slice_plot_index(nplot_slices)=j
!
            end if
!
          else
            if (iamp0) then
              write (*,*)
              write (*,*) '### WARNING from SET_DIAGNOSTICS:'
              write (*,*) '### An invalid plot field was requested.'
              write (*,*) '### This field will be ignored.'
              write (*,*) 'Field requested: ',trim(plotlist(i))
            end if
          end if
        enddo
      end if
!
! ****** Write the names of the requested fields to plot slices.
!
      if (iamp0) then
        write (9,*)
        write (9,*) repeat('-',72)
        write (9,*)
        write (9,*) '### COMMENT from SET_DIAGNOSTICS:'
        write (9,*) 'Number of slice fields to plot = ',nplot_slices
        if (nplot_slices.gt.0) then
          write (9,*)
          write (9,*) 'Fields to plot:'
        end if
        do i=1,nplot_slices
          write (9,*) trim(fldtab(slice_plot_index(i))%name)
        enddo
!
! ****** Write out the TP slice radii and indices table.
!
        if (n_tpslice_radii.gt.0) then
          write (9,*)
          write (9,*) '### COMMENT from SET_DIAGNOSTICS:'
          write (9,*) 'Slice indices with corresponding TP slice radii:'
          do i=1,n_tpslice_radii
            write (ch3seq,'(i3.3)') i
            write (9,*) ch3seq,' ',slice_tp_radii(i)
          enddo
        end if
      end if
!
!-----------------------------------------------------------------------
! ****** Diagnostic points.
!-----------------------------------------------------------------------
!
! ****** Determine the number of diagnostic points specified.
!
      ndiagp=0
      do i=1,mxdiagp
!
        select case (ucase(diag(i)%type))
        case ('VALUE')
!
          if (diag(i)%r.ne.NULL_VALUE.or. &
              diag(i)%t.ne.NULL_VALUE.or. &
              diag(i)%p.ne.NULL_VALUE) then
!
! ****** Check that the specified diagnostic point location is within
! ****** the physical domain, and store its parameters.
!
            if (diag(i)%r.lt.r0.or.diag(i)%r.gt.r1.or. &
                diag(i)%t.lt.t0.or.diag(i)%t.gt.t1.or. &
                diag(i)%p.lt.p0.or.diag(i)%p.gt.p1) then
              if (iamp0) then
                write (*,*)
                write (*,*) '### WARNING from SET_DIAGNOSTICS:'
                write (*,*) '### A diagnostic point location is'// &
                            ' outside the mesh limits.'
                write (*,*) 'Diagnostic point index: ',i
                write (*,*) 'Specified r location = ',diag(i)%r
                write (*,*) 'Specified t location = ',diag(i)%t
                write (*,*) 'Specified p location = ',diag(i)%p
                write (*,*) '### This diagnostic point will be'// &
                            ' ignored.'
              end if
            else
              ndiagp=ndiagp+1
              dp_indx(ndiagp)=i
              dp_type(ndiagp)='VALUE'
              dp_rval(ndiagp)=diag(i)%r
              dp_tval(ndiagp)=diag(i)%t
              dp_pval(ndiagp)=diag(i)%p
            end if
!
          end if
!
        case ('MIN','MAX','MINABS','MAXABS','NORM')
!
          ndiagp=ndiagp+1
          dp_indx(ndiagp)=i
          dp_type(ndiagp)=ucase(diag(i)%type)
          dp_rval(ndiagp)=0.
          dp_tval(ndiagp)=0.
          dp_pval(ndiagp)=0.
!
        case default
!
          if (iamp0) then
            write (*,*)
            write (*,*) '### WARNING from SET_DIAGNOSTICS:'
            write (*,*) '### Invalid diagnostic point type requested.'
            write (*,*) 'Diagnostic point index: ',i
            write (*,*) 'Requested type: ',trim(diag(i)%type)
            write (*,*) '### This diagnostic point will be ignored.'
          end if
!
        end select
!
      enddo
!
! ****** Allocate storage for the diagnostic point structure DIAGPT.
!
      allocate (diagpt(ndiagp))
!
! ****** Store the diagnostic point type and location in DIAGPT.
!
      do i=1,ndiagp
        diagpt(i)%type=dp_type(i)
        diagpt(i)%r=dp_rval(i)
        diagpt(i)%t=dp_tval(i)
        diagpt(i)%p=dp_pval(i)
      enddo
!
! ****** Locate the processor on which the diagnostic point resides
! ****** (only when the value at a point is requested).
!
      do i=1,ndiagp
        if (ucase(diagpt(i)%type).eq.'VALUE') then
          rv=diagpt(i)%r
          tv=diagpt(i)%t
          pv=diagpt(i)%p
          do irank=0,nproc-1
            r_0=r_g(decomp(irank)%i0_g)
            r_1=r_g(decomp(irank)%i1_g-1)
            t_0=t_g(decomp(irank)%j0_g)
            t_1=t_g(decomp(irank)%j1_g-1)
            p_0=p_g(decomp(irank)%k0_g)
            p_1=p_g(decomp(irank)%k1_g-1)
            rin=.false.
            if (decomp(irank)%iproc_r.eq.nproc_r-1) then
              if (rv.ge.r_0.and.rv.le.r_1) rin=.true.
            else
              if (rv.ge.r_0.and.rv.lt.r_1) rin=.true.
            end if
            tin=.false.
            if (decomp(irank)%iproc_t.eq.nproc_t-1) then
              if (tv.ge.t_0.and.tv.le.t_1) tin=.true.
            else
              if (tv.ge.t_0.and.tv.lt.t_1) tin=.true.
            end if
            pin=.false.
            if (decomp(irank)%iproc_p.eq.nproc_p-1) then
              if (pv.ge.p_0.and.pv.le.p_1) pin=.true.
            else
              if (pv.ge.p_0.and.pv.lt.p_1) pin=.true.
            end if
            if (rin.and.tin.and.pin) then
              diagpt(i)%iproc=irank
              exit
            end if
          enddo
          if (irank.ge.nproc) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in SET_DIAGNOSTICS:'
              write (*,*) '### Anomaly in locating the diagnostic'// &
                          ' point processor.'
              write (*,*) 'Diagnostic point location:'
              write (*,*) 'r = ',rv
              write (*,*) 't = ',tv
              write (*,*) 'p = ',pv
              write (*,*) '### [This is an internal error.]'
            end if
            call endrun (.true.)
          end if
        else
          diagpt(i)%iproc=iproc0
        end if
      enddo
!
! ****** Process the list of fields requested at each diagnostic
! ****** point.
!
      do i=1,ndiagp
!
! ****** Determine the number of diagnostic fields requested
! ****** for this point.
!
        do j=1,mxdiagq
          if (diag(dp_indx(i))%fields(j).eq.' ') exit
        enddo
        n=j-1
!
! ****** Set the indices of the diagnostic fields in DQ_INDX.
!
        ndq=0
        if (n.eq.1.and.ucase(diag(dp_indx(i))%fields(1)) &
            .eq.'ALL') then
          do k=1,nfields
            ndq=ndq+1
            dq_indx(ndq)=k
          enddo
        else
          do j=1,n
            k=match(diag(dp_indx(i))%fields(j), &
                    nfields,fldtab_names,.false.)
            if (k.gt.0) then
              ndq=ndq+1
              dq_indx(ndq)=k
            else
              if (iamp0) then
                write (*,*)
                write (*,*) '### WARNING from SET_DIAGNOSTICS:'
                write (*,*) '### An invalid diagnostic field was'// &
                            ' requested.'
                write (*,*) 'Diagnostic point index: ',dp_indx(i)
                write (*,*) 'Field requested: ', &
                            trim(diag(dp_indx(i))%fields(j))
                write (*,*) '### This field will be ignored.'
              end if
            end if
          enddo
        end if
!
        if (ndq.eq.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### WARNING from SET_DIAGNOSTICS:'
            write (*,*) '### No diagnostic fields were specified'// &
                        ' for a diagnostic point.'
            write (*,*) 'Diagnostic point index: ',dp_indx(i)
            write (*,*) '### This diagnostic point will not be useful.'
          end if
        end if
!
! ****** Set the number of diagnostic quantities for this point.
!
        diagpt(i)%nq=ndq
!
! ****** Allocate the structure for storage of the diagnostic
! ****** quantities.
!
        allocate (diagpt(i)%q(ndq))
!
! ****** Set names and pointers to the fields, as well as the
! ****** mesh-type flags.
!
        do j=1,ndq
          diagpt(i)%q(j)%name=fldtab(dq_indx(j))%name
          diagpt(i)%q(j)%fld=>fldtab(dq_indx(j))%f
          diagpt(i)%q(j)%rm=fldtab(dq_indx(j))%rm
          diagpt(i)%q(j)%tm=fldtab(dq_indx(j))%tm
          diagpt(i)%q(j)%pm=fldtab(dq_indx(j))%pm
        enddo
!
! ****** Allocate storage for the time history buffers.
! ****** If the value at the diagnostic point is being stored,
! ****** allocate storage only on the processor on which the
! ****** diagnostic point resides.
! ****** For global quantities, allocate storage on every
! ****** processor.
!
        if (ucase(diagpt(i)%type).eq.'VALUE') then
          if (iproc.eq.diagpt(i)%iproc) then
            do j=1,ndq
              allocate (diagpt(i)%q(j)%v(nhistmax))
            enddo
          end if
        else
          do j=1,ndq
            allocate (diagpt(i)%q(j)%v(nhistmax))
          enddo
        end if
!
! ****** Set the interpolation factors (only when the value
! ****** at a point is requested).
!
        if (ucase(diagpt(i)%type).eq.'VALUE') then
!
          ierr=0
          if (iproc.eq.diagpt(i)%iproc) then
            call interp (nrm1,r ,diagpt(i)%r,im_v,imp1_v,amr_v,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in SET_DIAGNOSTICS:'
              write (*,*) '### Anomaly in getting the interpolation'// &
                          ' factors for a diagnostic point.'
              write (*,*) '### [This is an internal error.]'
            end if
          end if
          call check_error_on_any_proc (ierr)
!
          ierr=0
          if (iproc.eq.diagpt(i)%iproc) then
            call interp (ntm1,t ,diagpt(i)%t,jm_v,jmp1_v,amt_v,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in SET_DIAGNOSTICS:'
              write (*,*) '### Anomaly in getting the interpolation'// &
                          ' factors for a diagnostic point.'
              write (*,*) '### [This is an internal error.]'
            end if
          end if
          call check_error_on_any_proc (ierr)
!
          ierr=0
          if (iproc.eq.diagpt(i)%iproc) then
            call interp (np  ,p ,diagpt(i)%p,km_v,kmp1_v,amp_v,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in SET_DIAGNOSTICS:'
              write (*,*) '### Anomaly in getting the interpolation'// &
                          ' factors for a diagnostic point.'
              write (*,*) '### [This is an internal error.]'
            end if
          end if
          call check_error_on_any_proc (ierr)
!
          ierr=0
          if (iproc.eq.diagpt(i)%iproc) then
            call interp (nr  ,rh,diagpt(i)%r,ih_v,ihp1_v,ahr_v,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in SET_DIAGNOSTICS:'
              write (*,*) '### Anomaly in getting the interpolation'// &
                          ' factors for a diagnostic point.'
              write (*,*) '### [This is an internal error.]'
            end if
          end if
          call check_error_on_any_proc (ierr)
!
          ierr=0
          if (iproc.eq.diagpt(i)%iproc) then
            call interp (nt  ,th,diagpt(i)%t,jh_v,jhp1_v,aht_v,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in SET_DIAGNOSTICS:'
              write (*,*) '### Anomaly in getting the interpolation'// &
                          ' factors for a diagnostic point.'
              write (*,*) '### [This is an internal error.]'
            end if
          end if
          call check_error_on_any_proc (ierr)
!
          ierr=0
          if (iproc.eq.diagpt(i)%iproc) then
            call interp (np  ,ph,diagpt(i)%p,kh_v,khp1_v,ahp_v,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in SET_DIAGNOSTICS:'
              write (*,*) '### Anomaly in getting the interpolation'// &
                          ' factors for a diagnostic point.'
              write (*,*) '### [This is an internal error.]'
            end if
          end if
          call check_error_on_any_proc (ierr)
!
          if (iproc.eq.diagpt(i)%iproc) then
            do j=1,ndq
              if (diagpt(i)%q(j)%rm) then
                diagpt(i)%q(j)%i  =im_v
                diagpt(i)%q(j)%ip1=imp1_v
                diagpt(i)%q(j)%ar =amr_v
              else
                diagpt(i)%q(j)%i  =ih_v
                diagpt(i)%q(j)%ip1=ihp1_v
                diagpt(i)%q(j)%ar =ahr_v
              end if
              if (diagpt(i)%q(j)%tm) then
                diagpt(i)%q(j)%j  =jm_v
                diagpt(i)%q(j)%jp1=jmp1_v
                diagpt(i)%q(j)%at =amt_v
              else
                diagpt(i)%q(j)%j  =jh_v
                diagpt(i)%q(j)%jp1=jhp1_v
                diagpt(i)%q(j)%at =aht_v
              end if
              if (diagpt(i)%q(j)%pm) then
                diagpt(i)%q(j)%k  =km_v
                diagpt(i)%q(j)%kp1=kmp1_v
                diagpt(i)%q(j)%ap =amp_v
              else
                diagpt(i)%q(j)%k  =kh_v
                diagpt(i)%q(j)%kp1=khp1_v
                diagpt(i)%q(j)%ap =ahp_v
              end if
            enddo
          end if
        end if
!
      enddo
!
! ****** Write the diagnostic point information.
!
      if (iamp0) then
        write (9,*)
        write (9,*) repeat('-',72)
        write (9,*)
        write (9,*) '### COMMENT from SET_DIAGNOSTICS:'
        write (9,*) 'Number of diagnostic points = ',ndiagp
      end if
!
      do i=1,ndiagp
        if (iamp0) then
          write (9,*)
          write (9,'(a,i2,a)') ' ### Diagnostic point # ',i,':'
          write (9,*) 'Type: ',trim(diagpt(i)%type)
          if (ucase(diagpt(i)%type).eq.'VALUE') then
            write (9,*) 'Location: r = ',diagpt(i)%r
            write (9,*) 'Location: t = ',diagpt(i)%t
            write (9,*) 'Location: p = ',diagpt(i)%p
            write (9,'(a,i4)') ' Processor rank in COMM_ALL'// &
                               ' on which this point is located: ', &
                               diagpt(i)%iproc
          end if
          if (diagpt(i)%nq.gt.0) then
            write (9,*) 'Diagnostic fields:'
          else
            write (9,*) 'No diagnostic fields were specified for'// &
                        ' this point.'
          end if
          do j=1,diagpt(i)%nq
            write (9,*) trim(diagpt(i)%q(j)%name)
          enddo
        end if
      enddo
      if (iamp0) then
        write (9,*)
        write (9,*) repeat('-',72)
        write (9,*)
      end if
!
end subroutine
!#######################################################################
subroutine set_field_table
!
!-----------------------------------------------------------------------
!
! ****** Set the entries in the field table definition FLDTAB.
!
!-----------------------------------------------------------------------
!
      use globals
      use mesh
      use fields
      use field_table
      use decomposition
      use mpidefs
      use upwind_resistivity
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Buffers for MPI communication.
!
      integer, dimension(3,nfields) :: sbuf
      integer, dimension(3,nfields,0:nproc-1) :: rbuf
      integer :: lbuf
!
!-----------------------------------------------------------------------
!
      integer :: i,ierr,irank
!
!-----------------------------------------------------------------------
!$acc enter data create(fldtab)
!
! ****** Define the properties of the fields.
!
      fldtab(IFLD_AR)%name='Ar'
      fldtab(IFLD_AR)%f=>a%r
      fldtab(IFLD_AR)%rm=.true.
      fldtab(IFLD_AR)%tm=.false.
      fldtab(IFLD_AR)%pm=.false.
      fldtab(IFLD_AR)%input_enabled=.true.
!
      fldtab(IFLD_AT)%name='At'
      fldtab(IFLD_AT)%f=>a%t
      fldtab(IFLD_AT)%rm=.false.
      fldtab(IFLD_AT)%tm=.true.
      fldtab(IFLD_AT)%pm=.false.
      fldtab(IFLD_AT)%input_enabled=.true.
!
      fldtab(IFLD_AP)%name='Ap'
      fldtab(IFLD_AP)%f=>a%p
      fldtab(IFLD_AP)%rm=.false.
      fldtab(IFLD_AP)%tm=.false.
      fldtab(IFLD_AP)%pm=.true.
      fldtab(IFLD_AP)%input_enabled=.true.
!
      fldtab(IFLD_VR)%name='vr'
      fldtab(IFLD_VR)%f=>v%r
      fldtab(IFLD_VR)%rm=.true.
      fldtab(IFLD_VR)%tm=.false.
      fldtab(IFLD_VR)%pm=.false.
      fldtab(IFLD_VR)%input_enabled=.true.
!
      fldtab(IFLD_VT)%name='vt'
      fldtab(IFLD_VT)%f=>v%t
      fldtab(IFLD_VT)%rm=.false.
      fldtab(IFLD_VT)%tm=.true.
      fldtab(IFLD_VT)%pm=.false.
      fldtab(IFLD_VT)%input_enabled=.true.
!
      fldtab(IFLD_VP)%name='vp'
      fldtab(IFLD_VP)%f=>v%p
      fldtab(IFLD_VP)%rm=.false.
      fldtab(IFLD_VP)%tm=.false.
      fldtab(IFLD_VP)%pm=.true.
      fldtab(IFLD_VP)%input_enabled=.true.
!
      fldtab(IFLD_BR)%name='Br'
      fldtab(IFLD_BR)%f=>b%r
      fldtab(IFLD_BR)%rm=.false.
      fldtab(IFLD_BR)%tm=.true.
      fldtab(IFLD_BR)%pm=.true.
      fldtab(IFLD_BR)%input_enabled=.true.
!
      fldtab(IFLD_BT)%name='Bt'
      fldtab(IFLD_BT)%f=>b%t
      fldtab(IFLD_BT)%rm=.true.
      fldtab(IFLD_BT)%tm=.false.
      fldtab(IFLD_BT)%pm=.true.
      fldtab(IFLD_BT)%input_enabled=.true.
!
      fldtab(IFLD_BP)%name='Bp'
      fldtab(IFLD_BP)%f=>b%p
      fldtab(IFLD_BP)%rm=.true.
      fldtab(IFLD_BP)%tm=.true.
      fldtab(IFLD_BP)%pm=.false.
      fldtab(IFLD_BP)%input_enabled=.true.
!
      fldtab(IFLD_JR)%name='Jr'
      fldtab(IFLD_JR)%f=>fj%r
      fldtab(IFLD_JR)%rm=.true.
      fldtab(IFLD_JR)%tm=.false.
      fldtab(IFLD_JR)%pm=.false.
!
      fldtab(IFLD_JT)%name='Jt'
      fldtab(IFLD_JT)%f=>fj%t
      fldtab(IFLD_JT)%rm=.false.
      fldtab(IFLD_JT)%tm=.true.
      fldtab(IFLD_JT)%pm=.false.
!
      fldtab(IFLD_JP)%name='Jp'
      fldtab(IFLD_JP)%f=>fj%p
      fldtab(IFLD_JP)%rm=.false.
      fldtab(IFLD_JP)%tm=.false.
      fldtab(IFLD_JP)%pm=.true.
!
      fldtab(IFLD_RHO)%name='rho'
      fldtab(IFLD_RHO)%f=>rho
      fldtab(IFLD_RHO)%rm=.false.
      fldtab(IFLD_RHO)%tm=.false.
      fldtab(IFLD_RHO)%pm=.false.
      fldtab(IFLD_RHO)%input_enabled=.true.
!
      fldtab(IFLD_P)%name='p'
      fldtab(IFLD_P)%f=>pres
      fldtab(IFLD_P)%rm=.false.
      fldtab(IFLD_P)%tm=.false.
      fldtab(IFLD_P)%pm=.false.
!
      fldtab(IFLD_PRES)%name='pres'
      fldtab(IFLD_PRES)%f=>pres
      fldtab(IFLD_PRES)%rm=.false.
      fldtab(IFLD_PRES)%tm=.false.
      fldtab(IFLD_PRES)%pm=.false.
!
      fldtab(IFLD_ETA)%name='eta'
      fldtab(IFLD_ETA)%f=>eta
      fldtab(IFLD_ETA)%rm=.true.
      fldtab(IFLD_ETA)%tm=.true.
      fldtab(IFLD_ETA)%pm=.true.
!
      fldtab(IFLD_VIS)%name='visc'
      fldtab(IFLD_VIS)%f=>vis
      fldtab(IFLD_VIS)%rm=.true.
      fldtab(IFLD_VIS)%tm=.true.
      fldtab(IFLD_VIS)%pm=.true.
!
      fldtab(IFLD_VR_OLD)%name='vr_old'
      fldtab(IFLD_VR_OLD)%f=>v_old%r
      fldtab(IFLD_VR_OLD)%rm=.true.
      fldtab(IFLD_VR_OLD)%tm=.false.
      fldtab(IFLD_VR_OLD)%pm=.false.
!
      fldtab(IFLD_VT_OLD)%name='vt_old'
      fldtab(IFLD_VT_OLD)%f=>v_old%t
      fldtab(IFLD_VT_OLD)%rm=.false.
      fldtab(IFLD_VT_OLD)%tm=.true.
      fldtab(IFLD_VT_OLD)%pm=.false.
!
      fldtab(IFLD_VP_OLD)%name='vp_old'
      fldtab(IFLD_VP_OLD)%f=>v_old%p
      fldtab(IFLD_VP_OLD)%rm=.false.
      fldtab(IFLD_VP_OLD)%tm=.false.
      fldtab(IFLD_VP_OLD)%pm=.true.
!
      fldtab(IFLD_SIFAC)%name='sifac'
      fldtab(IFLD_SIFAC)%f=>sifac
      fldtab(IFLD_SIFAC)%rm=.true.
      fldtab(IFLD_SIFAC)%tm=.true.
      fldtab(IFLD_SIFAC)%pm=.true.
!
      fldtab(IFLD_T_E)%name='Te'
      fldtab(IFLD_T_E)%f=>temp_e
      fldtab(IFLD_T_E)%rm=.false.
      fldtab(IFLD_T_E)%tm=.false.
      fldtab(IFLD_T_E)%pm=.false.
      fldtab(IFLD_T_E)%input_enabled=.true.
!
      fldtab(IFLD_T_P)%name='Tp'
      fldtab(IFLD_T_P)%f=>temp_p
      fldtab(IFLD_T_P)%rm=.false.
      fldtab(IFLD_T_P)%tm=.false.
      fldtab(IFLD_T_P)%pm=.false.
      fldtab(IFLD_T_P)%input_enabled=.true.
!
      fldtab(IFLD_T)%name='T'
      fldtab(IFLD_T)%f=>temp
      fldtab(IFLD_T)%rm=.false.
      fldtab(IFLD_T)%tm=.false.
      fldtab(IFLD_T)%pm=.false.
      fldtab(IFLD_T)%input_enabled=.true.
!
      fldtab(IFLD_HEAT)%name='heat'
      fldtab(IFLD_HEAT)%f=>heat
      fldtab(IFLD_HEAT)%rm=.false.
      fldtab(IFLD_HEAT)%tm=.false.
      fldtab(IFLD_HEAT)%pm=.false.
!
      fldtab(IFLD_EP)%name='ep'
      fldtab(IFLD_EP)%f=>ep
      fldtab(IFLD_EP)%rm=.false.
      fldtab(IFLD_EP)%tm=.false.
      fldtab(IFLD_EP)%pm=.false.
      fldtab(IFLD_EP)%input_enabled=.true.
!
      fldtab(IFLD_EM)%name='em'
      fldtab(IFLD_EM)%f=>em
      fldtab(IFLD_EM)%rm=.false.
      fldtab(IFLD_EM)%tm=.false.
      fldtab(IFLD_EM)%pm=.false.
      fldtab(IFLD_EM)%input_enabled=.true.
!
! ****** This one is broken since i not set...
!
      fldtab(IFLD_ETA_UW)%name='eta_uw'
      fldtab(IFLD_ETA_UW)%f=>eta_uw%i
      fldtab(IFLD_ETA_UW)%rm=.true.
      fldtab(IFLD_ETA_UW)%tm=.true.
      fldtab(IFLD_ETA_UW)%pm=.true.
!
      fldtab(IFLD_EFR)%name='EFr'
      fldtab(IFLD_EFR)%f=>e%r
      fldtab(IFLD_EFR)%rm=.true.
      fldtab(IFLD_EFR)%tm=.false.
      fldtab(IFLD_EFR)%pm=.false.
!
      fldtab(IFLD_EFT)%name='EFt'
      fldtab(IFLD_EFT)%f=>e%t
      fldtab(IFLD_EFT)%rm=.false.
      fldtab(IFLD_EFT)%tm=.true.
      fldtab(IFLD_EFT)%pm=.false.
!
      fldtab(IFLD_EFP)%name='EFp'
      fldtab(IFLD_EFP)%f=>e%p
      fldtab(IFLD_EFP)%rm=.false.
      fldtab(IFLD_EFP)%tm=.false.
      fldtab(IFLD_EFP)%pm=.true.
!
      fldtab(IFLD_V_PAR)%name='v_par'
      fldtab(IFLD_V_PAR)%f=>v_par
      fldtab(IFLD_V_PAR)%rm=.false.
      fldtab(IFLD_V_PAR)%tm=.false.
      fldtab(IFLD_V_PAR)%pm=.false.
!
      fldtab(IFLD_ZP)%name='zp'
      fldtab(IFLD_ZP)%f=>zp
      fldtab(IFLD_ZP)%rm=.false.
      fldtab(IFLD_ZP)%tm=.false.
      fldtab(IFLD_ZP)%pm=.false.
      fldtab(IFLD_ZP)%input_enabled=.true.
!
      fldtab(IFLD_ZM)%name='zm'
      fldtab(IFLD_ZM)%f=>zm
      fldtab(IFLD_ZM)%rm=.false.
      fldtab(IFLD_ZM)%tm=.false.
      fldtab(IFLD_ZM)%pm=.false.
      fldtab(IFLD_ZM)%input_enabled=.true.
!
! ****** Set the global dimensions of the fields and the pointers to
! ****** the mapping structures.
!
      do i=1,nfields
        if (fldtab(i)%rm) then
          fldtab(i)%n1_g=nrm1_g
          fldtab(i)%r_g=>r_g
          fldtab(i)%map_r=>map_rm
        else
          fldtab(i)%n1_g=nr_g
          fldtab(i)%r_g=>rh_g
          fldtab(i)%map_r=>map_rh
        end if
        if (fldtab(i)%tm) then
          fldtab(i)%n2_g=ntm1_g
          fldtab(i)%t_g=>t_g
          fldtab(i)%map_t=>map_tm
          fldtab(i)%maptp_t=>maptp_tm
        else
          fldtab(i)%n2_g=nt_g
          fldtab(i)%t_g=>th_g
          fldtab(i)%map_t=>map_th
          fldtab(i)%maptp_t=>maptp_th
        end if
        if (fldtab(i)%pm) then
          fldtab(i)%n3_g=npm1_g
          fldtab(i)%p_g=>p_g
          fldtab(i)%map_p=>map_pm
          fldtab(i)%maptp_p=>maptp_pm
        else
          fldtab(i)%n3_g=np_g
          fldtab(i)%p_g=>ph_g
          fldtab(i)%map_p=>map_ph
          fldtab(i)%maptp_p=>maptp_ph
        end if
!$acc enter data create(fldtab(i))
      enddo
!
! ****** Set the local dimensions of the fields.
!
! ****** This is communicated to all processors since global
! ****** gather/scatter operations require it.
!
! ****** Allocate storage for the dimensions.
!
      do i=1,nfields
        allocate (fldtab(i)%n1(0:nproc-1))
        allocate (fldtab(i)%n2(0:nproc-1))
        allocate (fldtab(i)%n3(0:nproc-1))
      enddo
!
! ****** Set the dimensions.
!
      do i=1,nfields
        fldtab(i)%n1(iproc)=size(fldtab(i)%f,1)
        fldtab(i)%n2(iproc)=size(fldtab(i)%f,2)
        fldtab(i)%n3(iproc)=size(fldtab(i)%f,3)
      enddo
!
! ****** Put the local dimensions into a buffer.
!
      do i=1,nfields
        sbuf(1,i)=fldtab(i)%n1(iproc)
        sbuf(2,i)=fldtab(i)%n2(iproc)
        sbuf(3,i)=fldtab(i)%n3(iproc)
      enddo
!
      lbuf=3*nfields
!
! ****** Communicate among all processors.  After this call, all
! ****** processors have the dimensions of all the fields in the
! ****** field table.
!
      call MPI_Allgather (sbuf,lbuf,MPI_INTEGER, &
                          rbuf,lbuf,MPI_INTEGER,comm_all,ierr)
!
! ****** Extract the dimensions from the buffer.
!
      do i=1,nfields
        do irank=0,nproc-1
          fldtab(i)%n1(irank)=rbuf(1,i,irank)
          fldtab(i)%n2(irank)=rbuf(2,i,irank)
          fldtab(i)%n3(irank)=rbuf(3,i,irank)
        enddo
!$acc enter data copyin(fldtab(i)%n1)
!$acc enter data copyin(fldtab(i)%n2)
!$acc enter data copyin(fldtab(i)%n3)
      enddo
!
end subroutine
!#######################################################################
pure subroutine interp (n,x,xv,i,ip1,a,ierr)
!$acc routine(interp) seq
!
!-----------------------------------------------------------------------
!
! ****** Get the interpolation factor at XV from the table X(N).
!
!-----------------------------------------------------------------------
!
! ****** This routine does not do the actual interpolation.  Use the
! ****** returned values of I, IP1, and A to get the interpolated
! ****** value.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, intent(in) :: n
      real(r_typ), dimension(n), intent(in) :: x
      real(r_typ), intent(in) :: xv
      integer, intent(out) :: i,ip1
      real(r_typ), intent(out) :: a
      integer, intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Check if the x-scale has only one point.
!
      if (n.eq.1.and.xv.eq.x(1)) then
        ip1=1
        a=0.
        return
      end if
!
! ****** Find the interval and compute the interpolation factor.
!
      do i=1,n-1
        if (xv.ge.x(i).and.xv.le.x(i+1)) then
          ip1=i+1
          if (x(i).eq.x(i+1)) then
            a=0.
          else
            a=(xv-x(i))/(x(i+1)-x(i))
          end if
          return
        end if
      enddo
!
! ****** ERROR: the value was not found.
!        (pure routines cannot have writes...
!         these should be written by the calling routine)
!      write (*,*)
!      write (*,*) '### ERROR in INTERP:'
!      write (*,*) '### Value not found in table.'
!      write (*,*) 'Value requested = ',xv
!      write (*,*) 'Min table value = ',x(1)
!      write (*,*) 'Max table value = ',x(n)
!      write (*,*) 'Number of values in table = ',n
!
      ierr=1
!
end subroutine
!#######################################################################
subroutine history_check
!
!-----------------------------------------------------------------------
!
! ****** Set the switches for collection of time histories,
! ****** the plotting of spatial diagnostics, and the dumping of
! ****** restart files.
!
!-----------------------------------------------------------------------
!
      use number_types
      use diagnostics
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical, save :: first=.true.
!
!-----------------------------------------------------------------------
!
      logical, external :: diagnostic_step
!
!-----------------------------------------------------------------------
!
!-----------------------------------------------------------------------
! ****** Set the switch for time history diagnostics.
!-----------------------------------------------------------------------
!
! ****** If IHISTINT > 0, collect time histories every IHISTINT
! ****** time steps.  Otherwise, if THISTINT > 0., collect time
! ****** histories every THISTINT intervals of time.
!
      history_step=.false.
!
      if (ihistint.le.0) then
        if (first.and.thistint.gt.0.) then
          history_step=.true.
        else
          history_step=diagnostic_step(t_last_check,thistint,time)
        end if
      else
        if (mod(ntime,ihistint).eq.0) history_step=.true.
      end if
!
!-----------------------------------------------------------------------
! ****** Set the switch for spatial diagnostics.
!-----------------------------------------------------------------------
!
! ****** If IPLTXINT > 0, plot spatial diagnostics every IPLTXINT
! ****** time steps.  Otherwise, if TPLTXINT > 0., plot spatial
! ****** diagnostics every TPLTXINT intervals of time.
!
      plotting_step=.false.
!
      if (ipltxint.le.0) then
        if (first.and.tpltxint.gt.0.) then
          plotting_step=.true.
        else
          plotting_step=diagnostic_step(t_last_check,tpltxint,time)
        end if
      else
        if (mod(ntime,ipltxint).eq.0) plotting_step=.true.
      end if
!
!-----------------------------------------------------------------------
! ****** Set the switch for restart file dumps.
!-----------------------------------------------------------------------
!
! ****** If IRSDUMP > 0, dump a restart file every IRSDUMP
! ****** time steps.  Otherwise, if TRSDUMP > 0., dump a restart
! ****** file every TRSDUMP intervals of time.
!
      restart_step=.false.
!
      if (irsdump.le.0) then
        if (first) then
          restart_step=.false.
        else
          restart_step=diagnostic_step(t_last_check,trsdump,time)
        end if
      else
        if (mod(ntime,irsdump).eq.0) restart_step=.true.
      end if
!
!-----------------------------------------------------------------------
! ****** Set the switch for tracer particle dumps.
!-----------------------------------------------------------------------
!
! ****** If trace_ixint > 0, plot tracers every trace_ixint
! ****** time steps.  Otherwise, if trace_txint > 0., plot tracers
! ****** every trace_txint intervals of time.
!
      trace_step=.false.
!
      if (trace_ixint.le.0) then
        if (first.and.trace_txint.gt.0.) then
          trace_step=.true.
        else
          trace_step=diagnostic_step(t_last_check,trace_txint,time)
        end if
      else
        if (mod(ntime,trace_ixint).eq.0) trace_step=.true.
      end if
!
!-----------------------------------------------------------------------
! ****** Set the switch for slice dumps.
!-----------------------------------------------------------------------
!
! ****** If slice_ixint > 0, plot slices every slice_ixint
! ****** time steps.  Otherwise, if slice_txint > 0., plot slices
! ****** every slice_txint intervals of time.
!
      slice_step=.false.
!
      if (slice_ixint.le.0) then
        if (first.and.slice_txint.gt.0.) then
          slice_step=.true.
        else
          slice_step=diagnostic_step(t_last_check,slice_txint,time)
        end if
      else
        if (mod(ntime,slice_ixint).eq.0) slice_step=.true.
      end if
!
!-----------------------------------------------------------------------
! ****** Set the switch for helicity pumping.
!-----------------------------------------------------------------------
!
! ****** if hpump_cadence>0, pump every hpump_cadence intervals of time.
! ****** Include an optional time offset to stagger with dumps/restarts.
!
      hpump_step=.false.
!
      if (.not.first.and.hpump_cadence.gt.0.) then
        hpump_time_last=t_last_check-hpump_time_offset
        hpump_time_now=time-hpump_time_offset
        hpump_step=diagnostic_step( hpump_time_last, hpump_cadence, &
                                    hpump_time_now)
      end if
!
! ****** Save the present TIME in T_LAST_CHECK.
!
      t_last_check=time
!
      if (first) first=.false.
!
end subroutine
!#######################################################################
function diagnostic_step (t_previous,t_interval,t)
!
!-----------------------------------------------------------------------
!
! ****** Check if T corresponds to a diagnostic step, based on the
! ****** values of T_PREVIOUS and T_INTERVAL.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: t_previous,t_interval,t
      logical :: diagnostic_step
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: tdump
!
!-----------------------------------------------------------------------
!
      diagnostic_step=.false.
!
      if (t_interval.le.0.) return
!
      tdump=t-mod(t,t_interval)
!
      if (t.ge.tdump.and.tdump.gt.t_previous) diagnostic_step=.true.
!
      return
end function
!#######################################################################
subroutine diags
!
!-----------------------------------------------------------------------
!
! ****** If requested, collect time diagnostics, plot spatial
! ****** diagnostics, or dump a restart file.
!
!-----------------------------------------------------------------------
!
      use diagnostics
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Collect time history diagnostics.
!
      if (history_step) call tdiagcol
!
! ****** Plot spatial diagnostics.
!
      if (plotting_step) call plot_dump
!
! ****** Dump a restart file.
!
      if (restart_step) call rsdump
!
! ****** Dump tracer particles.
!
      if (trace_step) call particle_dump
!
! ****** Dump slices.
!
      if (slice_step) call slice_dump
!
end subroutine
!#######################################################################
subroutine rsdump
!
!-----------------------------------------------------------------------
!
! ****** Write a restart file on a restart file dump interval.
!
!-----------------------------------------------------------------------
!
      use number_types
      use ident
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Restart file sequence number.
!
      integer, save :: iseq=0
!
!-----------------------------------------------------------------------
!
! ****** Increment the restart file sequence number.
!
      iseq=iseq+1
!
! ****** Write the restart file.
!
      call write_restart (iseq)
!
end subroutine
!#######################################################################
subroutine initialize_tracers
!
!-----------------------------------------------------------------------
!
! ****** If requested, load seed points of tracer particles.
!
!-----------------------------------------------------------------------
!
      use diagnostics
      use number_types
      use mpidefs
      use mesh
      use debug
      use rdhdf_2d_interface
      use lcase_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: nx,ny,ierr,i,nout
      logical :: scale
      real(r_typ), dimension(:,:), pointer, contiguous ::f
      real(r_typ), dimension(:), pointer, contiguous :: scale_x,scale_y
!
!-----------------------------------------------------------------------
!
      if (.not.trace_particles) return
!
      ierr=0
!
! ****** Load the seed points for the tracers from the requested file.
!
      call rdhdf_2d (trace_seed_file,scale,nx,ny,f,scale_x,scale_y,ierr)
!
      if (ierr.ne.0) then
        if (iamp0) then
          write (9,*)
          write (9,*) '### ERROR in INITIALIZE_TRACERS:'
          write (9,*) '### Could not read the specified seed file.'
          write (9,*) 'IERR (from RDHDF_2D) = ',ierr
          write (9,*) 'File name: ',trim(trace_seed_file)
          write (*,*)
          write (*,*) '### ERROR in INITIALIZE_TRACERS:'
          write (*,*) '### Could not read the specified seed file.'
          write (*,*) 'IERR (from RDHDF_2D) = ',ierr
          write (*,*) 'File name: ',trim(trace_seed_file)
        end if
      end if
      call check_error_on_any_proc (ierr)
!
      if (ny.ne.3) then
        ierr=1
        if (iamp0) then
          write (9,*)
          write (9,*) '### ERROR in INITIALIZE_TRACERS:'
          write (9,*) '### Seed file not formatted correctly.'
          write (9,*) '### It should be r,t,p values in an (N,3) array.'
          write (9,*) 'File name: ',trim(trace_seed_file)
          write (*,*)
          write (*,*) '### ERROR in INITIALIZE_TRACERS:'
          write (*,*) '### Seed file not formatted correctly.'
          write (*,*) '### It should be r,t,p values in an (N,3) array.'
          write (*,*) 'File name: ',trim(trace_seed_file)
        end if
      end if
      call check_error_on_any_proc (ierr)
!
      tracers%n=nx
!
      allocate (tracers%r(tracers%n))
      allocate (tracers%t(tracers%n))
      allocate (tracers%p(tracers%n))
!
      tracers%r(:)=f(:,1)
      tracers%t(:)=f(:,2)
      tracers%p(:)=f(:,3)
!
! ****** Deallocate temporary and unneeded arrays.
!
      deallocate (f)
      deallocate (scale_x)
      deallocate (scale_y)
!
! ****** Check that all particles are within the domain.
!
      nout=0
      do i=1,tracers%n
        if (tracers%r(i).lt.r0.or.tracers%r(i).gt.r1.or. &
            tracers%t(i).lt.t0.or.tracers%t(i).gt.t1.or. &
            tracers%p(i).lt.p0.or.tracers%p(i).gt.p1) nout=nout+1
      enddo
!
      if (nout.ne.0.and.iamp0) then
        write (9,*)
        write (9,*) '### Comment from INITIALIZE_TRACERS:'
        write (9,*) '### Some of the particle''s seed locations ', &
                         'are outside of the domain.'
        write (9,*) '### They will be zeroed and will not be advected.'
        write (9,*) '### Number outside: ', nout
        write (9,*) '### Fraction: ', float(nout)/float(tracers%n)
      end if
!$acc enter data copyin(tracers,tracers%r,tracers%t,tracers%p,tracers%n)
!
! ****** Initialize additional tracked quantities.
!
      if (trace_track_ds) then
        allocate (tracers%ds(tracers%n))
        tracers%ds(:)=0.
!$acc enter data copyin(tracers%ds)
      end if
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INITIALIZE_TRACERS:'
        write (9,*) '### Read tracer seeds from ',trim(trace_seed_file)
        write (9,*) '### Number of tracer particles: ',tracers%n
        if (idebug.gt.0) then
          write (9,*)
          write (9,*) 'Tracer particle locations (proc:',iproc,')'
          do i=1,tracers%n
            write (9,*) i,': (',tracers%r(i),tracers%t(i),tracers%p(i), &
                         ')'
          enddo
!
        end if
      end if
!
! ****** Set dump cadence to match plot cadence unless user overides.
!
      if (trace_ixint.eq.0.and.trace_txint.eq.0) then
        if (ipltxint.le.0) then
          trace_txint=tpltxint
        else
          trace_ixint=ipltxint
        end if
      end if
!
! ****** Set reseed type.
!
      trace_reseed_index=0
      do i=1,n_trace_reseed_types
        if (trim(lcase(trace_reseed_type)).eq. &
            trim(lcase(tr_name(i)))) then
          trace_reseed_index=i
          exit
        end if
      enddo
!
      if (trace_reseed_index.eq.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INITIALIZE_TRACERS:'
          write (*,*) '### The requested tracer reseed type'// &
                      ' is not valid: ',trim(trace_reseed_type)
          write (*,*)
          write (*,*) '### The tracer reseed type must be one'// &
                      ' of the following:'
          do i=1,n_trace_reseed_types
            write (*,*) ''''//trim(tr_name(i))//''''
          enddo
        end if
        call endrun (.true.)
      end if
!
end subroutine
!#######################################################################
subroutine tdiagcol
!
!-----------------------------------------------------------------------
!
! ****** Collect time history diagnostics.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use diagnostics
      use dtinfo
      use energy_diagnostic
      use vars
      use mpidefs
      use vnorm_interface
      use ucase_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j
!
      real(r_typ) :: jdotb,jxb
!
      integer :: i0,i1,j0,j1,k0,k1
      real(r_typ) :: ar,at,ap
      real(r_typ) :: f00,f01,f10,f11
!
!-----------------------------------------------------------------------
!
! ****** Check for an overflowing history buffer.
!
      if (ihist.eq.nhistmax) then
        call dumphist
        ihist=0
      end if
!
! ****** Increment the time-history index.
!
      ihist=ihist+1
!
! ****** Calculate the volume integrals of |J.B| and |JxB|.
!
      call volint_jb (b,fj,jdotb,jxb)
!
! ****** Load the time history buffer for this interval.
!
      thist( 1)%v(ihist)=time
      thist( 2)%v(ihist)=wr
      thist( 3)%v(ihist)=wt
      thist( 4)%v(ihist)=wp
      thist( 5)%v(ihist)=kr
      thist( 6)%v(ihist)=kt
      thist( 7)%v(ihist)=kp
      thist( 8)%v(ihist)=etherm
      thist( 9)%v(ihist)=jxb
      thist(10)%v(ihist)=jdotb
      thist(11)%v(ihist)=kparr
      thist(12)%v(ihist)=kpart
      thist(13)%v(ihist)=kparp
      thist(14)%v(ihist)=kperpr
      thist(15)%v(ihist)=kperpt
      thist(16)%v(ihist)=kperpp
      thist(17)%v(ihist)=rr
      thist(18)%v(ihist)=vv
      thist(19)%v(ihist)=poynt
      thist(20)%v(ihist)=e_conserved
      thist(21)%v(ihist)=dtime
      thist(22)%v(ihist)=flow_cfl
      thist(23)%v(ihist)=wave_cfl
!
!-----------------------------------------------------------------------
! ****** Process the diagnostic points.
!-----------------------------------------------------------------------
!
! ****** Loop over all diagnostic points.
!
      do i=1,ndiagp
!
        if (ucase(diagpt(i)%type).eq.'VALUE') then
!
! ****** Interpolate to get the value at the diagnostic point
! ****** only on the processor on which it resides.
!
          if (iproc.eq.diagpt(i)%iproc) then
!
! ****** Loop over all diagnostic quantities.
!
            do j=1,diagpt(i)%nq
!$acc update self(diagpt(i)%q(j)%fld) if_present
!
! ****** Set the interpolation factors.
!
              i0=diagpt(i)%q(j)%i
              i1=diagpt(i)%q(j)%ip1
              ar=diagpt(i)%q(j)%ar
              j0=diagpt(i)%q(j)%j
              j1=diagpt(i)%q(j)%jp1
              at=diagpt(i)%q(j)%at
              k0=diagpt(i)%q(j)%k
              k1=diagpt(i)%q(j)%kp1
              ap=diagpt(i)%q(j)%ap
!
! ****** Interpolate the value.
!
              f00= (one-ap)*diagpt(i)%q(j)%fld(i0,j0,k0) &
                  +     ap *diagpt(i)%q(j)%fld(i0,j0,k1)
              f01= (one-ap)*diagpt(i)%q(j)%fld(i0,j1,k0) &
                  +     ap *diagpt(i)%q(j)%fld(i0,j1,k1)
              f10= (one-ap)*diagpt(i)%q(j)%fld(i1,j0,k0) &
                  +     ap *diagpt(i)%q(j)%fld(i1,j0,k1)
              f11= (one-ap)*diagpt(i)%q(j)%fld(i1,j1,k0) &
                  +     ap *diagpt(i)%q(j)%fld(i1,j1,k1)
              diagpt(i)%q(j)%v(ihist)= &
                (one-ar)*((one-at)*f00+at*f01) &
               +     ar *((one-at)*f10+at*f11)
!
            enddo
!
          end if
!
        else
!
          select case (ucase(diagpt(i)%type))
          case ('MAX')
            do j=1,diagpt(i)%nq
              diagpt(i)%q(j)%v(ihist)=maxval(diagpt(i)%q(j)%fld)
            enddo
          case ('MAXABS')
            do j=1,diagpt(i)%nq
              diagpt(i)%q(j)%v(ihist)=maxval(abs(diagpt(i)%q(j)%fld))
            enddo
          case ('MIN')
            do j=1,diagpt(i)%nq
              diagpt(i)%q(j)%v(ihist)=minval(diagpt(i)%q(j)%fld)
            enddo
          case ('MINABS')
            do j=1,diagpt(i)%nq
              diagpt(i)%q(j)%v(ihist)=minval(abs(diagpt(i)%q(j)%fld))
            enddo
          case ('NORM')
            do j=1,diagpt(i)%nq
              diagpt(i)%q(j)%v(ihist)=vnorm(diagpt(i)%q(j)%rm, &
                                            diagpt(i)%q(j)%tm, &
                                            diagpt(i)%q(j)%pm, &
                                            diagpt(i)%q(j)%fld)
            enddo
          end select
!
        end if
!
      enddo
!
end subroutine
!#######################################################################
function vnorm (rm,tm,pm,f)
!
!-----------------------------------------------------------------------
!
! ****** Get the volume-averaged root-mean-square (norm) of the
! ****** field F.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
! ****** Note that the division by volume, as well as the square-root,
! ****** are performed in routine DUMPHIST.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: rm,tm,pm
      real(r_typ), dimension(:,:,:) :: f
      real(r_typ) :: vnorm
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: fav,dv
!
!-----------------------------------------------------------------------
!
! ****** Pointer to the appropriate phi mesh spacing.
!
      real(r_typ), dimension(:), pointer, contiguous :: d_p
!
!-----------------------------------------------------------------------
!
      if (pm) then
        d_p=>dp
      else
        d_p=>dph
      end if
!
! ****** Use the appropriate average, depending on the type of mesh
! ****** that F resides on.
!
      vnorm=0.
      if (rm) then
        if (tm) then
          do k=2,npm1
            do i=2,nrm1
              do j=2,ntm1
                fav=AVGRT(f,i,j,k)
                dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*d_p(k)
                vnorm=vnorm+fav**2*dv
              enddo
            enddo
          enddo
        else
          do k=2,npm1
            do i=2,nrm1
              do j=2,ntm1
                fav=AVGR(f,i,j,k)
                dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*d_p(k)
                vnorm=vnorm+fav**2*dv
              enddo
            enddo
          enddo
        end if
      else
        if (tm) then
          do k=2,npm1
            do i=2,nrm1
              do j=2,ntm1
                fav=AVGT(f,i,j,k)
                dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*d_p(k)
                vnorm=vnorm+fav**2*dv
              enddo
            enddo
          enddo
        else
          do k=2,npm1
            do i=2,nrm1
              do j=2,ntm1
                fav=AVG(f,i,j,k)
                dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*d_p(k)
                vnorm=vnorm+fav**2*dv
              enddo
            enddo
          enddo
        end if
      end if
!
      return
end function
!#######################################################################
subroutine magnetic_energy (b,wr,wt,wp)
!
!-----------------------------------------------------------------------
!
! ****** Get the r, theta, and phi components of the total magnetic
! ****** energy in the domain.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
      real(r_typ) :: wr,wt,wp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avbr,avbt,avbp
      real(r_typ) :: dv
!
!-----------------------------------------------------------------------
!
! ****** Calculate the magnetic energy.
!
      wr=0.
      wt=0.
      wp=0.
!$acc parallel loop collapse(3) default(present) reduction(+:wr,wt,wp)
!$omp parallel do collapse(3) default(shared) reduction(+:wr,wt,wp)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            avbr=AVGTP(b%r,i,j,k)
            avbt=AVGRP(b%t,i,j,k)
            avbp=AVGRT(b%p,i,j,k)
            dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*dph(k)
            wr=wr+avbr**2*dv
            wt=wt+avbt**2*dv
            wp=wp+avbp**2*dv
          enddo
        enddo
      enddo
!$omp end parallel do
      wr=half*wr
      wt=half*wt
      wp=half*wp
!
end subroutine
!#######################################################################
subroutine kinetic_energy (rho,v,kr,kt,kp)
!
!-----------------------------------------------------------------------
!
! ****** Get the r, theta, and phi components of the total kinetic
! ****** energy in the domain.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: rho
      type(vvec) :: v
      real(r_typ) :: kr,kt,kp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avrho
      real(r_typ) :: avvr,avvt,avvp
      real(r_typ) :: dv
!
!-----------------------------------------------------------------------
!
! ****** Calculate the kinetic energy.
!
      kr=0.
      kt=0.
      kp=0.
!$acc parallel loop collapse(3) default(present) reduction(+:kr,kt,kp)
!$omp parallel do collapse(3) default(shared) reduction(+:kr,kt,kp)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            avrho=AVG  (rho,i,j,k)
            avvr =AVGR (v%r,i,j,k)
            avvt =AVGT (v%t,i,j,k)
            avvp =AVGP (v%p,i,j,k)
            dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*dph(k)
            kr=kr+avrho*avvr**2*dv
            kt=kt+avrho*avvt**2*dv
            kp=kp+avrho*avvp**2*dv
          enddo
        enddo
      enddo
!$omp end parallel do
      kr=half*kr
      kt=half*kt
      kp=half*kp
!
end subroutine
!#######################################################################
subroutine kinetic_energy_pp (rho,v,b, &
                                    kparr,kpart,kparp, &
                                    kperpr,kperpt,kperpp)
!
!-----------------------------------------------------------------------
!
! ****** Get the r, theta, and phi components of the parallel and
! ****** perpendicular kinetic energy in the domain.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: rho
      type(vvec) :: v
      type(bvec) :: b
      real(r_typ) :: kparr,kpart,kparp
      real(r_typ) :: kperpr,kperpt,kperpp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avrho
      real(r_typ) :: avvr,avvt,avvp
      real(r_typ) :: avbr,avbt,avbp
      real(r_typ) :: bsq,vdotb
      real(r_typ) :: vparr,vpart,vparp
      real(r_typ) :: vperpr,vperpt,vperpp
      real(r_typ) :: dv
!
!-----------------------------------------------------------------------
!
! ****** Calculate the parallel and perpendicular kinetic energy.
!
      kparr=0.
      kpart=0.
      kparp=0.
      kperpr=0.
      kperpt=0.
      kperpp=0.
!$acc parallel loop collapse(3) default(present) &
!$acc          reduction(+:kparr,kpart,kparp,kperpr,kperpt,kperpp)
!$omp parallel do collapse(3) default(shared) &
!$omp          reduction(+:kparr,kpart,kparp,kperpr,kperpt,kperpp)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            avrho=AVG  (rho,i,j,k)
            avvr =AVGR (v%r,i,j,k)
            avvt =AVGT (v%t,i,j,k)
            avvp =AVGP (v%p,i,j,k)
            avbr =AVGTP(b%r,i,j,k)
            avbt =AVGRP(b%t,i,j,k)
            avbp =AVGRT(b%p,i,j,k)
            bsq=avbr**2+avbt**2+avbp**2
            vdotb=avvr*avbr+avvt*avbt+avvp*avbp
            vparr=vdotb*avbr/max(bsq,small_value)
            vpart=vdotb*avbt/max(bsq,small_value)
            vparp=vdotb*avbp/max(bsq,small_value)
            vperpr=avvr-vparr
            vperpt=avvt-vpart
            vperpp=avvp-vparp
            dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*dph(k)
            kparr=kparr+avrho*vparr**2*dv
            kpart=kpart+avrho*vpart**2*dv
            kparp=kparp+avrho*vparp**2*dv
            kperpr=kperpr+avrho*vperpr**2*dv
            kperpt=kperpt+avrho*vperpt**2*dv
            kperpp=kperpp+avrho*vperpp**2*dv
          enddo
        enddo
      enddo
!$omp end parallel do
      kparr=half*kparr
      kpart=half*kpart
      kparp=half*kparp
      kperpr=half*kperpr
      kperpt=half*kperpt
      kperpp=half*kperpp
!
end subroutine
!#######################################################################
subroutine thermal_energy (pres,gamma,etherm)
!
!-----------------------------------------------------------------------
!
! ****** Get the total thermal energy in the domain.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: pres
      real(r_typ) :: gamma
      real(r_typ) :: etherm
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avp
      real(r_typ) :: dv
!
!-----------------------------------------------------------------------
!
! ****** Calculate the thermal energy.
!
      etherm=0.
!$acc parallel loop collapse(3) default(present) reduction(+:etherm)
!$omp parallel do collapse(3) default(shared) reduction(+:etherm)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            avp=AVG(pres,i,j,k)
            dv=fl_fach(i)*rh(i)**2*sth(j)*drh(i)*dth(j)*dph(k)
            etherm=etherm+avp*dv
          enddo
        enddo
      enddo
!$omp end parallel do
      etherm=etherm/(gamma-one)
!
end subroutine
!#######################################################################
subroutine volint_jb (b,fj,jdotb,jxb)
!
!-----------------------------------------------------------------------
!
! ****** Get the volume-integral of |J.B| and |J x B|.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use types
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(bvec) :: b
      type(avec) :: fj
      real(r_typ) :: jdotb,jxb
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: avbr,avbt,avbp
      real(r_typ) :: avjr,avjt,avjp
      real(r_typ) :: jdb,jxbr,jxbt,jxbp,jxbmag
      real(r_typ) :: dv
!
!-----------------------------------------------------------------------
!
! ****** Calculate the volume integrals of |J x B| and |J.B|.
!
      jdotb=0.
      jxb=0.
!$acc parallel loop collapse(3) default(present) reduction(+:jdotb,jxb)
!$omp parallel do collapse(3) default(shared) reduction(+:jdotb,jxb)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            avbr=AVGTP(b%r ,i,j,k)
            avbt=AVGRP(b%t ,i,j,k)
            avbp=AVGRT(b%p ,i,j,k)
            avjr=AVGR (fj%r,i,j,k)
            avjt=AVGT (fj%t,i,j,k)
            avjp=AVGP (fj%p,i,j,k)
            jdb=abs(avbr*avjr+avbt*avjt+avbp*avjp)
            jxbr=avjt*avbp-avjp*avbt
            jxbt=avjp*avbr-avjr*avbp
            jxbp=avjr*avbt-avjt*avbr
            jxbmag=sqrt(jxbr**2+jxbt**2+jxbp**2)
            dv=rh(i)**2*sth(j)*drh(i)*dth(j)*dph(k)
            jdotb=jdotb+jdb*dv
            jxb=jxb+jxbmag*dv
          enddo
        enddo
      enddo
!$omp end parallel do
!
end subroutine
!#######################################################################
subroutine resistive_dissipation (eta,fj,rr)
!
!-----------------------------------------------------------------------
!
! ****** Get the rate of resistive dissipation in the domain.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: eta
      type(avec) :: fj
      real(r_typ) :: rr
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: etav
      real(r_typ) :: avjr,avjt,avjp
      real(r_typ) :: dv
!
!-----------------------------------------------------------------------
!
! ****** Calculate the rate of resistive dissipation.
!
      rr=0.
!$acc parallel loop collapse(3) default(present) reduction(+:rr)
!$omp parallel do collapse(3) default(shared) reduction(+:rr)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            etav=AVGRTP(eta ,i,j,k)
            avjr=AVGR  (fj%r,i,j,k)
            avjt=AVGT  (fj%t,i,j,k)
            avjp=AVGP  (fj%p,i,j,k)
            dv=rh(i)**2*sth(j)*drh(i)*dth(j)*dph(k)
            rr=rr+etav*(avjr**2+avjt**2+avjp**2)*dv
          enddo
        enddo
      enddo
!$omp end parallel do
!
end subroutine
!#######################################################################
subroutine viscous_dissipation (nu,rho,v,vv)
!
!-----------------------------------------------------------------------
!
! ****** Get the rate of viscous dissipation in the domain.
!
!-----------------------------------------------------------------------
!
! ****** This routine gets only the volume-integral contribution
! ****** for the part of the domain that resides on this processor.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: nu
      real(r_typ), dimension(nr,nt,np) :: rho
      type(vvec) :: v
      real(r_typ) :: vv
!
!-----------------------------------------------------------------------
!
! ****** Calculate the rate of viscous dissipation.
!
      vv=0.
!
end subroutine
!#######################################################################
subroutine dumphist
!
!-----------------------------------------------------------------------
!
! ****** Empty the time history buffer by writing to the next set
! ****** of history files in the file sequence.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh
      use ident
      use diagnostics
      use vars
      use mpidefs
      use timing
      use ucase_interface
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character, parameter :: TAB=achar(9)
!
      character(*), parameter :: FMT='(100(1pe15.8,a))'
!
!-----------------------------------------------------------------------
!
! ****** History file name and sequence number.
!
      character(512) :: histfile
      logical, save :: first=.true.
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
      integer :: i,j,k,n
      character(2) :: cpt
      character(8) :: lab
!
      integer, dimension(nhistq) :: ix
!
!-----------------------------------------------------------------------
!
! ****** Buffer for communication operations.
!
      integer :: lbuf
      real(r_typ), dimension(:,:), allocatable :: buf
!
!-----------------------------------------------------------------------
!
      if (ihist.le.1) return
!
! ****** Perform the required communication operations.
! ****** Use a buffer to reduce the number of communication calls.
!
!-----------------------------------------------------------------------
! ****** First, do "sum" operations.
!-----------------------------------------------------------------------
!
      n=0
      do i=1,nhistq
        if (thist(i)%gop.eq.GOP_SUM) then
          n=n+1
          ix(n)=i
        end if
      enddo
      if (n.gt.0) then
        allocate (buf(ihist,n))
        do i=1,n
          buf(:,i)=thist(ix(i))%v(1:ihist)
        enddo
        lbuf=n*ihist
        if (use_timer) call timer (TIME_CIO)
        call global_sum_v (lbuf,buf)
        if (use_timer) call timer (TIME_CIO)
        do i=1,n
          thist(ix(i))%v(1:ihist)=buf(:,i)
        enddo
        deallocate (buf)
      end if
!
!-----------------------------------------------------------------------
! ****** Next, do "min" operations.
!-----------------------------------------------------------------------
!
      n=0
      do i=1,nhistq
        if (thist(i)%gop.eq.GOP_MIN) then
          n=n+1
          ix(n)=i
        end if
      enddo
      if (n.gt.0) then
        allocate (buf(ihist,n))
        do i=1,n
          buf(:,i)=thist(ix(i))%v(1:ihist)
        enddo
        lbuf=n*ihist
        if (use_timer) call timer (TIME_CIO)
        call global_min_v (lbuf,buf)
        if (use_timer) call timer (TIME_CIO)
        do i=1,n
          thist(ix(i))%v(1:ihist)=buf(:,i)
        enddo
        deallocate (buf)
      end if
!
!-----------------------------------------------------------------------
! ****** Finally, do "max" operations.
!-----------------------------------------------------------------------
!
      n=0
      do i=1,nhistq
        if (thist(i)%gop.eq.GOP_MAX) then
          n=n+1
          ix(n)=i
        end if
      enddo
      if (n.gt.0) then
        allocate (buf(ihist,n))
        do i=1,n
          buf(:,i)=thist(ix(i))%v(1:ihist)
        enddo
        lbuf=n*ihist
        if (use_timer) call timer (TIME_CIO)
        call global_max_v (lbuf,buf)
        if (use_timer) call timer (TIME_CIO)
        do i=1,n
          thist(ix(i))%v(1:ihist)=buf(:,i)
        enddo
        deallocate (buf)
      end if
!
!-----------------------------------------------------------------------
! ****** Write histories to the file h<runid>.
!-----------------------------------------------------------------------
!
      if (legacy_output_filenames) then
        histfile='h'//runid
      else
        histfile='mas_history_a.out'
      end if
!
      if (iamp0) then
        if (first) then
          call ffopen (IO_HIST_DIAG,trim(histfile),'rw',ierr)
        else
          call ffopen (IO_HIST_DIAG,trim(histfile),'a',ierr)
        end if
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        if(first) then
          write (IO_HIST_DIAG,'(100a)')      trim(thist(1)%lab), &
                              (TAB,trim(thist(j)%lab),j=2,10)
        end if
        do i=1,ihist
          write (IO_HIST_DIAG,FMT)      thist(1)%v(i), &
                         (TAB,thist(j)%v(i),j=2,10)
        enddo
        close(IO_HIST_DIAG)
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from DUMPHIST:'
        write (IO_OUT,*) 'Wrote time histories to file: ',trim(histfile)
        FLUSH (IO_OUT)
      end if
!
!-----------------------------------------------------------------------
! ****** Write histories to the file v<runid>.
!-----------------------------------------------------------------------
!
      if (legacy_output_filenames) then
        histfile='v'//runid
      else
        histfile='mas_history_b.out'
      end if
!
      if (iamp0) then
        if (first) then
          call ffopen (IO_HIST_DIAG,trim(histfile),'rw',ierr)
        else
          call ffopen (IO_HIST_DIAG,trim(histfile),'a',ierr)
        end if
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        if (first) then
          write (IO_HIST_DIAG,'(100a)')      trim(thist(1)%lab), &
                              (TAB,trim(thist(j)%lab),j=11,nhistq)
        end if
        do i=1,ihist
          write (IO_HIST_DIAG,FMT)      thist(1)%v(i), &
                         (TAB,thist(j)%v(i),j=11,nhistq)
        enddo
        close(IO_HIST_DIAG)
        write (IO_OUT,*) 'Wrote time histories to file: ',trim(histfile)
        FLUSH (IO_OUT)
      end if
!
!-----------------------------------------------------------------------
! ****** Write diagnostic points to files of the form: d##<runid>.
!-----------------------------------------------------------------------
!
! ****** Perform the required communication operations.
! ****** Use a buffer to reduce the number of communication calls.
!
      do i=1,ndiagp
        if (diagpt(i)%nq.gt.0) then
          if (ucase(diagpt(i)%type).ne.'VALUE') then
            allocate (buf(ihist,diagpt(i)%nq))
            do j=1,diagpt(i)%nq
              buf(:,j)=diagpt(i)%q(j)%v(1:ihist)
            enddo
            lbuf=ihist*diagpt(i)%nq
            select case (ucase(diagpt(i)%type))
            case ('MIN','MINABS')
              call global_min_v (lbuf,buf)
            case ('MAX','MAXABS')
              call global_max_v (lbuf,buf)
            case ('NORM')
              call global_sum_v (lbuf,buf)
              buf=sqrt(buf/volume)
            end select
            do j=1,diagpt(i)%nq
              diagpt(i)%q(j)%v(1:ihist)=buf(:,j)
            enddo
            deallocate (buf)
          end if
        end if
      enddo
!
! ****** For diagnostic values at a point, the processor on which the
! ****** diagnostic point is located writes the data to the file.
! ****** For global diagnostic values, processor IPROC0 writes
! ****** the data to the file.
!
      do i=1,ndiagp
!
        write (cpt,'(i2.2)') i
        if (legacy_output_filenames) then
          histfile='d'//cpt//runid
        else
          histfile='mas_history_insitu_'//cpt//'.out'
        end if
!
        select case (diagpt(i)%type)
        case ('MIN')
          lab='_min'
        case ('MINABS')
          lab='_abs_min'
        case ('MAX')
          lab='_max'
        case ('MAXABS')
          lab='_abs_max'
        case ('NORM')
          lab='_norm'
        case default
          lab='_dp'//cpt
        end select
!
        ierr=0
        if (iproc.eq.diagpt(i)%iproc) then
          if (first) then
            call ffopen (IO_HIST_DIAG,trim(histfile),'rw',ierr)
          else
            call ffopen (IO_HIST_DIAG,trim(histfile),'a',ierr)
          end if
        end if
        call check_error_on_any_proc (ierr)
!
        if (iproc.eq.diagpt(i)%iproc) then
          if (first) then
            write (IO_HIST_DIAG,'(100a)') trim(thist(1)%lab), &
                                (TAB,trim(diagpt(i)%q(j)%name)// &
                                 trim(lab),j=1,diagpt(i)%nq)
          end if
          do k=1,ihist
            write (IO_HIST_DIAG,FMT) thist(1)%v(k), &
                          (TAB,diagpt(i)%q(j)%v(k),j=1,diagpt(i)%nq)
          enddo
          close(IO_HIST_DIAG)
        end if
!
        if (iamp0) then
          write (IO_OUT,*) &
            'Wrote diagnostic point time history to file: ', &
            trim(histfile)
          FLUSH (IO_OUT)
        end if
!
      enddo
!
      if (ndiagp.gt.0) then
        if (iamp0) then
          write (IO_OUT,*) 'NTIME = ',ntime
          write (IO_OUT,*) 'TIME = ',time
          FLUSH (IO_OUT)
        end if
      end if
!
      if (first) then
        first=.false.
      end if
end subroutine
!#######################################################################
subroutine plot_dump
!
!-----------------------------------------------------------------------
!
! ****** Dump the requested fields at the present time.
!
!-----------------------------------------------------------------------
!
      use field_table
      use diagnostics
      use vars
      use mpidefs
      use timing
      use hdfname_interface
      use write_field_interface
      use lcase_interface
      use mod_input_parameter
      use mod_eigen_matrix
      use fields
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** File sequence number.
!
      integer, save :: iseq=0
!
!-----------------------------------------------------------------------
!
      integer :: i,j,jelem,jj,natom
      character (8) :: froot
      character (1) :: snl='3'
!
!-----------------------------------------------------------------------
!
! ****** Increment the HDF sequence number.
!
      if (long_sequence_numbers) then
        iseq=mod(iseq+1,1000000)
        snl='6'
      else
        iseq=mod(iseq+1,1000)
        snl='3'
      end if
!
! ****** Write the requested fields to HDF files.
!
      do i=1,nplot
        j=plot_index(i)
        call write_field (hdfname(lcase(fldtab(j)%name),iseq), &
                          j,fldtab(j)%f)
      enddo
!
! ****** Write the charge states fields to HDF files.
!
      if (advance_fcs.and.plot_dump_fcs) then
        j=0
        do jelem=1,nelem
          natom=natom_list(jelem)
          do jj=1,natom+1
            j=j+1
            write (froot,'(a,a,a,i2.2,a)')'f_', &
            trim(char_element(i_chemi_eigen(jelem))),'_',jj-1,'_'
            call write_field (hdfname(froot,iseq),IFLD_RHO,fcs(:,:,:,j))
          enddo
        enddo
      end if
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from PLOT_DUMP:'
        write (IO_OUT,*) '### Wrote out the requested fields.'
        write (IO_OUT,*) 'File sequence number = ',iseq
        write (IO_OUT,*) 'NTIME = ',ntime
        write (IO_OUT,*) 'TIME = ',time
        write (IO_DUMP_3D, &
                  "(i"//snl//"."//snl//",'    ',E25.16E3)") iseq,time
        FLUSH (IO_OUT)
        FLUSH (IO_DUMP_3D)
      end if
!
end subroutine
!#######################################################################
subroutine particle_dump
!
!-----------------------------------------------------------------------
!
! ****** Dump the tracer particles at the present time.
!
!-----------------------------------------------------------------------
!
      use diagnostics
      use vars
      use mpidefs
      use timing
      use hdfname_interface
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** File sequence number.
!
      integer, save :: iseq=0
      character (1) :: snl='3'
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i
!
      real(r_typ), dimension(:,:), allocatable :: f
!
!-----------------------------------------------------------------------
!
!$acc update self(tracers%r,tracers%t,tracers%p)
      ierr=0
!
! ****** Increment the tracer sequence number.
!
      if (long_sequence_numbers) then
        iseq=mod(iseq+1,1000000)
        snl='6'
      else
        iseq=mod(iseq+1,1000)
        snl='3'
      end if
!
! ****** Write the tracer particles and requested values to HDF files.
!
      if (iamp0) then
        allocate (f(tracers%n,3))
!
        f(:,1)=tracers%r(:)
        f(:,2)=tracers%t(:)
        f(:,3)=tracers%p(:)
!
        call wrhdf_2d (hdfname('tracers_pos',iseq),.false., &
                  tracers%n,3,f,tracers%r(:),tracers%t(1:3),.true.,ierr)
!
        if (ierr.ne.0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### ERROR in PARTICLE_DUMP:'
          write (IO_OUT,*) '### Could not write the particles file.'
          write (IO_OUT,*) 'IERR (from WRHDF_2D) = ',ierr
          write (IO_OUT,*) 'File name: ', &
                           trim(hdfname('tracers_pos',iseq))
          write (*,*)
          write (*,*) '### ERROR in PARTICLE_DUMP:'
          write (*,*) '### Could not write the particles file.'
          write (*,*) 'IERR (from WRHDF_2D) = ',ierr
          write (*,*) 'File name: ',trim(hdfname('tracers_pos',iseq))
        end if
!
        deallocate (f)
!
        if (trace_track_ds) then
!$acc update self(tracers%ds)
          call wrhdf_1d (hdfname('tracers_ds',iseq),.false., &
                     tracers%n,tracers%ds,tracers%r,.true.,ierr)
!
          if (ierr.ne.0) then
            write (IO_OUT,*)
            write (IO_OUT,*) '### ERROR in PARTICLE_DUMP:'
            write (IO_OUT,*) '### Could not write a particle file.'
            write (IO_OUT,*) 'IERR (from WRHDF_1D) = ',ierr
            write (IO_OUT,*) 'File name: ', &
                             trim(hdfname('tracers_ds',iseq))
            write (*,*)
            write (*,*) '### ERROR in PARTICLE_DUMP:'
            write (*,*) '### Could not write a particle file.'
            write (*,*) 'IERR (from WRHDF_1D) = ',ierr
            write (*,*) 'File name: ',trim(hdfname('tracers_ds',iseq))
          end if
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from PARTICLE_DUMP:'
        write (IO_OUT,*) '### Wrote out the requested tracer quantities.'
        write (IO_OUT,*) 'File sequence number = ',iseq
        write (IO_OUT,*) 'NTIME = ',ntime
        write (IO_OUT,*) 'TIME = ',time
        write (IO_DUMP_TRACERS, &
                   "(i"//snl//"."//snl//",'    ',E25.16E3)") iseq,time
        FLUSH (IO_OUT)
        FLUSH (IO_DUMP_TRACERS)
      end if
!
! ****** If tracking ds, reset it for next dump.
!
      if (trace_track_ds) then
        do concurrent (i=1:tracers%n)
          tracers%ds(i)=0.
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine slice_dump
!
!-----------------------------------------------------------------------
!
! ****** Dump the sliced requested fields at the present time.
!
!-----------------------------------------------------------------------
!
      use field_table
      use diagnostics
      use vars
      use mpidefs
      use timing
      use hdf_tpslice_name_interface
      use lcase_interface
      use write_field_tp_interface
      use fields
      use mesh
      use globals, ONLY: nr,nrm,rb1,rb0
      use io_units
      use mod_input_parameter
      use mod_eigen_matrix
      use hdfname_interface
      use emerging_flux_params
      use prescribe_b_v_at_r0_vars
      use interp_interface
      use prescribe_tdc_from_file_r0
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** File sequence number.
!
      integer, save :: iseq=0
      character (1) :: snl='3'
      integer :: iseq_slice
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,ierr,r0idx,r1idx,r0_int_idx,r1_int_idx,jelem,jj, &
      natom
      real(r_typ) :: r0val,r1val,r_int_fac,tpslice_r
      integer :: iproc_rslice
      character (512) :: fname=''
      character (8) :: froot=''
      real(r_typ), dimension (:,:), allocatable :: a_tp
      real(r_typ), dimension (:), pointer, contiguous :: rvec
!
!-----------------------------------------------------------------------
!
! ****** Increment the HDF sequence number.
!
      if (long_sequence_numbers) then
        iseq=mod(iseq+1,1000000)
        snl='6'
      else
        iseq=mod(iseq+1,1000)
        snl='3'
      end if
!
! ****** Get the slice and write for each field.
!
      do i=1,nplot_slices
!
! ****** Get the field we want to plot.
!
        j=slice_plot_index(i)
!
! ****** Get the start and end index of the unique local r grid.
!
        if (rb0) then
          r0idx=1
        else
          r0idx=2
        end if
!
! ****** Check if field is on main or half mesh in r and set
! ****** range accordingly.
!
        if (fldtab(j)%rm) then
          r0val=r(r0idx)
          r1val=r(nrm)
          rvec=>r
        else
          r0val=rh(r0idx)
          r1val=rh(nr)
          rvec=>rh
        end if
!
        do k=1,n_tpslice_radii
!
! ****** Get the current selected tp slice r value.
!
          tpslice_r=slice_tp_radii(k)
!
          if ((tpslice_r.ge.r0val.and.tpslice_r.lt.r1val).or. &
              (rb1.and.tpslice_r.ge.r0val.and.tpslice_r.le.r1val)) then
!
            iproc_rslice=iproc_r
!
            allocate (a_tp(fldtab(j)%n2(iproc),fldtab(j)%n3(iproc)))
!
! ****** Interpolate and store in local array.
!
            call interp (nr,rvec,tpslice_r,r0_int_idx, &
                         r1_int_idx,r_int_fac,ierr)
!
!$acc update self(fldtab(j)%f(r0_int_idx:r1_int_idx,:,:)) if_present
            a_tp(:,:)=(one-r_int_fac)*fldtab(j)%f(r0_int_idx,:,:) &
                         +(r_int_fac)*fldtab(j)%f(r1_int_idx,:,:)
!
! ****** Write out slice.
!
            fname=hdf_tpslice_name(lcase(fldtab(j)%name),iseq,k)
!
         else
           iproc_rslice=0
           allocate (a_tp(1,1))
         end if
!
! ****** Use summation trick to make all ranks have iproc_rslice.
!
         call MPI_Allreduce (MPI_IN_PLACE,iproc_rslice,1, &
                             MPI_INTEGER,MPI_SUM,comm_r,ierr)
!
! ****** Due to error-checking, this needs to be called by all ranks.
!
         call write_field_tp (fname,j,a_tp,iproc_rslice)
!
         deallocate(a_tp)
!
        enddo
      enddo
!
! ****** Write the TDC debugging slices if requested.
!
      if (debug_tdc) then
!$acc update self(br_pbv,eflux_vr,eflux_vt,eflux_vp,eflux_er, &
!$acc             eflux_et,eflux_ep,vb%r0%r,vb%r0%t,vb%r0%p, &
!$acc             vxbbr0r,vxbbr0t,vxbbr0p,curl_et,div_et, &
!$acc             phi_tdc)
        fname=hdfname('br_pbv',iseq)
        call write_field_tp (fname,IFLD_BR,br_pbv,iproc_rb0)
        fname=hdfname('eflux_vr',iseq)
        call write_field_tp (fname,IFLD_VR,eflux_vr,iproc_rb0)
        fname=hdfname('eflux_vt',iseq)
        call write_field_tp (fname,IFLD_VT,eflux_vt,iproc_rb0)
        fname=hdfname('eflux_vp',iseq)
        call write_field_tp (fname,IFLD_VP,eflux_vp,iproc_rb0)
        fname=hdfname('eflux_er',iseq)
        call write_field_tp (fname,IFLD_VR,eflux_er,iproc_rb0)
        fname=hdfname('eflux_et',iseq)
        call write_field_tp (fname,IFLD_VT,eflux_et,iproc_rb0)
        fname=hdfname('eflux_ep',iseq)
        call write_field_tp (fname,IFLD_VP,eflux_ep,iproc_rb0)
        fname=hdfname('vbr0r',iseq)
        call write_field_tp (fname,IFLD_VR,vb%r0%r,iproc_rb0)
        fname=hdfname('vbr0t',iseq)
        call write_field_tp (fname,IFLD_VT,vb%r0%t,iproc_rb0)
        fname=hdfname('vbr0p',iseq)
        call write_field_tp (fname,IFLD_VP,vb%r0%p,iproc_rb0)
        fname=hdfname('vxbr0r',iseq)
        call write_field_tp (fname,IFLD_VR,vxbbr0r,iproc_rb0)
        fname=hdfname('vxbr0t',iseq)
        call write_field_tp (fname,IFLD_VT,vxbbr0t,iproc_rb0)
        fname=hdfname('vxbr0p',iseq)
        call write_field_tp (fname,IFLD_VP,vxbbr0p,iproc_rb0)
        fname=hdfname('curl_et',iseq)
        call write_field_tp (fname,IFLD_BR,curl_et,iproc_rb0)
        fname=hdfname('div_et',iseq)
        call write_field_tp (fname,IFLD_VR,div_et,iproc_rb0)
        fname=hdfname('phi_tdc',iseq)
        call write_field_tp (fname,IFLD_VR,phi_tdc,iproc_rb0)
      endif
!
! ****** Write the WTD debugging slices if requested.
!
      if (debug_wtd) then
        if (wtd_use_open_field_cutoff.and. &
            debug_wtd_open_field_cutoff) then
!$acc update self(wtd_open_flux_zmult,wtd_net_pflux,wtd_mask_open)
          fname=hdfname('wtd_open_flux_zmult',iseq)
          call write_field_tp(fname,IFLD_VR, &
                              wtd_open_flux_zmult,iproc_rb0)
          fname=hdfname('wtd_net_pflux',iseq)
          call write_field_tp(fname,IFLD_VR,wtd_net_pflux,iproc_rb0)
          fname=hdfname('wtd_mask_open',iseq)
          call write_field_tp(fname,IFLD_VR,wtd_mask_open,iproc_rb0)
        endif
      endif
!
! ****** Write the charge states fields to HDF files.
!
      if (advance_fcs.and.slice_dump_fcs) then
        j=0
        do jelem=1,nelem
          natom=natom_list(jelem)
          do jj=1,natom+1
            j=j+1
!
! ****** Get the start and end index of the unique local r grid.
!
            if (rb0) then
              r0idx=1
            else
              r0idx=2
            end if
!
! ****** Fields are all on the rh grid.
!
            r0val=rh(r0idx)
            r1val=rh(nr)
            rvec=>rh
            do k=1,n_tpslice_radii
!
! ****** Get the current selected tp slice r value.
!
              tpslice_r=slice_tp_radii(k)
!
              if ((tpslice_r.ge.r0val.and.tpslice_r.lt.r1val).or. &
               (rb1.and.tpslice_r.ge.r0val.and.tpslice_r.le.r1val)) then
!
                iproc_rslice=iproc_r
!
                allocate (a_tp(fldtab(IFLD_RHO)%n2(iproc), &
                               fldtab(IFLD_RHO)%n3(iproc)))
!
! ****** Interpolate and store in local array.
!
                call interp (nr,rvec,tpslice_r,r0_int_idx, &
                             r1_int_idx,r_int_fac,ierr)
!
                a_tp(:,:)=(one-r_int_fac)*fcs(r0_int_idx,:,:,j) &
                             +(r_int_fac)*fcs(r1_int_idx,:,:,j)
                write (froot,'(a,a,a,i2.2,a)')'f_',trim( &
                char_element(i_chemi_eigen(jelem))),'_',jj-1,'_'
!
! ****** Write out slice.
!
                fname=hdf_tpslice_name(froot,iseq,k)
!
              else
                iproc_rslice=0
                allocate (a_tp(1,1))
              end if
!
! ****** Use summation trick to make all ranks have iproc_rslice.
!
              call MPI_Allreduce (MPI_IN_PLACE,iproc_rslice,1, &
                                  MPI_INTEGER,MPI_SUM,comm_r,ierr)
!
! ****** Due to error-checking, this needs to be called by all ranks.
!
              call write_field_tp (fname,IFLD_RHO,a_tp,iproc_rslice)
!
              deallocate(a_tp)
!
            enddo
          enddo
        enddo
      end if
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from SLICE_DUMP:'
        write (IO_OUT,*) '### Should have written the requested fields'
        write (IO_OUT,*) '### at requested r slices.'
        write (IO_OUT,*) 'File sequence number = ',iseq
        write (IO_OUT,*) 'NTIME = ',ntime
        write (IO_OUT,*) 'TIME = ',time
        write (IO_DUMP_SLICE, &
                   "(i"//snl//"."//snl//",'    ',E25.16E3)") iseq,time
        FLUSH (IO_OUT)
        FLUSH (IO_DUMP_SLICE)
      end if
!
end subroutine
!#######################################################################
subroutine define_input_rs_params
!
!-----------------------------------------------------------------------
!
! ****** Define the parameters associated with the requested input
! ****** restart file configuration.
!
!-----------------------------------------------------------------------
!
      use vars
      use field_table
      use hdf_defs
      use restart
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      logical :: use_rs_input_file_root
      integer :: i
      character(2) :: ch2
!
!-----------------------------------------------------------------------
!
! ****** Check that the requested number of input restart files
! ****** is valid.
!
! ****** The restart file can either be a single file, a three-part
! ****** file, or a fifteen-part file.
!
      if (.not.(n_rs_input_file_parts.eq. 1.or. &
                n_rs_input_file_parts.eq. 3.or. &
                n_rs_input_file_parts.eq.15.or. &
                n_rs_input_file_parts.eq.17)) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in DEFINE_INPUT_RS_PARAMS:'
          write (*,*) '### The specified number of input restart'// &
                      ' file parts is invalid:'
          write (*,*) 'N_RS_INPUT_FILE_PARTS = ', &
                      n_rs_input_file_parts
          write (*,*)
          write (*,*) '### The only valid values are:'
          write (*,*) '1'
          write (*,*) '3'
          write (*,*) '15'
          write (*,*) '17'
        end if
        call endrun (.true.)
      end if
!
! ****** Set the number of input restart file parts.
!
      n_rs_i_files=n_rs_input_file_parts
!
! ****** Define the structure of input restart files, depending
! ****** on the type of restart file selected.
!
! ****** First, check if this is a restart run.
!
      if (n_rs_i_files.eq.1.and.rsifile.ne.' ') then
        restart_run=.true.
      else if (n_rs_i_files.eq.3 &
               .or.n_rs_i_files.eq.15.or.n_rs_i_files.eq.17) then
        if (rsifile_root.ne.' ') then
          restart_run=.true.
          use_rs_input_file_root=.true.
        else if (rsifile_parts(1).ne.' ') then
          restart_run=.true.
          use_rs_input_file_root=.false.
        end if
      else
        restart_run=.false.
      end if
!
! ****** If this is not a restart run, there is nothing further
! ****** to be done.
!
      if (.not.restart_run) return
!
! ****** Define the properties of the fields that are to be read
! ****** from the restart file.
!
      rs_i(:)%index=(/IFLD_ETA, &
                      IFLD_VIS, &
                      IFLD_AR, &
                      IFLD_AT, &
                      IFLD_AP, &
                      IFLD_VR, &
                      IFLD_VT, &
                      IFLD_VP, &
                      IFLD_RHO, &
                      IFLD_PRES, &
                      IFLD_VR_OLD, &
                      IFLD_VT_OLD, &
                      IFLD_VP_OLD, &
                      IFLD_EP, &
                      IFLD_EM, &
                      IFLD_T_E, &
                      IFLD_ZP, &
                      IFLD_ZM/)
!
      rs_i(:)%required=(/.true., &
                         .true., &
                         .true., &
                         .true., &
                         .true., &
                         .true., &
                         .true., &
                         .true., &
                         .true., &
                         .true., &
                         .false., &
                         .false., &
                         .false., &
                         .false., &
                         .false., &
                         .false., &
                         .false., &
                         .false./)
!
      if (n_rs_i_files.eq.1) then
        rs_i(:)%fname=rsifile
      else if (n_rs_i_files.eq.3) then
        if (use_rs_input_file_root) then
          rs_i( 1: 5)%fname=trim(rsifile_prefix)// &
                            'rs_p1_'// &
                            trim(rsifile_root)//'.h5'
          rs_i( 6:10)%fname=trim(rsifile_prefix)// &
                            'rs_p2_'// &
                            trim(rsifile_root)//'.h5'
          rs_i(11:n_rs_fields)%fname=trim(rsifile_prefix)// &
                            'rs_p3_'// &
                            trim(rsifile_root)//'.h5'
        else
          rs_i( 1: 5)%fname=rsifile_parts(1)
          rs_i( 6:10)%fname=rsifile_parts(2)
          rs_i(11:n_rs_fields)%fname=rsifile_parts(3)
        end if
      else if (n_rs_i_files.eq.15.or.n_rs_i_files.eq.17) then
        if (use_rs_input_file_root) then
          do i=1,n_rs_i_files
            write (ch2,'(i2.2)') i
            rs_i(i)%fname=trim(rsifile_prefix)// &
                          'rs_p'//ch2//'_'// &
                          trim(rsifile_root)//'.h5'
          enddo
        else
          do i=1,n_rs_i_files
            rs_i(i)%fname=rsifile_parts(i)
          enddo
        end if
      end if
!
end subroutine
!#######################################################################
subroutine define_output_rs_params
!
!-----------------------------------------------------------------------
!
! ****** Define the parameters associated with the requested output
! ****** restart file configuration.
!
!-----------------------------------------------------------------------
!
      use vars
      use field_table
      use hdf_defs
      use restart
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** The restart file is a single file.
! ****** Allocate memory for the output restart file structure.
!
      allocate (rs_o(1))
!
      rs_o(1)%nfields=18
!
      allocate (rs_o(1)%index(rs_o(1)%nfields))
      allocate (rs_o(1)%write(rs_o(1)%nfields))
!
! ****** Define the output restart file configuration.
!
! ****** Currently, all fields, including optional fields, are
! ****** written to the output file.
!
      rs_o(1)%index=(/IFLD_ETA, &
                      IFLD_VIS, &
                      IFLD_AR, &
                      IFLD_AT, &
                      IFLD_AP, &
                      IFLD_VR, &
                      IFLD_VT, &
                      IFLD_VP, &
                      IFLD_RHO, &
                      IFLD_PRES, &
                      IFLD_VR_OLD, &
                      IFLD_VT_OLD, &
                      IFLD_VP_OLD, &
                      IFLD_EP, &
                      IFLD_EM, &
                      IFLD_T_E, &
                      IFLD_ZP, &
                      IFLD_ZM/)
      rs_o(1)%write=.true.
      rs_o(1)%fname_root='rs'
!
! ****** Set the flag to indicate that the output restart file
! ****** configuration has been defined.
      output_rs_file_config_defined=.true.
!
end subroutine
!#######################################################################
subroutine read_restart_header
!
!-----------------------------------------------------------------------
!
! ****** Read the header from restart file.
!
! ****** This reads the mesh dimensions and scalar variables
! ****** from the file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars
      use energy_diagnostic
      use hdf_defs
      use mpidefs
      use restart
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i
!
! ****** Structures to assist in reading restart file variables.
!
      integer :: ncvars,nivars,nrvars
!
      type(cvar), dimension(:), allocatable :: cvars
      type(ivar), dimension(:), allocatable :: ivars
      type(rvar), dimension(:), allocatable :: rvars
!
      real(r_typ), dimension(:), allocatable :: rbuf
      integer, dimension(:), allocatable :: ibuf
!
!-----------------------------------------------------------------------
!
      logical, external :: rs_var_present
!
!-----------------------------------------------------------------------
!
! ****** Open the (first) restart file.
!
      call open_restart_file (rs_i(1)%fname)
!
      if (iamp0) then
        write (9,*)
        write (9,*) repeat ('-',72)
        write (9,*)
        write (9,*) '### COMMENT from READ_RESTART_HEADER:'
        write (9,*) 'Reading from restart file: ',trim(rs_i(1)%fname)
      end if
!
! ****** Read the header.
!
      ncvars=10
      allocate (cvars(ncvars))
!
      cvars( 1)%name='File type'
      cvars( 2)%name='Code'
      cvars( 3)%name='Version'
      cvars( 4)%name='Updated on'
      cvars( 5)%name='Source file'
      cvars( 6)%name='Run ID'
      cvars( 7)%name='Ran on machine'
      cvars( 8)%name='Machine type'
      cvars( 9)%name='Written on'
      cvars(10)%name='Written at'
!
      nivars=4
      allocate (ivars(nivars))
!
      ivars(1)%name='NR'
      ivars(2)%name='NT'
      ivars(3)%name='NP'
      ivars(4)%name='NTIME'
!
      nrvars=6
      allocate (rvars(nrvars))
!
      rvars(1)%name='TIME'
      rvars(2)%name='BR00'
      rvars(3)%name='E_DISSIPATED'
      rvars(4)%name='E_POYNT'
      rvars(5)%name='POYNT'
      rvars(6)%name='DTIME'
!
! ****** Read the header information from the restart file.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### Restart file information:'
        write (9,*)
        do i=3,ncvars
          if (rs_var_present(cvars(i)%name)) then
            call rdrsh5_c (cvars(i)%name,cvars(i)%value,ierr)
            if (ierr.ne.0) go to 300
            write (9,*) '    ',trim(cvars(i)%name)//': ', &
                               trim(cvars(i)%value)
          end if
        enddo
        do i=1,nivars
          call rdrsh5_i (ivars(i)%name,ivars(i)%value,ierr)
          if (ierr.ne.0) go to 300
        enddo
        do i=1,nrvars-1
          call rdrsh5_r (rvars(i)%name,rvars(i)%value,ierr)
          if (ierr.ne.0) go to 300
        enddo
!
! ****** Read the old time step, if it is present. If it is missing
! ****** set the value to dtmax or dt_init.
!
        call rdrsh5_r (rvars(nrvars)%name,rvars(nrvars)%value,ierr)
        if (ierr.ne.0) then
          write (9,*)
          write (9,*) '### WARNING from READ_RESTART_HEADER:'
          write (9,*) '### Restart file missing DTIME.'
          write (9,*)
          if (use_dt_init_on_restart) then
            rvars(nrvars)%value=dt_init
          else
            rvars(nrvars)%value=dtmax
          end if
          ierr=0
        end if
      end if
  300 continue
      call check_error_on_p0 (ierr)
!
! ****** Broadcast variables to all processors.
!    [][RMC][] Is this needed?   All procs read the header above?
!
      allocate (ibuf(nivars))
!
      if (iamp0) ibuf(:)=ivars(:)%value
!
      call MPI_Bcast (ibuf,nivars,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
!
      nr_rs   =ibuf(1)
      nt_rs   =ibuf(2)
      np_rs   =ibuf(3)
      ntime_rs=ibuf(4)
!
      deallocate (ibuf)
!
      allocate (rbuf(nrvars))
!
      if (iamp0) rbuf(:)=rvars(:)%value
!
      call MPI_Bcast (rbuf,nrvars,ntype_real,0,MPI_COMM_WORLD,ierr)
!
! ****** Set the time of the run if not overwritten.
!
      if (time_at_start.lt.0) then
        time=rbuf(1)
      else
        time=time_at_start
      end if
!
      br00=rbuf(2)
      dtime=rbuf(6)
!
! ****** The accumulated energies are apportioned to processor
! ****** IPROC0 (arbitrarily).  It is only the total sum over
! ****** all processors that has physical meaning.
!
      if (iamp0) then
        e_dissipated=rbuf(3)
        e_poynt     =rbuf(4)
        poynt       =rbuf(5)
      else
        e_dissipated=0.
        e_poynt     =0.
        poynt       =0.
      end if
!
      deallocate (rbuf)
!
      deallocate (cvars)
      deallocate (ivars)
      deallocate (rvars)
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from READ_RESTART_HEADER:'
        write (9,*) '### Mesh dimensions from restart file:'
        write (9,*)
        write (9,*) 'NR = ',nr_rs
        write (9,*) 'NT = ',nt_rs
        write (9,*) 'NP = ',np_rs
      end if
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from READ_RESTART_HEADER:'
        write (9,*) '### Time values from restart file:'
        write (9,*)
        write (9,*) 'TIME (at restart)  = ',time
        write (9,*) 'NTIME (at restart) = ',ntime_rs
      end if
!
! ****** Close the restart file.
!
      call close_restart_file
!
end subroutine
!#######################################################################
subroutine read_restart_mesh
!
!-----------------------------------------------------------------------
!
! ****** Read the mesh from the restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use restart
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Open the (first) restart file.
!
      call open_restart_file (rs_i(1)%fname)
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from READ_RESTART_FILE_MESH:'
        write (9,*) 'Reading the mesh from restart file: ', &
                    trim(rs_i(1)%fname)
      end if
!
! ****** Read the mesh.
!
      if (iamp0) then
        call rdrsh5_1d ('r',nrm1_g,r_g,ierr)
        if (ierr.ne.0) go to 100
        call rdrsh5_1d ('t',ntm1_g,t_g,ierr)
        if (ierr.ne.0) go to 100
        call rdrsh5_1d ('p',np_g,p_g,ierr)
        if (ierr.ne.0) go to 100
      end if
  100 continue
      call check_error_on_p0 (ierr)
!
! ****** Close the restart file.
!
      call close_restart_file
!
! ****** Broadcast the mesh to all processors.
!
      call MPI_Bcast (r_g,nrm1_g,ntype_real,iproc0,comm_all,ierr)
      call MPI_Bcast (t_g,ntm1_g,ntype_real,iproc0,comm_all,ierr)
      call MPI_Bcast (p_g,np_g,ntype_real,iproc0,comm_all,ierr)
!
end subroutine
!#######################################################################
subroutine read_restart_fields
!
!-----------------------------------------------------------------------
!
! ****** Read the fields from the restart file.
!
!-----------------------------------------------------------------------
!
      use fields
      use field_table
      use restart
      use seam_interface
      use vars
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Read the fields.
!
      do i=1,n_rs_fields
        call read_field_from_restart (rs_i(i)%fname, &
                                      rs_i(i)%index, &
                                      rs_i(i)%required, &
                                      rs_i(i)%read)
      enddo
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from READ_RESTART_FIELDS:'
        write (9,*) 'The fields were read successfully.'
        write (9,*)
        write (9,*) repeat ('-',72)
      end if
!
! ****** Load fields that were not present in the restart file
! ****** with default values.
!
      do i=1,n_rs_fields
        if (.not.rs_i(i)%required) then
          if (.not.rs_i(i)%read) then
            select case (rs_i(i)%index)
            case (IFLD_VR_OLD)
              fldtab(IFLD_VR_OLD)%f=fldtab(IFLD_VR)%f
            case (IFLD_VT_OLD)
              fldtab(IFLD_VT_OLD)%f=fldtab(IFLD_VT)%f
            case (IFLD_VP_OLD)
              fldtab(IFLD_VP_OLD)%f=fldtab(IFLD_VP)%f
            case (IFLD_EP)
              fldtab(IFLD_EP)%f=0.
            case (IFLD_EM)
              fldtab(IFLD_EM)%f=0.
            case (IFLD_T_E)
              fldtab(IFLD_T_E)%f=(he_rho/he_p)*fldtab(IFLD_PRES)%f/ &
                                               fldtab(IFLD_RHO )%f
            case (IFLD_ZP)
              fldtab(IFLD_ZP)%f=0.
            case (IFLD_ZM)
              fldtab(IFLD_ZM)%f=0.
            end select
          end if
        end if
      enddo
!
! ****** Seam the fields.
!
      call seam (eta)
      call seam (vis)
      call seam_avec_cpu (a)
      call seam (v%r)
      call seam (v%t)
      call seam (v%p)
      call seam (rho)
      call seam (pres)
      call seam (v_old%r)
      call seam (v_old%t)
      call seam (v_old%p)
      call seam (em)
      call seam (ep)
      call seam (temp_e)
      call seam (zm)
      call seam (zp)
!
      call read_vbr0_from_restart (rs_i(1)%fname)
!
end subroutine
!#######################################################################
subroutine read_field_from_restart (fname,ifld, &
                                          required, &
                                          field_read)
!
!-----------------------------------------------------------------------
!
! ****** Read the field with field table index IFLD from
! ****** restart file FNAME.
!
! ****** When REQUIRED=.true., an error occurs if the field is not
! ****** present in the file.  Otherwise, if the field is present
! ****** in the file, FIELD_READ=.true. is returned; if it is not
! ****** present, FIELD_READ=.false. is returned.
!
!-----------------------------------------------------------------------
!
      use number_types
      use fields
      use field_table
      use hdf_defs
      use mpidefs
      use distribute_array_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: ifld
      logical :: required
      logical :: field_read
!
!-----------------------------------------------------------------------
!
      integer :: ierr,n1,n2,n3
      logical :: field_present
!
!-----------------------------------------------------------------------
!
! ****** Declaration for a global field array.  This array is only
! ****** allocated on IPROC0.
!
      real(r_typ), dimension(:,:,:), allocatable :: a_g
!
!-----------------------------------------------------------------------
!
      logical, external :: rs_array_present
!
!-----------------------------------------------------------------------
!
! ****** Open the restart file.
!
      call open_restart_file (fname)
!
! ****** Check to see if the field is present in the file.
!
      if (iamp0) then
        field_present=rs_array_present(fldtab(ifld)%name)
      end if
      call MPI_Bcast (field_present,1,MPI_LOGICAL, &
                      iproc0,comm_all,ierr)
!
! ****** It is an error if REQUIRED=.true. and the field is not
! ****** present in the file.
!
      if (iamp0) then
        if (required.and.(.not.field_present)) then
          write (*,*)
          write (*,*) '### ERROR in READ_FIELD_FROM_RESTART:'
          write (*,*) '### A required field was not present'// &
                      ' in the restart file:'
          write (*,*) 'Field: ',trim(fldtab(ifld)%name)
          write (*,*) 'Restart file: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Read the field if it is present.
!
      if (field_present) then
        if (iamp0) then
          n1=fldtab(ifld)%n1_g
          n2=fldtab(ifld)%n2_g
          n3=fldtab(ifld)%n3_g
          allocate (a_g(n1,n2,n3))
          call rdrsh5_3d (fldtab(ifld)%name,n1,n2,n3,a_g,ierr)
        else
          allocate (a_g(1,1,1))
        end if
        call check_error_on_p0 (ierr)
        call distribute_array (fldtab(ifld)%n1,fldtab(ifld)%n2, &
                               fldtab(ifld)%n3,a_g,fldtab(ifld)%f)
        deallocate (a_g)
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from READ_FIELD_FROM_RESTART:'
          write (9,*) '### The following field was read in:'
          write (9,*) trim(fldtab(ifld)%name)
        end if
        field_read=.true.
      else
        field_read=.false.
      end if
!
! ****** Close the restart file.
!
      call close_restart_file
!
end subroutine
!#######################################################################
subroutine write_restart (iseq)
!
!-----------------------------------------------------------------------
!
! ****** Write a restart file.
!
!-----------------------------------------------------------------------
!
! ****** The sequence number ISEQ is used to create restart files
! ****** that are periodically written during the run.  For the
! ****** final restart file, use ISEQ=0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use fields
      use ident
      use energy_diagnostic
      use field_table
      use restart
      use assemble_array_interface
      use assemble_array_tp_interface
      use mpidefs
      use hdf_defs
      use io_units
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: iseq
!
!-----------------------------------------------------------------------
!
      integer :: ierr,req1,req2,proc_corner
      character(3) :: ch_seq
      character(256) :: fname
      character(4) :: fext
!
      integer :: i,j,ix
      integer :: n1,n2,n3
!
!-----------------------------------------------------------------------
!
! ****** Declaration for a global field array.  This array is only
! ****** allocated on IPROC0.
!
      real(r_typ), dimension(:,:,:), allocatable :: a_g
      real(r_typ), dimension(:,:), allocatable :: atp_g,atp_g0
!
!-----------------------------------------------------------------------
!
! ****** If the output restart file configuration has not been
! ****** defined yet, do not attempt to write a restart file.
! ****** This can happen if an error occurs early in the run
! ****** setup process.
!
      if (.not.output_rs_file_config_defined) return
!
      fext='.h5'
!
! ****** Convert the sequence number to a character string
! ****** (if requested).
!
      if (iseq.gt.0) then
        write (ch_seq,'(i3.3)') iseq
      else
        ch_seq=''
      end if
!
! ****** Get the time and date.
!
      call datetime (restart_file_date,restart_file_time)
!
! ****** Sum the accumulated energies over all processors.  These
! ****** are written to the restart file.
!
      energy_buf(1)=e_dissipated
      energy_buf(2)=e_poynt
      energy_buf(3)=poynt
!
      call global_sum_v (3,energy_buf)
!
! ****** Create the (first) restart file.
!
      fname=trim(rs_o(1)%fname_root)// &
            trim(runid)// &
            trim(ch_seq)//trim(fext)
!
      call create_restart_file (fname)
!
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from WRITE_RESTART:'
        write (IO_OUT,*) 'Writing to restart file: ',trim(fname)
        write (IO_OUT,*) 'NTIME = ',ntime
        write (IO_OUT,*) 'TIME = ',time
        if (iseq.gt.0) then
          write (IO_DUMP_RS,*) ch_seq,' ',time
          FLUSH (IO_DUMP_RS)
        end if
        FLUSH (IO_OUT)
      end if
!
! ****** Write the header.
!
      call write_restart_header (1)
!
! ****** Write the mesh.
!
      if (iamp0) then
        call wrrsh5_1d ('r',nrm1_g,r_g,ierr)
        if (ierr.ne.0) go to 100
        call wrrsh5_1d ('t',ntm1_g,t_g,ierr)
        if (ierr.ne.0) go to 100
        call wrrsh5_1d ('p',np_g,p_g,ierr)
        if (ierr.ne.0) go to 100
      end if
  100 continue
      call check_error_on_p0 (ierr)
!
! ****** vb%r0 fields.
!
!     Get the rank of the "corner" proc on the lower radial boundary.
!
      if (iproc_r.eq.iproc_rb0.and.iproc2d_tp.eq.0) then
        proc_corner=iproc
      else
        proc_corner=0
      end if
      call MPI_Allreduce (MPI_IN_PLACE,proc_corner,1,MPI_INTEGER, &
                          MPI_SUM,comm_all,ierr)
!
! ****** Need to allow corner rank to send 2D array to iproc0,
! ****** but also need to allow for the case where iproc0 is the corner.
!
      if (iproc_r.eq.iproc_rb0) then
        if (iproc2d_tp.eq.0) then
          allocate (atp_g(nt_g,np_g))
        else
          allocate (atp_g(1,1))
        end if
!$acc update self(vb%r0%r) if_present
        call assemble_array_tp (fldtab(IFLD_VR)%maptp_t, &
                                fldtab(IFLD_VR)%maptp_p,vb%r0%r,atp_g)
        if (iproc2d_tp.eq.0) then
          call MPI_Isend (atp_g,nt_g*np_g,ntype_real,iproc0,0, &
                          comm_all,req1,ierr)
        end if
      end if
      if (iamp0) then
        allocate (atp_g0(nt_g,np_g))
        call MPI_Irecv (atp_g0,nt_g*np_g,ntype_real,proc_corner,0, &
                        comm_all,req2,ierr)
      end if
      if (iproc_r.eq.iproc_rb0.and.iproc2d_tp.eq.0) then
        call MPI_Wait (req1,MPI_STATUS_IGNORE,ierr)
      end if
      if (iproc_r.eq.iproc_rb0) deallocate (atp_g)
      if (iamp0) then
        call MPI_Wait (req2,MPI_STATUS_IGNORE,ierr)
        call wrrsh5_2d ('vbr0r',nt_g,np_g,atp_g0,ierr)
        deallocate (atp_g0)
      end if
!
      if (iproc_r.eq.iproc_rb0) then
        if (iproc2d_tp.eq.0) then
          allocate (atp_g(ntm1_g,np_g))
        else
          allocate (atp_g(1,1))
        end if
!$acc update self(vb%r0%t) if_present
        call assemble_array_tp (fldtab(IFLD_VT)%maptp_t, &
                                fldtab(IFLD_VT)%maptp_p,vb%r0%t,atp_g)
        if (iproc2d_tp.eq.0) then
          call MPI_Isend (atp_g,ntm1_g*np_g,ntype_real,iproc0,0, &
                          comm_all,req1,ierr)
        end if
      end if
      if (iamp0) then
        allocate (atp_g0(ntm1_g,np_g))
        call MPI_Irecv (atp_g0,ntm1_g*np_g,ntype_real,proc_corner,0, &
                        comm_all,req2,ierr)
      end if
      if (iproc_r.eq.iproc_rb0.and.iproc2d_tp.eq.0) then
        call MPI_Wait (req1,MPI_STATUS_IGNORE,ierr)
      end if
      if (iproc_r.eq.iproc_rb0) deallocate (atp_g)
      if (iamp0) then
        call MPI_Wait (req2,MPI_STATUS_IGNORE,ierr)
        call wrrsh5_2d ('vbr0t',ntm1_g,np_g,atp_g0,ierr)
        deallocate (atp_g0)
      end if
!
      if (iproc_r.eq.iproc_rb0) then
        if (iproc2d_tp.eq.0) then
          allocate (atp_g(nt_g,npm1_g))
        else
          allocate (atp_g(1,1))
        end if
!$acc update self(vb%r0%p) if_present
        call assemble_array_tp (fldtab(IFLD_VP)%maptp_t, &
                                fldtab(IFLD_VP)%maptp_p,vb%r0%p,atp_g)
        if (iproc2d_tp.eq.0) then
          call MPI_Isend (atp_g,nt_g*npm1_g,ntype_real,iproc0,0, &
                          comm_all,req1,ierr)
        end if
      end if
      if (iamp0) then
        allocate (atp_g0(nt_g,npm1_g))
        call MPI_Irecv (atp_g0,nt_g*npm1_g,ntype_real,proc_corner,0, &
                        comm_all,req2,ierr)
      end if
      if (iproc_r.eq.iproc_rb0.and.iproc2d_tp.eq.0) then
        call MPI_Wait (req1,MPI_STATUS_IGNORE,ierr)
      end if
      if (iproc_r.eq.iproc_rb0) deallocate (atp_g)
      if (iamp0) then
        call MPI_Wait (req2,MPI_STATUS_IGNORE,ierr)
        call wrrsh5_2d ('vbr0p',nt_g,npm1_g,atp_g0,ierr)
        deallocate (atp_g0)
      end if
!
      call check_error_on_any_proc (ierr)
!
! ****** Write the WTD running average masks if necessary.
! ****** This follows the logic for vbr0 fields above, but
! ****** corner code is copied in case that gets moved in the future.
!
      if (wtd_use_open_field_cutoff) then
!
        if (iproc_r.eq.iproc_rb0.and.iproc2d_tp.eq.0) then
          proc_corner=iproc
        else
          proc_corner=0
        end if
        call MPI_Allreduce (MPI_IN_PLACE,proc_corner,1,MPI_INTEGER, &
                            MPI_SUM,comm_all,ierr)
!
        if (iproc_r.eq.iproc_rb0) then
          if (iproc2d_tp.eq.0) then
            allocate (atp_g(nt_g,np_g))
          else
            allocate (atp_g(1,1))
          end if
!
          call assemble_array_tp (fldtab(IFLD_VR)%maptp_t, &
                                fldtab(IFLD_VR)%maptp_p, &
                                wtd_open_flux_zmult,atp_g)
          if (iproc2d_tp.eq.0) then
            call MPI_Isend (atp_g,nt_g*np_g,ntype_real,iproc0,0, &
                          comm_all,req1,ierr)
          end if
        end if
        if (iamp0) then
          allocate (atp_g0(nt_g,np_g))
          call MPI_Irecv (atp_g0,nt_g*np_g,ntype_real,proc_corner,0, &
                          comm_all,req2,ierr)
        end if
        if (iproc_r.eq.iproc_rb0.and.iproc2d_tp.eq.0) then
          call MPI_Wait (req1,MPI_STATUS_IGNORE,ierr)
        end if
        if (iproc_r.eq.iproc_rb0) deallocate (atp_g)
        if (iamp0) then
          call MPI_Wait (req2,MPI_STATUS_IGNORE,ierr)
          call wrrsh5_2d ('wtd_ofzm',nt_g,np_g,atp_g0,ierr)
          deallocate (atp_g0)
        end if
      endif
!
! ****** Write the 3D fields.
!
      do j=1,rs_o(1)%nfields
!
        if (rs_o(1)%write(j)) then
          ix=rs_o(1)%index(j)
          n1=fldtab(ix)%n1_g
          n2=fldtab(ix)%n2_g
          n3=fldtab(ix)%n3_g
          if (iamp0) then
            allocate (a_g(n1,n2,n3))
          else
            allocate (a_g(1,1,1))
          end if
!$acc update self(fldtab(ix)%f) if_present
          call assemble_array (fldtab(ix)%map_r,fldtab(ix)%map_t, &
                               fldtab(ix)%map_p,fldtab(ix)%f,a_g)
          if (iamp0) then
            call wrrsh5_3d (fldtab(ix)%name,n1,n2,n3,a_g,ierr)
          end if
          call check_error_on_p0 (ierr)
          deallocate (a_g)
        end if
!
      enddo
!
! ****** Close the restart file.
!
      call close_restart_file
!
      if (advance_fcs) call write_fcs_restart (ch_seq)
!
end subroutine
!#######################################################################
subroutine read_fcs_restart
!
!-----------------------------------------------------------------------
!
! ****** Read the fcs restart file.
!
!-----------------------------------------------------------------------
!
      use globals
      use ident
      use restart
      use mpidefs
      use vars, only : fname_restart_fcs, i_chemi_eigen
      use hdf5
      use h5ds
      use field_table
      use fields
      use restart
      use distribute_array_interface
      use mod_input_parameter
      use mod_eigen_matrix
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(256) :: fname
      integer :: i,jcs,jelem,jj,natom,ierr
!
!-----------------------------------------------------------------------
!
      character(8) ::   dimname
      integer(HID_T) :: file_id       ! File identifier
      integer(HID_T) :: dset_id       ! Dataset identifier
      integer(HID_T) :: dspace_id,dspacedim_id   ! Dataspace identifiers
      integer(HID_T) :: dim_id        ! Dimension identifiers
      integer(HSIZE_T),dimension(3) :: s_dims
      integer(HSIZE_T),dimension(1) :: s_dims_i
!
      real(KIND_REAL_8), dimension(:,:,:), allocatable :: f8
!
!-----------------------------------------------------------------------
!
      allocate (f8(nr_g,nt_g,np_g))
      s_dims(:)=(/nr_g,nt_g,np_g/)
!
! ****** Initialize hdf5 interface.
!
      if (iamp0) then
        call h5open_f (ierr)
!
! ****** Open the file.
!
        call h5Fopen_f (trim(fname_restart_fcs),H5F_ACC_RDONLY_F, &
      file_id,ierr)
      end if
!
! ****** Open and read the dataspace.
!
      jcs=0
      do jelem=1,nelem
        natom=natom_list(jelem)
        do jj=1,natom+1
          jcs=jcs+1
          write (dimname,'(a,a,i2.2)') &
          trim(char_element(i_chemi_eigen(jelem))),'_',jj-1
          if (iamp0) then
            call h5Dopen_f (file_id,dimname,dset_id,ierr)
            call h5Dread_f (dset_id,H5T_NATIVE_DOUBLE,f8,s_dims,ierr)
            call h5Dclose_f (dset_id,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in READ_FCS_RESTART:'
              write (*,*) '### Could not read the dataset.'
              write (*,*) 'File name: ',trim(fname)
              write (*,*) 'Dataset name: ',trim(dimname)
              write (*,*) '[Error return (from h5Dwrite_f) = ',ierr,']'
              call endrun (.true.)
            end if
          end if
          call distribute_array (fldtab(IFLD_RHO)%n1, &
                             fldtab(IFLD_RHO)%n2, &
                             fldtab(IFLD_RHO)%n3, &
                             f8,fcs(:,:,:,jcs))
        enddo
      enddo
!
! ****** Close the file.
!
      if (iamp0) then
        call h5Fclose_f (file_id,ierr)
!
! ****** Close the hdf5 interface.
!
        call h5close_f (ierr)
      end if
!
      deallocate (f8)
!
end subroutine
!#######################################################################
subroutine write_fcs_restart (ch_seq)
!
!-----------------------------------------------------------------------
!
! ****** Write the fcs restart file.
!
!-----------------------------------------------------------------------
!
      use globals
      use ident
      use restart
      use vars, only : fname_restart_fcs, i_chemi_eigen
      use hdf5
      use h5ds
      use mpidefs
      use field_table
      use fields
      use assemble_array_interface
      use mod_input_parameter
      use mod_eigen_matrix
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(3) :: ch_seq
      character(256) :: fname
      integer :: i,jcs,jelem,jj,natom,ierr
!
!-----------------------------------------------------------------------
!
      character(8) ::   dimname
      integer(HID_T) :: file_id       ! File identifier
      integer(HID_T) :: dset_id       ! Dataset identifier
      integer(HID_T) :: dspace_id,dspacedim_id   ! Dataspace identifiers
      integer(HID_T) :: dim_id        ! Dimension identifiers
      integer(HSIZE_T),dimension(3) :: s_dims
      integer(HSIZE_T),dimension(1) :: s_dims_i
!
      real(KIND_REAL_8), dimension(:,:,:), allocatable :: f8
!
!-----------------------------------------------------------------------
!
      fname="fcs_"// &
            trim(runid)// &
            trim(ch_seq)//'.h5'
      allocate (f8(nr_g,nt_g,np_g))
      s_dims(:)=(/nr_g,nt_g,np_g/)
      if (iamp0)  then
!
! ****** Initialize hdf5 interface.
!
        call h5open_f (ierr)
! ****** Create the file.
!
        call h5Fcreate_f (trim(fname),H5F_ACC_TRUNC_F,file_id,ierr)
      end if
!
! ****** Create the dataspace.
!
      jcs=0
      do jelem=1,nelem
        natom=natom_list(jelem)
        do jj=1,natom+1
          jcs=jcs+1
          call assemble_array (fldtab(IFLD_RHO)%map_r, &
          fldtab(IFLD_RHO)%map_t, &
          fldtab(IFLD_RHO)%map_p,fcs(:,:,:,jcs),f8)
          write (dimname,'(a,a,i2.2)') &
          trim(char_element(i_chemi_eigen(jelem))),'_',jj-1
          if (iamp0)  then
            call h5Screate_simple_f (3,s_dims,dspace_id,ierr)
            call h5Dcreate_f (file_id,dimname,H5T_NATIVE_DOUBLE, &
                          dspace_id,dset_id,ierr)
            call h5Dwrite_f (dset_id,H5T_NATIVE_DOUBLE,f8,s_dims,ierr)
            call h5Dclose_f (dset_id,ierr)
            if (ierr.ne.0) then
              write (*,*)
              write (*,*) '### ERROR in WRITE_FCS_RESTART:'
              write (*,*) '### Could not write the dataset.'
              write (*,*) 'File name: ',trim(fname)
              write (*,*) 'Dataset name: ',trim(dimname)
              write (*,*) '[Error return (from h5Dwrite_f) = ',ierr,']'
              call endrun (.true.)
            end if
          end if
        enddo
      enddo
!
! ****** Close the dataspace.
!
      if (iamp0) then
        call h5Sclose_f (dspace_id,ierr)
!
! ****** Close the file.
!
        call h5Fclose_f (file_id,ierr)
!
! ****** Close the hdf5 interface.
!
        call h5close_f (ierr)
      end if
!
      deallocate (f8)
end subroutine
!#######################################################################
subroutine write_restart_header (ipart)
!
!-----------------------------------------------------------------------
!
! ****** Write the header to the restart file.
!
!-----------------------------------------------------------------------
!
! ****** IPART is the restart file part number (a useful tag for
! ****** multi-part files).
!
!-----------------------------------------------------------------------
!
      use globals
      use ident
      use vars
      use restart
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ipart
!
!-----------------------------------------------------------------------
!
      integer :: i,ierr
      character(2) :: ch_part,ch_nparts
      character(64) :: part_str
!
! ****** Structures to assist in writing restart file variables.
!
      integer :: ncvars,nivars,nrvars
!
      type(cvar), dimension(:), allocatable :: cvars
      type(ivar), dimension(:), allocatable :: ivars
      type(rvar), dimension(:), allocatable :: rvars
!
!-----------------------------------------------------------------------
!
! ****** Make the string that designates the restart file part.
!
      write (ch_part,'(i2)') ipart
      ch_part=adjustl(ch_part)
!
      write (ch_nparts,'(i2)') 1
      ch_nparts=adjustl(ch_nparts)
!
      part_str='PART '//trim(ch_part)//' OF '//trim(ch_nparts)
!
! ****** Assemble the header.
!
      ncvars=11
      allocate (cvars(ncvars))
!
      cvars( 1)=cvar('File type','RESTART')
      cvars( 2)=cvar('Code',idcode)
      cvars( 3)=cvar('Version',vers//branch_vers)
      cvars( 4)=cvar('Updated on',update)
      cvars( 5)=cvar('Source file',source)
      cvars( 6)=cvar('Run ID',runid)
      cvars( 7)=cvar('Ran on machine',trim(machname))
      cvars( 8)=cvar('Machine type',trim(machtype))
      cvars( 9)=cvar('Written on',restart_file_date)
      cvars(10)=cvar('Written at',restart_file_time)
      cvars(11)=cvar('Multi-part',trim(part_str))
!
      nivars=4
      allocate (ivars(nivars))
!
      ivars(1)=ivar('NR',nr_g)
      ivars(2)=ivar('NT',nt_g)
      ivars(3)=ivar('NP',np_g)
      ivars(4)=ivar('NTIME',ntime)
!
      nrvars=6
      allocate (rvars(nrvars))
!
      rvars(1)=rvar('TIME',time)
      rvars(2)=rvar('BR00',br00)
      rvars(3)=rvar('E_DISSIPATED',energy_buf(1))
      rvars(4)=rvar('E_POYNT'     ,energy_buf(2))
      rvars(5)=rvar('POYNT'       ,energy_buf(3))
      rvars(6)=rvar('DTIME',dtime_old)
!
! ****** Write the header.
!
      if (iamp0) then
        do i=1,ncvars
          call wrrsh5_c (cvars(i)%name,cvars(i)%value,ierr)
          if (ierr.ne.0) go to 100
        enddo
        do i=1,nivars
          call wrrsh5_i (ivars(i)%name,ivars(i)%value,ierr)
          if (ierr.ne.0) go to 100
        enddo
        do i=1,nrvars
          call wrrsh5_r (rvars(i)%name,rvars(i)%value,ierr)
          if (ierr.ne.0) go to 100
        enddo
      end if
  100 continue
      call check_error_on_p0 (ierr)
!
      deallocate (cvars)
      deallocate (ivars)
      deallocate (rvars)
!
end subroutine
!#######################################################################
subroutine open_restart_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Open the existing HDF restart file named FNAME for read
! ****** access.  It is an error if the file does not exist.
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use hdf5
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      character(16) :: rs_type,rs_code
!
!-----------------------------------------------------------------------
!
! ****** Open the restart file for read access.
!
      if (iamp0) then
        call h5open_f(ierr)
        call h5Fopen_f(trim(fname),H5F_ACC_RDONLY_F,rsfile_id,ierr)
!
        if (ierr.lt.0) then
          write (*,*)
          write (*,*) '### ERROR in OPEN_RESTART_FILE:'
          write (*,*) '### Could not open the requested'// &
                      ' restart file for read access:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        else
          ierr=0
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that this is a MAS restart file.
!
      call get_restart_file_type (fname,rs_type,rs_code)
!
      if (iamp0) then
        if (rs_type(1:7).eq.'RESTART'.and.rs_code.eq.'MAS') then
          ierr=0
        else
          write (*,*)
          write (*,*) '### ERROR in OPEN_RESTART_FILE:'
          write (*,*) '### This is not a MAS restart file:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Set the flag to indicate that the file is open for
! ****** read access.
!
      hdf_sd_file_open_for_read=.true.
      hdf_sd_file_open_for_write=.false.
      hdf_sd_currently_open_file=fname
!
end subroutine
!#######################################################################
subroutine get_restart_file_type (fname,rs_type,rs_code)
!
!-----------------------------------------------------------------------
!
! ****** Return the file type and the code name from the
! ****** currently open restart file.  These are read from the
! ****** restart file header.
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use restart
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      character(*) :: rs_type
      character(*) :: rs_code
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i
      type(cvar), dimension(2) :: cvars
!
!-----------------------------------------------------------------------
!
      logical, external :: rs_var_present
!
!-----------------------------------------------------------------------
!
      cvars(1)%name='File type'
      cvars(2)%name='Code'
!
      if (iamp0) then
        do i=1,2
          if (rs_var_present(cvars(i)%name)) then
            call rdrsh5_c (cvars(i)%name,cvars(i)%value,ierr)
            if (ierr.ne.0) go to 100
          else
            ierr=1
            go to 100
          end if
        enddo
      end if
      go to 200
!
  100 continue
!
! ****** Error: not a MAS restart file.
!
      if (iamp0) then
        write (*,*)
        write (*,*) '### ERROR in GET_RESTART_FILE_TYPE:'
        write (*,*) '### This is not a MAS restart file:'
        write (*,*) 'File name: ',trim(fname)
      end if
!
  200 continue
      call check_error_on_p0 (ierr)
!
      rs_type=cvars(1)%value
      rs_code=cvars(2)%value
!
end subroutine
!#######################################################################
subroutine close_restart_file
!
!-----------------------------------------------------------------------
!
! ****** Close the currently open HDF restart file.
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use hdf5
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** It is an error to try to close a file that has not been
! ****** opened for read or write access.
!
      if (.not.(hdf_sd_file_open_for_read.or. &
                hdf_sd_file_open_for_write)) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in CLOSE_RESTART_FILE:'
          write (*,*) '### Attempted to close a restart'// &
                      ' file that is not open:'
          write (*,*) 'File name: ',trim(hdf_sd_currently_open_file)
        end if
        call endrun (.true.)
      end if
!
! ****** Close the currently open restart file.
!
      if (iamp0) then
        if (hdf_sd_file_open_for_read.or. &
            hdf_sd_file_open_for_write) then
          call h5Fclose_f(rsfile_id,ierr)
          call h5close_f(ierr)
        end if
        if (ierr.lt.0) then
          write (*,*)
          write (*,*) '### ERROR in CLOSE_RESTART_FILE:'
          write (*,*) '### Could not close the requested'// &
                      ' restart file:'
          write (*,*) 'File name: ',trim(hdf_sd_currently_open_file)
          ierr=1
        else
          ierr=0
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Set the flags to indicate that the file is closed.
!
      hdf_sd_file_open_for_read=.false.
      hdf_sd_file_open_for_write=.false.
      hdf_sd_currently_open_file=' '
!
end subroutine
!#######################################################################
subroutine create_restart_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Create an HDF restart file named FNAME with write access.
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use hdf5
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Create the restart file.
!
      ierr=0
      if (iamp0) then
        call h5open_f (ierr)
        call h5fcreate_f(trim(fname),H5F_ACC_TRUNC_F,rsfile_id,ierr)
        if (ierr.lt.0) then
          write (*,*)
          write (*,*) '### ERROR in CREATE_RESTART_FILE:'
          write (*,*) '### Could not create an HDF'// &
                      ' restart file:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        else
          ierr=0
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Set the flags to indicate that the file is open for
! ****** write access.
!
      hdf_sd_file_open_for_read=.false.
      hdf_sd_file_open_for_write=.true.
      hdf_sd_currently_open_file=fname
!
end subroutine
!#######################################################################
subroutine wrrsh5_c (name,value,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write character variable NAME with value VALUE to
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name,value
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='WRRSH5_C'
!
!-----------------------------------------------------------------------
!
      character(1), parameter :: single_space=' '
      integer(HSIZE_T), parameter :: one=1
      integer(HSIZE_T) :: attrlen
      integer(HID_T) :: aspace_id     ! Attribute space identifier
      integer(HID_T) :: atype_id      ! Attribute type identifier
      integer(HID_T) :: attr_id       ! Attribute dentifier
!
!-----------------------------------------------------------------------
!
      integer(HSIZE_T), dimension(1) :: adims=(/1/)
      integer(HSIZE_T), dimension(1) :: data_dims
!
!-----------------------------------------------------------------------
!
      attrlen=len_trim(value)
!
! ****** Create scalar data space.
!
      call h5screate_simple_f(1,adims,aspace_id,ierr)
!
! ****** Create datatype for the attribute.
!
      call h5tcopy_f(H5T_NATIVE_CHARACTER,atype_id,ierr)
!
      data_dims(1)=1
      if (value.eq.'') then
        call h5tset_size_f(atype_id,one,ierr)
        call h5acreate_f(rsfile_id,name,atype_id,aspace_id,attr_id,ierr)
        call h5awrite_f(attr_id,atype_id,single_space,data_dims,ierr)
      else
        call h5tset_size_f(atype_id,attrlen,ierr)
        call h5acreate_f(rsfile_id,name,atype_id,aspace_id,attr_id,ierr)
        call h5awrite_f(attr_id,atype_id,trim(value),data_dims,ierr)
      end if
!
      call h5aclose_f(attr_id, ierr)
      call h5sclose_f(aspace_id, ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call wrrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine wrrsh5_i (name,value,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write integer variable NAME with value VALUE to
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: value
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='WRRSH5_I'
!
!-----------------------------------------------------------------------
!
      integer(HSIZE_T), dimension(1) :: adims=(/1/)
      integer(HSIZE_T), dimension(1) :: data_dims
      integer(HID_T) :: aspace_id     ! Attribute space identifier
      integer(HID_T) :: attr_id       ! Attribute dentifier
!
!-----------------------------------------------------------------------
!
! ****** Create scalar data space.
!
      call h5screate_simple_f(1,adims,aspace_id,ierr)
!
      data_dims(1)=1
!
      call h5acreate_f(rsfile_id,name,H5T_NATIVE_INTEGER, &
                       aspace_id,attr_id,ierr)
      call h5awrite_f(attr_id,H5T_NATIVE_INTEGER,value,data_dims,ierr)
!
      call h5aclose_f(attr_id, ierr)
      call h5sclose_f(aspace_id, ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call wrrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine wrrsh5_r (name,value,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write real variable NAME with value VALUE to
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      real(r_typ) :: value
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='WRRSH5_R'
!
!-----------------------------------------------------------------------
!
      integer(HSIZE_T), dimension(1) :: adims=(/1/)
      integer(HSIZE_T), dimension(1) :: data_dims
      integer(HID_T) :: aspace_id     ! Attribute space identifier
      integer(HID_T) :: attr_id       ! Attribute dentifier
!
!-----------------------------------------------------------------------
!
      data_dims(1)=1
!
      call h5screate_simple_f(1,adims,aspace_id,ierr)
!
      call h5acreate_f(rsfile_id,name,H5T_NATIVE_DOUBLE, &
                       aspace_id,attr_id,ierr)
      call h5awrite_f(attr_id,H5T_NATIVE_DOUBLE,value,data_dims,ierr)
!
      call h5aclose_f(attr_id, ierr)
      call h5sclose_f(aspace_id, ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call wrrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine wrrsh5_1d (name,nx,f,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write the real 1D array F(NX) with name NAME to
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf5
      use hdf_defs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: nx
      real(r_typ), dimension(nx) :: f
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='WRRSH5_1D'
!
!-----------------------------------------------------------------------
!
      integer, parameter :: ndim=1
      integer(HSIZE_T),dimension(ndim) :: dims
      integer(HID_T) :: dspace_id     ! Dataspace identifier
      integer(HID_T) :: dset_id       ! Dataset identifier
!
!-----------------------------------------------------------------------
!
      dims=(/nx/)
!
! ****** Create the dataspace.
!
      call h5Screate_simple_f (ndim,dims,dspace_id,ierr)
!
! ****** Create and write the dataset.
!
      if (kind(f).eq.KIND_REAL_4) then
        call h5Dcreate_f (rsfile_id,trim(name),H5T_NATIVE_REAL, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_REAL,f,dims,ierr)
      else
        call h5Dcreate_f (rsfile_id,trim(name),H5T_NATIVE_DOUBLE, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_DOUBLE,f,dims,ierr)
      end if
!
! ****** Close the dataset.
!
      call h5Dclose_f (dset_id,ierr)
!
! ****** Close the dataspace.
!
      call h5Sclose_f (dspace_id,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call wrrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine wrrsh5_2d (name,nx,ny,f,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write the real 2D array F(NX,NY) with name NAME to
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf5
      use hdf_defs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: nx,ny
      real(r_typ), dimension(nx,ny) :: f
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='WRRSH5_2D'
!
!-----------------------------------------------------------------------
!
      integer, parameter :: ndim=2
      integer(HSIZE_T),dimension(ndim) :: dims
      integer(HID_T) :: dspace_id     ! Dataspace identifier
      integer(HID_T) :: dset_id       ! Dataset identifier
!
!-----------------------------------------------------------------------
!
      dims=(/nx,ny/)
!
! ****** Create the dataspace.
!
      call h5Screate_simple_f (ndim,dims,dspace_id,ierr)
!
! ****** Create and write the dataset.
!
      if (kind(f).eq.KIND_REAL_4) then
        call h5Dcreate_f (rsfile_id,trim(name),H5T_NATIVE_REAL, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_REAL,f,dims,ierr)
      else
        call h5Dcreate_f (rsfile_id,trim(name),H5T_NATIVE_DOUBLE, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_DOUBLE,f,dims,ierr)
      end if
!
! ****** Close the dataset.
!
      call h5Dclose_f (dset_id,ierr)
!
! ****** Close the dataspace.
!
      call h5Sclose_f (dspace_id,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call wrrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine wrrsh5_3d (name,nx,ny,nz,f,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write the real 3D array F(NX,NY,NZ) with name NAME to
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf5
      use hdf_defs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: nx,ny,nz
      real(r_typ), dimension(nx,ny,nz) :: f
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='WRRSH5_3D'
!
!-----------------------------------------------------------------------
!
      integer, parameter :: ndim=3
      integer(HSIZE_T),dimension(ndim) :: dims
      integer(HID_T) :: dspace_id     ! Dataspace identifier
      integer(HID_T) :: dset_id       ! Dataset identifier
!
!-----------------------------------------------------------------------
!
      dims=(/nx,ny,nz/)
!
! ****** Create the dataspace.
!
      call h5Screate_simple_f (ndim,dims,dspace_id,ierr)
!
! ****** Create and write the dataset.
!
      if (kind(f).eq.KIND_REAL_4) then
        call h5Dcreate_f (rsfile_id,trim(name),H5T_NATIVE_REAL, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_REAL,f,dims,ierr)
      else
        call h5Dcreate_f (rsfile_id,trim(name),H5T_NATIVE_DOUBLE, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_DOUBLE,f,dims,ierr)
      end if
!
! ****** Close the dataset.
!
      call h5Dclose_f (dset_id,ierr)
!
! ****** Close the dataspace.
!
      call h5Sclose_f (dspace_id,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call wrrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine rdrsh5_c (name,value,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read character variable NAME into VALUE from
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use hdf5
      use hdf_defs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name,value
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='RDRSH5_C'
!
!-----------------------------------------------------------------------
!
      integer(HID_T) :: atype_id      ! Attribute type identifier
      integer(HID_T) :: attr_id       ! Attribute dentifier
      integer(HSIZE_T) :: attrlen,vallen
      integer(HSIZE_T), dimension(1) :: adims=(/1/)
      integer(HSIZE_T) :: i
!
!-----------------------------------------------------------------------
!
      character, dimension(:), allocatable :: cbuf
!
!-----------------------------------------------------------------------
!
      call h5aopen_by_name_f(rsfile_id,'.',name,attr_id,ierr)
!
      call h5aget_type_f(attr_id,atype_id,ierr)
!
      call h5aget_storage_size_f(attr_id,attrlen,ierr)
!
      allocate (cbuf(attrlen))
!
      call h5aread_f(attr_id,atype_id,cbuf,adims,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call rdrs_error_text (name,myname,ierr)
        return
      end if
!
! ****** Note that value is of length LENVALUE=64 (see module restart)
!
      value=' '
      vallen=len(value)
      do i=1,min(attrlen,vallen)
        value(i:i)=cbuf(i)
      enddo
      deallocate (cbuf)
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine rdrsh5_i (name,value,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read integer variable NAME into VALUE from
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use hdf5
      use hdf_defs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: value
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='RDRSH5_I'
!
!-----------------------------------------------------------------------
!
      integer(HID_T) :: atype_id      ! Attribute type identifier
      integer(HID_T) :: attr_id       ! Attribute dentifier
      integer(HSIZE_T), dimension(1) :: adims=(/1/)
!
!-----------------------------------------------------------------------
!
      call h5aopen_by_name_f(rsfile_id,'.',name,attr_id,ierr)
!
      call h5aget_type_f(attr_id,atype_id,ierr)
!
      call h5aread_f(attr_id,atype_id,value,adims,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call rdrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine rdrsh5_r (name,value,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read real variable NAME into VALUE from
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf5
      use hdf_defs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      real(r_typ) :: value
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='RDRSH5_R'
!
!-----------------------------------------------------------------------
!
      integer(HID_T) :: atype_id      ! Attribute type identifier
      integer(HID_T) :: attr_id       ! Attribute dentifier
      integer(HSIZE_T), dimension(1) :: adims=(/1/)
!
!-----------------------------------------------------------------------
!
! ****** Get the index of the variable.
!
      call h5aopen_by_name_f(rsfile_id,'.',name,attr_id,ierr)
!
      call h5aget_type_f(attr_id,atype_id,ierr)
!
      call h5aread_f(attr_id,atype_id,value,adims,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        call rdrs_error_text (name,myname,ierr)
        return
      end if
!
      ierr=0
!
end subroutine
!#######################################################################
subroutine rdrsh5_1d (name,nx,f,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read the real 1D array F(NX) with name NAME from
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: nx
      real(r_typ), dimension(nx) :: f
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='RDRSH5_1D'
!
!-----------------------------------------------------------------------
!
      integer :: i,ndim_in
      integer, parameter :: ndim=1
      integer(HID_T) :: dset_id       ! Dataset identifier
      integer(HID_T) :: dspace_id
      integer(HID_T) :: datatype_id
      integer(HSIZE_T),dimension(ndim) :: dims
      integer(HSIZE_T),dimension(:), allocatable :: dims_in,maxpts
!
      integer(SIZE_T) :: nt
!
!-----------------------------------------------------------------------
!
      real(KIND_REAL_4), dimension(:), allocatable :: f4
      real(KIND_REAL_8), dimension(:), allocatable :: f8
!
!-----------------------------------------------------------------------
!
      dims=(/nx/)
!
      call h5Dopen_f (rsfile_id,trim(name),dset_id,ierr)
!
! ****** Check that the rank and dimensions match the expected values.
!
      call h5Dget_space_f (dset_id,dspace_id,ierr)
!
      call h5Sget_simple_extent_ndims_f (dspace_id,ndim_in,ierr)
      if (ndim_in.ne.ndim) then
        ierr=4
        go to 900
      end if
!
      allocate(dims_in(ndim_in))
      allocate(maxpts(ndim_in))
!
      call h5Sget_simple_extent_dims_f (dspace_id,dims_in,maxpts,ierr)
      do i=1,ndim
        if (dims_in(i).ne.dims(i)) then
          ierr=5
          go to 900
        end if
      enddo
!
      deallocate(dims_in)
      deallocate(maxpts)
!
      call h5Dget_type_f (dset_id,datatype_id,ierr)
      call h5Tget_precision_f (datatype_id,nt,ierr)
!
! ****** Read the array.
!
      if (nt.eq.32) then
        allocate (f4(size(f)))
        call h5Dread_f(dset_id,datatype_id,f4,dims,ierr)
        f=f4
        deallocate (f4)
      else if (nt.eq.64) then
        allocate (f8(size(f)))
        call h5Dread_f(dset_id,datatype_id,f8,dims,ierr)
        f=f8
        deallocate (f8)
      else
        ierr=7
        go to 900
      end if
!
      call h5Tclose_f(datatype_id,ierr)
!
      call h5Dclose_f (dset_id,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        go to 900
      end if
!
      ierr=0
!
      return
!
! ****** Error return.
!
  900 continue
!
      call rdrs_error_text (name,myname,ierr)
!
end subroutine
!#######################################################################
subroutine rdrsh5_2d (name,nx,ny,f,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read the real 2D array F(NX,NY) with name NAME from
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: nx,ny
      real(r_typ), dimension(nx*ny) :: f
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='RDRSH5_2D'
!
!-----------------------------------------------------------------------
!
      integer :: i,ndim_in
      integer, parameter :: ndim=2
      integer(HID_T) :: dset_id       ! Dataset identifier
      integer(HID_T) :: dspace_id
      integer(HID_T) :: datatype_id
      integer(HSIZE_T),dimension(ndim) :: dims
      integer(HSIZE_T),dimension(:), allocatable :: dims_in,maxpts
!
      integer(SIZE_T) :: nt
!
!-----------------------------------------------------------------------
!
      real(KIND_REAL_4), dimension(:), allocatable :: f4
      real(KIND_REAL_8), dimension(:), allocatable :: f8
!
!-----------------------------------------------------------------------
!
      dims=(/nx,ny/)
!
      call h5Dopen_f (rsfile_id,trim(name),dset_id,ierr)
!
! ****** Check that the rank and dimensions match the expected values.
!
      call h5Dget_space_f (dset_id,dspace_id,ierr)
!
      call h5Sget_simple_extent_ndims_f (dspace_id,ndim_in,ierr)
      if (ndim_in.ne.ndim) then
        ierr=4
        go to 900
      end if
!
      allocate(dims_in(ndim_in))
      allocate(maxpts(ndim_in))
!
      call h5Sget_simple_extent_dims_f (dspace_id,dims_in,maxpts,ierr)
      do i=1,ndim
        if (dims_in(i).ne.dims(i)) then
          ierr=5
          go to 900
        end if
      enddo
!
      deallocate(dims_in)
      deallocate(maxpts)
!
      call h5Dget_type_f (dset_id,datatype_id,ierr)
      call h5Tget_precision_f (datatype_id,nt,ierr)
!
! ****** Read the array.
!
      if (nt.eq.32) then
        allocate (f4(size(f)))
        call h5Dread_f(dset_id,datatype_id,f4,dims,ierr)
        f=f4
        deallocate (f4)
      else if (nt.eq.64) then
        allocate (f8(size(f)))
        call h5Dread_f(dset_id,datatype_id,f8,dims,ierr)
        f=f8
        deallocate (f8)
      else
        ierr=7
        go to 900
      end if
!
      call h5Tclose_f(datatype_id,ierr)
!
      call h5Dclose_f (dset_id,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        go to 900
      end if
!
      ierr=0
!
      return
!
! ****** Error return.
!
  900 continue
!
      call rdrs_error_text (name,myname,ierr)
!
end subroutine
!#######################################################################
subroutine rdrsh5_3d (name,nx,ny,nz,f,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read the real 3D array F(NX,NY,NZ) with name NAME from
! ****** the HDF5 restart file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      integer :: nx,ny,nz
      real(r_typ), dimension(nx*ny*nz) :: f
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      character(*), parameter :: myname='RDRSH5_3D'
!
!-----------------------------------------------------------------------
!
      integer :: i,ndim_in
      integer, parameter :: ndim=3
      integer(HID_T) :: dset_id       ! Dataset identifier
      integer(HID_T) :: dspace_id
      integer(HID_T) :: datatype_id
      integer(HSIZE_T),dimension(ndim) :: dims
      integer(HSIZE_T),dimension(:), allocatable :: dims_in,maxpts
!
      integer(SIZE_T) :: nt
!
!-----------------------------------------------------------------------
!
      real(KIND_REAL_4), dimension(:), allocatable :: f4
      real(KIND_REAL_8), dimension(:), allocatable :: f8
!
!-----------------------------------------------------------------------
!
      dims=(/nx,ny,nz/)
!
      call h5Dopen_f (rsfile_id,trim(name),dset_id,ierr)
!
! ****** Check that the rank and dimensions match the expected values.
!
      call h5Dget_space_f (dset_id,dspace_id,ierr)
!
      call h5Sget_simple_extent_ndims_f (dspace_id,ndim_in,ierr)
      if (ndim_in.ne.ndim) then
        ierr=4
        go to 900
      end if
!
      allocate(dims_in(ndim_in))
      allocate(maxpts(ndim_in))
!
      call h5Sget_simple_extent_dims_f (dspace_id,dims_in,maxpts,ierr)
      do i=1,ndim
        if (dims_in(i).ne.dims(i)) then
          ierr=5
          go to 900
        end if
      enddo
!
      deallocate(dims_in)
      deallocate(maxpts)
!
      call h5Dget_type_f (dset_id,datatype_id,ierr)
      call h5Tget_precision_f (datatype_id,nt,ierr)
!
! ****** Read the array.
!
      if (nt.eq.32) then
        allocate (f4(size(f)))
        call h5Dread_f(dset_id,datatype_id,f4,dims,ierr)
        f=f4
        deallocate (f4)
      else if (nt.eq.64) then
        allocate (f8(size(f)))
        call h5Dread_f(dset_id,datatype_id,f8,dims,ierr)
        f=f8
        deallocate (f8)
      else
        ierr=7
        go to 900
      end if
!
      call h5Tclose_f(datatype_id,ierr)
!
      call h5Dclose_f (dset_id,ierr)
!
      if (ierr.lt.0) then
        ierr=1
        go to 900
      end if
!
      ierr=0
!
      return
!
! ****** Error return.
!
  900 continue
!
      call rdrs_error_text (name,myname,ierr)
!
end subroutine
!#######################################################################
subroutine wrrs_error_text (name,sub,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write the error text to the TTY for a failed restart
! ****** file write.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      character(*) :: sub
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      write (*,*)
      write (*,*) '### ERROR in WRITE_RESTART:'
      write (*,*) '### Could not write a variable/array to the file.'
      write (*,*) 'Variable name: ',trim(name)
      write (*,*) 'Subroutine: ',trim(sub)
      write (*,*) 'IERR = ',ierr
!
end subroutine
!#######################################################################
subroutine rdrs_error_text (name,sub,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write the error text to the TTY for a failed restart
! ****** file read.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      character(*) :: sub
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      write (*,*)
      write (*,*) '### ERROR in READ_RESTART_HEADER/READ_RESTART:'
      write (*,*) '### Could not read a variable/array from the file.'
      write (*,*) 'Variable name: ',trim(name)
      write (*,*) 'Subroutine: ',trim(sub)
      write (*,*) 'IERR = ',ierr
!
end subroutine
!#######################################################################
function rs_var_present (name)
!
!-----------------------------------------------------------------------
!
! ****** Check if the scalar variable NAME is present in
! ****** the HDF restart file.
!
! ****** If it is present, return .TRUE. as the function value;
! ****** otherwise, return .FALSE..
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      logical :: rs_var_present
!
!-----------------------------------------------------------------------
!
      integer(HID_T) :: attr_id
      integer :: ix
!
!-----------------------------------------------------------------------
!
      call h5aopen_by_name_f(rsfile_id,'.',name,attr_id,ix)
!
      if (ix.lt.0) then
        rs_var_present=.false.
      else
        rs_var_present=.true.
      end if
!
      return
end function
!#######################################################################
function rs_array_present (name)
!
!-----------------------------------------------------------------------
!
! ****** Check if the array variable NAME is present in
! ****** the HDF restart file.
!
! ****** If it is present, return .TRUE. as the function value;
! ****** otherwise, return .FALSE..
!
!-----------------------------------------------------------------------
!
      use hdf_defs
      use hdf5
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: name
      logical :: rs_array_present
!
!-----------------------------------------------------------------------
!
      integer(HID_T) :: dset_id
      integer :: ix
!
!-----------------------------------------------------------------------
!
      call h5Dopen_f (rsfile_id,trim(name),dset_id,ix)
!
      if (ix.lt.0) then
        rs_array_present=.false.
      else
        rs_array_present=.true.
      end if
!
      return
end function
!#######################################################################
subroutine timer (id)
!
!-----------------------------------------------------------------------
!
! ****** Toggle a timing event for the timer with index ID.
!
!-----------------------------------------------------------------------
!
! ****** The first call to this routine with a given ID initalizes
! ****** a timing event.  A second call with the same ID terminates
! ****** the timing event.
!
!-----------------------------------------------------------------------
!
! ****** This routine can be called in a nested way to measure
! ****** multiple timing events.  Calls to TIMER (with the same ID)
! ****** can be nested like do-loops in FORTRAN.
!
!-----------------------------------------------------------------------
!
      use timing
      use debug
      use mpidefs
      use io_units
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: id
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: second
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: t0,dt
      logical, save :: first=.true.
      character(5), save :: pch
      character(32), save :: fname
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Record the elapsed CPU time.
!
      t0=MPI_Wtime()-time_at_start_of_program
!
! ****** On the first time in, open the diagnostic files,
! ****** if requested.
!
      if (first.and.timer_log) then
        first=.false.
        pch(1:1)='P'
        write (pch(2:5),'(i4.4)') iprocw
        fname='timer_log.'//pch
        call ffopen (IO_TEMP,fname,'rw',ierr)
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in TIMER:'
          write (*,*) '### Could not open the timer log file.'
          write (*,*) 'File name: ',trim(fname)
          call endrun (.true.)
        end if
      elseif (timer_log) then
        call ffopen (IO_TEMP,fname,'a',ierr)
      end if
!
! ****** Check that the timer index is valid.
!
      if (id.le.0.or.id.gt.ntimers) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in TIMER:'
          write (*,*) '### Invalid timer index specified:'
          write (*,*) 'ID = ',id
        end if
        call endrun (.true.)
      end if
!
! ****** Process the timing event.
!
      if (ttask(id)%active) then
!
! ****** End of a timing event.
!
        if (level.le.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in TIMER:'
            write (*,*) '### Timer stack underflow.'
            write (*,*) 'This may signal an incorrect nesting of '// &
                        'TIMER calls.'
            write (*,*) 'LEVEL = ',level
            write (*,*) 'ID = ',id
          end if
          call endrun (.true.)
        end if
!
        if (timer_log) write (IO_TEMP,100) 'E: '//pch//' L',level, &
                                      ttask(id)%label,t0
        dt=t0-ttask(id)%tstart(level)
        ttask(id)%tused(level)=ttask(id)%tused(level)+dt
        level=level-1
        ttask(id)%active=.false.
!
! ****** Check if this call terminates accumulation of the total
! ****** communication time (see comments below).
! ****** If so, accumulate the time into TOTAL_COMM_TIME.
!
        if (id.eq.comm_time_track_id) then
          comm_time_track_id=0
          total_comm_time=total_comm_time+dt
        end if
!
      else
!
! ****** Beginning of a timing event.
!
        if (level.ge.nlevels) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in TIMER:'
            write (*,*) '### Timer stack overflow.'
            write (*,*) 'This may either signal an incorrect'// &
                        ' nesting of TIMER calls, or the'
            write (*,*) 'maximum number of timing levels'// &
                        ' (NLEVELS) needs to be increased.'
            write (*,*) 'NLEVELS = ',nlevels
            write (*,*) 'LEVEL = ',level
            write (*,*) 'ID = ',id
          end if
          call endrun (.true.)
        end if
!
        level=level+1
        if (timer_log) write (IO_TEMP,100) 'S: '//pch//' L',level, &
                                      ttask(id)%label,t0
        ttask(id)%tstart(level)=t0
        ttask(id)%ncalls(level)=ttask(id)%ncalls(level)+1
        ttask(id)%active=.true.
!
! ****** If this is a timing call to track communication time,
! ****** record the timer ID and the start time.
! ****** Note that only the topmost call to a communication timer
! ****** starts the accumulation (i.e., additional calls to the
! ****** timer nested within the topmost call are included in the
! ****** total communication time).
!
        if (ttask(id)%comm.and.comm_time_track_id.eq.0) then
          comm_time_track_id=id
        end if
!
      end if
!
      if (timer_log) close(IO_TEMP)
!
  100 format (a,i1,tr1,a,' t = ',f20.8)
!
end subroutine
!#######################################################################
subroutine write_timing
!
!-----------------------------------------------------------------------
!
! ****** Write out the timing information.
!
!-----------------------------------------------------------------------
!
      use number_types
      use ident
      use globals
      use vars
      use mpidefs
      use cgcom
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
! ****** Timing buffers.
!
      real(r_typ), dimension(2,ntimers) :: sbuf
      real(r_typ), dimension(2,ntimers,0:nproc-1) :: tbuf
!
      integer, dimension(2,ntimers) :: isbuf
      integer, dimension(2,ntimers,0:nproc-1) :: irbuf
      integer, dimension(ntimers,0:nproc-1) :: ncalls,ncalls_l2
!
      real(r_typ), dimension(0:nproc-1) :: tot_c_time
!
! ****** Timing statistics.
!
      real(r_typ), dimension(2,ntimers) :: ttmin,ttmax,ttavg,ttsdev
!
! ****** Timing file name.
!
      character(256) :: tfile
!
!-----------------------------------------------------------------------
!
      integer :: i,ierr
      integer :: irank
      integer :: lbuf
      integer :: nc,ncgw
      real(r_typ) :: tl2
      real(r_typ) :: tused,time_per_call
      real(r_typ) :: t_avg,c_avg,comm_percent
      real(r_typ) :: mpdt,normalized_time
      real(r_typ) :: time_elapsed
!
!-----------------------------------------------------------------------
!
! ****** Stop the timer that measures the total CPU time used by
! ****** the code.  Synchronize all processors to ensure
! ****** a more accurate wall time.
!
      call MPI_Barrier (MPI_COMM_WORLD,ierr)
!
      call timer (TIME_TOTAL)
!
! ****** Find the total CPU time used by the code.
!
      total_cpu_time=sum(ttask(TIME_TOTAL)%tused(:))
!
! ****** If the timing is not being measured, the timing output file
! ****** is not generated.
!
      if (.not.use_timer) return
!
! ****** Get the time that is not explicitly tracked ("other" time).
! ****** This is the total CPU time minus the total non-communication
! ****** "level 2" time.
!
      tl2=sum(ttask(:)%tused(2),mask=.not.ttask(:)%comm)
      ttask(TIME_OTHER)%tused(2)=total_cpu_time-tl2
      ttask(TIME_OTHER)%ncalls(2)=1
!
!-----------------------------------------------------------------------
! ****** Gather the timing information on all processors.
!-----------------------------------------------------------------------
!
! ****** Collect detailed statistics to show the total time used by
! ****** the routines that are being tracked (including the time used
! ****** by all the routines that they call).  Also, collect the
! ****** "level 2" time for summary timing information.
!
      do i=1,ntimers
        sbuf(1,i)=sum(ttask(i)%tused(:))
        sbuf(2,i)=ttask(i)%tused(2)
      enddo
!
! ****** Collect the total number of times each routine has been
! ****** called, as well as the number of "level 2" calls.
!
      do i=1,ntimers
        isbuf(1,i)=sum(ttask(i)%ncalls(:))
        isbuf(2,i)=ttask(i)%ncalls(2)
      enddo
!
      lbuf=2*ntimers
!
      call MPI_Allgather (sbuf,lbuf,ntype_real, &
                          tbuf,lbuf,ntype_real,MPI_COMM_WORLD,ierr)
!
      call MPI_Allgather (isbuf,lbuf,MPI_INTEGER, &
                          irbuf,lbuf,MPI_INTEGER,MPI_COMM_WORLD,ierr)
!
      ncalls   (:,:)=irbuf(1,:,:)
      ncalls_l2(:,:)=irbuf(2,:,:)
!
! ****** Gather the total communication time per processor.
!
      call MPI_Allgather (total_comm_time,1,ntype_real, &
                          tot_c_time,1,ntype_real,MPI_COMM_WORLD,ierr)
!
! ****** Open the timing file.
!
      if (legacy_output_filenames) then
        tfile='t'//runid
      else
        tfile='mas_timing.out'
      end if
!
      if (iamp0) then
        call ffopen (1,trim(tfile),'rw',ierr)
      end if
      call check_error_on_p0 (ierr)
!
!-----------------------------------------------------------------------
! ****** Write the timing for each processor.
!-----------------------------------------------------------------------
!
      if (iamp0) then
!
        do irank=0,nproc-1
!
          write (1,*)
          write (1,100)
          write (1,*)
          write (1,'(tr1,a,i6)') 'Rank ID = ',irank
!
! ****** Write the CPU time used by the tracked tasks.
!
          write (1,*)
          write (1,*) 'COMP time for tracked tasks:'
          write (1,200) repeat('-',27)
          write (1,250)
!
          do i=1,ntimers
            if (.not.ttask(i)%comm) then
              tused=tbuf(1,i,irank)
              nc=ncalls(i,irank)
              if (nc.ne.0) then
                time_per_call=tused/nc
              else
                time_per_call=0.
              end if
              if (i.eq.TIME_TOTAL) then
                write (1,200) ttask(i)%label,tused
              else
                write (1,200) ttask(i)%label,tused,nc,time_per_call
              end if
            end if
          enddo
!
! ****** Write the communication time used by the tracked tasks.
!
          write (1,*)
          write (1,*) 'Communication time for tracked tasks:'
          write (1,200) repeat('-',37)
          write (1,250)
!
          do i=1,ntimers
            if (ttask(i)%comm) then
              tused=tbuf(1,i,irank)
              nc=ncalls(i,irank)
              if (nc.ne.0) then
                time_per_call=tused/nc
              else
                time_per_call=0.
              end if
              write (1,200) ttask(i)%label,tused,nc,time_per_call
            end if
          enddo
          write (1,200) 'Total communication time',tot_c_time(irank)
!
! ****** Write the summary timing information.
!
          write (1,*)
          write (1,*) 'Summary timing information:'
          write (1,200) repeat('-',27)
          write (1,*)
          do i=1,ntimers
            if (.not.ttask(i)%comm) then
              if (i.eq.TIME_TOTAL) then
                write (1,200) repeat('-',40)
                write (1,200) ttask(i)%label,tbuf(1,i,irank)
                write (1,200) repeat('-',40)
              else if (ncalls_l2(i,irank).gt.0) then
                write (1,200) ttask(i)%label,tbuf(2,i,irank)
              end if
            end if
          enddo
!
        enddo
!
        write (1,*)
        write (1,100)
!
      end if
!
!-----------------------------------------------------------------------
! ****** Write the average timing statistics.
!-----------------------------------------------------------------------
!
      ttavg=sum(tbuf,dim=3)/float(nproc)
      ttmin=minval(tbuf,dim=3)
      ttmax=maxval(tbuf,dim=3)
!
      ttsdev(:,:)=0.
      do irank=0,nproc-1
        ttsdev(:,:)=ttsdev(:,:)+(tbuf(:,:,irank)-ttavg(:,:))**2
      enddo
      ttsdev(:,:)=sqrt(ttsdev(:,:)/nproc)
!
! ****** Get the average total time per processor.
!
      t_avg=ttavg(1,TIME_TOTAL)
!
! ****** Get the average communication time per processor.
!
      c_avg=sum(tot_c_time)/nproc
!
! ****** Calculate the percentage of communication time relative
! ****** to total time.
!
      if (t_avg.ne.0.) then
        comm_percent=100.*c_avg/t_avg
      else
        comm_percent=0.
      end if
!
! ****** Calculate the normalized time (/mesh-point/time-step).
!
      mpdt=float(nrm1_g)*float(ntm1_g)*float(np_g)*float(ntime)
      if (mpdt.ne.0.) then
        normalized_time=1.e6*t_avg*nproc/mpdt
      else
        normalized_time=0.
      end if
!
      if (iamp0) then
!
        write (1,*)
        write (1,*) 'Average times over all processors:'
        write (1,*) '----------------------------------'
        write (1,*)
        write (1,300) 'Avg          Min          Max       S. Dev'
        write (1,300) '---          ---          ---       ------'
        do i=1,ntimers
          if (ttask(i)%comm) then
            write (1,400) ttask(i)%label, &
                          ttavg(1,i),ttmin(1,i),ttmax(1,i),ttsdev(1,i)
          end if
        enddo
        do i=1,ntimers
          if (.not.ttask(i)%comm) then
            write (1,400) ttask(i)%label, &
                          ttavg(1,i),ttmin(1,i),ttmax(1,i),ttsdev(1,i)
          end if
        enddo
!
        write (1,*)
        write (1,200) 'Average total time per processor = ',t_avg
        write (1,200) 'Average comm. time per processor = ',c_avg
        write (1,200) 'Average comp. time per processor = ',t_avg-c_avg
        write (1,*)
        write (1,500) 'Average ratio of communication time to'// &
                      ' total time = ',comm_percent
!
        write (1,600) 'Normalized COMP time used: ',normalized_time
        time_elapsed=time-time_at_start
        if (time_elapsed.ne.0.) then
          normalized_time=(normalized_time*float(ntime))/time_elapsed
        else
          normalized_time=0.
        end if
        write (1,601) '                          ',normalized_time
!
        if (ntotal_si_p+ntotal_si_c+ntotal_visc.gt.0) then
          normalized_time=(1.e6*ttavg(1,TIME_V_SOLVER)*float(nproc))/ &
          (float(nrm1_g)*float(ntm1_g)*float(np_g))/ &
          (float(ntotal_si_p)+float(ntotal_si_c)+float(ntotal_visc))
        else
          normalized_time=0.
        end if
        write (1,602) '                          ',normalized_time
!
        if (ntotal_te.gt.0) then
          normalized_time=(1.e6*ttavg(1,TIME_ADVTCE)*float(nproc))/ &
            (float(nrm1_g)*float(ntm1_g)*float(np_g))/ &
            (float(ntotal_te))
        else
          normalized_time=0.
        end if
        write (1,603) '                          ',normalized_time
!
        ncgw=3*ntotal_a+ntotal_te + &
             3*(ntotal_si_p+ntotal_si_c+ntotal_visc)
!
        if (ncgw.gt.0) then
          normalized_time=(1.e6*t_avg*float(nproc))/ &
            (float(nrm1_g)*float(ntm1_g)*float(np_g))/ &
            float(ncgw)
        else
          normalized_time=0.
        end if
        write (1,604) '                          ',normalized_time
!
        write (1,*)
        write (1,100)
        write (1,*)
!
        close(1)
!
      end if
!
  100 format (80('='))
  200 format (tr1,a,f16.3,i16,f19.6)
  250 format (/,tr1,'Task',tr27,'Time Used',tr9, &
                    '# Calls',tr6,'Time per call', &
              /,tr1,'----',tr27,'---------',tr9, &
                    '-------',tr6,'-------------')
  300 format (tr1,tr34,a)
  400 format (tr1,a,4f13.3)
  500 format (tr1,a,f6.2,'%')
  600 format (/,tr1,a,f12.1,' micro-sec/mesh-point/time-step')
  601 format (tr1,a,f12.1,' micro-sec/mesh-point/normalized-time')
  602 format (tr1,a,f12.4,' micro-sec/mesh-point/vsolve-iter')
  603 format (tr1,a,f12.4,' micro-sec/mesh-point/tsolve-iter')
  604 format (tr1,a,f12.4,' micro-sec/mesh-point/weighted-CG-iter')
!
end subroutine
!#######################################################################
subroutine ffopen (iun,fname,mode,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Open file FNAME and link it to unit IUN.
!
! ****** If there is an error, this routine returns IERR.ne.0.
!
!-----------------------------------------------------------------------
!
! ****** When MODE='r', the file must exist.
! ****** When MODE='w', the file is created.
! ****** When MODE='rw', the file must exist, but can be overwritten.
! ****** When MODE='a', the file is created if it does not exist,
! ******                otherwise, it is appended.
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: iun
      character(*) :: fname
      character(*) :: mode
      integer :: ierr
      logical :: ex
!
!-----------------------------------------------------------------------
!
      ierr=0
!
      if (mode.eq.'r') then
        open (iun,file=fname,form="FORMATTED",status='old',err=900)
      else if (mode.eq.'rw') then
        open (iun,file=fname,form="FORMATTED",status='replace',err=900)
      else if (mode.eq.'w') then
        open (iun,file=fname,form="FORMATTED",status='new',err=900)
      elseif (mode.eq.'a') then
        inquire(file=fname, exist=ex)
        if (ex) then
          open (iun,file=fname,form="FORMATTED", &
                position='append',err=900)
        else
          open (iun,file=fname,form="FORMATTED",status='new',err=900)
        end if
      else
        write (*,*)
        write (*,*) '### ERROR in FFOPEN:'
        write (*,*) '### Invalid MODE requested.'
        write (*,*) 'MODE = ',mode
        write (*,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
      return
!
  900 continue
!
      write (*,*)
      write (*,*) '### ERROR in FFOPEN:'
      write (*,*) '### Error while opening the requested file.'
      write (*,*) 'File name: ',trim(fname)
      write (*,*) 'MODE = ',mode
      ierr=1
!
end subroutine
!#######################################################################
function hdfname (root,seq)
!
!-----------------------------------------------------------------------
!
! ****** Return an HDF file name of the form '<root><seq>.h5'.
!
!-----------------------------------------------------------------------
!
      use vars, only : long_sequence_numbers
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: root
      integer :: seq
      character(256) :: hdfname
!
!-----------------------------------------------------------------------
!
      character(3) :: ch3seq
      character(6) :: ch6seq
!
!-----------------------------------------------------------------------
!
      if (long_sequence_numbers) then
        write (ch6seq,'(i6.6)') seq
        hdfname=trim(root)//ch6seq//'.h5'
      else
        write (ch3seq,'(i3.3)') seq
        hdfname=trim(root)//ch3seq//'.h5'
      end if
!
      return
end function
!#######################################################################
function hdf_tpslice_name (root,seq1,seq2)
!
!-----------------------------------------------------------------------
!
! ****** Return an HDF slice file name of the form:
! ****** '<root><seq1>_tp<seq2>.h5'.
!
!-----------------------------------------------------------------------
!
      use vars, only : long_sequence_numbers
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: root
      integer :: seq1,seq2
      character(512) :: hdf_tpslice_name
!
!-----------------------------------------------------------------------
!
      character(3) :: ch3seq,seq2str
      character(6) :: ch6seq
!
!-----------------------------------------------------------------------
!
      write (seq2str,'(i3.3)') seq2
!
      if (long_sequence_numbers) then
        write (ch6seq,'(i6.6)') seq1
        hdf_tpslice_name='slice_tp'//seq2str// &
                         '_'//trim(root)//ch6seq//'.h5'
      else
        write (ch3seq,'(i3.3)') seq1
        hdf_tpslice_name='slice_tp'//seq2str// &
                         '_'//trim(root)//ch3seq//'.h5'
      end if
!
      return
end function
!#######################################################################
subroutine rdhdf_2d (fname,scale,nx,ny,f,x,y,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D scientific data set from an HDF file.
!
!-----------------------------------------------------------------------
!
! ****** This routine calls routine RDHDF to read the file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*), intent(in) :: fname
      logical, intent(out) :: scale
      integer, intent(out) :: nx,ny
      real(r_typ), dimension(:,:), pointer, contiguous :: f
      real(r_typ), dimension(:), pointer, contiguous :: x,y
      integer, intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Declaration for the SDS structure.
!
      type(sds) :: s
!
!-----------------------------------------------------------------------
!
! ****** Temporary 2D array pointer.
!
      real(r_typ), dimension(:,:), pointer, contiguous :: f2
!
!-----------------------------------------------------------------------
!
! ****** Read the data set.
!
      call rdhdf (fname,s,ierr)
!
      if (ierr.ne.0) return
!
! ****** Check that this is a 2D data set.
!
      if (s%ndim.ne.2) then
        write (9,*)
        write (9,*) '### ERROR in RDHDF_2D:'
        write (9,*) '### The HDF file does not contain a 2D data set.'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Set the output arguments.
!
      nx=s%dims(1)
      ny=s%dims(2)
      scale=s%scale
      x=>s%scales(1)%f
      y=>s%scales(2)%f
      deallocate (s%scales(3)%f)
      allocate (f2(nx,ny))
      f2=s%f(:,:,1)
      f=>f2
      deallocate (s%f)
!
end subroutine
!#######################################################################
subroutine rdhdf_3d (fname,scale,nx,ny,nz,f,x,y,z,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 3D scientific data set from an HDF file.
!
!-----------------------------------------------------------------------
!
! ****** This routine calls routine RDHDF to read the file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*), intent(in) :: fname
      logical, intent(out) :: scale
      integer, intent(out) :: nx,ny,nz
      real(r_typ), dimension(:,:,:), pointer, contiguous :: f
      real(r_typ), dimension(:), pointer, contiguous :: x,y,z
      integer, intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Declaration for the SDS structure.
!
      type(sds) :: s
!
!-----------------------------------------------------------------------
!
! ****** Read the data set.
!
      call rdhdf (fname,s,ierr)
!
      if (ierr.ne.0) return
!
! ****** Check that this is a 3D data set.
!
      if (s%ndim.ne.3) then
        write (9,*)
        write (9,*) '### ERROR in RDHDF_3D:'
        write (9,*) '### The HDF file does not contain a 3D data set.'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Set the output arguments.
!
      nx=s%dims(1)
      ny=s%dims(2)
      nz=s%dims(3)
      scale=s%scale
      x=>s%scales(1)%f
      y=>s%scales(2)%f
      z=>s%scales(3)%f
      f=>s%f
!
end subroutine
!#######################################################################
subroutine wrhdf_1d (fname,scale,nx,f,x,hdf32,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write a 1D scientific data set to an HDF file.
!
!-----------------------------------------------------------------------
!
! ****** This routine calls routine WRHDF to write the file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
      use assign_ptr_1d_interface
      use assign_ptr_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      character(512) :: fname_new
      logical :: scale
      integer :: nx
      real(r_typ), dimension(nx,1,1) :: f
      real(r_typ), dimension(nx) :: x
      logical :: hdf32
      integer :: ierr
      intent(in) :: scale,nx,f,x,hdf32
      intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Declaration for the SDS structure.
!
      type(sds) :: s
!
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Set the structure components.
!
      s%ndim=1
      s%dims(1)=nx
      s%dims(2)=1
      s%dims(3)=1
      s%scale=scale
      s%hdf32=hdf32
      if (scale) then
        call assign_ptr_1d (x,s%scales(1)%f)
      else
        nullify (s%scales(1)%f)
      end if
      nullify (s%scales(2)%f)
      nullify (s%scales(3)%f)
      call assign_ptr_3d (f,s%f)
!
! ****** Write the data set.
!
      call wrhdf (fname,s,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in WRHDF_1D:'
        write (9,*) '### Could not write the 1D data set.'
        write (9,*) 'File name: ',trim(fname)
        return
      end if
!
end subroutine
!#######################################################################
subroutine wrhdf_2d (fname,scale,nx,ny,f,x,y,hdf32,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write a 2D scientific data set to an HDF file.
!
!-----------------------------------------------------------------------
!
! ****** This routine calls routine WRHDF to write the file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
      use assign_ptr_1d_interface
      use assign_ptr_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      character(512) :: fname_new
      logical, intent(in) :: scale
      integer, intent(in) :: nx,ny
      real(r_typ), dimension(nx,ny,1), intent(in) :: f
      real(r_typ), dimension(nx), intent(in) :: x
      real(r_typ), dimension(ny), intent(in) :: y
      logical, intent(in) :: hdf32
      integer, intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Declaration for the SDS structure.
!
      type(sds) :: s
!
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Set the structure components.
!
      s%ndim=2
      s%dims(1)=nx
      s%dims(2)=ny
      s%dims(3)=1
      s%scale=scale
      s%hdf32=hdf32
      if (scale) then
        call assign_ptr_1d (x,s%scales(1)%f)
        call assign_ptr_1d (y,s%scales(2)%f)
      else
        nullify (s%scales(1)%f)
        nullify (s%scales(2)%f)
      end if
      nullify (s%scales(3)%f)
      call assign_ptr_3d (f,s%f)
!
! ****** Write the data set.
!
      call wrhdf (fname,s,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in WRHDF_2D:'
        write (9,*) '### Could not write the 1D data set.'
        write (9,*) 'File name: ',trim(fname)
        return
      end if
!
end subroutine
!#######################################################################
subroutine wrhdf_3d (fname,scale,nx,ny,nz,f,x,y,z,hdf32,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write a 3D scientific data set to an HDF file.
!
!-----------------------------------------------------------------------
!
! ****** This routine calls routine WRHDF to write the file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
      use assign_ptr_1d_interface
      use assign_ptr_3d_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      logical, intent(in) :: scale
      integer, intent(in) :: nx,ny,nz
      real(r_typ), dimension(nx,ny,nz), intent(in) :: f
      real(r_typ), dimension(nx), intent(in) :: x
      real(r_typ), dimension(ny), intent(in) :: y
      real(r_typ), dimension(nz), intent(in) :: z
      logical, intent(in) :: hdf32
      integer, intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Declaration for the SDS structure.
!
      type(sds) :: s
!
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Set the structure components.
!
      s%ndim=3
      s%dims(1)=nx
      s%dims(2)=ny
      s%dims(3)=nz
      s%scale=scale
      s%hdf32=hdf32
      if (scale) then
        call assign_ptr_1d (x,s%scales(1)%f)
        call assign_ptr_1d (y,s%scales(2)%f)
        call assign_ptr_1d (z,s%scales(3)%f)
      else
        nullify (s%scales(1)%f)
        nullify (s%scales(2)%f)
        nullify (s%scales(3)%f)
      end if
      call assign_ptr_3d (f,s%f)
!
! ****** Write the data set.
!
      call wrhdf (fname,s,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in WRHDF_3D:'
        write (9,*) '### Could not write the 1D data set.'
        write (9,*) 'File name: ',trim(fname)
        return
      end if
!
end subroutine
!#######################################################################
subroutine assign_ptr_1d (from,to)
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), target :: from
      real(r_typ), dimension(:), pointer :: to
!
!-----------------------------------------------------------------------
!
      to=>from
!
end subroutine
!#######################################################################
subroutine assign_ptr_3d (from,to)
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:,:,:), target :: from
      real(r_typ), dimension(:,:,:), pointer :: to
!
!-----------------------------------------------------------------------
!
      to=>from
!
end subroutine
!#######################################################################
subroutine rdhdf (fname,s,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 1D, 2D, or 3D scientific data set from an HDF file.
! ****** This routine uses the standard SD API (not the old DFSD).
!
!-----------------------------------------------------------------------
!
! ****** This routine allocates the required memory and returns
! ****** pointers to the data and scale arrays.
!
!-----------------------------------------------------------------------
!
! ****** Input arguments:
!
!          FNAME   : [character(*)]
!                    HDF data file name to read from.
!
! ****** Output arguments:
!
!          S       : [structure of type SDS]
!                    A structure that holds the field, its
!                    dimensions, and the scales, with the
!                    components described below.
!
!          IERR    : [integer]
!                    IERR=0 is returned if the data set was read
!                    successfully.  Otherwise, IERR is set to a
!                    nonzero value.
!
! ****** Components of structure S:
!
!          NDIM    : [integer]
!                    Number of dimensions found in the data set.
!
!          DIMS    : [integer, dimension(3)]
!                    Number of points in the data set dimensions.
!                    For a 1D data set, DIMS(2)=DIMS(3)=1.
!                    For a 2D data set, DIMS(3)=1.
!
!          SCALE   : [logical]
!                    Flag to indicate the presence of scales (axes)
!                    in the data set.  SCALE=.false. means that scales
!                    were not found; SCALE=.true. means that scales
!                    were found.
!
!          HDF32   : [logical]
!                    Flag to indicate the precision of the data set
!                    read in.  HDF32=.true. means that the data is
!                    32-bit; HDF32=.false. means that the data is
!                    64-bit.
!
!          SCALES  : [structure of type RP1D, dimension(3)]
!                    This array holds the pointers to the scales
!                    when SCALE=.true., and is undefined otherwise.
!
!          F       : [real, pointer to a rank-3 array]
!                    This array holds the data set values.
!
! ****** The storage for the arrays pointed to by F, and the
! ****** scales (if present) in structure SCALES, is allocated by
! ****** this routine.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      type(sds) :: s
      integer :: ierr
      intent(in) :: fname
      intent(out) :: s,ierr
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_IO)
!
      ierr=0
!
      call rdh5 (fname,s,ierr)
!
      if (use_timer) call timer (TIME_IO)
!
end subroutine
!#######################################################################
subroutine rdh5 (fname,s,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 1D, 2D, or 3D scientific data set from an HDF5 file.
! ****** The HDF5 file is currently assumed to contain only one
! ****** dataset (1D,2d,3D), with or without scales, in group "/",
! ****** and has no other data members.
!
!-----------------------------------------------------------------------
!
! ****** This routine allocates the required memory and returns
! ****** pointers to the data and scale arrays.
!
!-----------------------------------------------------------------------
!
! ****** Input arguments:
!
!          FNAME   : [character(*)]
!                    HDF5 data file name to read from.
!
! ****** Output arguments:
!
!          S       : [structure of type SDS]
!                    A structure that holds the field, its
!                    dimensions, and the scales, with the
!                    components described below.
!
!          IERR    : [integer]
!                    IERR=0 is returned if the data set was read
!                    successfully.  Otherwise, IERR is set to a
!                    nonzero value.
!
! ****** Components of structure S:
!
!          NDIM    : [integer]
!                    Number of dimensions found in the data set.
!
!          DIMS    : [integer, dimension(3)]
!                    Number of points in the data set dimensions.
!                    For a 1D data set, DIMS(2)=DIMS(3)=1.
!                    For a 2D data set, DIMS(3)=1.
!
!          SCALE   : [logical]
!                    Flag to indicate the presence of scales (axes)
!                    in the data set.  SCALE=.false. means that scales
!                    were not found; SCALE=.true. means that scales
!                    were found.
!
!          HDF32   : [logical]
!                    Flag to indicate the precision of the data set
!                    read in.  HDF32=.true. means that the data is
!                    32-bit; HDF32=.false. means that the data is
!                    64-bit.
!
!          SCALES  : [structure of type RP1D, dimension(3)]
!                    This array holds the pointers to the scales
!                    when SCALE=.true., and is undefined otherwise.
!
!          F       : [real, pointer to a rank-3 array]
!                    This array holds the data set values.
!
! ****** The storage for the arrays pointed to by F, and the
! ****** scales (if present) in structure SCALES, is allocated by
! ****** this routine.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
      use hdf5
      use h5ds
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(sds) :: s
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,obj_type,n_members
!
      integer(HID_T) :: file_id       ! File identifier
      integer(HID_T) :: dset_id       ! Dataset identifier
      integer(HID_T) :: dspace_id     ! Dataspace identifier
      integer(HID_T) :: dim_id        ! Dimension identifiers
      integer(HID_T) :: datatype_id   ! Datatype identifiers
!
      integer(SIZE_T) :: prec
!
      integer(HSIZE_T),dimension(:), allocatable :: s_dims,maxpts
      integer(HSIZE_T),dimension(1) :: s_dims_i
!
      real(KIND_REAL_4), dimension(:,:,:), allocatable :: f4
      real(KIND_REAL_4), dimension(:),     allocatable :: f4dim
      real(KIND_REAL_8), dimension(:,:,:), allocatable :: f8
      real(KIND_REAL_8), dimension(:),     allocatable :: f8dim
!
      character(512) :: obj_name
      character(4), parameter :: cname='RDH5'
!
      logical :: is_scale
!
!-----------------------------------------------------------------------
!
! ****** Initialize dimension count and arrays.
!
      s%ndim=0
      s%dims(:)=1
!
! ****** Initialize hdf5 interface.
!
      call h5open_f (ierr)
!
! ****** Open hdf5 file.
!
      call h5Fopen_f (trim(fname),H5F_ACC_RDONLY_F,file_id,ierr)
!
! ****** Get information about the hdf5 file.
!
      call h5Gn_members_f (file_id,"/",n_members,ierr)
!
! ****** Make sure there is (at maximum) one 3D dataset with scales.
!
      if (n_members.eq.0.or.n_members.gt.4) then
        write (*,*)
        write (*,*) '### ERROR in ',cname,':'
        write (*,*) '### Input file contains too few/many datasets.'
        write (*,*) 'File name: ',trim(fname)
        return
      end if
!
! ****** Assume the Dataset is in index 0 and get its name.
!
      call h5Gget_obj_info_idx_f (file_id,"/",0,obj_name,obj_type,ierr)
!
! ****** Open Dataset.
!
      call h5Dopen_f (file_id,trim(obj_name),dset_id,ierr)
!
! ****** Make sure the Dataset is not a scale.
!
      call h5DSis_scale_f(dset_id,is_scale,ierr)
      if (is_scale) then
        write (*,*)
        write (*,*) '### ERROR in ',cname,':'
        write (*,*) '### Input file Dataset at index 0 is a scale.'
        write (*,*) 'File name: ',trim(fname)
        return
      end if
!
! ****** Get dimensions (need s_dims array for format requirements).
!
      call h5Dget_space_f (dset_id,dspace_id,ierr)
      call h5Sget_simple_extent_ndims_f (dspace_id,s%ndim,ierr)
!
      allocate(s_dims(s%ndim))
!
      allocate(maxpts(s%ndim))
      call h5Sget_simple_extent_dims_f (dspace_id,s_dims,maxpts,ierr)
      deallocate(maxpts)
!
      do j=1,s%ndim
        s%dims(j)=INT(s_dims(j))
      end do
!
! ****** Get the floating-point precision of the data and set flag.
!
      call h5Dget_type_f (dset_id,datatype_id,ierr)
      call h5Tget_precision_f (datatype_id,prec,ierr)
!
      if (prec.eq.32) then
        s%hdf32=.true.
      elseif (prec.eq.64) then
        s%hdf32=.false.
      end if
!
! ****** Allocate the memory for the Dataset array in s.
!
      allocate (s%f(s%dims(1),s%dims(2),s%dims(3)))
!
! ****** Need to read the file in its own datatype, and then convert
! ****** to datatype of s%f.
!
      if (s%hdf32) then
        allocate (f4(s%dims(1),s%dims(2),s%dims(3)))
        call h5Dread_f (dset_id,datatype_id,f4,s_dims,ierr)
        do k=1,s%dims(3)
          do j=1,s%dims(2)
            do i=1,s%dims(1)
              s%f(i,j,k)=REAL(f4(i,j,k),r_typ)
            enddo
          enddo
        enddo
        deallocate (f4)
      else
        allocate (f8(s%dims(1),s%dims(2),s%dims(3)))
        call h5Dread_f (dset_id,datatype_id,f8,s_dims,ierr)
        s%f(:,:,:)=f8(:,:,:)
        deallocate (f8)
      end if
!
      deallocate(s_dims)
!
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### ERROR in RDH5:'
        write (*,*) '### Error while reading the dataset.'
        write (*,*) 'File name: ',trim(fname)
        write (*,*) '[Error return (from H5DREAD_F) = ',ierr,']'
        ierr=4
        return
      end if
!
! ****** Close the hdf5 type descriptor.
!
      call h5Tclose_f (datatype_id,ierr)
!
! ****** Check if there might be scales present, if so, read them.
!
      if (n_members.gt.1) then
!
! ***** First check that the number of scale datasets match the # dim.
!
        if (n_members-1.ne.s%ndim) then
          write (*,*)
          write (*,*) '### ERROR in RDH5:'
          write (*,*) '### # scales does not match # dims.'
          write (*,*) 'File name: ',trim(fname)
          return
        end if
!
        s%scale=.true.
!
! ****** Loop through scales, make sure each is a scale, and read them.
!
        do i=1,n_members-1
!
! ****** Get the name of scale dataset.
!
          call h5Gget_obj_info_idx_f (file_id,"/",i, &
                                     obj_name,obj_type,ierr)
!
! ****** Open scale dataset.
!
          call h5Dopen_f (file_id,trim(obj_name),dim_id,ierr)
!
! ****** Make sure the scale is a scale.
!
          call h5DSis_scale_f (dim_id,is_scale,ierr)
          if (.not.is_scale) then
            write (*,*)
            write (*,*) '### ERROR in RDH5:'
            write (*,*) '### Scale is not a scale.'
            write (*,*) 'File name: ',trim(fname)
            return
          end if
!
! ****** Get dimension of scale.
!
          s_dims_i=s%dims(i)
!
! ****** Allocate scale.
!
          allocate (s%scales(i)%f(s_dims_i(1)))
!
! ****** Get the floating-point precision of the scale.
!
          call h5Dget_type_f (dim_id,datatype_id,ierr)
          call h5Tget_precision_f (datatype_id,prec,ierr)
!
! ****** Read in the scale data.
!
          if (prec.eq.32) then
            allocate (f4dim(s_dims_i(1)))
            call h5Dread_f (dim_id,datatype_id,f4dim,s_dims_i,ierr)
            do j=1,s%dims(i)
              s%scales(i)%f(j)=REAL(f4dim(j),r_typ)
            end do
            deallocate (f4dim)
          elseif (prec.eq.64) then
            allocate (f8dim(s_dims_i(1)))
            call h5Dread_f (dim_id,datatype_id,f8dim,s_dims_i,ierr)
            s%scales(i)%f(:)=f8dim(:)
            deallocate (f8dim)
          end if
!
! ****** Close the scale dataset.
!
          call h5Dclose_f (dim_id,ierr)
!
        enddo
!
! ****** Allocate dummy scales (of length 1) for empty dimensions.
!
        do i=s%ndim+1,3
          allocate (s%scales(i)%f(1))
        enddo
      else
!
! ****** If scales are not present, allocate dummy
! ****** scales (of length 1) so that the pointers to the scales
! ****** are valid.
!
        s%scale=.false.
!
        allocate (s%scales(1)%f(1))
        allocate (s%scales(2)%f(1))
        allocate (s%scales(3)%f(1))
      end if
!
! ****** Close the dataset.
!
      call h5Dclose_f (dset_id,ierr)
!
! ****** Close the file.
!
      call h5Fclose_f (file_id,ierr)
!
! ****** Close FORTRAN interface.
!
      call h5close_f (ierr)
!
end subroutine
!#######################################################################
subroutine wrhdf (fname,s,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write a 1D, 2D, or 3D scientific data set to an HDF5 file.
!
!-----------------------------------------------------------------------
!
! ****** Input arguments:
!
!          FNAME   : [character(*)]
!                    HDF data file name to write to.
!
!          S       : [structure of type SDS]
!                    A structure that holds the field, its
!                    dimensions, and the scales, with the
!                    components described below.
!
! ****** Output arguments:
!
!          IERR    : [integer]
!                    IERR=0 is returned if the data set was written
!                    successfully.  Otherwise, IERR is set to a
!                    nonzero value.
!
! ****** Components of structure S:
!
!          NDIM    : [integer]
!                    Number of dimensions in the data set.
!
!          DIMS    : [integer, dimension(3)]
!                    Number of points in the data set dimensions.
!                    Only DIMS(1 .. NDIM) are referenced.
!
!          SCALE   : [logical]
!                    Flag to indicate the presence of scales (axes)
!                    in the data set.  SCALE=.false. means that scales
!                    are not being supplied; SCALE=.true. means that
!                    scales are being supplied.
!
!          HDF32   : [logical]
!                    Flag to specify the precision of the data to
!                    be written to the file.  Set HDF32=.true. to
!                    write 32-bit data, and HDF32=.false. to write
!                    64-bit data.
!
!          SCALES  : [structure of type RP1D, dimension(3)]
!                    This array holds the pointers to the scales
!                    when SCALE=.true., and is not referenced
!                    otherwise.
!
!          F       : [real, pointer to a rank-3 array]
!                    This array holds the data set values.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*), intent(in) :: fname
      type(sds), intent(in) :: s
      integer, intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_IO)
!
      ierr=0
!
! ****** Check the number of dimensions.
!
      if (s%ndim.le.0.or.s%ndim.gt.3) then
        write (9,*)
        write (9,*) '### ERROR in WRHDF:'
        write (9,*) '### Could not write the SDS data.'
        write (9,*) 'Invalid number of dimensions.'
        write (9,*) 'Number of dimensions = ',s%ndim
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Write hdf5 file.
!
      call wrh5 (fname,s,ierr)
!
      if (use_timer) call timer (TIME_IO)
!
end subroutine
!#######################################################################
subroutine wrh5 (fname,s,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Write a 1D, 2D, or 3D scientific data set to an HDF5 file.
!
!-----------------------------------------------------------------------
!
! ****** Input arguments:
!
!          FNAME   : [character(*)]
!                    HDF data file name to write to.
!
!          S       : [structure of type SDS]
!                    A structure that holds the field, its
!                    dimensions, and the scales, with the
!                    components described below.
!
! ****** Output arguments:
!
!          IERR    : [integer]
!                    IERR=0 is returned if the data set was written
!                    successfully.  Otherwise, IERR is set to a
!                    nonzero value.
!
!-----------------------------------------------------------------------
!
      use number_types
      use sds_def
      use hdf5
      use h5ds
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      type(sds) :: s
      integer :: ierr
      intent(in) :: fname,s
      intent(out) :: ierr
!
!-----------------------------------------------------------------------
!
      character(8) ::   dimname
      integer :: i,j,k
      integer(HID_T) :: file_id       ! File identifier
      integer(HID_T) :: dset_id       ! Dataset identifier
      integer(HID_T) :: dspace_id,dspacedim_id   ! Dataspace identifiers
      integer(HID_T) :: dim_id        ! Dimension identifiers
      integer(HSIZE_T),dimension(3) :: s_dims
      integer(HSIZE_T),dimension(1) :: s_dims_i
!
      real(KIND_REAL_4), dimension(:,:,:), allocatable :: f4
      real(KIND_REAL_4), dimension(:),     allocatable :: f4dim
      real(KIND_REAL_8), dimension(:,:,:), allocatable :: f8
      real(KIND_REAL_8), dimension(:),     allocatable :: f8dim
!
!-----------------------------------------------------------------------
!
! ****** HDF5 calls are picky about the integer format for the dims
! ****** so the s%dims need to be converted to HSIZE_T integers.
!
! ****** Also, sometimes calls to wrhdf() for 1D and 2D datasets
! ****** do not have the unused dims(i) set to 1 (unset).
! ****** To avoid needing a function call to implicitly reshape
! ****** f(n), set the dims here.
!
      do i=1,3
         if (i.le.s%ndim) then
           s_dims(i)=INT(s%dims(i),HSIZE_T)
         else
           s_dims(i)=1
         endif
      end do
!
! ****** Initialize hdf5 interface.
!
      call h5open_f (ierr)
!
! ****** Create the file.
!
      call h5Fcreate_f (trim(fname),H5F_ACC_TRUNC_F,file_id,ierr)
!
! ****** Create the dataspace.
!
      call h5Screate_simple_f (s%ndim,s_dims,dspace_id,ierr)
!
! ****** Create and write the dataset (convert s%f to proper type).
!
      if (s%hdf32) then
        allocate (f4(s_dims(1),s_dims(2),s_dims(3)))
        do k=1,s%dims(3)
          do j=1,s%dims(2)
            do i=1,s%dims(1)
              f4(i,j,k)=REAL(s%f(i,j,k),KIND_REAL_4)
            enddo
          enddo
        enddo
        call h5Dcreate_f (file_id,'Data',H5T_NATIVE_REAL, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_REAL,f4,s_dims,ierr)
        deallocate (f4)
      else
        allocate (f8(s_dims(1),s_dims(2),s_dims(3)))
        f8(:,:,:)=s%f(:,:,:)
        call h5Dcreate_f (file_id,'Data',H5T_NATIVE_DOUBLE, &
                          dspace_id,dset_id,ierr)
        call h5Dwrite_f (dset_id,H5T_NATIVE_DOUBLE,f8,s_dims,ierr)
        deallocate (f8)
      end if
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### ERROR in WRH5:'
        write (*,*) '### Could not write the dataset.'
        write (*,*) 'File name: ',trim(fname)
        write (*,*) '[Error return (from h5Dwrite_f) = ',ierr,']'
        ierr=4
        return
      end if
!
! ****** Check for scales.  If present, add them to the hdf5 dataset.
!
      if (s%scale) then
        do i=1,s%ndim
          if (i.eq.1) then
            dimname='dim1'
          elseif (i.eq.2) then
            dimname='dim2'
          elseif (i.eq.3) then
            dimname='dim3'
          end if
          s_dims_i=s_dims(i)
          call h5Screate_simple_f(1,s_dims_i,dspacedim_id,ierr)
          if (s%hdf32) then
            allocate (f4dim(s_dims_i(1)))
            do j=1,s%dims(i)
              f4dim(j)=REAL(s%scales(i)%f(j),KIND_REAL_4)
            enddo
            call h5Dcreate_f (file_id,dimname,H5T_NATIVE_REAL, &
                              dspacedim_id,dim_id,ierr)
            call h5Dwrite_f (dim_id,H5T_NATIVE_REAL, &
                             f4dim,s_dims_i,ierr)
            deallocate (f4dim)
          else
            allocate (f8dim(s_dims_i(1)))
            f8dim(:)=s%scales(i)%f(:)
            call h5Dcreate_f (file_id,dimname,H5T_NATIVE_DOUBLE, &
                              dspacedim_id,dim_id,ierr)
            call h5Dwrite_f (dim_id,H5T_NATIVE_DOUBLE, &
                             f8dim,s_dims_i,ierr)
            deallocate (f8dim)
          end if
          call h5DSset_scale_f (dim_id,ierr,dimname)
          call h5DSattach_scale_f (dset_id,dim_id,i,ierr)
          call h5DSset_label_f(dset_id, i, dimname, ierr)
          call h5Dclose_f (dim_id,ierr)
          call h5Sclose_f (dspacedim_id,ierr)
        end do
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in WRH5:'
          write (*,*) '### Could not write the scales.'
          write (*,*) 'File name: ',trim(fname)
          ierr=5
          return
        end if
      end if
!
! ****** Close the dataset.
!
      call h5Dclose_f (dset_id,ierr)
!
! ****** Close the dataspace.
!
      call h5Sclose_f (dspace_id,ierr)
!
! ****** Close the file.
!
      call h5Fclose_f (file_id,ierr)
!
! ****** Close the hdf5 interface.
!
      call h5close_f (ierr)
!
end subroutine
!#######################################################################
subroutine advtce
!
!-----------------------------------------------------------------------
!
! ****** Advance the temperature for thermal conduction.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use mpidefs
      use timing
      use cgcom
      use mesh
      use debug
      use seam_interface
      use matrix_storage_t_solve
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: fne,dv,dtime_exp,time_stepped
      real(r_typ) :: dtime_local2,dtime_tmp
      real(r_typ), parameter :: one=1._r_typ
      integer :: i,j,k,ierr,i_sstc
      logical :: we_are_done
!
! ****** Arrays for the temperature and the RHS for the 3D thermal
! ****** conduction solve.
!
      real(r_typ), dimension(nr,nt,np) :: rhs3d
      real(r_typ), dimension(nr,nt,np) :: taux
      real(r_typ), dimension(N_cgvec) :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVTCE)
!
! ****** Set the solve type, equation, and vector size.
!
      equation_solved=EQ_TE
      solve_type=ST_T
      N_CG=N_cgvec
!
! *** Allocate matrix coefficents.
!
      call alloc_t_matrix_coefs
!
! ****** Set up tc subcycles.
!
      i_sstc=1
      time_stepped=0.
      we_are_done=.false.
!
      if (tc_auto_subcycle) then
        dtime_local2=dtime
      else
        dtime_local2=dtime/REAL(tc_subcycles,r_typ)
      end if
!
      if (.not.use_exp_tc.and..not.use_sts_tc) then
        dtime_tmp=dtime
        dtime=dtime_local2
        call load_matrix_t_solve_implicit (temp_e0)
        dtime=dtime_tmp
        call load_preconditioner_t_solve
      else
        call load_matrix_t_solve_explicit (temp_e0)
      end if
!$acc enter data create(x_cg)
!
! ****** Reset the time step to start the autocycle dt correctly.
!
      if (tc_auto_subcycle) dtime_local2=0.
!
! ****** Start the subcycle loop.
!
      do
!
! ****** Compute and set the practical time-step if requested.
!
        if (tc_auto_subcycle) then
!
          call get_dtptl_tc (dtime_local2,temp_e,temp_e0)
!
! ****** Lower time step to reach the end time exactly if
! ****** it would otherwise go too far.
!
          if (time_stepped+dtime_local2.ge.dtime) then
            dtime_local2=dtime-time_stepped
            we_are_done=.true.
          end if
!
! ****** Take one last big step if hitting max # cycles.
! ****** Note: This not the same as having that number from the start.
!
          if (i_sstc.eq.tc_subcycles_max) then
            dtime_local2=dtime-time_stepped
            we_are_done=.true.
          end if
!
! ****** Need to re-load the matrix due to change in dtime if using pcg.
!
          if (.not.use_exp_tc.and..not.use_sts_tc) then
            dtime_tmp=dtime
            dtime=dtime_local2
            call load_matrix_t_solve_implicit (temp_e0)
            call load_preconditioner_t_solve
            dtime=dtime_tmp
          end if
!
          tc_subcycles = CEILING((dtime-time_stepped)/dtime_local2)
!
        end if
!
! ****** Take the tc step based on the method chosen.
!
        if (use_exp_tc) then
!
! ****** Explicit Forward Euler
!
          call get_dtexp_tc (dtime_exp)
          sts_s=ceiling(dtime_local2/dtime_exp)
          dtime_exp=dtime_local2/REAL(sts_s,r_typ)
          call pack_scalar (temp_e,x_cg)
          call alloc_cg_ax_tmp
          call take_exp_step (x_cg,sts_s,dtime_exp)
          call dealloc_cg_ax_tmp
          call unpack_scalar (temp_e,x_cg)
          call set_bc_temp_e (temp_e,one)
          call seam_scalar (temp_e,nr,nt,np)
!
        elseif (use_sts_tc) then
!
! ****** Explicit Super Time Stepping
!
          call load_sts (dtime_local2)
          call pack_scalar (temp_e,x_cg)
          if (sts_type.eq.3) then
            call take_sts_step_rk2 (x_cg,dtime_local2)
          elseif (sts_type.eq.2) then
            call take_sts_step_rk2 (x_cg,dtime_local2)
          elseif(sts_type.eq.1) then
            call take_sts_step_rkl1 (x_cg,dtime_local2)
          end if
          call unpack_scalar (temp_e,x_cg)
          call set_bc_temp_e (temp_e,one)
          call seam_scalar (temp_e,nr,nt,np)
          call unload_sts
!
        else
!
! ****** Implicit Backward Euler (PCG)
!
! ****** Set the RHS and the guess.
!
!$acc enter data create(rhs_cg,taux,rhs3d)
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            taux(i,j,k)=0.
            rhs3d(i,j,k)=0.
          enddo
          do concurrent (i=1:N_cgvec)
            rhs_cg(i)=0.
            x_cg(i)=0.
          enddo
!
! ****** Get the RHS and the guess.
!
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
            fne=rho(i,j,k)/he_rho
            rhs3d(i,j,k)=fne*(temp_e(i,j,k) &
                         +dqdt(i,j,k)*temp_e0(i,j,k))*dv
          enddo
!
          call pack_scalar (rhs3d,rhs_cg)
!
! ****** Use a trick to accumulate the contribution of the
! ****** boundary conditions (i.e., the inhomogenous part)
! ****** to the RHS.  x_cg is used as a tmp array here.
!
          call set_bc_temp_e (taux,one)
!
          call seam_scalar (taux,nr,nt,np)
!
          call one_plus_div_kappa_grad_t (taux,x_cg)
!
          do concurrent (i=1:N_cgvec)
            rhs_cg(i)=rhs_cg(i)-x_cg(i)
          enddo
!
! ****** Pack temperature array into 1D vector.
!
          call pack_scalar (temp_e,x_cg)
!
! ****** Solve the 3D implicit equations for the thermal conduction.
!
! ****** Set the tolerance for the solve.
!
          epscg_desired=epscg_t
!
          if (idebug.gt.0.or.ncghist.gt.0) then
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from ADVTC:'
              write (9,*) '### CG solution for the thermal conduction:'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
          end if
!
          call solve (x_cg,rhs_cg,ierr)
!
          if (ierr.ne.0) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in ADVTC:'
              write (*,*) '### CG solution for the thermal conduction:'
              write (*,*) '### The solver did not converge.'
            end if
            ifabort=.true.
            call final_diags
          end if
!
          if (idebug.gt.0.or.ncghist.gt.0) then
            if (iamp0) then
              write (9,900) '### Thermal conduction:',ncg,bnrm,rnrm
            end if
          end if
!
          call unpack_scalar (temp_e,x_cg)
          call set_bc_temp_e (temp_e,one)
          call seam_scalar (temp_e,nr,nt,np)
!
!$acc exit data delete(rhs_cg,taux,rhs3d)
        end if
!
! ****** Update the amount of the large time step that has been stepped.
!
        time_stepped=time_stepped+dtime_local2
!
        if (iamp0.and.idebug.gt.0) then
          write(*,*) '--> TC(E) Subcycle #',i_sstc,' SC: ',tc_subcycles, &
                 ' dtcycle:',dtime_local2,' time_stepped: ',time_stepped
        end if
!
! ****** If we are using a set number of subcycles, check if done.
!
        if (.not.tc_auto_subcycle.and.i_sstc.eq.tc_subcycles) then
          we_are_done=.true.
        end if
!
! ****** Exit the loop if the full time step is complete.
!
        if (we_are_done) exit
!
        i_sstc=i_sstc+1
!
      enddo
!
      if (print_matrix_t) call write_matrix_t
!
      call dealloc_t_matrix_coefs
!$acc exit data delete(x_cg)
!
      if (use_timer) call timer (TIME_ADVTCE)
!
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
!
end subroutine
!#######################################################################
subroutine advtcp
!
!-----------------------------------------------------------------------
!
! ****** Advance the proton+alpha temperature for thermal conduction.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use mpidefs
      use timing
      use cgcom
      use mesh
      use debug
      use seam_interface
      use matrix_storage_t_solve
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: fne,dv,dtime_exp,time_stepped
      real(r_typ) :: dtime_local2,dtime_tmp
      real(r_typ), parameter :: one=1._r_typ
      integer :: i,j,k,ierr,i_sstc
      logical :: we_are_done
!
! ****** Array for the potential and the RHS for the 3D thermal
! ****** conduction solve.
!
      real(r_typ), dimension(nr,nt,np) :: rhs3d
      real(r_typ), dimension(nr,nt,np) :: taux
      real(r_typ), dimension(N_cgvec) :: x_cg,rhs_cg
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVTCP)
!
! ****** Set the solve type, equation, and vector size.
!
      equation_solved=EQ_TP
      solve_type=ST_T
      N_CG=N_cgvec
!
! *** Allocate matrix coefficents.
!
      call alloc_t_matrix_coefs
!
! ****** Set up tc subcycles.
!
      i_sstc=1
      time_stepped=0.
      we_are_done=.false.
!
      if (tc_auto_subcycle) then
        dtime_local2=dtime
      else
        dtime_local2=dtime/REAL(tc_subcycles,r_typ)
      end if
!
      if (.not.use_exp_tc.and..not.use_sts_tc) then
        dtime_tmp=dtime
        dtime=dtime_local2
        call load_matrix_t_solve_implicit (temp_p0)
        dtime=dtime_tmp
        call load_preconditioner_t_solve
      else
        call load_matrix_t_solve_explicit (temp_p0)
      end if
!$acc enter data create(x_cg)
!
! ****** Reset the time step to start the autocycle dt correctly.
!
      if (tc_auto_subcycle) dtime_local2=0.
!
! ****** Start the subcycle loop.
!
      do
!
! ****** Compute and set the practical time-step if requested.
!
        if (tc_auto_subcycle) then
!
          call get_dtptl_tc (dtime_local2,temp_p,temp_p0)
!
! ****** Lower time step to reach the end time exactly if
! ****** it would otherwise go too far.
!
          if (time_stepped+dtime_local2.ge.dtime) then
            dtime_local2=dtime-time_stepped
            we_are_done=.true.
          end if
!
! ****** Take one last big step if hitting max # cycles.
! ****** Note: This not the same as having that number from the start.
!
          if (i_sstc.eq.tc_subcycles_max) then
            dtime_local2=dtime-time_stepped
            we_are_done=.true.
          end if
!
! ****** Need to re-load the matrix due to change in dtime if using pcg.
!
          if (.not.use_exp_tc.and..not.use_sts_tc) then
            dtime_tmp=dtime
            dtime=dtime_local2
            call load_matrix_t_solve_implicit (temp_p0)
            call load_preconditioner_t_solve
            dtime=dtime_tmp
          end if
!
          tc_subcycles = CEILING((dtime-time_stepped)/dtime_local2)
!
        end if
!
! ****** Take the tc step based on the method chosen.
!
        if (use_exp_tc) then
!
! ****** Explicit Forward Euler
!
          call get_dtexp_tc (dtime_exp)
          sts_s=ceiling(dtime_local2/dtime_exp)
          dtime_exp=dtime_local2/REAL(sts_s,r_typ)
          call pack_scalar (temp_p,x_cg)
          call alloc_cg_ax_tmp
          call take_exp_step (x_cg,sts_s,dtime_exp)
          call dealloc_cg_ax_tmp
          call unpack_scalar (temp_p,x_cg)
          call set_bc_temp_e (temp_p,one)
          call seam_scalar (temp_p,nr,nt,np)
!
        elseif (use_sts_tc) then
!
! ****** Explicit Super Time Stepping
!
          call load_sts (dtime_local2)
          call pack_scalar (temp_p,x_cg)
          if (sts_type.eq.3) then
            call take_sts_step_rk2 (x_cg,dtime_local2)
          elseif (sts_type.eq.2) then
            call take_sts_step_rk2 (x_cg,dtime_local2)
          elseif(sts_type.eq.1) then
            call take_sts_step_rkl1 (x_cg,dtime_local2)
          end if
          call unpack_scalar (temp_p,x_cg)
          call set_bc_temp_e (temp_p,one)
          call seam_scalar (temp_p,nr,nt,np)
          call unload_sts
!
!
        else
!
! ****** Implicit Backward Euler (PCG)
!
! ****** Set the RHS and the guess.
!
!$acc enter data create(rhs_cg,taux,rhs3d)
          do concurrent (k=1:np, j=1:nt, i=1:nr)
            taux(i,j,k)=0.
            rhs3d(i,j,k)=0.
          enddo
          do concurrent (i=1:N_cgvec)
            rhs_cg(i)=0.
            x_cg(i)=0.
          enddo
!
! ****** Get the RHS and the guess.
!
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            dv=fl_fach(i)*rh(i)**2*drh(i)*dth(j)*sth(j)*dph(k)
            fne=rho(i,j,k)/he_rho
            rhs3d(i,j,k)=fne*(temp_p(i,j,k))*dv
          enddo
!
          call pack_scalar (rhs3d,rhs_cg)
!
! ****** Use a trick to accumulate the contribution of the
! ****** boundary conditions (i.e., the inhomogenous part)
! ****** to the RHS.  x_cg is used as a tmp array here.
!
          call set_bc_temp_p (taux,one)
!
          call seam_scalar (taux,nr,nt,np)
!
          call one_plus_div_kappa_grad_t (taux,x_cg)
!
          do concurrent (i=1:N_cgvec)
            rhs_cg(i)=rhs_cg(i)-x_cg(i)
          enddo
!
! ****** Pack temperature array into 1D vector.
!
          call pack_scalar (temp_p,x_cg)
!
! ****** Solve the 3D implicit equations for the thermal conduction.
!
! ****** Set the tolerance for the solve.
!
          epscg_desired=epscg_t
!
          if (idebug.gt.0.or.ncghist.gt.0) then
            if (iamp0) then
            write (9,*)
              write (9,*) '### COMMENT from ADVTCP:'
              write (9,*) '### CG solution for the thermal conduction:'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
          end if
!
          call solve (x_cg,rhs_cg,ierr)
!
          if (ierr.ne.0) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in ADVTCP:'
              write (*,*) '### CG solution for the thermal conduction:'
              write (*,*) '### The solver did not converge.'
            end if
            ifabort=.true.
            call final_diags
          end if
!
          if (idebug.gt.0.or.ncghist.gt.0) then
            if (iamp0) then
              write (9,900) '### Thermal conduction (P):',ncg,bnrm,rnrm
            end if
          end if
!
          call unpack_scalar (temp_p,x_cg)
          call set_bc_temp_e (temp_p,one)
          call seam_scalar (temp_p,nr,nt,np)
!
!$acc exit data delete(rhs_cg,taux,rhs3d)
        end if
!
! ****** Update the amount of the large time step that has been stepped.
!
        time_stepped=time_stepped+dtime_local2
!
        if (iamp0.and.idebug.gt.0) then
          write(*,*) '--> TC(P) Subcycle #',i_sstc,' SC: ',tc_subcycles, &
                 ' dtcycle:',dtime_local2,' time_stepped: ',time_stepped
        end if
!
! ****** If we are using a set number of subcycles, check if done.
!
        if (.not.tc_auto_subcycle.and.i_sstc.eq.tc_subcycles) then
          we_are_done=.true.
        end if
!
! ****** Exit the loop if the full time step is complete.
!
        if (we_are_done) exit
!
        i_sstc=i_sstc+1
!
      enddo
!
      if (print_matrix_t) call write_matrix_t
!
      call dealloc_t_matrix_coefs
!$acc exit data delete(x_cg)
!
      if (use_timer) call timer (TIME_ADVTCP)
!
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
!
end subroutine
!#######################################################################
subroutine ax_t (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the implicit thermal conduction advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ps_t, N_CG
      use sts, ONLY : use_sts_tc,use_exp_tc
      use globals, ONLY : nr,nt,np
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0._r_typ
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ) :: hpar
!
!-----------------------------------------------------------------------
!
      if (use_sts_tc.or.use_exp_tc) then
        hpar=one
      else
        hpar=zero
      end if
!
! ***** Unpack p into scalar ps_t.
!
      call unpack_scalar (ps_t,p)
!
! ***** Set the boundary values of ps.
!
      call set_bc_temp_e (ps_t,hpar)
!
! ***** Seam ps along edges between processors.
!
      call seam_scalar (ps_t,nr,nt,np)
!
! ***** Get the matrix-vector product.
!
      call one_plus_div_kappa_grad_t (ps_t,q)
!
end subroutine
!#######################################################################
subroutine ax_v_par (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the parallel implicit momentum advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ps_v_par, N_CG
      use globals, ONLY : nr,nt,np
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0._r_typ
!
!-----------------------------------------------------------------------
!
! ***** Unpack p into scalar ps_v_par.
!
      call unpack_scalar (ps_v_par,p)
!
! ***** Set the boundary values of ps.
!
      call set_bc_v_par (ps_v_par,zero)
!
! ***** Seam ps along edges between processors.
!
      call seam_scalar (ps_v_par,nr,nt,np)
!
! ***** Get the matrix-vector product.
!
      call one_minus_div_grad_v_par (ps_v_par,q)
!
end subroutine
!#######################################################################
subroutine ax_divb (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the divergence cleaning solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use cgcom, ONLY : ps_divb, N_CG
      use globals, ONLY: nrm,ntm,npm
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
! ***** Unpack p into scalar ps_divb.
!
      call unpack_divb (ps_divb,p)
!
! ***** Set the boundary values of ps (only pole required here).
!
      call set_pole_bc_divb_phi (ps_divb)
!
! ***** Seam ps along edges between processors.
!
      call seam_scalar (ps_divb,nrm,ntm,npm)
!
! ***** Get the matrix-vector product.
!
      call delsq_divb (ps_divb,q)
!
end subroutine
!#######################################################################
subroutine get_dtexp_tc (dtime_tc_exp)
!
!-----------------------------------------------------------------------
!
! ****** Get the explicit Euler time step limit for thermal conduction.
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
      use matrix_storage_t_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: dtime_tc_exp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: safety=0.95_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,d
      real(r_typ) :: max_eig,gersh_rad
!
!-----------------------------------------------------------------------
!
! *** Estimate maximum eigenvalue using Gershgorin disks:
!
      max_eig=0.
!
!$acc parallel default(present) reduction(max:max_eig)
!$omp parallel default(shared) reduction(max:max_eig)
!$acc loop collapse(3) reduction(max:max_eig)
!$omp do collapse(3) reduction(max:max_eig)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            gersh_rad=0.
!$acc loop seq
            do d=1,19
              gersh_rad=gersh_rad+abs(a_dia(d,i,j,k))
            enddo
            max_eig=max(gersh_rad,max_eig)
          enddo
        enddo
      enddo
!$omp end parallel do
!$acc end parallel
!
! *** Compute the Euler time-step bound.
!
      dtime_tc_exp=two/max_eig
!
      call global_min (dtime_tc_exp)
!
! *** Apply safety factor.
!
      dtime_tc_exp=safety*dtime_tc_exp
!
end subroutine
!#######################################################################
subroutine get_dtexp_visc (dtime_exp)
!
!-----------------------------------------------------------------------
!
! ****** Get the explicit Euler time step limit for viscosity.
! ****** This is (currently) only valid when using STS or EXP (since
! ****** matrix coefs have a "dtime" in them otherwise)
!
!-----------------------------------------------------------------------
!
      use globals
      use mpidefs
      use matrix_storage_v_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: dtime_exp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: safety=0.95_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,d
      real(r_typ) :: max_eig,gersh_rad
!
!-----------------------------------------------------------------------
!
! *** Estimate maximum eigenvalue using Gershgorin disks:
!
      max_eig=0.
!
!$acc parallel default(present) reduction(max:max_eig)
!$omp parallel default(shared) reduction(max:max_eig)
!$acc loop collapse(3) reduction(max:max_eig)
!$omp do collapse(3) reduction(max:max_eig)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm-1
            gersh_rad=0.
!$acc loop seq
            do d=1,15
              gersh_rad=gersh_rad+abs(a_r(d,i,j,k))
            enddo
            max_eig=max(gersh_rad,max_eig)
          enddo
        enddo
      enddo
!$omp enddo
!
!$acc loop collapse(3) reduction(max:max_eig)
!$omp do collapse(3) reduction(max:max_eig)
      do k=2,npm1
        do j=2,ntm-1
          do i=2,nrm1
            gersh_rad=0.
!$acc loop seq
            do d=1,15
              gersh_rad=gersh_rad+abs(a_t(d,i,j,k))
            enddo
            max_eig=max(gersh_rad,max_eig)
          enddo
        enddo
      enddo
!$omp enddo
!
!$acc loop collapse(3) reduction(max:max_eig)
!$omp do collapse(3) reduction(max:max_eig)
      do k=2,npm-1
        do j=2,ntm1
          do i=2,nrm1
            gersh_rad=0.
!$acc loop seq
            do d=1,15
              gersh_rad=gersh_rad+abs(a_p(d,i,j,k))
            enddo
            max_eig=max(gersh_rad,max_eig)
          enddo
        enddo
      enddo
!$omp enddo
!$omp end parallel
!$acc end parallel
!
! *** Compute the Euler time-step bound.
!
      dtime_exp=two/max_eig
!
      call global_min (dtime_exp)
!
! *** Apply safety factor.
!
      dtime_exp=safety*dtime_exp
!
end subroutine
!#######################################################################
subroutine get_dtptl_visc (dtime_current)
!
!-----------------------------------------------------------------------
!
! ****** Estimate the practical time step limit for viscosity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use cgcom
      use mesh
      use matrix_storage_v_solve
      use coef_storage
      use dissipation_profiles
      use fields, ONLY : v,vis
      use mpidefs
      use debug
      use sts
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), INTENT(INOUT) :: dtime_current
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: safe=0.95_r_typ
      real(r_typ), parameter :: fmin = 1e-14_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,di,dj,dk,i0,j0,ir1,jr1,it1,jt1,ip1,jp1
      real(r_typ), dimension(N_cgvec) :: Ay,y
      type(vvec) :: Ay_vvec
      real(r_typ) :: axabsmax_r,axabsmax_t,axabsmax_p,axabsmax
      real(r_typ) :: dtime_ptl,deltau,deltaf
      logical :: tmplog
!
!-----------------------------------------------------------------------
!
      dtime_ptl=HUGE(one)
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_V: dtime_current     = ', &
                    dtime_current
      end if
!
      N_CG=N_cgvec
!
      call alloc_vvec (Ay_vvec)
!
! ****** Need to load explicit matrix if using PCG.
! ****** Implicit matrix is re-loaded after this routine is called.
!
      if (.not.use_exp_visc.and..not.use_sts_visc) then
        do concurrent (k=1:npm, j=1:ntm, i=1:nrm)
          coef(i,j,k)=vis(i,j,k)
        enddo
        call load_matrix_v_solve_explicit
      end if
!
!$acc enter data create (Ay,y)
!
      call pack_vvec (v,y)
!
      call alloc_cg_ax_tmp
      tmplog=use_exp_visc
      use_exp_visc=.true.
      call ax_v (y,Ay)
      use_exp_visc=tmplog
      call dealloc_cg_ax_tmp
!
      call unpack_vvec (Ay_vvec,Ay)
!$acc exit data delete (Ay,y)
!
      call seam_vvec (Ay_vvec)
!
! ****** Since the boundary conditions in r and theta for F are not
!        always computed (external conditons are often used),
!        we do not want to include the adjacent boundary points here.
!        If this is a concern, the stricture delta-u/2Fmax could be
!        used in the (rare) case that the max F is boundary-adjacent.
!
      if (rb0) then
        i0=3
      else
        i0=2
      end if
      if (tb0) then
        j0=3
      else
        j0=2
      end if
!
! ****** These are component specific.
!
      if (rb1) then
        ir1=nrm-2
        it1=nrm2
        ip1=nrm-2
      else
        ir1=nrm-1
        it1=nrm1
        ip1=nrm-1
      end if
      if (tb1) then
        jr1=ntm2
        jt1=ntm-2
        jp1=ntm2
      else
        jr1=ntm1
        jt1=ntm-1
        jp1=ntm1
      end if
!
! ****** Each row in the matrix here coorisponds to a vX grid point
! ****** So check Af_X for all components, and then take max.
!
      axabsmax_r=-one
      axabsmax_t=-one
      axabsmax_p=-one
!
!$acc parallel loop collapse(3) default(present) &
!$acc                           reduction(max:axabsmax_r)
      do k=2,npm1
        do j=j0,jr1
          do i=i0,ir1
            if (ABS(v%r(i,j,k)).gt.fmin) then
              axabsmax_r=MAX(ABS(Ay_vvec%r(i,j,k)),axabsmax_r)
            end if
          enddo
        enddo
      enddo
!
!$acc parallel loop collapse(3) default(present) &
!$acc                           reduction(max:axabsmax_t)
      do k=2,npm1
        do j=j0,jt1
          do i=i0,it1
            if (ABS(v%t(i,j,k)).gt.fmin) then
              axabsmax_t=MAX(ABS(Ay_vvec%t(i,j,k)),axabsmax_t)
            end if
          enddo
        enddo
      enddo
!
!$acc parallel loop collapse(3) default(present) &
!$acc                           reduction(max:axabsmax_p)
      do k=2,npm-1
        do j=j0,jp1
          do i=i0,ip1
            if (ABS(v%p(i,j,k)).gt.fmin) then
              axabsmax_p=MAX(ABS(Ay_vvec%p(i,j,k)),axabsmax_p)
            end if
          enddo
        enddo
      enddo
!
      axabsmax=MAX(axabsmax_r,axabsmax_t,axabsmax_p)
      call global_max (axabsmax)
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_V: MAX(|F|)          = ', &
                    axabsmax
      end if
!
      if (axabsmax.gt.zero) then
!
!$acc parallel default(present) &
!$acc                     copyin(axabsmax) reduction(min:dtime_ptl)
!$acc loop collapse(3) reduction(min:dtime_ptl)
        do k=2,npm1
          do j=j0,jr1
            do i=i0,ir1
              if (axabsmax.eq.ABS(Ay_vvec%r(i,j,k)) &
                  .and.ABS(v%r(i,j,k)).gt.fmin) then
!
!$acc loop seq reduction(min:dtime_ptl)
                do dk=-1,1
                  if (dk.ne.0) then
!
                    deltau=v%r(i,j,k   ) &
                          -v%r(i,j,k+dk)
!
                    deltaf=Ay_vvec%r(i,j,k   ) &
                          -Ay_vvec%r(i,j,k+dk)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do dj=-1,1
                  if (dj.ne.0) then
!
                    deltau=v%r(i,j   ,k) &
                          -v%r(i,j+dj,k)
!
                    deltaf=Ay_vvec%r(i,j,   k) &
                          -Ay_vvec%r(i,j+dj,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do di=-1,1
                  if (di.ne.0) then
!
                    deltau=v%r(i,   j,k) &
                          -v%r(i+di,j,k)
!
                    deltaf=Ay_vvec%r(i,   j,k) &
                          -Ay_vvec%r(i+di,j,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
              end if
!
            enddo
          enddo
        enddo
!
!$acc loop collapse(3) reduction(min:dtime_ptl)
        do k=2,npm1
          do j=j0,jt1
            do i=i0,it1
              if (axabsmax.eq.ABS(Ay_vvec%t(i,j,k)) &
                  .and.ABS(v%t(i,j,k)).gt.fmin) then
!
!$acc loop seq reduction(min:dtime_ptl)
                do dk=-1,1
                  if (dk.ne.0) then
!
                    deltau=v%t(i,j,k   ) &
                          -v%t(i,j,k+dk)
!
                    deltaf=Ay_vvec%t(i,j,k   ) &
                          -Ay_vvec%t(i,j,k+dk)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do dj=-1,1
                  if (dj.ne.0) then
!
                    deltau=v%t(i,j   ,k) &
                          -v%t(i,j+dj,k)
!
                    deltaf=Ay_vvec%t(i,j,   k) &
                          -Ay_vvec%t(i,j+dj,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do di=-1,1
                  if (di.ne.0) then
!
                    deltau=v%t(i,   j,k) &
                          -v%t(i+di,j,k)
!
                    deltaf=Ay_vvec%t(i,   j,k) &
                          -Ay_vvec%t(i+di,j,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
              end if
!
            enddo
          enddo
        enddo
!
!$acc loop collapse(3) reduction(min:dtime_ptl)
        do k=2,npm-1
          do j=j0,jp1
            do i=i0,ip1
              if (axabsmax.eq.ABS(Ay_vvec%p(i,j,k)) &
                  .and.ABS(v%p(i,j,k)).gt.fmin) then
!
!$acc loop seq reduction(min:dtime_ptl)
                do dk=-1,1
                  if (dk.ne.0) then
!
                    deltau=v%p(i,j,k   ) &
                          -v%p(i,j,k+dk)
!
                    deltaf=Ay_vvec%p(i,j,k   ) &
                          -Ay_vvec%p(i,j,k+dk)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do dj=-1,1
                  if (dj.ne.0) then
!
                    deltau=v%p(i,j   ,k) &
                          -v%p(i,j+dj,k)
!
                    deltaf=Ay_vvec%p(i,j,   k) &
                          -Ay_vvec%p(i,j+dj,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do di=-1,1
                  if (di.ne.0) then
!
                    deltau=v%p(i,   j,k) &
                          -v%p(i+di,j,k)
!
                    deltaf=Ay_vvec%p(i,   j,k) &
                          -Ay_vvec%p(i+di,j,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
              end if
!
            enddo
          enddo
        enddo
!$acc end parallel
      end if
!
      call global_min (dtime_ptl)
!
! ****** Add safety factor.
!
      dtime_ptl=safe*dtime_ptl
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_V: PTL timestep      = ', &
                    dtime_ptl
      end if
!
! ****** Don't let the new dt be smaller than the previous one.
! ****** dtime_current should be set to zero on the first call of the
! ****** cycle!
!
      if (dtime_ptl.lt.dtime_current) dtime_ptl=dtime_current
!
      dtime_current=dtime_ptl
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_V: PTL timestep used = ', &
                    dtime_current
      end if
!
      call dealloc_vvec (Ay_vvec)
!
end subroutine
!#######################################################################
subroutine get_dtptl_tc (dtime_current,temp_current,temp0)
!
!-----------------------------------------------------------------------
!
! ****** Estimate the practical time step limit for thermal conduction.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use cgcom
      use mesh
      use matrix_storage_t_solve
      use dissipation_profiles
      use mpidefs
      use debug
      use sts
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), INTENT(INOUT) :: dtime_current
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: zero=0.
      real(r_typ), parameter :: safe=0.95_r_typ
      real(r_typ), parameter :: fmin = 1e-14_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,di,dj,dk,i0,i1,j0,j1
      real(r_typ), dimension(N_cgvec) :: Ay,y
      real(r_typ), dimension(nr,nt,np) :: Ay_t
      real(r_typ), dimension(nr,nt,np) :: temp_current, temp0
      real(r_typ) :: avrho,dv
      real(r_typ) :: axabsmax
      real(r_typ) :: dtime_ptl,deltau,deltaf
      logical :: tmplog
!
!-----------------------------------------------------------------------
!
! ****** Since the boundary conditions in r and theta for F are not
!        always computed (external conditons are often used),
!        we do not want to include the adjacent boundary points here.
!        If this is a concern, the stricture delta-u/2Fmax could be
!        used in the (rare) case that the max F is boundary-adjacent.
!
      if (rb0) then
        i0=3
      else
        i0=2
      end if
      if (rb1) then
        i1=nrm2
      else
        i1=nrm1
      end if
      if (tb0) then
        j0=3
      else
        j0=2
      end if
      if (tb1) then
        j1=ntm2
      else
        j1=ntm1
      end if
!
      dtime_ptl=HUGE(one)
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_T: dtime_current     = ', &
                    dtime_current
      end if
!
      N_CG=N_cgvec
!
! ****** Need to load explicit matrix if using PCG.
! ****** Implicit matrix is re-loaded after this routine is called.
!
      if (.not.use_exp_tc.and..not.use_sts_tc) then
        call load_matrix_t_solve_explicit (temp0)
      end if
!
!$acc enter data create(Ay_t,Ay,y)
!
      call pack_scalar (temp_current,y)
!
      call alloc_cg_ax_tmp
      tmplog=use_exp_tc
      use_exp_tc=.true.
      call ax_t (y,Ay)
      use_exp_tc=tmplog
      call dealloc_cg_ax_tmp
!
      call unpack_scalar (Ay_t,Ay)
!
!$acc exit data delete (Ay,y)
!
      call seam_scalar (Ay_t,nr,nt,np)
!
      axabsmax=-one
!
!$acc parallel loop collapse(3) default(present) &
!$acc                           reduction(max:axabsmax)
      do k=2,npm1
        do j=j0,j1
          do i=i0,i1
            if (ABS(temp_current(i,j,k)).gt.fmin) then
              axabsmax=MAX(ABS(Ay_t(i,j,k)),axabsmax)
            end if
          enddo
        enddo
      enddo
!$acc end parallel
!
      call global_max (axabsmax)
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_T: MAX(|F|)          = ', &
                    axabsmax
      end if
!
      if (axabsmax.gt.zero) then
!
!$acc parallel default(present) &
!$acc                     copyin(axabsmax) reduction(min:dtime_ptl)
!$acc loop collapse(3) reduction(min:dtime_ptl)
        do k=2,npm1
          do j=j0,j1
            do i=i0,i1
              if (axabsmax.eq.ABS(Ay_t(i,j,k)) &
                  .and.ABS(temp_current(i,j,k)).gt.fmin) then
!
!$acc loop seq reduction(min:dtime_ptl)
                do dk=-1,1
                  if (dk.ne.0) then
!
                    deltau=temp_current(i,j,k   ) &
                          -temp_current(i,j,k+dk)
!
                    deltaf=Ay_t(i,j,k   ) &
                          -Ay_t(i,j,k+dk)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do dj=-1,1
                  if (dj.ne.0) then
!
                    deltau=temp_current(i,j   ,k) &
                          -temp_current(i,j+dj,k)
!
                    deltaf=Ay_t(i,j,   k) &
                          -Ay_t(i,j+dj,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
!$acc loop seq reduction(min:dtime_ptl)
                do di=-1,1
                  if (di.ne.0) then
!
                    deltau=temp_current(i,   j,k) &
                          -temp_current(i+di,j,k)
!
                    deltaf=Ay_t(i,   j,k) &
                          -Ay_t(i+di,j,k)
!
                    if (deltau*deltaf.lt.-fmin) then
                      dtime_ptl=MIN(-deltau/deltaf,dtime_ptl)
                    end if
!
                  end if
                enddo
!
              end if
!
            enddo
          enddo
        enddo
!$acc end parallel
      end if
!
      call global_min (dtime_ptl)
!
! ****** Add safety factor.
!
      dtime_ptl=safe*dtime_ptl
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_T: PTL timestep      = ', &
                    dtime_ptl
      end if
!
! ****** Use the input dt to set a maximum for the dtflux.
! ****** dtime_current should be set to zero on the first call of the
! ****** cycle!
!
      if (dtime_ptl.lt.dtime_current) dtime_ptl=dtime_current
!
      dtime_current=dtime_ptl
!$acc exit data delete(Ay_t)
!
      if (idebug.gt.0.and.iamp0) then
        write (*,*) ' '
        write (*,*) '  GET_DTIME_DIFFUSION_PTL_T: PTL timestep used = ', &
                    dtime_current
      end if
!
end subroutine
!#######################################################################
subroutine load_kappa_mask
!
!-----------------------------------------------------------------------
!
! ****** Load the profile that controls the transition of kappa
! ****** between a field-aligned tensor and an isotropic thermal
! ****** conductivity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use fields
      use mpidefs
      use ucase_interface
      use global_to_local_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      real(r_typ), dimension(nr_g,nt_g,np_g) :: kappa_mask_g
!
!-----------------------------------------------------------------------
!
!
! ****** Allocate memory for the mask as it is used whether kappa mask
! ****** is active or not.                        .
!
      allocate (kappa_mask(nr,nt,np))
!
! ****** Check if a mask was requested.
!
      if (.not.use_kappa_mask) then
        kappa_mask(:,:,:)=1.0_r_typ
        return
      end if
!
! ****** Interpolate the profile from the specified file.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from LOAD_KAPPA_MASK:'
        write (9,*) '### Reading the (r,t,p) mask'// &
                    ' from file: ', &
                    trim(kappa_mask_file)
        call read_rtp_interp_hhh_internal (kappa_mask_file, &
                                           kappa_mask_g,ierr)
      end if
      call check_error_on_p0 (ierr)
      call global_to_local (kappa_mask_g,kappa_mask)
!
end subroutine
!#######################################################################
subroutine read_rtp_interp_hhh_internal (fname,f_g,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 3D field in from HDF file FNAME
! ****** and interpolate it into global array F_G.
!
! ****** WARNING: only the internal points of F_G are interpolated.
! ****** The boundary points are set to 0.
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use rdhdf_3d_interface
      use ucase_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(nr_g,nt_g,np_g) :: f_g
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: nx,ny,nz
      real(r_typ), dimension(:), pointer, contiguous :: x,y,z
      real(r_typ), dimension(:,:,:), pointer, contiguous :: f
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** When the file name is the special string '<ZERO>',
! ****** the array F_G is set to 0.
!
      if (ucase(fname).eq.'<ZERO>') then
        f_g=0.
        return
      end if
!
! ****** Read the array and its scales.  This call allocates the
! ****** arrays X, Y, Z, and F.
!
      call rdhdf_3d (fname,scale,nx,ny,nz,f,x,y,z,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_RTP_INTERP_HHH_INTERNAL:'
        write (9,*) '### Could not read the specified field.'
        write (9,*) 'IERR (from RDHDF_3D) = ',ierr
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Check that the array has scales.
!
      if (.not.scale) then
        write (9,*)
        write (9,*) '### ERROR in READ_RTP_INTERP_HHH_INTERNAL:'
        write (9,*) '### The file does not have scales.'
        write (9,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
! ****** Interpolate the field on the RH_G, TH_G and PH_G mesh into
! ****** array F_G, at the internal points.
!
      f_g=0.
!
      call interp_3d (nx,ny,nz,x,y,z,f,nrm2_g,ntm2_g,npm2_g, &
                      rh_g(2:nrm1_g), &
                      th_g(2:ntm1_g), &
                      ph_g(2:npm1_g), &
                      f_g(2:nrm1_g,2:ntm1_g,2:npm1_g), &
                      .false.,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_RTP_INTERP_HHH_INTERNAL:'
        write (9,*) '### The scales in the file are not valid:'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Deallocate temporary arrays.
!
      deallocate (x)
      deallocate (y)
      deallocate (z)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine initialize_heating
!
!-----------------------------------------------------------------------
!
! ****** Initialize the parameters that set the coronal heating
! ****** source.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use io_units
      use fields
      use mpidefs
      use lcase_interface
      use heating_parameters
      use radiative_loss_parameters
      use field_table
      use write_field_tp_interface
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,n,hsi
      logical :: validheatsource
      real(r_typ), dimension(nt,np) :: heatflux
!
!-----------------------------------------------------------------------
!
!$acc enter data copyin(heatsource)
!
! ****** Check that the specified heat source types are valid.
!
      do n=1,max_heat_sources
!$acc enter data copyin(heatsource(n)%center_gaussian, &
!$acc                   heatsource(n)%r_profile, &
!$acc                   heatsource(n)%t_profile, &
!$acc                   heatsource(n)%b_profile, &
!$acc                   heatsource(n)%time_profile)
!
        if (.not.heatsource(n)%active) cycle
!
! ****** Set the integer heat source type.
!
        hs_type(n)=0
        do i=1,n_heat_source_types
          if (lcase(heatsource(n)%type).eq.trim(hs_name(i))) then
            hs_type(n)=i
            exit
          end if
        enddo
!
        if (hs_type(n).eq.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in INITIALIZE_HEATING:'
            write (*,*) '### Invalid heat source type specified:'
            write (*,*) 'Specified heat source type: ', &
                        trim(heatsource(n)%type)
            write (*,*) 'Heat source index = ',n
            write (*,*)
            write (*,*) '### The heating profile type must be one'// &
                        ' of the following:'
            do i=1,n_heat_source_types
              write (*,*) ''''//trim(hs_name(i))//''''
            end do
          end if
          call endrun (.true.)
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from INITIALIZE_HEATING:'
            write (9,*) '### Activated a heat source:'
            write (9,*) 'Heat source index: ',n
            if (heatsource(n)%name.ne.' ') then
              write (9,*) 'Heat source name: ', &
                          trim(heatsource(n)%name)
            end if
            write (9,*) 'Heat source type: ', &
                        trim(heatsource(n)%type)
          end if
        end if
!
      enddo
!$acc enter data copyin(hs_type)
!
! ****** If requested, load the heat array specified by the
! ****** file whose name is in variable HEAT_FILE.
!
      if (heat_file.ne.' ') then
        call load_heat_from_file (heat_file)
        add_heat_from_file=.true.
      else
        add_heat_from_file=.false.
      end if
!
! ****** If requested, load the heat mask specified by the
! ****** file whose name is in variable HEAT_MASK_FILE.
!
      if (heat_mask_file.ne.' ') then
        call load_heat_mask_from_file (heat_mask_file)
        have_heat_mask=.true.
      else
        have_heat_mask=.false.
      end if
!
! ****** Calculate the initial heat flux.
!
!$acc update device(b%r,b%t,b%p,fj%r,fj%t,fj%p,eta,etacel)
      if (advance_zw.and.wtd_add_zw_heating) then
!$acc update device(zp,zm,rho)
      end if
      call heating
!$acc update self(heat)
!
      hsi=0
      do i=1,max_heat_sources
        if (heatsource(n)%active) hsi=1
      enddo
      if (hsi.eq.1.or.add_heat_from_file.or. &
          (advance_zw.and.wtd_add_zw_heating).or.add_ohmic_heating.or. &
          legacy_output_filenames) then
!
        heatflux(:,:)=0.
!
        call calculate_heat_flux (heat,heatflux)
!
! ****** Convert the heat flux into physical units.
!
        heatflux(:,:)=fn_q0*heatflux(:,:)
!
! ****** Write the heat flux to file.
!
        call write_field_tp ('heatflux.h5',IFLD_HEAT,heatflux,0)
      end if
!
! ****** Setup the chromospheric heating function.
!
      if (use_chromo_heat) then
!
        if (.not.rad_law_initialized) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in INITIALIZE_HEATING:'
            write (*,*) '### Chromospheric heating is specified'// &
                        ' but radiative losses are not initialized!'
          end if
          call endrun (.true.)
        end if
!
        allocate (heat_chromo(nr,nt,np))
!
        call setup_chromo_heat (heat_chromo)
!$acc enter data copyin(heat_chromo)
!
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from INITIALIZE_HEATING:'
          write (IO_OUT,*) '### Activated chromospheric heating:'
          write (IO_OUT,*) '### chromo_heat_t_zqc_0: ', &
                            chromo_heat_t_zqc_0
          write (IO_OUT,*) '### chromo_heat_t_zqc_1: ', &
                            chromo_heat_t_zqc_1
          FLUSH (IO_OUT)
        end if
!
      end if
!
end subroutine
!#######################################################################
subroutine setup_chromo_heat (h)
!
!-----------------------------------------------------------------------
!
! ****** Initialize the chromospheric heating function, which is based
! ****** off of the radiative loss function at r0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use radiative_loss_parameters
      use heating_parameters
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: h
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k,n
      real(r_typ) :: rho0rad, a0, lam0
      real(r_typ), dimension(1) :: tbc0_array,qrad_array
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Get the prefactors
!
      n=1
      tbc0_array(1)=tbc0
      call get_qrad(qrad_array,tbc0_array,n)
      rho0rad=rho0*he_rho
      a0=rho0rad**2*qrad_array(1)/fn_qrad
      lam0=tbc0/fn_t/g0
!
! ****** Get the heating term
!
      do k=1, np
        do j=1, nt
          do i=1, nr
            h(i,j,k)=a0*exp(-(rh(i)-one)/lam0)
          enddo
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine initialize_radiative_loss
!
!-----------------------------------------------------------------------
!
! ****** Initialize the radiative loss function parameters.
!
!-----------------------------------------------------------------------
!
      use number_types
      use radiative_loss_parameters
      use lcase_interface
      use mpidefs, ONLY : iamp0
      use vars
      use io_units
      use heating_parameters, ONLY: use_chromo_heat, &
           chromo_heat_t_zqc_0, chromo_heat_t_zqc_1
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,n
      real(r_typ) :: q1,qp1
      real(r_typ), dimension(1) :: t_zqc_1_array,q_array
!
!-----------------------------------------------------------------------
!
! ****** Check that the radiative loss fucntion requested is valid
! ****** and set the required index value.
!
      rad_law_index=0
      do i=1,n_rad_law
        if (trim(lcase(rad_law)).eq.trim(lcase(rad_law_name(i)))) then
          rad_law_index=i
          exit
        end if
      enddo
!
      if (rad_law_index.eq.0) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in INITIALIZE_RADIATIVE_LOSS:'
          write (*,*) '### The requested radiative loss function'// &
                      ' is not valid: ',trim(rad_law)
          write (*,*)
          write (*,*) '### The radiative loss function must be one'// &
                      ' of the following:'
          do i=1,n_rad_law
            write (*,*) ''''//trim(rad_law_name(i))//''''
          enddo
        end if
        call endrun (.true.)
      end if
!
! ****** Store the temperatures in the RADIATIVE_LOSS_LAW module.
!
      t_zqc_0=tchromo
      t_zqc_1=1.5_r_typ*tchromo
      t_zqc_1_array(1)=t_zqc_1
!
! ****** Override t_zqc_0 and t_zqc_1 if using chromo_heating
!
      if (use_chromo_heat) then
        t_zqc_0=chromo_heat_t_zqc_0
        t_zqc_1=chromo_heat_t_zqc_1
      end if
!
! ****** Get the values of Q and Q' at t_zqc_1.
! ****** (No boost or near-0 smoothing is done for these).
!
      n=1
!$acc enter data copyin(t_zqc_1_array)
!$acc enter data create(q_array)
      call get_qrad (q_array,t_zqc_1_array,n)
!$acc update self(q_array)
      q1=q_array(1)
!
      call get_dqrad (q_array,t_zqc_1_array,n)
!$acc update self(q_array)
      qp1=q_array(1)
!$acc exit data delete(q_array,t_zqc_1_array)
!
! ****** Set the coefficients.
!
      a_zqc=two*q1-qp1*(t_zqc_1-t_zqc_0)
      b_zqc=q1-qp1*(t_zqc_1-t_zqc_0)
      if (iamp0) then
        write (IO_OUT,*)
        write (IO_OUT,*) '### COMMENT from INITIALIZE_RADIATIVE_LOSS:'
        write (IO_OUT,*) '### Activated radiative loss function.'
        write (IO_OUT,*) 'Radiative loss function index: ',rad_law_index
        write (IO_OUT,*) 'Radiative loss function name: ',trim(rad_law)
        if (.not.legacy_q_chromo_reduction) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### Region over which Q is being modified:'
          write (IO_OUT,*) 'Base temperature [K]  = ',t_zqc_0
          write (IO_OUT,*) 'Upper temperature [K] = ',t_zqc_1
        end if
        FLUSH (IO_OUT)
      end if
!
! ****** Set the flag to indicate that the radiative loss law has
! ****** been initialized.
!
      rad_law_initialized=.true.
!
end subroutine
!#######################################################################
subroutine load_heat_from_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Read the heat array from file FNAME and interpolate
! ****** it to the code mesh.
!
!-----------------------------------------------------------------------
!
! ****** This heating is added to the coronal heating source.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use mpidefs
      use rdhdf_3d_interface
      use field_table
      use distribute_array_interface
      use seam_interface
      use heating_parameters
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      logical :: scale
      integer :: nr_f,nt_f,np_f
      real(r_typ), dimension(:), pointer, contiguous :: r_f,t_f,p_f
      real(r_typ), dimension(:,:,:), pointer, contiguous :: f
      real(r_typ), dimension(:,:,:), pointer, contiguous :: heat_g
!
!-----------------------------------------------------------------------
!
! ****** Read the heat array from HDF file FNAME on IPROC0.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from LOAD_HEAT_FROM_FILE:'
        write (9,*) '### Reading the heat from file: ', &
                    trim(fname)
!
        call rdhdf_3d (fname,scale,nr_f,nt_f,np_f,f, &
                       r_f,t_f,p_f,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_HEAT_FROM_FILE:'
          write (*,*) '### Could not read the heat array:'
          write (*,*) 'IERR (from RDHDF_3D) = ',ierr
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array has scales.
!
      if (iamp0) then
        ierr=0
        if (.not.scale) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_HEAT_FROM_FILE:'
          write (*,*) '### The heat file does not have scales:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the global array on IPROC0.
!
      if (iamp0) then
        allocate (heat_g(nr_g,nt_g,np_g))
      else
        allocate (heat_g(1,1,1))
      end if
!
! ****** Interpolate the array at the internal points on IPROC0.
!
      if (iamp0) then
        heat_g=0.
        call interp_3d (nr_f,nt_f,np_f,r_f,t_f,p_f,f, &
                        nrm2_g,ntm2_g,npm2_g, &
                        rh_g(2:nrm1_g), &
                        th_g(2:ntm1_g), &
                        ph_g(2:npm1_g), &
                        heat_g(2:nrm1_g,2:ntm1_g,2:npm1_g), &
                        .true.,ierr)
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_HEAT_FROM_FILE:'
          write (*,*) '### An error occurred while interpolating'// &
                      ' the heat array to the code mesh:'
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Set the boundary points at r=R0 and r=R1.
! ****** This uses zero-derivative BCs.
!
      if (iamp0) then
        heat_g(   1,:,:)=heat_g(     2,:,:)
        heat_g(nr_g,:,:)=heat_g(nrm1_g,:,:)
      end if
!
! ****** Set the phi boundary points periodically.
!
      if (iamp0) then
        heat_g(:,:,   1)=heat_g(:,:,npm1_g)
        heat_g(:,:,np_g)=heat_g(:,:,     2)
      end if
!
! ****** Allocate storage for the local array.
!
      allocate (heat_from_file(nr,nt,np))
!
! ****** Distribute the global array from IPROC0 to the local arrays.
!
      call distribute_array (fldtab(IFLD_HEAT)%n1, &
                             fldtab(IFLD_HEAT)%n2, &
                             fldtab(IFLD_HEAT)%n3, &
                             heat_g,heat_from_file)
!$acc enter data copyin(heat_from_file)
!
! ****** Set boundary conditions at the poles.
!
      call set_pole_bc_scalar_hhh (heat_from_file)
!
! ****** Seam the array.
!
      call seam_scalar (heat_from_file,nr,nt,np)
!
! ****** Deallocate temporary arrays.
!
      if (iamp0) then
        deallocate (r_f)
        deallocate (t_f)
        deallocate (p_f)
        deallocate (f)
      end if
!
      deallocate (heat_g)
!
end subroutine
!#######################################################################
subroutine load_heat_mask_from_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Read the heat mask from file FNAME and interpolate
! ****** it to the code mesh.
!
!-----------------------------------------------------------------------
!
! ****** This heat mask is used to modify the coronal heating source.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use mpidefs
      use rdhdf_3d_interface
      use field_table
      use distribute_array_interface
      use seam_interface
      use heating_parameters
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      logical :: scale
      integer :: nr_f,nt_f,np_f
      real(r_typ), dimension(:), pointer, contiguous :: r_f,t_f,p_f
      real(r_typ), dimension(:,:,:), pointer, contiguous :: f
      real(r_typ), dimension(:,:,:), pointer, contiguous :: heat_mask_g
!
!-----------------------------------------------------------------------
!
! ****** Read the heat mask from HDF file FNAME on IPROC0.
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from LOAD_HEAT_MASK_FROM_FILE:'
        write (9,*) '### Reading the heat mask from file: ', &
                    trim(fname)
!
        call rdhdf_3d (fname,scale,nr_f,nt_f,np_f,f, &
                       r_f,t_f,p_f,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_HEAT_MASK_FROM_FILE:'
          write (*,*) '### Could not read the heat mask:'
          write (*,*) 'IERR (from RDHDF_3D) = ',ierr
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Check that the array has scales.
!
      if (iamp0) then
        ierr=0
        if (.not.scale) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_HEAT_MASK_FROM_FILE:'
          write (*,*) '### The heat mask file does not have scales:'
          write (*,*) 'File name: ',trim(fname)
          ierr=1
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the global array on IPROC0.
!
      if (iamp0) then
        allocate (heat_mask_g(nr_g,nt_g,np_g))
      else
        allocate (heat_mask_g(1,1,1))
      end if
!
! ****** Interpolate the array at the internal points on IPROC0.
!
      if (iamp0) then
        heat_mask_g=0.
        call interp_3d (nr_f,nt_f,np_f,r_f,t_f,p_f,f, &
                        nrm2_g,ntm2_g,npm2_g, &
                        rh_g(2:nrm1_g), &
                        th_g(2:ntm1_g), &
                        ph_g(2:npm1_g), &
                        heat_mask_g(2:nrm1_g,2:ntm1_g,2:npm1_g), &
                        .true.,ierr)
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in LOAD_HEAT_MASK_FROM_FILE:'
          write (*,*) '### An error occurred while interpolating'// &
                      ' the heat mask to the code mesh:'
          write (*,*) 'File name: ',trim(fname)
        end if
      end if
      call check_error_on_p0 (ierr)
!
! ****** Set the boundary points at r=R0 and r=R1.
! ****** This uses zero-derivative BCs.
!
      if (iamp0) then
        heat_mask_g(   1,:,:)=heat_mask_g(     2,:,:)
        heat_mask_g(nr_g,:,:)=heat_mask_g(nrm1_g,:,:)
      end if
!
! ****** Set the phi boundary points periodically.
!
      if (iamp0) then
        heat_mask_g(:,:,   1)=heat_mask_g(:,:,npm1_g)
        heat_mask_g(:,:,np_g)=heat_mask_g(:,:,     2)
      end if
!
! ****** Allocate storage for the local array.
!
      allocate (heat_mask(nr,nt,np))
!
! ****** Distribute the global array from IPROC0 to the local arrays.
!
      call distribute_array (fldtab(IFLD_HEAT)%n1, &
                             fldtab(IFLD_HEAT)%n2, &
                             fldtab(IFLD_HEAT)%n3, &
                             heat_mask_g,heat_mask)
!$acc enter data copyin(heat_mask)
!
! ****** Set boundary conditions at the poles.
!
      call set_pole_bc_scalar_hhh (heat_mask)
!
! ****** Seam the array.
!
      call seam_scalar (heat_mask,nr,nt,np)
!
! ****** Deallocate temporary arrays.
!
      if (iamp0) then
        deallocate (r_f)
        deallocate (t_f)
        deallocate (p_f)
        deallocate (f)
      end if
!
      deallocate (heat_mask_g)
!
end subroutine
!#######################################################################
subroutine calculate_heat_flux (heat,heatflux)
!
!-----------------------------------------------------------------------
!
! ****** Calculate the heat flux at r=R0 in array HEATFLUX by
! ****** integrating the volumetric heating in array HEAT over r.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: heat
      real(r_typ), dimension(nt,np) :: heatflux
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            heatflux(j,k)=heatflux(j,k)+ &
                          fl_fach(i)*rh(i)**2*drh(i)*heat(i,j,k)
          enddo
        enddo
      enddo
!
! ****** Sum over radius over all processors.
!
      call global_sum_v_r (nt*np,heatflux)
!
end subroutine
!#######################################################################
subroutine heating
!
!-----------------------------------------------------------------------
!
! ****** Set the coronal heating source.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use fields
      use mpidefs
      use heating_parameters
      use wtd
      use profile_value_interface
      use s2c_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: small_value=tiny(one)
      real(r_typ), parameter :: csmall=1.0e-16_r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ierr
      integer :: i,j,k,n
      real(r_typ) :: brv,btv,bpv,bmod,btrans,brhat
      real(r_typ) :: rprof,tprof,bprof,bexpprof,timeprof
      real(r_typ) :: maskprof,nlprof
      real(r_typ) :: h,h0,h1,xc,yc,zc,x0,y0,z0,dl2
      real(r_typ) :: jrv,jtv,jpv,etav
      real(r_typ) :: wtd_lambda
      real(r_typ) :: heat_emp, heat_zw,horho
!
      real(r_typ), dimension(2:ntm1,2:npm1) :: nl_factor
      real(r_typ), dimension(2:ntm1,2:npm1) :: b_photo
!
!-----------------------------------------------------------------------
!$acc enter data create(nl_factor,b_photo)
!
! ****** Zero out the heat array.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        heat(i,j,k)=0.
      enddo
!
! ****** Get the mask that picks out the neutral line at the base
! ****** of the corona.  This is based on the inclination of the
! ****** magnetic field to the radial vector.
! ****** Save the photospheric magnetic field magntitude in
! ****** B_PHOTO.
!
      if (rb0) then
        do concurrent (k=2:npm1, j=2:ntm1)
          brv=AVGRTP(b%r,2,j,k)
          btv=AVGP  (b%t,1,j,k)
          bpv=AVGT  (b%p,1,j,k)
          bmod=sqrt(brv**2+btv**2+bpv**2)
          brhat=brv/max(bmod,small_value)
          nl_factor(j,k)=(one-brhat**2)**2
          b_photo(j,k)=bmod
        enddo
      end if
!
! ****** Broadcast NL_FACTOR to all processors sharing
! ****** this base location.
!
!$acc host_data use_device(nl_factor,b_photo)
      call MPI_Bcast (nl_factor,(nt-2)*(np-2),ntype_real, &
                      iproc_rb0,comm_r,ierr)
!
! ****** Broadcast B_PHOTO to all processors sharing
! ****** this base location.
!
      call MPI_Bcast (b_photo,(nt-2)*(np-2),ntype_real, &
                      iproc_rb0,comm_r,ierr)
!$acc end host_data
!
! ****** Add the contributions of all the heat sources at
! ****** each mesh point.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
!
! ****** Get the local magnetic field components.
!
        brv=AVGTP(b%r,i,j,k)
        btv=AVGRP(b%t,i,j,k)
        bpv=AVGRT(b%p,i,j,k)
        bmod=sqrt(brv**2+btv**2+bpv**2)
        btrans=sqrt(btv**2+bpv**2)
!
! ****** Loop over all sources.
!
        do n=1,max_heat_sources
!
! ****** Skip heat sources that have not been activated.
!
          if (.not.heatsource(n)%active) cycle
!
          h=0.0
!
! ****** Set the radial profile.
!
          if (heatsource(n)%r_profile%active) then
            rprof=profile_value(heatsource(n)%r_profile,rh_true(i))
          else
            rprof=one
          end if
!
! ****** Set the theta profile.
!
          if (heatsource(n)%t_profile%active) then
            tprof=profile_value(heatsource(n)%t_profile,th(j))
          else
            tprof=one
          end if
!
! ****** Set the magnetic field profile.
!
          if (heatsource(n)%b_profile%active) then
            bprof=profile_value(heatsource(n)%b_profile,bmod)
          else
            bprof=one
          end if
!
! ****** Set the time profile.
!
          if (heatsource(n)%time_profile%active) then
            timeprof=profile_value(heatsource(n)%time_profile,time)
          else
            timeprof=one
          end if
!
! ****** Set the B-exponential attenuation (a la Karel Schrijver).
!
          if (heatsource(n)%b_attenuation) then
            bexpprof=exp(-(bmod/heatsource(n)%b_cutoff)**2)
          else
            bexpprof=one
          end if
!
! ****** Apply the heat mask.
!
          if (heatsource(n)%use_mask.and.have_heat_mask) then
            maskprof=heat_mask(i,j,k)
          else
            maskprof=one
          end if
!
! ****** Evaluate the heating source.
!
          if (hs_type(n).eq.HS_DEF_B_DEP) then
!
! ****** Heating proportional to a power of B.
!
            h= timeprof*rprof*tprof*bprof*bexpprof*maskprof &
               *heatsource(n)%h0*bmod**heatsource(n)%power
!
          else if (hs_type(n).eq.HS_DEF_BR_DEP) then
!
! ****** Jon Linker heating at neutral lines.
!
            h= timeprof*rprof*tprof*bprof*bexpprof*maskprof &
               *heatsource(n)%h0*bmod*(btrans/bmod)**2 &
               /(abs(brv)+heatsource(n)%brmax) &
               *exp(-(rh_true(i)-one)/heatsource(n)%lambda)
!
          else if (hs_type(n).eq.HS_DEF_EXP) then
!
! ****** Exponential fall-off with radius.
!
            h= timeprof*rprof*tprof*bprof*bexpprof*maskprof &
               *heatsource(n)%h0 &
               *exp(-(rh_true(i)-one)/heatsource(n)%lambda)
!
          else if (hs_type(n).eq.HS_DEF_2EXP) then
!
! ****** Two-exponential heating with short-scale enhancement
! ****** at neutral lines.
!
            h0=heatsource(n)%q0*exp(-(rh_true(i)-one) &
                                   /heatsource(n)%lambda0) &
                                   /heatsource(n)%lambda0
            h1=heatsource(n)%q1*exp(-(rh_true(i)-one) &
                                   /heatsource(n)%lambda1) &
                                   /heatsource(n)%lambda1
            h=timeprof*rprof*tprof*maskprof*(nl_factor(j,k)*h0+h1)
!
          else if (hs_type(n).eq.HS_DEF_EXP_BPHOTO) then
!
! ****** Exponential heating with b-dependent strength, with an
! ****** optional neutral line mask.
!
            if (heatsource(n)%b_profile%active) then
              bprof=profile_value(heatsource(n)%b_profile, &
                                  b_photo(j,k))
            else
              bprof=one
            end if
!
            if (heatsource(n)%b_attenuation) then
              bexpprof=exp(-( b_photo(j,k) &
                             /heatsource(n)%b_cutoff)**2)
            else
              bexpprof=one
            end if
!
            if (heatsource(n)%nl_mask) then
              nlprof=nl_factor(j,k)
            else
              nlprof=one
            end if
!
            h= timeprof*heatsource(n)%h0 &
               *nlprof &
               *maskprof &
               *rprof*tprof*bprof*bexpprof &
               *b_photo(j,k)**heatsource(n)%power &
               *exp(-(rh_true(i)-one) &
                     /heatsource(n)%lambda)
          else if (hs_type(n).eq.HS_DEF_GAUSSIAN) then
!
! ****** Gaussian and a given height.    .
!
            call s2c (heatsource(n)%center_gaussian(1), &
                      heatsource(n)%center_gaussian(2), &
                      heatsource(n)%center_gaussian(3),xc,yc,zc)
            call s2c (rh_true(i),th(j),ph(k),x0,y0,z0)
            dl2=(x0-xc)**2+(y0-yc)**2+(z0-zc)**2
            h= timeprof*maskprof*rprof*tprof*bprof*bexpprof* &
                 heatsource(n)%h0 &
                /(sqrtpi*heatsource(n)%lambda) &
              *exp(-dl2/(heatsource(n)%lambda)**2)
!
          end if
!
          heat(i,j,k)=heat(i,j,k)+h
!
        enddo
!
      enddo
!
! ****** Add a heating source from a file, if requested.
!
      if (add_heat_from_file) then
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          heat(i,j,k)=heat(i,j,k)+heat_from_file(i,j,k)
        enddo
      end if
!
! ****** Add in the heating due to z+,z- dissipation
!
      if (advance_zw.and.wtd_add_zw_heating) then
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          heat_emp=heat(i,j,k)
          brv=AVGTP(b%r,i,j,k)
          btv=AVGRP(b%t,i,j,k)
          bpv=AVGRT(b%p,i,j,k)
          bmod=sqrt(brv**2+btv**2+bpv**2)
          wtd_lambda=wtd_lambda0*sqrt(wtd_b0/(bmod+csmall))
          heat_zw=0.25_r_typ* &
                      rho(i,j,k)*wtd_rho_factor(rho(i,j,k))* &
                      (abs(zm(i,j,k))*zp(i,j,k)**2 + &
                       abs(zp(i,j,k))*zm(i,j,k)**2)/wtd_lambda
!
          heat(i,j,k)=(one-zw_heat_factor)*heat_emp + &
                           zw_heat_factor*heat_zw
!
! ****** Add back in the exponential heatsource
!
          do n=1,max_heat_sources
            if (.not.heatsource(n)%active) cycle
!
            if (heatsource(n)%r_profile%active) then
              rprof=profile_value(heatsource(n)%r_profile,rh_true(i))
            else
              rprof=one
            end if
!
            if (heatsource(n)%t_profile%active) then
              tprof=profile_value(heatsource(n)%t_profile,th(j))
            else
              tprof=one
            end if
!
            if (heatsource(n)%b_profile%active) then
              bprof=profile_value(heatsource(n)%b_profile,bmod)
            else
              bprof=one
            end if
!
            if (heatsource(n)%time_profile%active) then
              timeprof=profile_value(heatsource(n)%time_profile,time)
            else
              timeprof=one
            end if
!
            if (heatsource(n)%b_attenuation) then
              bexpprof=exp(-(bmod/heatsource(n)%b_cutoff)**2)
            else
              bexpprof=one
            end if
!
            if (heatsource(n)%use_mask.and.have_heat_mask) then
              maskprof=heat_mask(i,j,k)
            else
              maskprof=one
            end if
!
            h=0.0
            if (hs_type(n).eq.HS_ZW_EXPONENTIAL) then
              h=timeprof*rprof*tprof*bprof*bexpprof*maskprof &
                *heatsource(n)%h0 &
                *exp(-(rh_true(i)-one)/heatsource(n)%lambda)
              heat(i,j,k)=heat(i,j,k)+h*zw_heat_factor
            end if
          enddo
!
! ****** Apply manual limiter to stop heat explosions at large radii
!
          if (wtd_use_zw_horho_limit) then
            if (rh_true(i) .ge. zw_horho_limit_rlim) then
              horho=heat(i,j,k)/rho(i,j,k)
              if (horho.gt.zw_horho_limit_value) then
                heat(i,j,k)=zw_horho_limit_value*rho(i,j,k)
              end if
            end if
          end if
!
        enddo
      end if
!
! ****** Flat-top the heating if requested.
!
      if (heating_flat_topped) then
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          heat(i,j,k)=min(heat(i,j,k),heat_max)
        enddo
      end if
!
! ****** Add in the ohmic heating term if requested.
!
      if (add_ohmic_heating) then
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          jrv=AVGR(fj%r,i,j,k)
          jtv=AVGT(fj%t,i,j,k)
          jpv=AVGP(fj%p,i,j,k)
          etav=AVGRTP(eta,i,j,k)+AVGRTP(etacel,i,j,k)
          heat(i,j,k)=heat(i,j,k) + &
             ohmic_heating_factor*etav*(jrv**2+jtv**2+jpv**2)
        enddo
      end if
!
!$acc exit data delete(nl_factor,b_photo)
end subroutine
!#######################################################################
function get_2t_coupling_constant()
!
!-----------------------------------------------------------------------
!
! *** Set the coupling constant "D_mas" for 2T frictional heating.
!
!     D_mas collects the constants and unit normalizations for heat
!     exchange between electrons and protons+alphas in the 2T model.
!
!     The heating is the CUMULATIVE heating: Qtot = Qep + Qea, where
!       - Qep is btw electrons (e) and protons (p).
!       - Qea is btw electrons (e) and alpha particles (a).
!
!     Start with heating term for electrons and an ion species, Q_ei.
!     From Braginski 1965 book, minus [eq. 2.17] and 1/[eq 2.5e] give:
!
!       Q_ei = D*Z^2/A*n_e*n_i*(T_i-T_e)/(T_e^(3/2)), where
!
!       D = 4*sqrt(me*2*pi)*ln_lambda*e^4/mp/sqrt(k_b).
!
!     Get Q_tot = Q_ep + Q_ea = he_p_p*D*n_e^2*(T_i-T_e)/T_e^(3/2)
!
!     Then convert D*he_p_p to MAS units by:
!       1) conv heating rate: 1/fn_heat
!       2) conv cgs n_e to MAS: n_e=rho*fn_n/he_rho --> (fn_n/he_rho)^2
!       3) conv cgs T to MAS: T=temp*fn_T --> 1/sqrt(fn_T)
!
!     This gives: D_mas = D*he_p_p/he_rho^2*fn_n^2/sqrt(fn_t)/fn_heat
!
!     Then we can define the heating rate for electrons in MAS as:
!       Q_mas = D_mas*rho^2*(temp_p - temp_e)/temp_e^(3/2)
!
!     The heating rate for ions is -Q_mas.
!
!     NOTES:
!      - Braginski uses T as an energy [eV] --> kB is implied.
!      - A is the atomic number, Z is the ion charge.
!      - he_p_p comes from np + na = ne*(1+f)/(1+2f).
!      - See Lynn Wilson III et al. 2018 ApJS for a good source of
!        formulas in SI notation and solar related references.
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
      use vars, ONLY :  he_p_p, he_rho, coulomb_log, fn_t, fn_n, fn_heat
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: get_2t_coupling_constant
!
!-----------------------------------------------------------------------
!
!
      real(r_typ), parameter ::  e=4.8032e-10_r_typ
      real(r_typ), parameter :: me=9.1094e-28_r_typ
      real(r_typ), parameter :: mp=1.6726e-24_r_typ
      real(r_typ), parameter :: kb=1.3807e-16_r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: four=4._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: D
      real(r_typ) :: D_mas
!
!-----------------------------------------------------------------------
!
      D=four*sqrt(me*two*pi)*coulomb_log*e**4/mp/sqrt(kb)
!
      D_mas=D*he_p_p/he_rho**2*fn_n**2/sqrt(fn_t)/fn_heat
!
      get_2t_coupling_constant=D_mas
!
      return
end function
!#######################################################################
subroutine solve_2t_coupling
!
!-----------------------------------------------------------------------
!
! *** Implicit solve for frictional heating between electrons & ions.
!
!     Update MAS Te and Tp based on a non-linear point implicit solve
!     for the coupled system of two equations:
!
!     Starting from the heating rate we must get reaction terms
!     for Te and Tp, using the convention Qe=Q_mas, Qi=-Q_mas.
!
!       Q_mas = D_mas*rho^2*(Ti-Te)/Te^3/2, then mult by (gamma-1)/n:
!
!       Re =  (gamma-1)*he_rho/he_p_e/rho*Q_mas  (he_p_e == 1 always)
!       Rp = -(gamma-1)*he_rho/he_p_p/rho*Q_mas  (he_p_p == (1+f)/(1+2f)
!
!     Fold all like terms into C = (gamma-1)*he_rho*rho*D_mas, get:
!
!       Re =  C*(Tp - Te)/Te^3/2
!       Rp = -C*(Tp - Te)/Te^3/2/he_p_p
!
!     The point implicit update in Toth et al. 2012 JCP 231, 870 is:
!
!       X_n+1 = X_n + dt*S + beta*dt*dS/dX.(X_n+1 - X_n)
!
!     where X is the solution vector, S is the source term vector, and
!     dS/dX is the Jacobian J.
!
!     This can be written in terms of dX = X_n+1 - X_n as:
!
!       (I - beta*dt*J).dX = dt*S
!
!     So using X1=Te, X2=Tp, S1=Re, S2=Rp, we just need to compute the
!     matrix elements of J analytically and multiply dt*S by the matrix
!     inverse of M=(I - beta*dt*J) to get the change of Te and Tp.
!
!     NOTE: Plugging in the actual terms, one can show det(M) > 1 if
!       Te>0 and Tp>0, so we *shouldnt* have problems with this solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars
      use fields, ONLY : rho,temp_e,temp_p
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: C
      real(r_typ) :: s1, s2, j11, j12, j21, j22
      real(r_typ) :: aa, bb, cc, dd
      real(r_typ) :: te, tp, diffp, t32, t52, betadt, det
      real(r_typ) :: dtp, dte
      real(r_typ), parameter :: beta=0.5_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ), parameter :: two=2.0_r_typ
      real(r_typ), parameter :: three=3.0_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      character(32) :: FNAME_E='E-TEMPERATURE'
      character(32) :: FNAME_P='P-TEMPERATURE'
      character(32) :: RNAME='2TCPL'
!
!-----------------------------------------------------------------------
!
! ****** Loop over temp_e and temp_p, compute terms and update.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
!
! ****** Pre Factors.
!
        betadt=beta*dtime
        C=(gamma-1)*he_rho*rho(i,j,k)*d_couple_2t
        te=temp_e(i,j,k)
        tp=temp_p(i,j,k)
        diffp=tp-te
        t32=sqrt(te)*te
        t52=sqrt(te)*te*te
!
! ****** Source terms * timestep.
!
        s1= dtime*C*diffp/t32
        s2=-dtime*C*diffp/t32/he_p_p
!
! ****** Jacobian terms, Jij=dSi/dXj.
!
        j11=C*(te-three*tp)/(two*t52)
        j12=C/t32
        j21=-j11/he_p_p
        j22=-j12/he_p_p
!
! ****** Matrix terms (I-beta*dtime*J).
!
        aa=one-betadt*j11
        bb=-betadt*j12
        cc=-betadt*j21
        dd=one-betadt*j22
!
! ****** Invert and get the solution.
!
        det=aa*dd-bb*cc
        dte=( s1*dd-s2*bb)/det
        dtp=(-s1*cc+s2*aa)/det
!
! ****** Update.
!
        temp_e(i,j,k)=temp_e(i,j,k)+dte
        temp_p(i,j,k)=temp_p(i,j,k)+dtp
!
      enddo
!
! ****** Set boundary conditions and seam.
!
      call set_bc_temp_e (temp_e,one)
!
      call seam_scalar (temp_e,nr,nt,np)
!
      call set_bc_temp_p (temp_p,one)
!
      call seam_scalar (temp_p,nr,nt,np)
!
! ****** Floor temperatures.
!
      if (iftfloor) then
        call floor_field (temp_e,nr,nt,np,FNAME_E,RNAME,tfloor)
        call floor_field (temp_p,nr,nt,np,FNAME_P,RNAME,tfloor)
      end if
!
! ****** Check for negative temperatures.
!
      if (ifcheck0temp) then
        call check_negative_field (temp_e,nr,nt,np,FNAME_E,RNAME)
        call check_negative_field (temp_p,nr,nt,np,FNAME_P,RNAME)
      end if
!
end subroutine
!#######################################################################
pure function profile_value (prof,x)
!$acc routine(profile_value) seq
!
!-----------------------------------------------------------------------
!
! ****** Evaluate the three-value profile PROF at location X.
!
!-----------------------------------------------------------------------
!
      use number_types
      use profile_def
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(profile), intent(in) :: prof
      real(r_typ), intent(in) :: x
      real(r_typ) :: profile_value
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: four=4._r_typ
      real(r_typ), parameter :: min_normalized_arg_value=-20.
      real(r_typ), parameter :: max_normalized_arg_value=20.
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: arg1,arg2,tanh_val1,tanh_val2,h1,h2
!
!-----------------------------------------------------------------------
!
! ****** If the profile has not been activated, return a default
! ****** value of 1.
!
      if (.not.prof%active) then
        profile_value=one
        return
      end if
!
! ****** Evaluate the arguments, avoiding unnecessary evaluation of
! ****** the tanh function for efficiency.
!
! ****** Note that a profile width of zero is allowed, in which
! ****** case the transition becomes a step function.
!
      if (prof%w(1).ne.0.) then
        arg1=four*(x-prof%x(1))/abs(prof%w(1))
      else
        if (x.ge.prof%x(1)) then
          arg1=max_normalized_arg_value
        else
          arg1=min_normalized_arg_value
        end if
      end if
!
      if (prof%w(2).ne.0.) then
        arg2=four*(x-prof%x(2))/abs(prof%w(2))
      else
        if (x.ge.prof%x(2)) then
          arg2=max_normalized_arg_value
        else
          arg2=min_normalized_arg_value
        end if
      end if
!
      if (arg1.le.min_normalized_arg_value) then
        tanh_val1=-one
      else if (arg1.ge.max_normalized_arg_value) then
        tanh_val1=one
      else
        tanh_val1=tanh(arg1)
      end if
!
      if (arg2.le.min_normalized_arg_value) then
        tanh_val2=-one
      else if (arg2.ge.max_normalized_arg_value) then
        tanh_val2=one
      else
        tanh_val2=tanh(arg2)
      end if
!
! ****** Set the values of the "smoothed step functions".
!
      h1=half*(one+tanh_val1)
      h2=half*(one+tanh_val2)
!
! ****** Evaluate the profile value.
!
      profile_value=prof%f(1)+(prof%f(2)-prof%f(1))*h1 &
                             +(prof%f(3)-prof%f(2))*h2
!
      return
end function
!#######################################################################
subroutine get_normalization_params
!
!-----------------------------------------------------------------------
!
! ****** Calculate the normalization factors that convert
! ****** physical units to normalized code units.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), external :: get_2t_coupling_constant
!
!-----------------------------------------------------------------------
!
! ****** Set the parameters related to the Helium fraction, HE_FRAC.
! ****** HE_FRAC is defined by n_alpha=HE_FRAC*n_p,
! ****** where n_alpha is the Helium number density and
! ****** n_p is the proton number density.
!
! ****** HE_RHO is defined by rho(norm)=HE_RHO*n_e(norm),
! ****** where n_e is the electron number density.
!
      he_rho=(1._r_typ+4._r_typ*he_frac)/(1._r_typ+2._r_typ*he_frac)
!
! ****** HE_P is defined by p(norm)=HE_P*n_e(norm)*T(norm),
! ****** where p is the total pressure.
! ****** HE_P_P and H_P_E are defined as follows
! ****** p(norm)=n_e(norm)*(he_p_e*Te(norm)+HE_P_P*Tp(norm))
!
      he_p=(2._r_typ+3._r_typ*he_frac)/(1._r_typ+2._r_typ*he_frac)
      he_p_p=(1._r_typ+he_frac)/(1._r_typ+2._r_typ*he_frac)
      he_p_e=1._r_typ
      if (advance_tp) then
        he_p_x=he_p_e
      else
        he_p_x=he_p
      end if
!
! ****** HE_NP is defined by n_p(norm)=HE_NP*n_e(norm).
!
      he_np=1._r_typ/(1._r_typ+2._r_typ*he_frac)
!
! ****** Define the normalization variables for length, FNORML,
! ****** time, FNORMT, and mass, FNORMM.
!
      fnorml=rsun
      fnormt=sqrt(g0norm*fnorml/g0phys)
      fnormm=fn0phys*fmp*(fnorml)**3
!
! ****** Define the factors to normalize various physical
! ****** quantities. The physical quantity is expressed in terms
! ****** of the normalized quantity by:
! ****** Q(physical) = FN_Q * Q(normalized).
!
! ****** Number density normalization [/cm**3].
!
      fn_n=fn0phys
!
! ****** Mass density normalization [g/cm**3].
!
      fn_rho=fmp*fn0phys
!
! ****** Pressure normalization [erg/cm**3].
!
      fn_p=fmp*fn0phys*(fnorml/fnormt)**2
!
! ****** Temperature normalization [K].
!
      fn_t=fmp*fnorml**2/(boltz*fnormt**2)
!
! ****** Velocity normalization [cm/s].
!
      fn_v=fnorml/fnormt
!
! ****** Magnetic field normalization [Gauss].
!
      fn_b=sqrt(4._r_typ*pi*fn_rho)*fnorml/fnormt
!
! ****** Radiation loss function Q(T) normalization [erg-cm**3/s].
!
      fn_qrad=fmp*fnorml**2/(fn0phys*fnormt**3)
!
! ****** Heating Rate normalization [erg/cm**3/s].
!
      fn_heat=fn_p/fnormt
!
! ****** Thermal conductivity normalization [erg/cm/s/K].
!
      fn_kappa=boltz*fn0phys*fnorml**2/fnormt
!
! ****** Surface heat flux normalization [ergs/cm**2/s].
!
      fn_q0=fnormm/fnormt**3
!
! ****** Radiation balance boundary condition constants.
! ****** These are for temp_e only and do not seem to be
! ****** currently used.
!
      fn_rd1=.5_r_typ*tcond*fkspitz*fn_t**2 &
             /(he_np*fnorml**2*fn0phys**2)
      fn_rd2=2._r_typ/7._r_typ*(fn_q0/fnorml)/(he_np*fn0phys**2)
!
! ****** Two temperature coupling coefficient.
!
      d_couple_2t=get_2t_coupling_constant()
!
end subroutine
!#######################################################################
subroutine one_plus_div_kappa_grad_t (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = dV * (1 + div kappa grad) P
! ******   (for STS: Q = (gamma-1)/rho * (div kappa grad) P)
! ******
! ****** at the internal points.
!
!-----------------------------------------------------------------------
!
! ****** This routine is for the thermal conduction advance.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use matrix_storage_t_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: ps
      real(r_typ), dimension(2:nrm1,2:ntm1,2:npm1) :: q
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
! ****** Set the internal points of Q.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        q(i,j,k) = &
             a_dia( 1,i,j,k)*ps(i  ,j-1,k-1) &
           + a_dia( 2,i,j,k)*ps(i-1,j  ,k-1) &
           + a_dia( 3,i,j,k)*ps(i  ,j  ,k-1) &
           + a_dia( 4,i,j,k)*ps(i+1,j  ,k-1) &
           + a_dia( 5,i,j,k)*ps(i  ,j+1,k-1) &
           + a_dia( 6,i,j,k)*ps(i-1,j-1,k  ) &
           + a_dia( 7,i,j,k)*ps(i  ,j-1,k  ) &
           + a_dia( 8,i,j,k)*ps(i+1,j-1,k  ) &
           + a_dia( 9,i,j,k)*ps(i-1,j  ,k  ) &
           + a_dia(10,i,j,k)*ps(i  ,j  ,k  ) &
           + a_dia(11,i,j,k)*ps(i+1,j  ,k  ) &
           + a_dia(12,i,j,k)*ps(i-1,j+1,k  ) &
           + a_dia(13,i,j,k)*ps(i  ,j+1,k  ) &
           + a_dia(14,i,j,k)*ps(i+1,j+1,k  ) &
           + a_dia(15,i,j,k)*ps(i  ,j-1,k+1) &
           + a_dia(16,i,j,k)*ps(i-1,j  ,k+1) &
           + a_dia(17,i,j,k)*ps(i  ,j  ,k+1) &
           + a_dia(18,i,j,k)*ps(i+1,j  ,k+1) &
           + a_dia(19,i,j,k)*ps(i  ,j+1,k+1)
      enddo
!
end subroutine
!#######################################################################
subroutine write_matrix_t
!
!-----------------------------------------------------------------------
!
! ****** Write the matrix for the 3D thermal conduction solve to a file.
! ****** This can be useful for debugging.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mpidefs
      use cgcom
      use vars
      use matrix_storage_t_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(:), allocatable :: xvec,yvec,dummy
      real(r_typ), dimension(:,:), allocatable :: amat
!
!-----------------------------------------------------------------------
!
      integer :: ierr,i,j,k,ll
!
!-----------------------------------------------------------------------
!
      if (nproc.ne.1) then
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from WRITE_MATRIX_T:'
          write (*,*) '### Could not write the matrix.'
          write (*,*) '### For this diagnostic you must run'// &
                      ' on only 1 processor.'
        end if
        return
      end if
!
      N_CG=N_cgvec
      call alloc_cg_ax_tmp
!
      allocate (xvec(N_cgvec))
      allocate (yvec(N_cgvec))
      xvec=0.
      yvec=0.
      allocate (dummy(1))
!
      allocate (amat(N_cgvec,N_cgvec))
      amat=0.
!
      ll=0
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            ll=ll+1
            xvec(ll)=one
            call ax_t (xvec,yvec)
            amat(:,ll)=yvec(:)
            xvec(ll)=0.
          enddo
        enddo
      enddo
!
      call wrhdf_2d ('amat_t.h5',.false.,N_cgvec,N_cgvec, &
                     amat,dummy,dummy,hdf32,ierr)
!
      if (ierr.ne.0) then
        write (*,*)
        write (*,*) '### WARNING from WRITE_MATRIX_T:'
        write (*,*) '### Could not write the matrix.'
        write (*,*) 'IERR (from WRHDF_2D) = ',ierr
      else
        write (*,*)
        write (*,*) '### COMMENT from WRITE_MATRIX_T:'
        write (*,*) 'Wrote the matrix for the thermal conduction'// &
                    ' solve to file: amat_t.h5'
      end if
!
      deallocate (xvec)
      deallocate (yvec)
      deallocate (amat)
      deallocate (dummy)
      call dealloc_cg_ax_tmp
!
end subroutine
!#######################################################################
pure function boost (tempk)
!$acc routine(boost) seq
!
!-----------------------------------------------------------------------
!
! ****** Boost function for thermal conductivity.
! ****** This MUST be the inverse of boost_i().
!
! ****** TEMPK is the temperature in degrees Kelvin.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars, ONLY : t_cutoff1
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: tempk
      real(r_typ) :: boost
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: quarter=0.25_r_typ
!
!-----------------------------------------------------------------------
!
      boost=(one+(tempk/t_cutoff1)**(-10))**(quarter)
!
      return
end function
!#######################################################################
subroutine apply_boost_i (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Boost function for radiation loss.
! ****** This MUST be the inverse of boost().
!
! ****** TEMPK is the temperature in degrees Kelvin.
!
!-----------------------------------------------------------------------
!
      use number_types
      use vars, ONLY : t_cutoff1
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: quarter=0.25_r_typ
!
!-----------------------------------------------------------------------
!
      do concurrent (i=1:n)
        qrad(i)=qrad(i)*(one+(tempk(i)/t_cutoff1)**(-10))**(-quarter)
      enddo
!
end subroutine
!#######################################################################
subroutine get_qrad (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Select the radiation law, based on variable RAD_LAW.
!
!-----------------------------------------------------------------------
!
      use vars, ONLY : rad_law
      use radiative_loss_parameters
      use mpidefs, ONLY : iamp0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
! ****** Call the appropriate radiative loss law.
!
      select case (rad_law_index)
      case (RAD_LAW_ATHAY)
        call get_qrad_athay(qrad,tempk,n)
      case (RAD_LAW_ROSNER)
        call get_qrad_rosner(qrad,tempk,n)
      case (RAD_LAW_RTV)
        call get_qrad_rtv(qrad,tempk,n)
      case (RAD_LAW_CHIANTI_v71_CORONA)
        call get_qrad_chianti_v71_corona(qrad,tempk,n)
      case (RAD_LAW_CHIANTI_v71_PHOTO)
        call get_qrad_chianti_v71_photo(qrad,tempk,n)
      case (RAD_LAW_CHIANTI_v713_HYBRID)
        call get_qrad_chianti_v713_hybrid(qrad,tempk,n)
      case default
        if(iamp0) then
          write (*,*)
          write (*,*) '### ERROR in QRAD:'
          write (*,*) '### Invalid radiation law selected.'
          write (*,*) 'rad_law_index:',rad_law_index
          write (*,*) 'rad_law:',rad_law
          write (*,*) '[This is an internal error.]'
        end if
        call endrun (.true.)
      end select
!
! ****** Only apply boost and near-0 smoothing if
! ****** qrad initialization is complete (this is needed for setup).
!
      if(rad_law_initialized) then
!
! ****** Apply the reduction of Q at the base of the chromosphere.
!
        call apply_q_chromo_mod (qrad,tempk,n)
!
! ****** Attenuate Q by the boost factor for thermal conductivity.
!
        call apply_boost_i (qrad,tempk,n)
!
      end if
!
end subroutine
!#######################################################################
subroutine apply_q_chromo_mod (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Apply modification to Q at the base of the chromosphere to
! ****** smoothly go to zero.
!
! ****** The value of Q is overwritten by the modified value.
!
!-----------------------------------------------------------------------
!
      use number_types
      use radiative_loss_parameters
      use vars,  ONLY : legacy_q_chromo_reduction
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: small_value=tiny(1._r_typ)
!
!-----------------------------------------------------------------------
!
! ****** Parameter to make Q'(T) continuous at T_ZQC_0.  This adds
! ****** a narrow layer near T_ZQC_0 in which Q is quadratic in T,
! ****** avoiding a discontinuity at T_ZQC_0.
!
      real(r_typ), parameter :: alpha0=.01_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: fac,alpha,g
      integer :: i
!
!-----------------------------------------------------------------------
!
! ****** Reduce the radiative loss to zero smoothly at the base
! ****** of the chromosphere.
!
      if (legacy_q_chromo_reduction) then
!
! ****** Use the legacy scheme (originally developed by Yung Mok)
! ****** if requested.  This option is not recommended; it is
! ****** provided for backward compatibility.
!
        do concurrent (i=1:n)
          if (tempk(i).le.t_zqc_0) then
            qrad(i)=0.
          else
            fac=(tempk(i)/t_zqc_0)**4-one
            fac=one/max(fac,small_value)
            qrad(i)=qrad(i)*exp(-fac)
          end if
        enddo
!
      else
!
! ****** Make Q go to zero at the base of the chromosphere
! ****** smoothly.  Q and Q' match the radiative loss law values
! ****** at T_ZQC_1.
!
        do concurrent (i=1:n)
          if (tempk(i).le.t_zqc_0) then
            qrad(i)=0.
          else if (tempk(i).le.t_zqc_1) then
            alpha=(tempk(i)-t_zqc_0)/(t_zqc_1-t_zqc_0)
            g=one-exp(-alpha/alpha0)
            qrad(i)=(a_zqc-b_zqc*alpha)*alpha*g
          end if
        enddo
!
      end if
!
end subroutine
!#######################################################################
subroutine get_dqrad (dqrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Derivative of radiative loss function in [erg-cm**3/s/K].
! ****** dqrad = (q(temp+) - q(temp-))/(temp+ - temp-)
!
! ****** TEMPK is the temperature in degrees Kelvin.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: dqrad,tempk
!
!-----------------------------------------------------------------------
!
! ****** Fractional increment to use in evaluating the derivative
! ****** numerically.
!
      real(r_typ), parameter :: eps=1e-4_r_typ
!
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(n) :: qradp,qradm,temp_tmp
      integer :: i
      real(r_typ) :: dt
!
!-----------------------------------------------------------------------.
!
!$acc enter data create(qradp,qradm,temp_tmp)
      do concurrent (i=1:n)
        temp_tmp(i)=(one+half*eps)*tempk(i)
      enddo
!
      call get_qrad (qradp,temp_tmp,n)
!
      do concurrent (i=1:n)
        temp_tmp(i)=(one-half*eps)*tempk(i)
      enddo
!
      call get_qrad (qradm,temp_tmp,n)
!
      do concurrent (i=1:n)
        dt=eps*tempk(i)
        dqrad(i)=(qradp(i)-qradm(i))/dt
      enddo
!
!$acc exit data delete(qradp,qradm,temp_tmp)
end subroutine
!#######################################################################
subroutine get_qrad_rosner (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Rosner radiative loss function in [erg-cm**3/s].
!
! ****** TEMPK is the temperature in degrees Kelvin.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: t,qalpha,qchi
      integer :: i
!
!-----------------------------------------------------------------------
!
      do concurrent (i=1:n)
!
        t=tempk(i)
!
        if (tempk(i).lt.2.00e4_r_typ) then
          qalpha=6.15_r_typ
          qchi=1.408e-30_r_typ
          t=t*1.e-3_r_typ
        else if (tempk(i).ge.2.00e4_r_typ &
            .and.tempk(i).lt.3.76e4_r_typ) then
          qalpha=0.
          qchi=1.412e-22_r_typ
        else if (tempk(i).ge.3.76e4_r_typ &
            .and.tempk(i).lt.7.94e4_r_typ) then
          qalpha=2._r_typ
          qchi=9.988e-32_r_typ
        else if (tempk(i).ge.7.94e4_r_typ &
            .and.tempk(i).lt.2.51e5_r_typ) then
          qalpha=0.
          qchi=6.297e-22_r_typ
        else if (tempk(i).ge.2.51e5_r_typ &
            .and.tempk(i).lt.5.91e5_r_typ) then
          qalpha=-2._r_typ
          qchi=3.967e-11_r_typ
        else if (tempk(i).ge.5.91e5_r_typ &
            .and.tempk(i).lt.2.08e6_r_typ) then
          qalpha=0.
          qchi=1.136e-22_r_typ
        else if (tempk(i).ge.2.08e6_r_typ) then
          qalpha=-0.67_r_typ
          qchi=1.943e-18_r_typ
        end if
!
        qrad(i)=qchi*t**qalpha
      enddo
!
end subroutine
!#######################################################################
subroutine get_qrad_athay (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Athay radiative loss function in [erg-cm**3/s].
!
! ****** TEMPK is the temperature in degrees Kelvin.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
! ****** Parameters for Athay's radiative loss law.
!
      real(r_typ), parameter :: q0=1.e-22_r_typ
      real(r_typ), parameter :: c1=0.4_r_typ
      real(r_typ), parameter :: c2=4.0_r_typ
      real(r_typ), parameter :: c3=4.5_r_typ
      real(r_typ), parameter :: c4=2.0_r_typ
      real(r_typ), parameter :: d1=-30.0_r_typ
      real(r_typ), parameter :: d2=-20.0_r_typ
      real(r_typ), parameter :: d3=-16.0_r_typ
      real(r_typ), parameter :: d4=-4.0_r_typ
      real(r_typ), parameter :: e1=4.6_r_typ
      real(r_typ), parameter :: e2=4.9_r_typ
      real(r_typ), parameter :: e3=5.35_r_typ
      real(r_typ), parameter :: e4=6.1_r_typ
!
      integer :: i
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: t10
!
!-----------------------------------------------------------------------
!
      do concurrent (i=1:n)
        t10=log10(tempk(i))
!
        qrad(i)=q0*( c1*exp(d1*(t10-e1)**2) &
                    +c2*exp(d2*(t10-e2)**2) &
                    +c3*exp(d3*(t10-e3)**2) &
                    +c4*exp(d4*(t10-e4)**2))
      enddo
!
end subroutine
!#######################################################################
subroutine get_qrad_rtv (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** RTV radiative loss function in [erg-cm**3/s].
!
! ****** TEMPK is the temperature in degrees Kelvin.
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: t1=1.2882496e5_r_typ
      real(r_typ), parameter :: c1=2.7360324e-29_r_typ
      real(r_typ), parameter :: c2=0.1548817e-18_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sqrttemp
      integer :: i
!
!-----------------------------------------------------------------------
!
      do concurrent (i=1:n)
        sqrttemp=sqrt(tempk(i))
        if (tempk(i).lt.t1) then
          qrad(i)=c1*tempk(i)*tempk(i)/sqrttemp
        else
          qrad(i)=c2/sqrttemp
        end if
      enddo
!
end subroutine
!#######################################################################
subroutine get_qrad_chianti_v71_corona (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Radiative loss function from CHIANTI with coronal
! ****** abundances.
!
! ****** TEMPK is the temperature in [K].
! ****** QRAD is returned in [erg-cm**3/s].
!
!-----------------------------------------------------------------------
!
      use number_types
      use chianti_v71_rad_loss_corona
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: ten=10._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ii,i
      real(r_typ) :: log10_t,log10_q,i_cont,alpha
!
!-----------------------------------------------------------------------
!
! ****** Interpolate log10(T) linearly from the uniform-increment
! ****** table LOG10_Q_TABLE.
!
      do concurrent (i=1:n)
!
        log10_t=log10(tempk(i))
!
        i_cont=one+(log10_t-log10_t_min)*log10_dt_inv
        ii=floor(i_cont)
!
        if (ii.lt.1) then
          log10_q=log10_q_table(1)
        else if (ii.ge.n_elem) then
          log10_q=log10_q_table(n_elem)
        else
          alpha=i_cont-ii
          log10_q=(one-alpha)*log10_q_table(ii) &
                       +alpha*log10_q_table(ii+1)
        end if
!
        qrad(i)=ten**log10_q
      enddo
!
end subroutine
!#######################################################################
subroutine get_qrad_chianti_v71_photo (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Radiative loss function from CHIANTI with photospheric
! ****** abundances.
!
! ****** TEMPK is the temperature in [K].
! ****** QRAD is returned in [erg-cm**3/s].
!
!-----------------------------------------------------------------------
!
      use number_types
      use chianti_v71_rad_loss_photo
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: ten=10._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ii,i
      real(r_typ) :: log10_t,log10_q,i_cont,alpha
!
!-----------------------------------------------------------------------
!
! ****** Interpolate log10(T) linearly from the uniform-increment
! ****** table LOG10_Q_TABLE.
!
      do concurrent (i=1:n)
        log10_t=log10(tempk(i))
!
        i_cont=one+(log10_t-log10_t_min)*log10_dt_inv
        ii=floor(i_cont)
!
        if (ii.lt.1) then
          log10_q=log10_q_table(1)
        else if (ii.ge.n_elem) then
          log10_q=log10_q_table(n_elem)
        else
          alpha=i_cont-ii
          log10_q=(one-alpha)*log10_q_table(ii) &
                       +alpha*log10_q_table(ii+1)
        end if
!
        qrad(i)=ten**log10_q
      enddo
!
end subroutine
!#######################################################################
subroutine get_qrad_chianti_v713_hybrid (qrad,tempk,n)
!
!-----------------------------------------------------------------------
!
! ****** Radiative loss function from CHIANTI with hybrid
! ****** abundances.
!
! ****** TEMPK is the temperature in [K].
! ****** QRAD is returned in [erg-cm**3/s].
!
!-----------------------------------------------------------------------
!
      use number_types
      use chianti_v713_rad_loss_hybrid
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: n
      real(r_typ), dimension(n) :: qrad,tempk
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: ten=10._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: ii,i
      real(r_typ) :: log10_t,log10_q,i_cont,alpha
!
!-----------------------------------------------------------------------
!
      do concurrent (i=1:n)
!
! ****** Interpolate log10(T) linearly from the uniform-increment
! ****** table LOG10_Q_TABLE.
!
        log10_t=log10(tempk(i))
!
        i_cont=one+(log10_t-log10_t_min)*log10_dt_inv
        ii=floor(i_cont)
!
        if (ii.lt.1) then
          log10_q=log10_q_table(1)
        else if (ii.ge.n_elem) then
          log10_q=log10_q_table(n_elem)
        else
          alpha=i_cont-ii
          log10_q=(one-alpha)*log10_q_table(ii) &
                       +alpha*log10_q_table(ii+1)
        end if
!
        qrad(i)=ten**log10_q
!
      enddo
!
end subroutine
!#######################################################################
subroutine initialize_from_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Load in a 1D solution for the gas variables.
!
!-----------------------------------------------------------------------
!
! ****** Values for vr, rho, and p are read from file FNAME.
! ****** All other variables are set to zero.
!
! ****** NP1D is the number of radial points in the file.
!
! ****** Typical examples are a Parker wind solution or a hydrostatic
! ****** equilibrium.
!
!-----------------------------------------------------------------------
!
! ****** Note that the main real arrays for v, rho, and p are set
! ****** by this routine.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use seam_interface
      use characteristics
      use io_units
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), allocatable ::  rt(:),rhot(:),vrt(:),pt(:),pwt(:)
      real(r_typ) ::  alpha,fac,fac2
      integer :: ierr,np1d,ir,irp1,i,j,k
!
!-----------------------------------------------------------------------
!
      if (iamp0) then
        call ffopen (IO_INPUT,fname,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        np1d=-1
        do
          read (IO_INPUT,'(a)',err=100,end=100)
          np1d=np1d+1
        enddo
  100   continue
        close(IO_INPUT)
      end if
!
! ****** Broadcast the number of lines to all processors.
!
      call MPI_Bcast (np1d,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
!
! ****** Allocate storage for the fields to be read.
!
      allocate (rt(np1d))
      allocate (rhot(np1d))
      allocate (vrt(np1d))
      allocate (pt(np1d))
      allocate (pwt(np1d))
!
! ****** Read the input file (only on processor IPROC0).
!
      if (iamp0) then
        call ffopen (IO_INPUT,fname,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        read (IO_INPUT,*)
        do i=1,np1d
          read (IO_INPUT,*) rt(i),vrt(i),rhot(i),pt(i),pwt(i)
        enddo
        close(IO_INPUT)
      end if
!
! ****** Broadcast the values to all processors.
!
      call MPI_Bcast (rt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (vrt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (rhot,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (pt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (pwt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
!
! ****** Note that the input file contains the (normalized)
! ****** electron number density.
! ****** Convert the electron density to mass density RHO.
!
      do i=1,np1d
        rhot(i)=he_rho*rhot(i)
      enddo
!
! ****** Re-scale p and rho to give a base density of
! ****** RHO0.
!
      call interp (np1d,rt,r0,ir,irp1,alpha,ierr)
!
      fac=rho0/((one-alpha)*rhot(ir)+alpha*rhot(irp1))
!
      do i=1,np1d
        rhot(i)=fac*rhot(i)
        pt(i)=fac*pt(i)
      enddo
!
! ****** Interpolate to the code mesh.
!
      do i=1,nrm
        call interp (np1d,rt,r(i),ir,irp1,alpha,ierr)
        do k=1,np
          do j=1,nt
            v%r(i,j,k)=(one-alpha)*vrt(ir)+alpha*vrt(irp1)
          enddo
        enddo
      enddo
!
      do i=2,nrm1
        call interp (np1d,rt,rh(i),ir,irp1,alpha,ierr)
        do k=1,np
          do j=1,nt
            rho(i,j,k)=(one-alpha)*rhot(ir)+alpha*rhot(irp1)
            pres(i,j,k)=(one-alpha)*pt(ir)+alpha*pt(irp1)
          enddo
        enddo
      enddo
!
! ****** Set boundary values.
!
      rho0i=0.
      rho0f=0.
      pr0i=0.
      pr0f=0.
      pr0v=0.
!
! ****** Set the initial and final base densities.
!
      call interp (np1d,rt,r0,ir,irp1,alpha,ierr)
!
      fac=((one-alpha)*pt(ir)+alpha*pt(irp1))
      if (rb0) then
        do k=1,np
          do j=1,nt
            rho0i(j,k)=rho0
            rho0f(j,k)=rho0
            pr0i(j,k)=fac
            pr0f(j,k)=fac
            pr0v(j,k)=fac
          enddo
        enddo
      end if
!
! ****** Broadcast the base density to all processors sharing
! ****** this base location.
!
      call MPI_Bcast (rho0i,nt*np,ntype_real,iproc_rb0,comm_r,ierr)
      call MPI_Bcast (rho0f,nt*np,ntype_real,iproc_rb0,comm_r,ierr)
!
! ****** Set the BCs at r=R0 on RHO and PRES.
!
      if (rb0) then
        do k=1,np
          do j=1,nt
            rho(1,j,k)=two*rho0i(j,k)-rho(2,j,k)
            pres(1,j,k)=two*pr0i(j,k)-pres(2,j,k)
          enddo
        enddo
      end if
!
! ****** Set the BCs at r=R1 on RHO and PRES.
!
      call interp (np1d,rt,r1,ir,irp1,alpha,ierr)
      fac=((one-alpha)*pt(ir)+alpha*pt(irp1))
      fac2=((one-alpha)*rhot(ir)+alpha*rhot(irp1))
!
      if (rb1) then
        do k=1,np
          do j=1,nt
            rho(nr,j,k)=two*fac2-rho(nrm1,j,k)
            pres(nr,j,k)=two*fac-pres(nrm1,j,k)
          enddo
        enddo
      end if
!
! ****** Set boundary conditions at the poles.
!
      call set_pole_bc_scalar_hhh_cpu (rho)
      call set_pole_bc_scalar_hhh_cpu (pres)
!
      call seam (rho)
      call seam (pres)
!
      v%t(:,:,:)=0.
      if (calculation_frame.eq."COROTATING") then
        do k=1,np
          do j=1,nt
            do i=1,nr
              v%p(i,j,k)=-rh(i)*sth(j)*omega_corotate
            enddo
          enddo
        enddo
        do k=1,np
          do j=1,nt
            vb%r0%p(j,k)=-r0*sth(j)*omega_corotate
          enddo
        enddo
      else
        v%p(:,:,:)=0.
        vb%r0%p(:,:)=0.
      end if
!
      call interp (np1d,rt,r0,ir,irp1,alpha,ierr)
      vb%r0%r(:,:)=((one-alpha)*vrt(ir)+alpha*vrt(irp1))
      call interp (np1d,rt,r1,ir,irp1,alpha,ierr)
      vb%r1%r(:,:)=((one-alpha)*vrt(ir)+alpha*vrt(irp1))
      vb%r0%t(:,:)=0.
      vb%r1%t(:,:)=0.
      vb%r1%p(:,:)=0.
!
      deallocate (rt)
      deallocate (rhot)
      deallocate (vrt)
      deallocate (pt)
      deallocate (pwt)
!
end subroutine
!#######################################################################
subroutine load_bc_temp_e
!
!-----------------------------------------------------------------------
!
! ****** Load boundary conditions on temperature at the physical
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use characteristics
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
! This is already done in set_r0_bc() - is it needed here?
        do concurrent (k=1:np, j=1:nt)
          tr0v(j,k)=tbc0/fn_t
        enddo
      end if
!
      if (rb1) then
        if (char_bc1) then
          if (advance_tp) then
            do concurrent (k=2:npm1, j=2:ntm1)
              tr1v(j,k)=(he_rho/(he_p_e+he_p_p* &
                         temp_p(nrm1,j,k)/temp_e(nrm1,j,k))) &
                        *cbc1_pb(j,k)/cbc1_rhob(j,k)
            enddo
          else
            do concurrent (k=2:npm1, j=2:ntm1)
              tr1v(j,k)=(he_rho/he_p)*cbc1_pb(j,k)/cbc1_rhob(j,k)
            enddo
          end if
        else
          do concurrent (k=2:npm1, j=2:ntm1)
            tr1v(j,k)=temp_e(nr,j,k)
          enddo
        end if
      end if
!
end subroutine
!#######################################################################
subroutine load_bc_temp_p
!
!-----------------------------------------------------------------------
!
! ****** Load boundary conditions on proton temperature at the physical
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use characteristics
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
! This is already done in set_r0_bc() - is it needed here?
        do concurrent (k=1:np, j=1:nt)
          tr0v(j,k)=tbc0/fn_t
        enddo
      end if
!
      if (rb1) then
        if (char_bc1) then
          do concurrent (k=2:npm1, j=2:ntm1)
            tr1v_p(j,k)=(he_rho/(he_p_p+he_p_e* &
                         temp_e0(nrm1,j,k)/temp_p(nrm1,j,k))) &
                        *cbc1_pb(j,k)/cbc1_rhob(j,k)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1)
            tr1v_p(j,k)=temp_p(nr,j,k)
          enddo
        end if
      end if
!
end subroutine
!#######################################################################
subroutine set_bc_temp_e (tc,bcmask)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on temperature at the physical
! ****** boundaries. Interplanetary cases do not allow Spitzer's
! ****** thermal conduction.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use interplanetary_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: tc
      real(r_typ) :: bcmask
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
        if (interplanetary_run) then
          do concurrent (k=2:npm1, j=2:ntm1)
            tc(1,j,k)=bcmask*two*t_ip(j,k)-tc(2,j,k)
          enddo
        else if (advance_tc) then
          do concurrent (k=2:npm1, j=2:ntm1)
            tc(1,j,k)=bcmask*tr0v(j,k)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1)
            tc(1,j,k)=bcmask*two*tr0v(j,k)-tc(2,j,k)
          enddo
        end if
      end if
!
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
!cc            tc(nr,j,k)=bcmask*two*tr1v(j,k)-tc(nrm1,j,k)
          tc(nr,j,k)=bcmask*tr1v(j,k)
        enddo
      end if
!
! ****** Theta boundaries.
!
      call set_pole_bc_scalar_hhh (tc)
!
end subroutine
!#######################################################################
subroutine set_bc_temp_p (tc,bcmask)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on temperature at the physical
! ****** boundaries. Interplanetary cases do not allow Spitzer's
! ****** thermal conduction.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use interplanetary_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: tc
      real(r_typ) :: bcmask
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
        if (interplanetary_run) then
          do concurrent (k=2:npm1, j=2:ntm1)
            tc(1,j,k)=bcmask*two*t_ip(j,k)-tc(2,j,k)
          enddo
        else if (advance_tc) then
          do concurrent (k=2:npm1, j=2:ntm1)
              tc(1,j,k)=bcmask*tr0v(j,k)
          enddo
        else
          do concurrent (k=2:npm1, j=2:ntm1)
            tc(1,j,k)=bcmask*two*tr0v(j,k)-tc(2,j,k)
          enddo
        end if
      end if
!
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
!cc            tc(nr,j,k)=bcmask*two*tr1v_p(j,k)-tc(nrm1,j,k)
          tc(nr,j,k)=bcmask*tr1v_p(j,k)
        enddo
      end if
!
! ****** Theta boundaries.
!
      call set_pole_bc_scalar_hhh (tc)
!
end subroutine
!#######################################################################
subroutine setpt
!
!-----------------------------------------------------------------------
!
! ****** Set the pressure and mean temperature
! ****** from the density and electron and proton temperatures.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      character(32) :: FNAME='PRESSURE', RNAME='SETPT'
!
!-----------------------------------------------------------------------
!
! ****** Set the mean temperature of all points.
!
      if (advance_tp) then
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          temp(i,j,k)=(he_p_e*temp_e(i,j,k) &
                      +he_p_p*temp_p(i,j,k))/he_p
        enddo
      else
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          temp(i,j,k)=temp_e(i,j,k)
        enddo
      end if
!
! ****** Set pressure of internal points.
! ****** (Outer radial boundary (nr) needed in case char_bc1=.false.)
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nr)
        pres(i,j,k)=(he_p/he_rho)*rho(i,j,k)*temp(i,j,k)
      enddo
!
! ****** Set boundary conditions so they are consistent.
!
      call set_bc_pres
!
! ****** Seam.
!
      call seam_scalar (pres,nr,nt,np)
!
! *** Check for negative pressures.
!
      if (ifcheck0pres) then
        call check_negative_field (pres,nr,nt,np,FNAME,RNAME)
      end if
!
end subroutine
!#######################################################################
subroutine filter_hhh (f)
!
!-----------------------------------------------------------------------
!
! ****** Filter a 3D field defined on the (rh,th,ph) mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: f
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: i64=.015625_r_typ,i16=.0625_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Temporary arrays.
!
      real(r_typ), dimension(nr,nt,np) :: ff
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** Seam the field.
!
      call seam_scalar (f,nr,nt,np)
!
! ****** Apply the boundary conditions at the poles.
!
      call set_pole_bc_scalar_hhh (f)
!
! ****** Apply a "(1,2,1)/4" digital filter in r, theta and phi.
!
!$acc enter data create(ff)
      do concurrent (i=1:nr, j=1:nt, k=1:np)
        ff(i,j,k)=f(i,j,k)
      enddo
!
      do concurrent (i=2:nrm1, j=2:ntm1, k=2:npm1)
        ff(i,j,k)=i64* &
            ( (f(i-1,j-1,k-1)+two*f(i-1,j-1,k  )+f(i-1,j-1,k+1)) &
         +two*(f(i-1,j  ,k-1)+two*f(i-1,j  ,k  )+f(i-1,j  ,k+1)) &
             +(f(i-1,j+1,k-1)+two*f(i-1,j+1,k  )+f(i-1,j+1,k+1)) &
        +two*((f(i  ,j-1,k-1)+two*f(i  ,j-1,k  )+f(i  ,j-1,k+1)) &
         +two*(f(i  ,j  ,k-1)+two*f(i  ,j  ,k  )+f(i  ,j  ,k+1)) &
             +(f(i  ,j+1,k-1)+two*f(i  ,j+1,k  )+f(i  ,j+1,k+1))) &
             +(f(i+1,j-1,k-1)+two*f(i+1,j-1,k  )+f(i+1,j-1,k+1)) &
         +two*(f(i+1,j  ,k-1)+two*f(i+1,j  ,k  )+f(i+1,j  ,k+1)) &
             +(f(i+1,j+1,k-1)+two*f(i+1,j+1,k  )+f(i+1,j+1,k+1)))
      enddo
!
      if (rb0) then
        do concurrent (k=2:npm1, j=2:ntm1)
          ff(1,j,k)= &
           (i16*( (f(1,j-1,k-1)+two*f(1,j-1,k  )+f(1,j-1,k+1)) &
             +two*(f(1,j  ,k-1)+two*f(1,j  ,k  )+f(1,j  ,k+1)) &
                 +(f(1,j+1,k-1)+two*f(1,j+1,k  )+f(1,j+1,k+1))) &
           +i16*( (f(2,j-1,k-1)+two*f(2,j-1,k  )+f(2,j-1,k+1)) &
             +two*(f(2,j  ,k-1)+two*f(2,j  ,k  )+f(2,j  ,k+1)) &
                 +(f(2,j+1,k-1)+two*f(2,j+1,k  )+f(2,j+1,k+1)))) &
            -ff(2,j,k)
        enddo
      end if
!
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
          ff(nr,j,k)= &
            (i16*( (f(nr  ,j-1,k-1)+two*f(nr  ,j-1,k)+f(nr  ,j-1,k+1)) &
              +two*(f(nr  ,j  ,k-1)+two*f(nr  ,j  ,k)+f(nr  ,j  ,k+1)) &
                  +(f(nr  ,j+1,k-1)+two*f(nr  ,j+1,k)+f(nr  ,j+1,k+1))) &
            +i16*( (f(nrm1,j-1,k-1)+two*f(nrm1,j-1,k)+f(nrm1,j-1,k+1)) &
              +two*(f(nrm1,j  ,k-1)+two*f(nrm1,j  ,k)+f(nrm1,j  ,k+1)) &
                  +(f(nrm1,j+1,k-1)+two*f(nrm1,j+1,k)+f(nrm1,j+1,k+1)))) &
             -ff(nrm1,j,k)
        enddo
      end if
!
      do concurrent (i=1:nr, j=1:nt, k=1:np)
        f(i,j,k)=ff(i,j,k)
      enddo
!
!$acc exit data delete(ff)
end subroutine
!#######################################################################
subroutine advpw
!
!-----------------------------------------------------------------------
!
! ****** Advance the Alfven wave pressure energy density ep and em.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use timing
      use alfven_wave_pressure
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vaw_ep,vaw_em
!
      real(r_typ), dimension(nr,nt,np) :: va,divv,div_ep,div_em,epp,emp
      real(r_typ), dimension(2:nrm1) :: fkdotvmx,dt_rhopaw_i
!
      real(r_typ) :: dtaw,avvr,avvt,avvp,fkr2,fkt2,fkp2, &
                     fkdotv_ep,fkdotv_em,dtawr,s_ep,s_em,bsq, &
                     avbp,avbt,avbr,db2_ep,db2_em,tau_aw_i,wdbob_aw_i, &
                     fkdotvmx_tmp,tmp
      integer :: i,j,k,nsteps,it
      character(32) :: FNAME1='EP', FNAME2='EM', RNAME='ADVPW'
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVPW)
!$acc enter data create(va,divv,div_ep,div_em,epp,emp, &
!$acc                   fkdotvmx,dt_rhopaw_i)
!
! ****** Allocate temporary wave advection velocity.
!
      call alloc_vvec (vaw_ep)
      call alloc_vvec (vaw_em)
!
! ****** Calculate the Alfven speed.
!
      call getva (va)
!
! ****** Get the wave advection velocity.
!
      call getvaw (one,va,vaw_ep)
      call getvaw (-one,va,vaw_em)
!
! ****** Determine the boundary conditions on the Alfven waves
! ****** at the radial boundaries.
!
      call getbcep (vaw_ep)
      call getbcem (vaw_em)
!
! ****** Get the divergence of velocity.
!
      call get_divv (v,divv)
!
! ****** Estimate the maximum explicit stable time step.
!
!$acc parallel default(present)
!$acc loop gang
!$omp parallel do default(shared)
      do i=2,nrm1
        tmp=0.
!$acc loop collapse(2) reduction(max:tmp)
        do k=2,npm1
          do j=2,ntm1
            fkr2=drh_i(i)**2
            fkt2=(rh_i(i)*dth_i(j))**2
            fkp2=(sth_i(j)*rh_i(i)*dp_mult*dph_i(k))**2
!
            avvr=AVGR (vaw_ep%r,i,j,k)
            avvt=AVGT (vaw_ep%t,i,j,k)
            avvp=AVGP (vaw_ep%p,i,j,k)
            fkdotv_ep=sqrt(fkr2*avvr**2+fkt2*avvt**2+fkp2*avvp**2)
!
            avvr=AVGR (vaw_em%r,i,j,k)
            avvt=AVGT (vaw_em%t,i,j,k)
            avvp=AVGP (vaw_em%p,i,j,k)
            fkdotv_em=sqrt(fkr2*avvr**2+fkt2*avvt**2+fkp2*avvp**2)
!
            fkdotvmx_tmp=max(fkdotv_ep,fkdotv_em)
            tmp=max(tmp,fkdotvmx_tmp)
          enddo
        enddo
        fkdotvmx(i)=max(1.e-20_r_typ,tmp)
      enddo
!$acc end parallel
!$omp end parallel do
!
      dtaw=dtime
!
!$acc parallel loop default(present) reduction(min:dtaw)
!$omp parallel do default(shared) reduction(min:dtaw)
      do i=2,nrm1
        dtaw=min(dtaw,safety_factor_aw*cfl*rho_aw/fkdotvmx(i))
      enddo
!$omp end parallel do
!
      call global_min (dtaw)
!
      nsteps=CEILING(dtime/dtaw)
!
      dtaw=dtime/nsteps
!
! ****** Keep track of the average time step used.
!        Add average number of steps - maybe like sts?
      nsaw=nsaw+1
      dtawav=(dtawav*(nsaw-1)+dtaw)/nsaw
!
! ****** Set the (artificial) radial "density profile".
!
      do concurrent (i=2:nrm1)
        dtawr=safety_factor_aw*cfl/fkdotvmx(i)
        dt_rhopaw_i(i)=dtaw/max(dtaw/dtawr,one)
      enddo
!
      call global_min_v_tp (nr-2,dt_rhopaw_i)
!
      if (dissipate_aw) then
        wdbob_aw_i=one/wdbob_aw
        tau_aw_i=one/tau_aw
      end if
!
! ****** Advance the Alfven wave energy density.
!
      do it=1,nsteps
!
! ****** Predictor step.
!
        call divqv (one,ep,vaw_ep,div_ep)
        call divqv (one,em,vaw_em,div_em)
!
        if (pred_t) then
!
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            epp(i,j,k)=ep(i,j,k)-div_ep(i,j,k)*dt_rhopaw_i(i)
            emp(i,j,k)=em(i,j,k)-div_em(i,j,k)*dt_rhopaw_i(i)
          enddo
!
! ****** Set boundary conditions.
!
          call setbcep (epp)
          call setbcem (emp)
!
          call seam_scalar (epp,nr,nt,np)
          call seam_scalar (emp,nr,nt,np)
!
! ****** Corrector step.
!
          call divqv (one,epp,vaw_ep,div_ep)
          call divqv (one,emp,vaw_em,div_em)
!
        end if
!
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          ep(i,j,k)=ep(i,j,k)-dt_rhopaw_i(i)* &
                          (div_ep(i,j,k)+half*ep(i,j,k)*divv(i,j,k))
          em(i,j,k)=em(i,j,k)-dt_rhopaw_i(i)* &
                          (div_em(i,j,k)+half*em(i,j,k)*divv(i,j,k))
        enddo
!
! ****** Add in the dissipation term.
!
        if (dissipate_aw) then
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            avbr=AVGRTP(b%r,i+1,j  ,k)
            avbt=AVGP  (b%t,i  ,j  ,k)
            avbp=AVGT  (b%p,i  ,j  ,k)
            bsq=avbr**2+avbt**2+avbp**2
            db2_ep=two*ep(i,j,k)/bsq
            db2_em=two*em(i,j,k)/bsq
            s_ep=half*(one+tanh((db2_ep-dbob_aw**2)*wdbob_aw_i))
            s_em=half*(one+tanh((db2_em-dbob_aw**2)*wdbob_aw_i))
            ep(i,j,k)=ep(i,j,k)/(one+s_ep*dt_rhopaw_i(i)*tau_aw_i)
            em(i,j,k)=em(i,j,k)/(one+s_em*dt_rhopaw_i(i)*tau_aw_i)
          enddo
        end if
!
! ****** Set boundary conditions.
!
        call setbcep (ep)
        call setbcem (em)
!
        call seam_scalar (ep,nr,nt,np)
        call seam_scalar (em,nr,nt,np)
!
      enddo
!
      call dealloc_vvec (vaw_ep)
      call dealloc_vvec (vaw_em)
!
! ****** Filter/smooth poles.
!
      if (pole_filter_pw) then
        call smooth_poles_scalars (ep)
        call smooth_poles_scalars (em)
      end if
!
! *** Check for negative values.
!
      if (ifcheck0pw) then
        call check_negative_field (ep,nr,nt,np,FNAME1,RNAME)
        call check_negative_field (em,nr,nt,np,FNAME2,RNAME)
      end if
!
!$acc exit data delete(va,divv,div_ep,div_em,epp,emp, &
!$acc                  fkdotvmx,dt_rhopaw_i)
      if (use_timer) call timer (TIME_ADVPW)
!
end subroutine
!#######################################################################
subroutine getva (va)
!
!-----------------------------------------------------------------------
!
! ****** Calculate the Alfven speed.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: va
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: avrho,brav,btav,bpav,bsq,vab
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        avrho=AVG(rho,i,j,k)
        brav=AVGTP(b%r,i,j,k)
        btav=AVGRP(b%t,i,j,k)
        bpav=AVGRT(b%p,i,j,k)
        bsq=brav**2+btav**2+bpav**2
        va(i,j,k)=sqrt(bsq/avrho)
      enddo
!
! ****** Now do BCs (uses internal va pts, so need sync but not seam).
!
      if (rb0) then
        do concurrent (k=2:npm1, j=2:ntm1)
          avrho=AVGR(rho,2,j,k)
          brav=AVGRTP(b%r,2,j,k)
          btav=AVGP(b%t,1,j,k)
          bpav=AVGT(b%p,1,j,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va( 1,j,k)=2._r_typ*vab-va(   2,j,k)
        enddo
      end if
!
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
          avrho=AVGR  (rho,nr  ,j,k)
          brav =AVGRTP(b%r,nr  ,j,k)
          btav =AVGP  (b%t,nrm1,j,k)
          bpav =AVGT  (b%p,nrm1,j,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(nr,j,k)=2._r_typ*vab-va(nrm1,j,k)
        enddo
      end if
!
      if (tb0) then
        do concurrent (k=2:npm1, i=2:nrm1)
          avrho=AVGT  (rho,i,2,k)
          brav =AVGP  (b%r,i,1,k)
          btav =AVGRTP(b%t,i,2,k)
          bpav =AVGR  (b%p,i,1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(i,1,k)=2._r_typ*vab-va(i,2,k)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=2:npm1, i=2:nrm1)
          avrho=AVGT  (rho,i,nt,k)
          brav =AVGP  (b%r,i,ntm1,k)
          btav =AVGRTP(b%t,i,nt  ,k)
          bpav =AVGR  (b%p,i,ntm1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(i,nt,k)=2._r_typ*vab-va(i,ntm1,k)
        enddo
      end if
!
! ****** Now do corner BCs (also need sync but not seam).
!
      if (rb0.and.tb0) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,2,2,k)
          brav=AVGRP(b%r,2,1,k)
          btav=AVGTP(b%t,1,2,k)
          bpav=AVG(b%p,1,1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va( 1, 1,k)=4._r_typ*vab-va(   1,   2,k) &
                                  -va(   2,   1,k) &
                                  -va(   2,   2,k)
        enddo
      end if
!
      if (rb0.and.tb1) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,2,nt,k)
          brav=AVGRP(b%r,2,ntm1,k)
          btav=AVGTP(b%t,1,nt,k)
          bpav=AVG  (b%p,1,ntm1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va( 1,nt,k)=4._r_typ*vab-va(   1,ntm1,k) &
                                  -va(   2,nt  ,k) &
                                  -va(   2,ntm1,k)
        enddo
      end if
!
      if (rb1.and.tb0) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,nr,2,k)
          brav =AVGRP(b%r,nr,1,k)
          btav =AVGTP(b%t,nrm1,2,k)
          bpav =AVG  (b%p,nrm1,1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(nr, 1,k)=4._r_typ*vab-va(nr  ,   2,k) &
                                  -va(nrm1,   1,k) &
                                  -va(nrm1,   2,k)
        enddo
      end if
!
      if (rb1.and.tb1) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,nr,nt,k)
          brav =AVGRP(b%r,nr,ntm1,k)
          btav =AVGTP(b%t,nrm1,nt,k)
          bpav =AVG  (b%p,nrm1,ntm1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(nr,nt,k)=4._r_typ*vab-va(nr  ,ntm1,k) &
                                  -va(nrm1,nt  ,k) &
                                  -va(nrm1,ntm1,k)
        enddo
      end if
!
      call seam_scalar (va,nr,nt,np)
!
end subroutine
!#######################################################################
subroutine getva_zw (va)
!
!-----------------------------------------------------------------------
!
! ****** Calculate the Alfven speed.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use wtd, ONLY : wtd_bc_extrap_fac_r1
      use seam_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: va
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: avrho,brav,btav,bpav,bsq,vab
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        avrho=AVG(rho,i,j,k)
        brav=AVGTP(b%r,i,j,k)
        btav=AVGRP(b%t,i,j,k)
        bpav=AVGRT(b%p,i,j,k)
        bsq=brav**2+btav**2+bpav**2
        va(i,j,k)=sqrt(bsq/avrho)
      enddo
!
! ****** Now do BCs (uses internal va pts, so need sync but not seam).
!
      if (rb0) then
        do concurrent (k=2:npm1, j=2:ntm1)
          avrho=AVGR(rho,2,j,k)
          brav=AVGRTP(b%r,2,j,k)
          btav=AVGP(b%t,1,j,k)
          bpav=AVGT(b%p,1,j,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va( 1,j,k)=max(2._r_typ*vab-va(   2,j,k), &
                         va(   2,j,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
          avrho=AVGR  (rho,nr  ,j,k)
          brav =AVGRTP(b%r,nr  ,j,k)
          btav =AVGP  (b%t,nrm1,j,k)
          bpav =AVGT  (b%p,nrm1,j,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(nr,j,k)=max(2._r_typ*vab-va(nrm1,j,k), &
                         va(nrm1,j,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
      if (tb0) then
        do concurrent (k=2:npm1, i=2:nrm1)
          avrho=AVGT  (rho,i,2,k)
          brav =AVGP  (b%r,i,1,k)
          btav =AVGRTP(b%t,i,2,k)
          bpav =AVGR  (b%p,i,1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(i, 1,k)=max(2._r_typ*vab-va(i,   2,k), &
                         va(i,   2,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
      if (tb1) then
        do concurrent (k=2:npm1, i=2:nrm1)
          avrho=AVGT  (rho,i,nt,k)
          brav =AVGP  (b%r,i,ntm1,k)
          btav =AVGRTP(b%t,i,nt  ,k)
          bpav =AVGR  (b%p,i,ntm1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(i,nt,k)=max(2._r_typ*vab-va(i,ntm1,k), &
                         va(i,ntm1,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
! ****** Now do corner BCs (also need sync but not seam).
!
      if (rb0.and.tb0) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,2,2,k)
          brav=AVGRP(b%r,2,1,k)
          btav=AVGTP(b%t,1,2,k)
          bpav=AVG(b%p,1,1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va( 1, 1,k)=max(4._r_typ*vab-va(   1,   2,k) &
                                      -va(   2,   1,k) &
                                      -va(   2,   2,k), &
                          va(   2,   2,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
      if (rb0.and.tb1) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,2,nt,k)
          brav=AVGRP(b%r,2,ntm1,k)
          btav=AVGTP(b%t,1,nt,k)
          bpav=AVG  (b%p,1,ntm1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va( 1,nt,k)=max(4._r_typ*vab-va(   1,ntm1,k) &
                                      -va(   2,nt  ,k) &
                                      -va(   2,ntm1,k), &
                          va(   2,ntm1,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
      if (rb1.and.tb0) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,nr,2,k)
          brav =AVGRP(b%r,nr,1,k)
          btav =AVGTP(b%t,nrm1,2,k)
          bpav =AVG  (b%p,nrm1,1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(nr, 1,k)=max(4._r_typ*vab-va(nr  ,   2,k) &
                                      -va(nrm1,   1,k) &
                                      -va(nrm1,   2,k), &
                          va(nrm1,   2,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
      if (rb1.and.tb1) then
        do concurrent (k=2:npm1)
          avrho=AVGRT(rho,nr,nt,k)
          brav =AVGRP(b%r,nr,ntm1,k)
          btav =AVGTP(b%t,nrm1,nt,k)
          bpav =AVG  (b%p,nrm1,ntm1,k)
          bsq=brav**2+btav**2+bpav**2
          vab=sqrt(bsq/avrho)
          va(nr,nt,k)=max(4._r_typ*vab-va(nr  ,ntm1,k) &
                                      -va(nrm1,nt  ,k) &
                                      -va(nrm1,ntm1,k), &
                          va(nrm1,ntm1,k)*wtd_bc_extrap_fac_r1)
        enddo
      end if
!
      call seam_scalar (va,nr,nt,np)
      call set_pole_bc_scalar_hhh (va)
!
end subroutine
!#######################################################################
subroutine setbcep (epp)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on the Alfven wave energy density ep.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: epp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
        do concurrent (k=2:npm1, j=2:ntm1)
          epp(1,j,k)=two*epbcr0re(j,k)-epp(2,j,k)
        enddo
      end if
!
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
          epp(nr,j,k)=two*epbcr1re(j,k)-epp(nrm1,j,k)
        enddo
      end if
!
! ****** Theta boundaries.
!
      call set_pole_bc_scalar_hhh (epp)
!
end subroutine
!#######################################################################
subroutine setbcem (emp)
!
!-----------------------------------------------------------------------
!
! ****** Set boundary conditions on the Alfven wave energy density em.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: emp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** R boundaries.
!
      if (rb0) then
        do concurrent (k=2:npm1, j=2:ntm1)
          emp(1,j,k)=two*embcr0re(j,k)-emp(2,j,k)
        enddo
      end if
!
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
          emp(nr,j,k)=two*embcr1re(j,k)-emp(nrm1,j,k)
        enddo
      end if
!
! ****** Theta boundaries.
!
      call set_pole_bc_scalar_hhh (emp)
!
end subroutine
!#######################################################################
subroutine getvaw (pm,va,vaw)
!
!-----------------------------------------------------------------------
!
! ****** Calculate the Alfven wave advection velocity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: small_value=tiny(1._r_typ)
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: pm
      real(r_typ), dimension(nr,nt,np) :: va
      type(vvec) :: vaw
!
!-----------------------------------------------------------------------
!
      real(r_typ) ::  avva,avbr,avbt,avbp,bsq
      real(r_typ) ::  brhat,bthat,bphat
      integer :: i,j,k
      real(r_typ) :: omval
!
!-----------------------------------------------------------------------
!
!
! ****** Set omega based on chosen frame.
!
      if (calculation_frame.eq.'COROTATING') then
        omval=omega_corotate
      else
        omval=0.
      end if
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        avva=AVGR  (va ,i+1,j  ,k)
        avbr=AVGRTP(b%r,i+1,j  ,k)
        avbt=AVGP  (b%t,i  ,j  ,k)
        avbp=AVGT  (b%p,i  ,j  ,k)
        bsq=avbr**2+avbt**2+avbp**2
        bsq=max(bsq,small_value)
        brhat=avbr/sqrt(bsq)
        vaw%r(i,j,k)=v%r(i,j,k)+pm*brhat*avva
      enddo
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        avva=AVGT  (va ,i  ,j+1,k)
        avbr=AVGP  (b%r,i  ,j  ,k)
        avbt=AVGRTP(b%t,i  ,j+1,k)
        avbp=AVGR  (b%p,i  ,j  ,k)
        bsq=avbr**2+avbt**2+avbp**2
        bsq=max(bsq,small_value)
        bthat=avbt/sqrt(bsq)
        vaw%t(i,j,k)=v%t(i,j,k)+pm*bthat*avva
      enddo
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        avva=AVGP  (va ,i,j,k+1)
        avbr=AVGT  (b%r,i,j,k  )
        avbt=AVGR  (b%t,i,j,k  )
        avbp=AVGRTP(b%p,i,j,k+1)
        bsq=avbr**2+avbt**2+avbp**2
        bsq=max(bsq,small_value)
        bphat=avbp/sqrt(bsq)
        vaw%p(i,j,k)=v%p(i,j,k)+omval*rh(i)*sth(j)+pm*bphat*avva
      enddo
!
      call seam_vvec (vaw)
!
end subroutine
!#######################################################################
subroutine getvaw_half (pm,va,vawh)
!
!-----------------------------------------------------------------------
!
! ****** Calculate the Alfven wave advection velocity on the half mesh
! ****** need to avg vvec only in the cardinal direction
! ****** need to avg bvec in the off directions
! ****** take out bmag=0.0 if statement, use tiny number instead
! ****** also only care about internal points --> no seam or BC check
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: pm
      real(r_typ), dimension(nr,nt,np) :: va
      type(hvec) :: vawh
!
!-----------------------------------------------------------------------
!
      real(r_typ) ::  avvr,avvt,avvp,avbr,avbt,avbp,bsq,bmag
      real(r_typ) ::  brhat,bthat,bphat
      integer :: i,j,k
      real(r_typ) :: omval
      real(r_typ), parameter :: ctiny=1.e-16_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Set omega based on chosen frame.
!
      if (calculation_frame.eq.'COROTATING') then
        omval=omega_corotate
      else
        omval=0.
      end if
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        avvr=AVGR   (v%r, i ,j ,k)
        avvt=AVGT   (v%t, i ,j ,k)
        avvp=AVGP   (v%p, i ,j ,k)
        avbr=AVGTP  (b%r, i ,j ,k)
        avbt=AVGRP  (b%t, i ,j ,k)
        avbp=AVGRT  (b%p, i ,j ,k)
        bsq=avbr**2+avbt**2+avbp**2
        bmag=sqrt(bsq)+ctiny
        brhat=avbr/bmag
        bthat=avbt/bmag
        bphat=avbp/bmag
        vawh%r(i,j,k)=avvr+pm*brhat*va(i,j,k)
        vawh%t(i,j,k)=avvt+pm*bthat*va(i,j,k)
        vawh%p(i,j,k)=avvp+pm*bphat*va(i,j,k)+omval*rh(i)*sth(j)
      enddo
!
end subroutine
!#######################################################################
subroutine getbcep (vaw)
!
!-----------------------------------------------------------------------
!
! ****** Set the Alfven wave energy density ep at the radial
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use alfven_wave_pressure
      use interplanetary_vars
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vaw
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: av_br
!
!-----------------------------------------------------------------------
!
      if (rb0) then
        if (.not.interplanetary_run) then
          if (modulate_pw0) then
            do concurrent (k=2:npm1, j=2:ntm1)
              if (vaw%r(1,j,k).ge.0._r_typ) then
                av_br=abs(AVGRP (b%r,2,j  ,k))
                epbcr0re(j,k)=2._r_typ*pw0*pw0_factor*br00/av_br
              else
                epbcr0re(j,k)=EXTRAPR0H(ep,   2,j,k)
              end if
            enddo
          else
            do concurrent (k=1:np, j=1:nt)
              if (vaw%r(1,j,k).ge.0._r_typ) then
                epbcr0re(j,k)=2._r_typ*pw0*pw0_factor*awthprof(j)
              else
                epbcr0re(j,k)=EXTRAPR0H(ep,   2,j,k)
              end if
            enddo
          end if
        end if
      end if
      if (rb1) then
        do concurrent (k=1:np, j=1:nt)
          if (vaw%r(nrm1,j,k).le.0._r_typ) then
            epbcr1re(j,k)=0._r_typ
          else
            epbcr1re(j,k)=EXTRAPR1H(ep,nrm1,j,k)
          end if
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine getbcem (vaw)
!
!-----------------------------------------------------------------------
!
! ****** Set the Alfven wave energy density em at the radial
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use alfven_wave_pressure
      use interplanetary_vars
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vaw
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: av_br
!
!-----------------------------------------------------------------------
!
      if (rb0) then
        if (.not.interplanetary_run) then
          if (modulate_pw0) then
            do concurrent (k=1:np, j=1:nt)
              if (vaw%r(1,j,k).ge.0._r_typ) then
                av_br=abs(AVGRP (b%r,2,j  ,k))
                embcr0re(j,k)=2._r_typ*pw0*pw0_factor*br00/av_br
              else
                embcr0re(j,k)=EXTRAPR0H(em,   2,j,k)
              end if
            enddo
          else
            do concurrent (k=1:np, j=1:nt)
              if (vaw%r(1,j,k).ge.0._r_typ) then
                embcr0re(j,k)=2._r_typ*pw0*pw0_factor*awthprof(j)
              else
                embcr0re(j,k)=EXTRAPR0H(em,   2,j,k)
              end if
            enddo
          end if
        end if
      end if
      if (rb1) then
        do concurrent (k=1:np, j=1:nt)
          if (vaw%r(nrm1,j,k).le.0.) then
            embcr1re(j,k)=0.
          else
            embcr1re(j,k)=EXTRAPR1H(em,nrm1,j,k)
          end if
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine load_awthprof
!
!-----------------------------------------------------------------------
!
! ****** Load the latitudinal Alfven wave profile into array AWTHPROF.
!
!-----------------------------------------------------------------------
!
! ****** Smooth latitude profile :
!
!    ___________           ___________  0
!               \_________/             1
!    north pole   equator   south pole
!
! ****** The variables AWTHPROF_TH and AWTHPROF_DTH control the profile.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use mpidefs
      use timing
      use alfven_wave_pressure
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: j
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: zero=0.
!
!-----------------------------------------------------------------------
!
      allocate (awthprof(nt))
!
      if (use_pw_theta_profile) then
        if (awthprof_dth.eq.zero) then
!
          do j=1,nt
            awthprof(j)=one-sth(j)**2
          enddo
        else if (awthprof_dth.lt.zero) then
          do j=1,nt
            awthprof(j)=zero
            if (th(j).lt.awthprof_th.or.th(j).gt.awthprof2_th) then
              awthprof(j)=one
            end if
          enddo
!
        else
!
          do j=1,nt
            if (th(j).lt.half*(awthprof2_th+awthprof_th)) then
              awthprof(j)= &
              one-half*(one+tanh((th(j)-awthprof_th)/awthprof_dth))
            else
              awthprof(j)= &
              one-half*(one-tanh((th(j)-awthprof2_th)/awthprof_dth))
            end if
          enddo
!
        end if
      else
        awthprof(:)=one
      end if
!
end subroutine
!#######################################################################
subroutine advzw
!
!-----------------------------------------------------------------------
!
! ****** Advance the Alfven wave pressure.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use alfven_wave_pressure
      use wtd
      use mesh
      use timing
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: logva
      real(r_typ), dimension(nr,nt,np) :: logrho
      real(r_typ), dimension(nr,nt,np) :: r_1_p
      real(r_typ), dimension(nr,nt,np) :: r_1_m
      real(r_typ), dimension(nr,nt,np) :: r_2_p
      real(r_typ), dimension(nr,nt,np) :: r_2_m
      real(r_typ), dimension(nr,nt,np) :: d0
      real(r_typ), dimension(nr,nt,np) :: va
      real(r_typ), dimension(nr,nt,np) :: zpp
      real(r_typ), dimension(nr,nt,np) :: zmp
      real(r_typ), dimension(nr,nt,np) :: vdgzp
      real(r_typ), dimension(nr,nt,np) :: vdgzm
      type(vvec) :: vwpv,vwmv
      type(hvec) :: vwph,vwmh
      type(vvec) :: fl_cpp,fl_cpm,fl_cmp,fl_cmm
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: dtaw,dtawr,avvr,avvt,avvp,fkr2,fkt2,fkp2,fkdotv
      real(r_typ) :: brv,btv,bpv,bmod
      real(r_typ) :: upwindc_s, upwindc_z, wtd_lambda
      real(r_typ) :: zpx, zmx, o_p, o_m, d1p, d1m, d2p, d2m
      real(r_typ) :: det, dzp, dzm
      real(r_typ) :: d_p, d_p_dzp, d_p_dzm
      real(r_typ) :: d_m, d_m_dzm, d_m_dzp
      real(r_typ) :: beta,fkdotvmx
      integer :: i,j,k,nsteps,it
      real(r_typ),parameter :: zero=0._r_typ
      real(r_typ),parameter :: one =1._r_typ
      real(r_typ),parameter :: two =2._r_typ
      real(r_typ),parameter :: half=0.5_r_typ
      real(r_typ),parameter :: quarter=0.25_r_typ
      real(r_typ),parameter :: csmall=1.0e-16_r_typ
      real(r_typ) :: dt_exp, dt_imp, beta_dt_imp
      real(r_typ) :: vs, rho_factor
!
!-----------------------------------------------------------------------
!
      if (use_timer) call timer (TIME_ADVZW)
!$acc enter data create(logva,logrho,r_1_p,r_1_m,r_2_p,r_2_m,d0,va, &
!$acc                   zpp,zmp,vdgzp,vdgzm)
!
! ****** Allocate the upwind direction coefficients if needed.
!
      if (wtd_use_flux_limiter_gradzw.or. &
          wtd_use_flux_limiter_gradsrc) then
        call alloc_vvec (fl_cpp)
        call alloc_vvec (fl_cpm)
        call alloc_vvec (fl_cmp)
        call alloc_vvec (fl_cmm)
      end if
!
! ****** Set upwind coefficients
!
      upwindc_s=zw_uwc_s
      upwindc_z=zw_uwc_z
!
! ****** Calculate the Alfven speed on the half mesh
! ****** NOTE averaging va across the pole can fix fp errors if you
! ****** are using a non-zero upwindc_s in grad(logva).
!
      call getva_zw (va)
!
! ****** Calculate the wave velocities on the v mesh.
! ****** This is needed for upwind coeffs in v_dot_grad_q
!
      call alloc_vvec (vwpv)
      call alloc_vvec (vwmv)
      call getvaw ( one,va,vwpv)
      call getvaw (-one,va,vwmv)
!
! ****** Calculate the wave velocities on the half mesh.
! ****** This is needed for the all of the terms.
!
      call alloc_hvec (vwph)
      call alloc_hvec (vwmh)
      call getvaw_half ( one,va,vwph)
      call getvaw_half (-one,va,vwmh)
!
! ****** Set the Boundary Conditions
!
      if (wtd_use_open_field_cutoff) then
        call compute_open_field_flux_cutoff
      endif
!
      call setbczw (zp,zm,vwpv,vwmv)
!
! ****** Find the maximum time step allowed for an explicit
! ****** advance (account for both + and - directions).
!
      fkdotvmx=1.e-20_r_typ
!$acc parallel loop collapse(3) default(present) &
!$acc  reduction(max:fkdotvmx)
!$omp parallel do collapse(3) default(shared) &
!$omp reduction(max:fkdotvmx)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
            avvr=AVG(vwph%r,i,j,k)
            avvt=AVG(vwph%t,i,j,k)
            avvp=AVG(vwph%p,i,j,k)
            fkr2=drh_i(i)**2
            fkt2=(rh_i(i)*dth_i(j))**2
            fkp2=(sth_i(j)*rh_i(i)*dp_mult*dph_i(k))**2
            fkdotv=sqrt(fkr2*avvr**2+fkt2*avvt**2+fkp2*avvp**2)
            fkdotvmx=MAX(fkdotvmx,fkdotv)
            avvr=AVG(vwmh%r,i,j,k)
            avvt=AVG(vwmh%t,i,j,k)
            avvp=AVG(vwmh%p,i,j,k)
            fkdotv=sqrt(fkr2*avvr**2+fkt2*avvt**2+fkp2*avvp**2)
            fkdotvmx=MAX(fkdotvmx,fkdotv)
          enddo
        enddo
      enddo
!$omp end parallel do
!
      dtaw=min(dtime,zw_cfl*zw_rho_aw/fkdotvmx)
!
      call global_min (dtaw)
!
! ****** Determine the number of steps. Because of Strang splitting,
! ****** one step is 2 explicit (dtaw), 1 implicit (2x dtaw) updates.
!
      nsteps=ceiling(half*dtime/dtaw)
      if (nsteps.lt.1) nsteps=1
      dtaw=half*dtime/real(nsteps,r_typ)
!
! ****** Keep track of the average time step used.
!
      nszw=nszw+1
      dtzwav=(dtzwav*(nszw-1)+dtaw)/nszw
!
! ****** Calculate the directional upwind coefficients if needed.
!
      if (wtd_use_flux_limiter_gradzw.or. &
          wtd_use_flux_limiter_gradsrc) then
!
        do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
          vs=sign(one, vwpv%r(i,j,k))
          fl_cpp%r(i,j,k)=(one+vs)
          fl_cpm%r(i,j,k)=(one-vs)
          vs=sign(one, vwmv%r(i,j,k))
          fl_cmp%r(i,j,k)=(one+vs)
          fl_cmm%r(i,j,k)=(one-vs)
        enddo
!
        do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
          vs=sign(one, vwpv%t(i,j,k))
          fl_cpp%t(i,j,k)=(one+vs)
          fl_cpm%t(i,j,k)=(one-vs)
          vs=sign(one, vwmv%t(i,j,k))
          fl_cmp%t(i,j,k)=(one+vs)
          fl_cmm%t(i,j,k)=(one-vs)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
          vs=sign(one, vwpv%p(i,j,k))
          fl_cpp%p(i,j,k)=(one+vs)
          fl_cpm%p(i,j,k)=(one-vs)
          vs=sign(one, vwmv%p(i,j,k))
          fl_cmp%p(i,j,k)=(one+vs)
          fl_cmm%p(i,j,k)=(one-vs)
        enddo
      end if
!
! ****** Calculate the RHS Term Coefficients (WKB, Refl, Diss)
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        logrho(i,j,k)=log(abs(rho(i,j,k)))
        logva(i,j,k)=log(abs(va(i,j,k)))
      enddo
!
      if (.not.wtd_use_flux_limiter_gradsrc) then
        call v_dot_grad_q (upwindc_s, logrho, vwmv, vwmh, r_1_p)
        call v_dot_grad_q (upwindc_s, logrho, vwpv, vwph, r_1_m)
        call v_dot_grad_q (upwindc_s, logva,  vwmv, vwmh, r_2_p)
        call v_dot_grad_q (upwindc_s, logva,  vwpv, vwph, r_2_m)
      else
        call v_dot_grad_q_limited (logrho, fl_cmp,fl_cmm, vwmh, r_1_p)
        call v_dot_grad_q_limited (logrho, fl_cpp,fl_cpm, vwph, r_1_m)
        call v_dot_grad_q_limited (logva,  fl_cmp,fl_cmm, vwmh, r_2_p)
        call v_dot_grad_q_limited (logva,  fl_cpp,fl_cpm, vwph, r_2_m)
      end if
!
! ****** Get the Strang split update timesteps
!
      dt_exp=dtaw/zw_rho_aw
      dt_imp=two*dt_exp
      beta_dt_imp=half*dt_imp
!
! ****** Update all the coeffs that don't change during the subcycles.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        r_1_p(i,j,k)=r_1_p(i,j,k)*0.25_r_typ
        r_1_m(i,j,k)=r_1_m(i,j,k)*0.25_r_typ
        r_2_p(i,j,k)=r_2_p(i,j,k)*0.5_r_typ
        r_2_m(i,j,k)=r_2_m(i,j,k)*0.5_r_typ
        brv=AVGTP(b%r,i,j,k)
        btv=AVGRP(b%t,i,j,k)
        bpv=AVGRT(b%p,i,j,k)
        bmod=sqrt(brv**2+btv**2+bpv**2)
        wtd_lambda=wtd_lambda0*sqrt(wtd_b0/(bmod+csmall))
        d0(i,j,k)=0.5_r_typ*wtd_rho_factor(rho(i,j,k))/wtd_lambda
      enddo
!
! ****** Cuttoff the reflection coefficients if using effective rho.
!
      if (wtd_use_zw_effective_rho_limit) then
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          rho_factor=wtd_rho_factor(rho(i,j,k))
          r_2_p(i,j,k)=r_2_p(i,j,k)*rho_factor
          r_2_m(i,j,k)=r_2_m(i,j,k)*rho_factor
        enddo
      end if
!
! ****** Special flags
!
      if (.not.zw_reflection) then
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          r_2_p(i,j,k)=0.
          r_2_m(i,j,k)=0.
        enddo
      end if
!
      if (.not.zw_dissp) then
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          d0(i,j,k)=0.
        enddo
      end if
!
! ****** Advance both Alfven wave amplitudes.
!
      do it=1,nsteps
!
! ****** FIRST ADVECTION STEP: Predictor step.
!
        if (.not.wtd_use_flux_limiter_gradzw) then
          call v_dot_grad_q (upwindc_z, zp, vwpv, vwph, vdgzp)
          call v_dot_grad_q (upwindc_z, zm, vwmv, vwmh, vdgzm)
        else
          call v_dot_grad_q_limited (zp, fl_cpp,fl_cpm, vwph, vdgzp)
          call v_dot_grad_q_limited (zm, fl_cmp,fl_cmm, vwmh, vdgzm)
        end if
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          zpp(i,j,k)=zp(i,j,k)-vdgzp(i,j,k)*dt_exp
          zmp(i,j,k)=zm(i,j,k)-vdgzm(i,j,k)*dt_exp
        enddo
!
! ****** Set boundary conditions.
!
        call setbczw (zpp,zmp,vwpv,vwmv)
!
        call seam_scalar (zpp,nr,nt,np)
        call seam_scalar (zmp,nr,nt,np)
!
! ****** FIRST ADVECTION STEP: Corrector step.
! ****** (mix with implicit update loop over all points).
!
        if (.not.wtd_use_flux_limiter_gradzw) then
          call v_dot_grad_q (upwindc_z, zpp, vwpv, vwph, vdgzp)
          call v_dot_grad_q (upwindc_z, zmp, vwmv, vwmh, vdgzm)
        else
          call v_dot_grad_q_limited (zpp, fl_cpp,fl_cpm, vwph, vdgzp)
          call v_dot_grad_q_limited (zmp, fl_cmp,fl_cmm, vwmh, vdgzm)
        end if
!
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
!
! ****** FIRST ADVECTION STEP: Corrector step advance.
!
          zpx=half*(zp(i,j,k)+zpp(i,j,k)-vdgzp(i,j,k)*dt_exp)
          zmx=half*(zm(i,j,k)+zmp(i,j,k)-vdgzm(i,j,k)*dt_exp)
!
! ****** Get the dissipation terms (need derivatives as well)
!
          d_p=d0(i,j,k)*abs(zmx)*zpx
          d_p_dzp=d0(i,j,k)*abs(zmx)
          d_p_dzm=d0(i,j,k)*sign(1._r_typ,zmx)*zpx
!
          d_m=d0(i,j,k)*abs(zpx)*zmx
          d_m_dzm=d0(i,j,k)*abs(zpx)
          d_m_dzp=d0(i,j,k)*sign(1._r_typ,zpx)*zmx
!
! ****** Implicit source term update for zp,zm at dt=dtaw
! ****** Here S is the source term vector (1=zp, 2=zm)
! ****** and J is the 2x2 Jacobian matrix: dS/dz
!
! ****** matrix diagonal terms: 1-dt*J11, 1-dt*J22
!
          o_p=1._r_typ-beta_dt_imp*(r_1_p(i,j,k)-d_p_dzp)
          o_m=1._r_typ-beta_dt_imp*(r_1_m(i,j,k)-d_m_dzm)
!
! ****** vector source terms: dt*S1, dt*S2
!
          d1p=dt_imp*(r_1_p(i,j,k)*zpx+r_2_p(i,j,k)*zmx-d_p)
          d1m=dt_imp*(r_1_m(i,j,k)*zmx+r_2_m(i,j,k)*zpx-d_m)
!
! ****** matrix cross terms: dt*J12, dt*J21 (neglect minus, it cancels)
!
          d2p=beta_dt_imp*(r_2_p(i,j,k)-d_p_dzm)
          d2m=beta_dt_imp*(r_2_m(i,j,k)-d_m_dzp)
!
! ****** solution: matrix inverse * vector source
!
          det=(o_p*o_m-d2p*d2m)
          dzp=(o_m*d1p+d2p*d1m)/det
          dzm=(o_p*d1m+d2m*d1p)/det
!
! ****** don't need dt here because it is in vector source terms already
!
          zp(i,j,k)=zpx+dzp
          zm(i,j,k)=zmx+dzm
        enddo
!
! ****** Set boundary conditions (after implicit update).
!
        call setbczw (zp,zm,vwpv,vwmv)
!
        call seam_scalar (zp,nr,nt,np)
        call seam_scalar (zm,nr,nt,np)
!
! ****** SECOND ADVECTION STEP: Predictor step.
!
        if (.not.wtd_use_flux_limiter_gradzw) then
          call v_dot_grad_q (upwindc_z, zp, vwpv, vwph, vdgzp)
          call v_dot_grad_q (upwindc_z, zm, vwmv, vwmh, vdgzm)
        else
          call v_dot_grad_q_limited (zp, fl_cpp,fl_cpm, vwph, vdgzp)
          call v_dot_grad_q_limited (zm, fl_cmp,fl_cmm, vwmh, vdgzm)
        end if
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          zpp(i,j,k)=zp(i,j,k)-vdgzp(i,j,k)*dt_exp
          zmp(i,j,k)=zm(i,j,k)-vdgzm(i,j,k)*dt_exp
        enddo
!
! ****** Set boundary conditions.
!
        call setbczw (zpp,zmp,vwpv,vwmv)
!
        call seam_scalar (zpp,nr,nt,np)
        call seam_scalar (zmp,nr,nt,np)
!
! ****** SECOND ADVECTION STEP: Corrector step.
!
        if (.not.wtd_use_flux_limiter_gradzw) then
          call v_dot_grad_q (upwindc_z, zpp, vwpv, vwph, vdgzp)
          call v_dot_grad_q (upwindc_z, zmp, vwmv, vwmh, vdgzm)
        else
          call v_dot_grad_q_limited (zpp, fl_cpp,fl_cpm, vwph, vdgzp)
          call v_dot_grad_q_limited (zmp, fl_cmp,fl_cmm, vwmh, vdgzm)
        end if
!
        do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
          zp(i,j,k)=half*(zp(i,j,k)+zpp(i,j,k)-vdgzp(i,j,k)*dt_exp)
          zm(i,j,k)=half*(zm(i,j,k)+zmp(i,j,k)-vdgzm(i,j,k)*dt_exp)
        enddo
!
! ****** Apply an amplitude limit
!
        if (wtd_use_zw_limit) then
          do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
            zp(i,j,k)=MAX(zp(i,j,k),-zwlimit(i))
            zp(i,j,k)=MIN(zp(i,j,k), zwlimit(i))
            zm(i,j,k)=MAX(zm(i,j,k),-zwlimit(i))
            zm(i,j,k)=MIN(zm(i,j,k), zwlimit(i))
          enddo
        end if
!
! ****** Set boundary conditions.
!
        call setbczw (zp,zm,vwpv,vwmv)
!
        call seam_scalar (zp,nr,nt,np)
        call seam_scalar (zm,nr,nt,np)
!
        if (pole_filter_z) then
          call smooth_poles_scalars (zp)
          call smooth_poles_scalars (zm)
        end if
!
      enddo
!
      call dealloc_vvec (vwpv)
      call dealloc_vvec (vwmv)
      call dealloc_hvec (vwph)
      call dealloc_hvec (vwmh)
!
      if (wtd_use_flux_limiter_gradzw.or. &
          wtd_use_flux_limiter_gradsrc) then
        call dealloc_vvec (fl_cpp)
        call dealloc_vvec (fl_cpm)
        call dealloc_vvec (fl_cmp)
        call dealloc_vvec (fl_cmm)
      end if
!
!$acc exit data delete(logva,logrho,r_1_p,r_1_m,r_2_p,r_2_m,d0,va, &
!$acc                  zpp,zmp,vdgzp,vdgzm)
      if (use_timer) call timer (TIME_ADVZW)
!
end subroutine
!#######################################################################
subroutine init_zw
!
!-----------------------------------------------------------------------
!
! ****** Initialize the WTD model.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use seam_interface
      use alfven_wave_pressure
      use wtd
      use ucase_interface
      use mesh, ONLY : rh
      use vars
      use io_units
      use mpidefs
      use restart
      use global_to_local_tp_interface
      use field_table
      use write_field_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      integer :: ierr_bc=0, ierr_flux=0, ierr_ic=1, ierr_config=0
      real(r_typ), parameter :: negquarter=-0.25_r_typ
      real(r_typ), parameter :: four=4.0_r_typ
      integer, parameter :: ntest=8
      real(r_typ), dimension(ntest) :: b_test
      real(r_typ), dimension(ntest) :: z_out
      real(r_typ) :: avbr
      real(r_typ) :: scale_height
      real(r_typ), dimension(nt_g,np_g) :: z0_flux_mask_g
!
!-----------------------------------------------------------------------
!
! ****** initialize the zp, zm initial conditions
!
!-----------------------------------------------------------------------
!
! ****** If it is not a restart or has been loaded already,
! ****** set initial conditions.
!
      if (.not.(restart_run.or.ucase(wtd_icond).eq.'FROM_INIT_3D')) then
!
        if (ucase(wtd_icond).eq.'WKB') then
          do k=1,np
            do j=1,nt
              do i=1,nr
                zp(i,j,k)=wtd_z0*(rho(i,j,k)/rho0)**negquarter*wtd_icfac
               zm(i,j,k)=-wtd_z0*(rho(i,j,k)/rho0)**negquarter*wtd_icfac
              enddo
            enddo
          enddo
          ierr_ic=0
        end if
!
! ****** Loop over the initial condition options.
!
        if (ucase(wtd_icond).eq.'WKB_BR') then
          do k=2,npm1
            do j=2,ntm1
              do i=2,nrm1
                avbr=AVGTP(b%r,i,j,k)
                if (avbr .gt. 0._r_typ) zp(i,j,k)= &
                          wtd_z0*(rho(i,j,k)/rho0)**negquarter*wtd_icfac
                if (avbr .lt. 0._r_typ) zm(i,j,k)= &
                         -wtd_z0*(rho(i,j,k)/rho0)**negquarter*wtd_icfac
              enddo
            enddo
          enddo
          call seam(zp)
          call seam(zm)
          ierr_ic=0
        end if
!
        if (ucase(wtd_icond).eq.'FROM_FILE') then
          call read_zw_profile (wtd_ic1dfile)
          do k=2,npm1
            do j=2,ntm1
              do i=2,nrm1
                zp(i,j,k)=zp(i,j,k)*wtd_icfac
                zm(i,j,k)=zm(i,j,k)*wtd_icfac
              enddo
            enddo
          enddo
          call seam(zp)
          call seam(zm)
          ierr_ic=0
        end if
!
        if (ucase(wtd_icond).eq.'CONSTANT') then
          zp= wtd_icfac
          zm=-wtd_icfac
          ierr_ic=0
        end if
!
        if (ucase(wtd_icond).eq.'EPEM') then
          do k=1,np
            do j=1,nt
              do i=1,nr
                zp(i,j,k)= sqrt(ep(i,j,k)*four/rho(i,j,k))
                zm(i,j,k)=-sqrt(em(i,j,k)*four/rho(i,j,k))
              enddo
            enddo
          enddo
          ierr_ic=0
        end if
!
        if (iamp0) then
          if (ierr_ic.ne.0) then
            write (9,*)
            write (9,*) '### ERROR in INIT_ZW:'
            write (9,*) '### Initial Condition for z+,z- is not'// &
                        ' recognized: ',wtd_icond
              write (*,*) '### Please check the name of wtd_icond.'
          else
            write (9,*)
            write (9,*) '### COMMENT from INIT_ZW:'
            write (9,*) '### Initial Condition for z+,z- is: ',wtd_icond
          end if
        end if
        call check_error_on_any_proc (ierr_ic)
!
      end if
!
! ****** check reflective BC type
! ****** use integers to avoid string manipulation inside loops
!
      if (ucase(wtd_reflect_bc).eq.'NONE') IRBC_TYPE=IRBC_NONE
      if (ucase(wtd_reflect_bc).eq.'CONS') IRBC_TYPE=IRBC_CONS
      if (ucase(wtd_reflect_bc).eq.'AMPL') IRBC_TYPE=IRBC_AMPL
!
! ****** check if IRBC was not set, crash if so
!
      if (IRBC_TYPE.lt.0) ierr_bc=1
!
      if (iamp0) then
        if (ierr_bc.ne.0) then
          write (9,*)
          write (9,*) '### ERROR in INIT_ZW:'
          write (9,*) '### Reflective BC requested for z+,z- is not'// &
                      ' recognized: ',wtd_reflect_bc
          write (9,*) '### Please check the name of wtd_reflect_bc.'
        else
          write (9,*)
          write (9,*) '### COMMENT from INIT_ZW:'
          write (9,*) '### Reflective BC for z+,z- is: ',wtd_reflect_bc
        end if
      end if
      call check_error_on_any_proc (ierr_bc)
!
! ****** Setup the z0 flux mask if requested.
!
      if (wtd_use_zw_flux_mask) then
!
        allocate (z0_flux_mask(nt,np))
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INIT_ZW'
          write (9,*) '### Reading zw0 flux mask profile from file: ', &
                        trim(z0_flux_mask_tp_file)
!
          call read_tp_interp_hh ( z0_flux_mask_tp_file, &
                                   z0_flux_mask_g,1,ierr_bc)
          write (9,*) '  The square root of this profile will'
          write (9,*) '  multiply wtd_z0 at the boundary.'
!
          if (ierr_bc.ne.0) then
            write (9,*)
            write (9,*) '### ERROR in INIT_ZW:'
            write (9,*) '### Failed to read zw0 mask profile!'
          end if
!
        end if
        call check_error_on_p0 (ierr_bc)
!
        call global_to_local_tp (z0_flux_mask_g,z0_flux_mask)
!
! ****** take the square root since flux is prop to z0^2.
!
        z0_flux_mask(:,:)=sqrt(z0_flux_mask(:,:))
!
        if (iamp0) then
          write (9,*)
          write (9,*) '### COMMENT from INIT_ZW'
          write (9,*) '### Writing sqrt of interpolated flux mask'
          write (9,*) '### wtd_z0_flux_mask'
        end if
        call write_field_tp ('wtd_z0_flux_mask.h5', &
                              IFLD_ZP,z0_flux_mask,0)
!
!$acc enter data copyin(z0_flux_mask)
      end if
!
! ****** Check settings for the optional open field cutoff.
!
      if (wtd_use_open_field_cutoff) then
!
        if (.not.advance_pw.or.pw0<=0.0_r_typ) then
          ierr_config=1
          if (iamp0) then
              write (9,*)
              write (9,*) '### ERROR in INIT_ZW:'
              write (9,*) '### ep and em are required if using the '
              write (9,*) '### Poynting flux limiter for WTD!'
              write (9,*) '### Set advance_pw=.true. and pw0 to a'
              write (9,*) '### value greater than 0! This run had:'
              write (9,*) '###   advance_pw: ', advance_pw
              write (9,*) '###   pw0: ', pw0
          end if
          call check_error_on_p0 (ierr_config)
        endif
!
        if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from INIT_ZW'
              write (9,*) '### The Poynting flux limiter for open'
              write (9,*) '### fields in the WTD model is active!'
              write (9,*) '###   maxflux [erg cm-2 s-1]:', &
                                 wtd_open_cutoff_maxflux
              write (9,*) '###   eq time [s]:', wtd_open_cutoff_dt_eq_s
        endif
!
        allocate (wtd_open_flux_zmult(nt,np))
        allocate (wtd_mask_open(nt,np))
        allocate (wtd_net_pflux(nt,np))
!
! ****** Initialize default values (slices on first step will have them).
!
        wtd_open_flux_zmult(:,:)=1.0_r_typ
        wtd_mask_open(:,:)=0.0_r_typ
        wtd_net_pflux(:,:)=1.0_r_typ
!
! ****** If this is a restart run, load and overwrite the default zmult.
!
        if (restart_run) then
          call read_open_cutoff_from_restart (rs_i(1)%fname)
        endif
!
!$acc enter data copyin(wtd_open_flux_zmult,wtd_mask_open,wtd_net_pflux)
      endif
!
! ****** Check the flux-limiter type.
! ****** Use integers to avoid string manipulation inside loops.
!
      if (ucase(zw_flux_limiter_type).eq.'OSPRE')  IFLUX=IFLUX_ospre
      if (ucase(zw_flux_limiter_type).eq.'MINMOD') IFLUX=IFLUX_minmod
!
! ****** Check if IFLUX was not set, crash if so.
!
      if (IFLUX.lt.0) ierr_flux=1
!
      if (iamp0) then
        if (ierr_flux.ne.0) then
          write (9,*)
          write (9,*) '### ERROR in INIT_ZW:'
          write (9,*) '### Flux limiter requested for the z+,z-' // &
                      ' advance is not recognized!'
          write (9,*) '### zw_flux_limiter_type: ', zw_flux_limiter_type
          write (9,*) '### Please check zw_flux_limiter_type.'
        else
          write (9,*)
          write (9,*) '### COMMENT from INIT_ZW:'
          write (9,*) '### Flux limiter for z+,z- is: ', &
                           zw_flux_limiter_type
        end if
      end if
      call check_error_on_any_proc (ierr_flux)
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from INIT_ZW:'
        write (9,'(a,F10.4)') ' zw_heat_factor: ', zw_heat_factor
        write (9,'(a,F10.4)') ' zw_pressure_factor: ', &
                                                  zw_pressure_factor
      end if
!
! ******* ZW limiter, load the radial amplitude limit if desired
!
      if (wtd_use_zw_limit) then
        zwlimit(:)=HUGE(1.0_r_typ)
        if (zw_limit_radial_file.ne.' ') then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from INIT_ZW:'
            write (9,*) 'Reading radial zw limit file: ', &
                         trim(zw_limit_radial_file)
          end if
          call read_zw_limit_file (zw_limit_radial_file)
        end if
!
! ******* Overwrite with the max amplitude specified as well
!
        do i=1,nr
          zwlimit(i)=min(zwlimit(i),zw_limit_amplitude)
        enddo
!
        if (iamp0) then
          write (IO_OUT,*)
          write (IO_OUT,*) '### COMMENT from INIT_ZW:'
          write (IO_OUT,*) 'zw limit is the following on p0'
          do i=1,nr
            write (IO_OUT,*) 'i, rh, zwlimit',i,' ',rh(i),' ',zwlimit(i)
          enddo
          FLUSH (IO_OUT)
        end if
!
!$acc update device(zwlimit)
      end if
!
end subroutine
!#######################################################################
subroutine setbczw (zpt,zmt,vawp,vawm)
!
!-----------------------------------------------------------------------
!
! ****** Set the Alfven wave amplitudes zp,zm at the radial
! ****** boundaries.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use fields
      use vars
      use wtd
      use interplanetary_vars
      use mesh
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vawp
      type(vvec) :: vawm
      real(r_typ), dimension(nr,nt,np) :: zpt
      real(r_typ), dimension(nr,nt,np) :: zmt
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: zpbcr0, zmbcr0, zpbcr1, zmbcr1
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: one =1.0_r_typ
      real(r_typ), parameter :: two =2._r_typ
      real(r_typ), parameter :: csmall=1.e-16_r_typ
      real(r_typ) :: brv,btv,bpv,bmod,inc
      real(r_typ) :: zpex, zmex, pwex, factor, cutpw, cutb, zcut
      logical :: setbcp, setbcm
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      if (rb0) then
!
        if (.not.interplanetary_run) then
          do concurrent (k=2:npm1, j=2:ntm1)
!
! ****** get the extrapolated values
!
            zpex=EXTRAPR0H(zpt,   2,j,k)
            zmex=EXTRAPR0H(zmt,   2,j,k)
!
! ****** get the boundary values
!
            setbcp=.false.
            setbcm=.false.
!
! ****** zp at r0
!
            if (vawp%r(1,j,k).ge.zero) then
              setbcp=.true.
              zpbcr0=wtd_z0
              if (wtd_use_zw_flux_mask) then
                zpbcr0=zpbcr0*z0_flux_mask(j,k)
              end if
              if (wtd_use_open_field_cutoff) then
                zpbcr0=zpbcr0*wtd_open_flux_zmult(j,k)
              endif
            else
              zpbcr0=zpex
            end if
!
! ****** zm at r0
!
            if (vawm%r(1,j,k).ge.zero) then
              setbcm=.true.
              zmbcr0=-wtd_z0
              if (wtd_use_zw_flux_mask) then
                zmbcr0=zmbcr0*z0_flux_mask(j,k)
              end if
              if (wtd_use_open_field_cutoff) then
                zmbcr0=zmbcr0*wtd_open_flux_zmult(j,k)
              endif
            else
              zmbcr0=zmex
            end if
!
! ****** if neither wave velocities are outwards set them to zero
!
            if ((.not.setbcp).and.(.not.setbcm)) then
              zpbcr0=zero
              zmbcr0=zero
!            write(*,*) ''
!            write(*,*) '### SETBCZW '
!            write(*,*) 'both waves inward at j,k:',j-1+j0_g,k-1+k0_g
!            write(*,*) ''
            end if
!
! ****** if both wave velocities are outwards set them to zero
!
            if (setbcp.and.setbcm) then
              zpbcr0=zero
              zmbcr0=zero
!            write(*,*) ''
!            write(*,*) '### SETBCZW '
!            write(*,*) 'both waves outward at j,k:',j-1+j0_g,k-1+k0_g
!            write(*,*) ''
            end if
!
! ****** Apply Reflective BCs
!
            if (IRBC_TYPE .eq. IRBC_CONS) then
              if (vawm%r(1,j,k).lt.zero) &
                           zpbcr0= sqrt(zpbcr0**2+zmbcr0**2)
              if (vawp%r(1,j,k).lt.zero) &
                           zmbcr0=-sqrt(zpbcr0**2+zmbcr0**2)
            elseif (IRBC_TYPE .eq. IRBC_AMPL) then
              if (vawm%r(1,j,k).lt.zero) zpbcr0=zpbcr0+zmbcr0
              if (vawp%r(1,j,k).lt.zero) zmbcr0=zpbcr0+zmbcr0
            end if
!
! ****** Update the fields
!
            zpt(1,j,k)=two*zpbcr0-zpt(2,j,k)
            zmt(1,j,k)=two*zmbcr0-zmt(2,j,k)
          enddo
        else
!
! ****** Interplanetary run
!
          do concurrent (k=2:npm1, j=2:ntm1)
            zpt(1,j,k)=two*zpbcr0re(j,k)-zpt(2,j,k)
            zmt(1,j,k)=two*zmbcr0re(j,k)-zmt(2,j,k)
          enddo
        end if
!
      end if !rb0
!
      if (rb1) then
!
        do concurrent (k=2:npm1, j=2:ntm1)
!
          if (vawp%r(nrm1,j,k).le.zero) then
            zpbcr1=zero
!            zpbcr1=EXTRAPR1H(zpt,nrm1,j,k)
          else
            zpbcr1=EXTRAPR1H(zpt,nrm1,j,k)
          end if
!
          if (vawm%r(nrm1,j,k).le.zero) then
            zmbcr1=zero
!            zmbcr1=EXTRAPR1H(zmt,nrm1,j,k)
          else
            zmbcr1=EXTRAPR1H(zmt,nrm1,j,k)
          end if
!
          zpt(nr,j,k)=two*zpbcr1-zpt(nrm1,j,k)
          zmt(nr,j,k)=two*zmbcr1-zmt(nrm1,j,k)
!
        enddo
!
      end if
!
! ****** Theta boundaries.
!
      call set_pole_bc_scalar_hhh (zpt)
      call set_pole_bc_scalar_hhh (zmt)
!
end subroutine
!#######################################################################
subroutine v_dot_grad_q (upwind_q,q,vv,vh,vdgq)
!
!-----------------------------------------------------------------------
!
! ****** Compute v dot grad(q) and return it in array vdgq.
! ******  vv is on the v mesh, vh is on half mesh.
! ******  vv is used for the upwinding coeff, vh, for the v dot.
! ******  the upwinding form comes from the divqv routine
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: upwind_q
      real(r_typ), dimension(nr,nt,np) :: q,vdgq
      type(vvec) :: vv
      type(hvec) :: vh
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: vrm,vrp,crm,crp
      real(r_typ) :: vtm,vtp,ctm,ctp
      real(r_typ) :: vpm,vpp,cpm,cpp
!
!-----------------------------------------------------------------------
!
! ****** Zero out the VDGQ array.
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        vdgq(i,j,k)=0.
      enddo
!
! ****** Compute v dot grad q.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        vrp=AVG(vv%r,i  ,j  ,k  )
        vrm=AVG(vv%r,i-1,j  ,k  )
        vtp=AVG(vv%t,i  ,j  ,k  )
        vtm=AVG(vv%t,i  ,j-1,k  )
        vpp=AVG(vv%p,i  ,j  ,k  )
        vpm=AVG(vv%p,i  ,j  ,k-1)
        crp=sign(upwind_q,vrp)
        crm=sign(upwind_q,vrm)
        ctp=sign(upwind_q,vtp)
        ctm=sign(upwind_q,vtm)
        cpp=sign(upwind_q,vpp)
        cpm=sign(upwind_q,vpm)
        vdgq(i,j,k)=vh%r(i,j,k)*(ADVR(q,i+1,j,k,crp)- &
                       ADVR(q,i  ,j,k,crm))*drh_i(i) &
                   +vh%t(i,j,k)*(ADVT(q,i,j+1,k,ctp)- &
                       ADVT(q,i,j  ,k,ctm))*rh_i(i)*dth_i(j) &
                   +vh%p(i,j,k)*(ADVP(q,i,j,k+1,cpp)- &
                       ADVP(q,i,j,k  ,cpm))*rh_i(i)*sth_i(j)*dph_i(k)
      enddo
!
end subroutine
!#######################################################################
subroutine v_dot_grad_q_limited (q,fl_cp,fl_cm,vh,vdgq)
!
!-----------------------------------------------------------------------
!
! ****** Compute v dot grad(q) and return it in array vdgq.
! ******  vv is on the v mesh, vh is on half mesh.
! ******  vv is used for determinig the limited states, while vh
! ******  is used for the v dot.
!
! ****** The limiting is calculated using standard flux-limiter style.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: q,vdgq
      type(hvec) :: vh
      type(vvec) :: fl_cp,fl_cm
!
!-----------------------------------------------------------------------
!
      type(vvec) :: rr,phi,qlim
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: vs,qlow,qhigh
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Allocate the arrays on the main mesh.
!
      call alloc_vvec (rr)
      call alloc_vvec (phi)
      call alloc_vvec (qlim)
!
! ****** Get the flux limiter coefficients
!
      call get_steepness_indicator (q,rr,fl_cp,fl_cm)
      call get_flux_limiter (rr, phi)
!
! ****** Compute the high and low resolution reconstructions.
!
!
! ****** R-direction
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        qlow =half*( fl_cp%r(i,j,k)*q(i  ,j  ,k  ) + &
                     fl_cm%r(i,j,k)*q(i+1,j  ,k  ))
        qhigh=half*( q(i+1,j,k)+q(i,j,k))
        qlim%r(i,j,k)=qlow-phi%r(i,j,k)*(qlow-qhigh)
      enddo
!
! ****** T-direction
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        qlow =half*( fl_cp%t(i,j,k)*q(i  ,j  ,k  ) + &
                     fl_cm%t(i,j,k)*q(i  ,j+1,k  ))
        qhigh=half*( q(i,j+1,k)+q(i,j,k))
        qlim%t(i,j,k)=qlow-phi%t(i,j,k)*(qlow-qhigh)
      enddo
!
! ****** P-direction
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        qlow =half*( fl_cp%p(i,j,k)*q(i  ,j  ,k  ) + &
                     fl_cm%p(i,j,k)*q(i  ,j  ,k+1))
        qhigh=half*( q(i,j,k+1)+q(i,j,k))
        qlim%p(i,j,k)=qlow-phi%p(i,j,k)*(qlow-qhigh)
      enddo
!
! ****** Compute v dot grad q.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm1)
        vdgq(i,j,k)= vh%r(i,j,k)*drh_i(i)* &
                       ( qlim%r(i,j,k)-qlim%r(i-1,j,k)) + &
                     vh%t(i,j,k)*rh_i(i)*dth_i(j)* &
                       ( qlim%t(i,j,k)-qlim%t(i,j-1,k)) + &
                     vh%p(i,j,k)*sth_i(j)*dph_i(k)* &
                       ( qlim%p(i,j,k)-qlim%p(i,j,k-1))
      enddo
!
      call dealloc_vvec (rr)
      call dealloc_vvec (phi)
      call dealloc_vvec (qlim)
!
end subroutine
!#######################################################################
subroutine get_steepness_indicator (qq,rr,fl_cp,fl_cm)
!
!-----------------------------------------------------------------------
!
! ****** Compute the flux limiter function (phi) at the diagonal
! ****** cell interfaces for a variable on the half mesh. This means
! ****** that phi is on the vmesh
!
! ****** The velocity at these locations (vmesh) is used to determine
! ****** the upwind direction
!
! ****** This style/notation is follows the standard flux limiter
! ****** conventions.
! ****** rr:  is the steepness indicator
!
! ****** NOTE: The two seams for each direction are there because
! ******       I need q(i+1)-q(i) at both sides of the mesh. This can
! ******       be done by first seaming q(i+1)-q(i) and then seaming
! ******       the steepness indicator on its main mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: rr,fl_cp,fl_cm
      real(r_typ), dimension(nr,nt,np) :: qq
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nr,nt,np) :: diffp
      real(r_typ) :: coeff, vsgn, rp, rm
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!$acc enter data create(diffp)
!
! ****** Steepness in R direction
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        diffp(i,j,k)=qq(i+1,j,k)-qq(i,j,k)
      enddo
      call seam_scalar_xd (diffp,nr,nt,np,.true.,.false.,.false.)
!
      do concurrent (k=2:npm1,j=2:ntm1,i=2:nrm-1)
        rp=MAX(diffp(i-1,j,k)/diffp(i,j,k),zero)
        rm=MAX(diffp(i+1,j,k)/diffp(i,j,k),zero)
        rr%r(i,j,k)=half*(fl_cp%r(i,j,k)*rp+fl_cm%r(i,j,k)*rm)
      enddo
      call seam_scalar_xd (rr%r,nrm,nt,np,.true.,.false.,.false.)
!
! ****** Steepness in T direction
!
      do concurrent (k=2:npm1,j=1:ntm1,i=2:nrm1)
        diffp(i,j,k)=qq(i,j+1,k)-qq(i,j,k)
      enddo
      call seam_scalar_xd (diffp,nr,nt,np,.false.,.true.,.false.)
!
      do concurrent (k=2:npm1,j=2:ntm-1,i=2:nrm1)
        rp=MAX(diffp(i,j-1,k)/diffp(i,j,k),zero)
        rm=MAX(diffp(i,j+1,k)/diffp(i,j,k),zero)
        rr%t(i,j,k)=half*(fl_cp%t(i,j,k)*rp+fl_cm%t(i,j,k)*rm)
      enddo
      call seam_scalar_xd (rr%t,nr,ntm,np,.false.,.true.,.false.)
!
! ****** phi in P direction
!
      do concurrent (k=1:npm1,j=2:ntm1,i=2:nrm1)
        diffp(i,j,k)=qq(i,j,k+1)-qq(i,j,k)
      enddo
      call seam_scalar_xd (diffp,nr,nt,np,.false.,.false.,.true.)
!
      do concurrent (k=2:npm-1, j=2:ntm1,i=2:nrm1)
        rp=MAX(diffp(i,j,k-1)/diffp(i,j,k),zero)
        rm=MAX(diffp(i,j,k+1)/diffp(i,j,k),zero)
        rr%p(i,j,k)=half*(fl_cp%p(i,j,k)*rp+fl_cm%p(i,j,k)*rm)
      enddo
      call seam_scalar_xd (rr%p,nr,nt,npm,.false.,.false.,.true.)
!
!$acc exit data delete (diffp)
end subroutine
!#######################################################################
subroutine get_flux_limiter (rr, phi)
!
!-----------------------------------------------------------------------
!
! ****** Compute the flux limiter function (phi) at the diagonal
! ****** cell interfaces for a variable on the half mesh. This means
! ****** that phi is on the vmesh
!
! ****** This routine takes the steepness indicator (calculated in
! ****** get_steepness_indicator) and computs the flux_limiter function
!
! ****** This style/notation is follows the standard flux limiter
! ****** conventions.
! ****** rr:  is the steepness indicator
! ****** phi: is the flux limiter function
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: rr, phi
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ), parameter :: onep5=1.5_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
! ****** OSPRE LIMITER
!
      if (iFLUX.eq.iFLUX_ospre) then
        call flux_limiter_ospre( &
               rr%r, phi%r, 1,nrm-1, 2,ntm1,  2,npm1,  nrm, nt, np)
        call flux_limiter_ospre( &
               rr%t, phi%t, 2,nrm1,  1,ntm-1, 2,npm1,  nr, ntm, np)
        call flux_limiter_ospre( &
               rr%p, phi%p, 2,nrm1,  2,ntm1,  1,npm-1, nr, nt, npm)
      end if
!
! ****** MinMod LIMITER
!
      if (iFLUX.eq.iFLUX_minmod) then
        call flux_limiter_minmod( &
               rr%r, phi%r, 1,nrm-1, 2,ntm1,  2,npm1,  nrm, nt, np)
        call flux_limiter_minmod( &
               rr%t, phi%t, 2,nrm1,  1,ntm-1, 2,npm1,  nr, ntm, np)
        call flux_limiter_minmod( &
               rr%p, phi%p, 2,nrm1,  2,ntm1,  1,npm-1, nr, nt, npm)
      end if
!
! ****** R Boundary Conditions
!
      if (rb0) then
        do concurrent (k=2:npm1, j=2:ntm1)
          phi%r(1,j,k)=phi%r(2,j,k)
        enddo
      end if
      if (rb1) then
        do concurrent (k=2:npm1, j=2:ntm1)
          phi%r(nrm1,j,k)=phi%r(nrm1-1,j,k)
        enddo
      end if
!
! ****** T Boundary Conditions
!
      if (tb0) then
        do concurrent (k=2:npm1, i=2:nrm1)
          phi%t(i,1,k)=phi%t(i,2,k)
        enddo
      end if
      if (tb1) then
        do concurrent (k=2:npm1, i=2:nrm1)
          phi%t(i,ntm1,k)=phi%t(i,ntm1-1,k)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine flux_limiter_ospre (rr,phi,i0,i1,j0,j1,k0,k1,ni,nj,nk)
!
!-----------------------------------------------------------------------
!
! ****** Compute the ospre flux limiter function over the specified
! ****** indexes of an array
!
! ****** This style/notation is follows the standard flux limiter
! ****** conventions.
! ****** rr:  is the steepness indicator
! ****** phi: is the flux limiter function
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
      integer, intent(in) :: ni,nj,nk
      real(r_typ), intent(in), dimension(ni,nj,nk) :: rr
      real(r_typ), intent(inout), dimension(ni,nj,nk) :: phi
      integer, intent(in) :: i0,i1,j0,j1,k0,k1
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ), parameter :: zero =0.0_r_typ
      real(r_typ), parameter :: one  =1.0_r_typ
      real(r_typ), parameter :: onep5=1.5_r_typ
!
!-----------------------------------------------------------------------
!
      do concurrent (k=k0:k1, j=j0:j1, i=i0:i1)
        phi(i,j,k)=MAX(onep5*( rr(i,j,k)**2+rr(i,j,k)) &
                       /( rr(i,j,k)**2+rr(i,j,k)+one), zero)
      enddo
!
end subroutine
!#######################################################################
subroutine flux_limiter_minmod (rr,phi,i0,i1,j0,j1,k0,k1,ni,nj,nk)
!
!-----------------------------------------------------------------------
!
! ****** Compute the minmod flux limiter function over the specified
! ****** indexes of an array
!
! ****** This style/notation is follows the standard flux limiter
! ****** conventions.
! ****** rr:  is the steepness indicator
! ****** phi: is the flux limiter function
!
!-----------------------------------------------------------------------
!
      use number_types
!
!-----------------------------------------------------------------------
!
      implicit none
!
      integer, intent(in) :: ni,nj,nk
      real(r_typ), intent(in), dimension(ni,nj,nk) :: rr
      real(r_typ), intent(inout), dimension(ni,nj,nk) :: phi
      integer, intent(in) :: i0,i1,j0,j1,k0,k1
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ), parameter :: zero=0.0_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
!
!-----------------------------------------------------------------------
!
      do concurrent (k=k0:k1, j=j0:j1, i=i0:i1)
        phi(i,j,k)=MAX(zero,MIN(one,rr(i,j,k)))
      enddo
!
end subroutine
!#######################################################################
subroutine get_fpw (f)
!
!-----------------------------------------------------------------------
!
! ****** Compute the wave pressure force: F=-grad(pw)
!
! ****** This is in a separate routine to save a force vector and be
! ****** the same style as other formulations of the pw force
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use fields, ONLY : b, zp, zm, rho, ep, em, pres
      use wtd, ONLY : wtd_add_zw_pressure,zw_pressure_factor
      use vars, ONLY : advance_pw,advance_zw
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: f
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: eighth=0.125_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ), parameter :: half=0.5_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: pwe,pwz
      real(r_typ), dimension(nr,nt,np) :: pwhhh
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
!$acc enter data create(pwhhh)
      pwe=0.
      pwz=0.
!
! ****** Get pw on hhh mesh first
!
      do concurrent (k=1:np, j=1:nt, i=1:nr)
        if (advance_pw) pwe=half*(ep(i,j,k)+em(i,j,k))
        if (advance_zw.and.wtd_add_zw_pressure) then
          pwz=eighth*rho(i,j,k)*(zm(i,j,k)-zp(i,j,k))**2
          pwhhh(i,j,k)=(one-zw_pressure_factor)*pwe &
                            +(zw_pressure_factor)*pwz
        else
          pwhhh(i,j,k)=pwe
        end if
      enddo
!
! ****** R component of the force (vr, is on mhh)
!
      do concurrent (k=2:npm1, j=2:ntm1, i=2:nrm-1)
        f%r(i,j,k)=-(pwhhh(i+1,j  ,k  ) &
                    -pwhhh(i  ,j  ,k  ))*dr_i(i)
      enddo
!
! ****** T component of the force (vt, is on hmh)
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        f%t(i,j,k)= -( pwhhh(i  ,j+1,k  ) &
                      -pwhhh(i  ,j  ,k  ))*rh_i(i)*dt_i(j)
      enddo
!
! ****** P component of the force (vp is on hhm)
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        f%p(i,j,k)= -( pwhhh(i  ,j  ,k+1) &
                      -pwhhh(i  ,j  ,k  ))*rh_i(i)*sth_i(j)*dp_i(k)
      enddo
!
! ****** No seam is needed here since boundaries of f are never used.
!
!$acc exit data delete(pwhhh)
end subroutine
!#######################################################################
pure function wtd_rho_factor(rho_mas)
!$acc routine(wtd_rho_factor) seq
!
!-----------------------------------------------------------------------
!
! ****** gets the coefficient to floor the rho dependence of WTD heating
!
!-----------------------------------------------------------------------
!
      use number_types
      use wtd, ONLY : wtd_use_zw_effective_rho_limit, &
                      zw_effective_rho_limit_lr, &
                      zw_effective_rho_limit_lw
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), intent(in) :: rho_mas
      real(r_typ) :: wtd_rho_factor
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: one =1.0_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Density based tanh on/off switch for WTD coefficients.
!
      if (wtd_use_zw_effective_rho_limit) then
        wtd_rho_factor=half*(one- &
             tanh((log10(rho_mas)-zw_effective_rho_limit_lr)/ &
                                  zw_effective_rho_limit_lw))
      else
        wtd_rho_factor=one
      end if
!
      return
end function
!#######################################################################
subroutine read_zw_limit_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Load in a 1D profile that sets the amplitude limit for zp,zm
!
!-----------------------------------------------------------------------
!
! ****** Values for zmax are read in as a function of r
!
! ****** NP1D is the number of radial points in the file.
!
! ****** Note! This does not rescale the file to use input file's z0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh, ONLY : rh
      use fields, ONLY : zwlimit
      use mpidefs
      use globals
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), allocatable ::  rt(:), zwt(:)
      real(r_typ) ::  alpha,fac,fac2
      integer :: ierr,np1d,ir,irp1,i,j,k
!
!-----------------------------------------------------------------------
!
      if (iamp0) then
        call ffopen (43,fname,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        np1d=-1
        do
          read (43,'(a)',err=100,end=100)
          np1d=np1d+1
        enddo
  100   continue
        close (43)
      end if
!
! ****** Broadcast the number of lines to all processors.
!
      call MPI_Bcast (np1d,1,MPI_Integer,0,MPI_COMM_WORLD,ierr)
      call check_error_on_any_proc (ierr)
!
! ****** Allocate storage for the fields to be read.
!
      allocate (rt(np1d))
      allocate (zwt(np1d))
!
! ****** Read the input file (only on processor IPROC0).
!
      if (iamp0) then
        call ffopen (43,fname,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        read (43,*)
        do i=1,np1d
          read (43,*) rt(i),zwt(i)
        enddo
        close (43)
      end if
!
! ****** Broadcast the values to all processors.
!
      call MPI_Bcast (rt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (zwt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call check_error_on_any_proc (ierr)
!
! ****** Interpolate to the code mesh
! ****** note that zwlimit is only used on interior points.
!
      do i=2,nrm1
        call interp (np1d,rt,rh(i),ir,irp1,alpha,ierr)
        zwlimit(i)=(one-alpha)*zwt(ir)+alpha*zwt(irp1)
      enddo
!
      deallocate (rt)
      deallocate (zwt)
!
end subroutine
!#######################################################################
subroutine read_zw_profile (fname)
!
!-----------------------------------------------------------------------
!
! ****** Load in 1D profile that sets the initial values for zp and zm.
!
!-----------------------------------------------------------------------
!
! ****** Values for zp and zm are read in as a function of r.
!
! ****** NP1D is the number of radial points in the file.
!
! ****** Note! This does not rescale the file to use input file's z0.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh, ONLY : rh
      use fields, ONLY : zp,zm,b
      use vars
      use mpidefs
      use globals
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), allocatable ::  rt(:), zpt(:), zmt(:)
      real(r_typ) ::  alpha,fac,fac2, avbr, zin, zout
      integer :: ierr,np1d,ir,irp1,i,j,k
!
!-----------------------------------------------------------------------
!
      if (iamp0) then
        call ffopen (43,fname,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        np1d=-1
        do
          read (43,'(a)',err=100,end=100)
          np1d=np1d+1
        enddo
  100   continue
        close (43)
      end if
!
! ****** Broadcast the number of lines to all processors.
!
      call MPI_Bcast (np1d,1,MPI_Integer,0,MPI_COMM_WORLD,ierr)
      call check_error_on_any_proc (ierr)
!
! ****** Allocate storage for the fields to be read.
!
      allocate (rt(np1d))
      allocate (zpt(np1d))
      allocate (zmt(np1d))
!
! ****** Read the input file (only on processor IPROC0).
!
      if (iamp0) then
        call ffopen (43,fname,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        read (43,*)
        do i=1,np1d
          read (43,*) rt(i),zpt(i),zmt(i)
        enddo
        close (43)
      end if
!
! ****** Broadcast the values to all processors.
!
      call MPI_Bcast (rt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (zpt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (zmt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call check_error_on_any_proc (ierr)
!
! ****** Interpolate to the code mesh
! ****** note that zwlimit is only used on interior points
!
      do i=2,nrm1
        call interp (np1d,rt,rh(i),ir,irp1,alpha,ierr)
        do k=2,npm1
          do j=2,ntm1
            avbr=AVGTP(b%r,i,j,k)
            zout=(one-alpha)*zpt(ir)+alpha*zpt(irp1)
            zin =(one-alpha)*zmt(ir)+alpha*zmt(irp1)
            if (avbr .ge. 0._r_typ) then
              zp(i,j,k)=zout
              zm(i,j,k)=zin
            else
              zp(i,j,k)=-zin
              zm(i,j,k)=-zout
            end if
          enddo
        enddo
      enddo
!
      deallocate (rt)
      deallocate (zpt)
      deallocate (zmt)
!
end subroutine
!#######################################################################
subroutine compute_open_field_flux_cutoff
!
!-----------------------------------------------------------------------
!
! ****** Compute the optional open field Poynting flux cutoff for
! ****** the WTD model
!
!-----------------------------------------------------------------------
!
! ****** This computes a "flux-reduction" factor that will reduce
! ****** outward Poynting flux by that amount.
!
! ****** The final output is the square root of this factor since
! ****** it hits the wave amplitude BC in setbczw.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mesh
      use fields
      use vars
      use mpidefs
      use globals
      use wtd
      use alfven_wave_pressure, ONLY: pw0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: efac0 = 0.8_r_typ
      real(r_typ), parameter :: efacw = 0.06_r_typ
      real(r_typ), parameter :: ds0 = 0.017453292519943295_r_typ
      real(r_typ), parameter :: fnet_clip = 1e1_r_typ
      logical, save :: called_once=.false.
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: ew0, fn_flux_cgs
      real(r_typ) :: frac, equilibration_time_mas
      real(r_typ) :: ep0, em0, efac, mask_open_now
      real(r_typ) :: zp0, zm0, rho_0, br0, fp0, fm0, fnet
      real(r_typ) :: da, area_ratio
      real(r_typ) :: weighted_flux_ratio, flux_multiplier, zmult_now
!
!-----------------------------------------------------------------------
!
      integer :: j, k
      real(r_typ), parameter :: quarter=0.25_r_typ
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ), parameter :: two=2.0_r_typ
!
!-----------------------------------------------------------------------
!
! ****** BC for the wave energies and energy flux normalization.
!
      ew0 = two*pw0
      fn_flux_cgs = fn_p*fn_v
!
! ****** Fractional multiplier for running time average.
!
      equilibration_time_mas = wtd_open_cutoff_dt_eq_s/fnormt
      frac = dtime/equilibration_time_mas
      if (frac.gt.one) frac = one
!
      do concurrent (k=2:npm1, j=2:ntm1)
!
! ****** Compute the mask for open flux. This is based on the
! ****** The fact that the WKB wave energies will be zero in one
! ****** direction on a purely open field line (since no reflection).
! ****** I use abs to avoid a spurious small negative number.
!
        ep0 = half*(ep(1,j,k) + ep(2,j,k))
        em0 = half*(em(1,j,k) + em(2,j,k))
        efac = sqrt(abs(ep0*em0)/ew0**2)
        mask_open_now = half*(one - tanh((efac-efac0)/efacw))
!
! ****** Compute the net outward Poynting flux from zp and zm.
! ****** Clip to ignore cases with net energy inflow but save
! ****** the original value for diagnostic purposes.
!
        zp0 = half*(zp(1,j,k) + zp(2,j,k))
        zm0 = half*(zm(1,j,k) + zm(2,j,k))
        rho_0 = half*(rho(1,j,k) + rho(2,j,k))
        br0 = AVGRTP(b%r,2,j,k)
        fp0 = quarter*br0*sqrt(rho_0)*zp0**2
        fm0 = -quarter*br0*sqrt(rho_0)*zm0**2
        wtd_net_pflux(j,k) = (fp0 + fm0)*fn_flux_cgs
        fnet = wtd_net_pflux(j,k)
        if (fnet.lt.fnet_clip) fnet = fnet_clip
!
! ****** Compute the angular area of the cell w.r.t. to reference area.
!
        da = sth(j)*dth(j)*dph(k)
        area_ratio = da/(ds0**2)
!
! ****** Compute sqrt(area) weighted flux ratio and flux multiplier.
!
        weighted_flux_ratio = &
          fnet/wtd_open_cutoff_maxflux*sqrt(area_ratio)
!
        flux_multiplier = one
        if (weighted_flux_ratio.gt.one) then
          flux_multiplier = one/weighted_flux_ratio*(mask_open_now) &
                            + (one-mask_open_now)
        endif
!
! ****** Take the square root for applying flux reduction to z0.
!
        zmult_now = sqrt(flux_multiplier)
!
! ****** Now add the current values to the running time average.
!
! ****** NOTE: We leave the open mask as instant because ep and em
! ******       update according to the WKB wave propagation --> they
! *****        already have a built-in timescale.
!
        wtd_mask_open(j,k) = mask_open_now
!
        wtd_open_flux_zmult(j,k) = &
          (one-frac)*wtd_open_flux_zmult(j,k) + frac*zmult_now
!
      enddo
!
! ****** Seam and add a pole BC for plotting purposes.
!
      if (debug_wtd_open_field_cutoff) then
!
        call seam_2d_tp (wtd_open_flux_zmult,nt,np,.true.,.true.)
        call seam_2d_tp (wtd_net_pflux,nt,np,.true.,.true.)
        call seam_2d_tp (wtd_mask_open,nt,np,.true.,.true.)
!
        call set_pole_bc_scalar_tp_hh(wtd_open_flux_zmult)
        call set_pole_bc_scalar_tp_hh(wtd_net_pflux)
        call set_pole_bc_scalar_tp_hh(wtd_mask_open)
!
        if (.not.called_once) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### DEBUGGING COMPUTE_OPEN_FIELD_FLUX_CUTOFF'
            write (9,*) '  ew0', ew0
            write (9,*) '  fn_flux_cgs:', fn_flux_cgs
            write (9,*) '  fnet_clip', fnet_clip
            write (9,*) '  cutoff_maxflux:', wtd_open_cutoff_maxflux
            write (9,*) '  eq time [s]:', wtd_open_cutoff_dt_eq_s
            write (9,*) '  eq time [MAS]:', equilibration_time_mas
          endif
          called_once=.true.
        endif
      endif
!
end subroutine
!#######################################################################
subroutine read_open_cutoff_from_restart (fname)
!
!-----------------------------------------------------------------------
!
! ****** Read the time-averaged open field cutoff mask from the restart
!        files, if they are there.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use global_to_local_tp_interface
      use field_table
      use wtd
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: ix,nodes,i,j,k,ierr
      real(r_typ), dimension(:,:), allocatable :: atp_g
      logical :: field_present
!
!-----------------------------------------------------------------------
!
      logical, external :: rs_array_present
!
!-----------------------------------------------------------------------
!
! ****** Open the restart file.
!
      call open_restart_file (fname)
!
! ****** Check to see if the wtd_ofzm field is present in the file.
!
      if (iamp0) then
        field_present=rs_array_present('wtd_ofzm')
      end if
      call MPI_Bcast (field_present,1,MPI_LOGICAL, &
                      iproc0,comm_all,ierr)
!
! ****** If the field is not present, use averages for the fields
!
      if (.not.field_present) then
        call close_restart_file
        wtd_open_flux_zmult(:,:)=1.0_r_typ
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from READ_OPEN_CUTOFF_FROM_RESTART:'
          write (*,*) '### wtd_open_flux_zmult is not present.'
          write (*,*) '### Setting it to 1.0 instead.'
        end if
        return
      end if
!
      allocate (atp_g(nt_g,np_g))
      if (iamp0) then
        call rdrsh5_2d ('wtd_ofzm',nt_g,np_g,atp_g,ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from READ_OPEN_CUTOFF_FROM_RESTART:'
        write (9,*) '### wtd_open_flux_zmult has been read from the'
        write (9,*) '### restart file.'
      end if
!
! ****** Broadcast ATP_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (atp_g,nt_g*np_g,ntype_real, &
                      iproc0,comm_all,ierr)
      call check_error_on_p0 (ierr)
!
! ****** Copy from global to local array.
!
      do k=1,np
        do j=1,nt
          wtd_open_flux_zmult(j,k)=atp_g(j0_g+j-1,k0_g+k-1)
        enddo
      enddo
!
      deallocate (atp_g)
!
! ****** Close the restart file.
!
      call close_restart_file
!
end subroutine
!#######################################################################
subroutine newflux
!
!-----------------------------------------------------------------------
!
! ****** Find the electric field corresponding to the newly emerged
! ****** flux at the r=R0 boundary for an emerging flux run.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use emerging_flux_params
      use cgcom
      use timing
      use debug
      use drive_profile
      use shear_profile
      use flow_profile
      use prescribe_b_v_at_r0_vars
      use prescribe_tdc_from_file_r0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: one=1.0_r_typ
      real(r_typ), parameter :: tiny_value=1.e-20_r_typ
      real(r_typ) :: eps_ef
      real(r_typ), parameter :: four=4._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Local flux array.
!
      real(r_typ), dimension(ntm,npm) :: dbr
!
! ****** Array for the RHS of the 2D potential solve at
! ****** the lower radial boundary.
!
      real(r_typ), dimension(ntm,npm), target :: rhs2d,psi
      real(r_typ), dimension(nt,np), target :: dvxb,phi
      real(r_typ), dimension(:,:), allocatable :: et_star,ep_star
      real(r_typ), dimension(:,:), allocatable :: et_save,ep_save
      real(r_typ) :: vtaux(ntm,np),vpaux(nt,npm)
!
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp,av_et,av_ep,av_b2,av_er
      real(r_typ) :: brav,btp,cs
      real(r_typ) :: normrhs,brmono
      real(r_typ) :: epsq,et_dot_bt,er_star,curl_old,curl_new
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      integer :: ierr=0
      real(r_typ) :: dv
!
      logical, save :: first=.true.
!
!-----------------------------------------------------------------------
!
! ****** If this is not an emerging flux run of the second kind
! ****** (i.e. one reading Br from files), copy bt and bp and return
!
      if (.not.evolve_flux.and..not.prescribe_bv) then
        if (first) then
          first=.false.
          allocate (bt_pbv (nt,npm))
          allocate (bp_pbv (ntm,np))
!$acc enter data create(bt_pbv,bp_pbv)
!
          do concurrent (k=1:npm, j=1:nt)
            bt_pbv(j,k)=0.
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            bp_pbv(j,k)=0.
          enddo
        end if
        return
      end if
!
! ****** On the first time in, allocate rest of electric field arrays.
!
      if (first) then
        first=.false.
        allocate (bt_pbv (nt,npm))
        allocate (bp_pbv (ntm,np))
        allocate (vr_pbv (nt,np))
        allocate (vt_pbv (ntm,np))
        allocate (vp_pbv (nt,npm))
!$acc enter data create(bt_pbv,bp_pbv,vr_pbv,vt_pbv,vp_pbv)
      endif
!
      do concurrent (k=1:np, j=1:nt)
        eflux_er(j,k)=0.
        eflux_vr(j,k)=0.
        vr_pbv  (j,k)=0.
        phi_tdc (j,k)=0.
      enddo
!
      do concurrent (k=1:npm, j=1:nt)
        eflux_vp(j,k)=0.
        bt_pbv(j,k)=0.
        vp_pbv(j,k)=0.
      enddo
!
      do concurrent (k=1:np, j=1:ntm)
        eflux_vt(j,k)=0.
        bp_pbv(j,k)=0.
        vt_pbv(j,k)=0.
      enddo
!
      do concurrent (k=1:npm, j=1:ntm)
        br_pbv(j,k)=0.
      enddo
!
      do concurrent (k=1:np, j=1:ntm1)
        eflux_et(j,k)=0.
      enddo
!
      do concurrent (k=1:npm1, j=1:nt)
        eflux_ep(j,k)=0.
      enddo
!
! ****** Get the new boundary values from file(s).
!
      if (prescribe_bv) then
        call get_pbv_boundaries
!$acc update device(br_pbv,bt_pbv,bp_pbv,vr_pbv,vt_pbv,vp_pbv)
      else
        if (if_pchip) then
          call get_flux_pchip (time,br_pbv)
        else if (time_dependent_corona_from_files) then
          call get_all_pchip (time,br_pbv,vt_pbv,vp_pbv,phi_tdc)
          ef_is_on=.true.
!$acc update device(vt_pbv,vp_pbv,phi_tdc)
        else
          call get_flux (time,br_pbv)
        end if
!$acc update device(br_pbv)
      end if
!
      if (.not.ef_is_on.and..not.prescribe_bv) then
!
        do concurrent (k=1:np, j=1:nt)
          eflux_er(j,k)=0.
        enddo
!
        do concurrent (k=1:np, j=1:ntm1)
          eflux_et(j,k)=0.
        enddo
!
        do concurrent (k=1:npm1, j=1:nt)
          eflux_ep(j,k)=0.
        enddo
!
        return
      end if
!
! ****** Find the tangential electric field required to
! ****** emerge this flux.  This requires the solution of
! ****** an elliptic equation.
!
      if (rb0) then
!
!$acc enter data create(dbr,rhs2d,psi)
        do concurrent (k=1:npm, j=1:ntm)
          dbr(j,k)=0.
        enddo
!
        if (br_mono_active) then
          brmono=half*(br_mono(1)+br_mono(2))
        else
          brmono=0.
        end if
!
        do concurrent (k=1:npm1, j=1:ntm1)
          brav=half*(b%r(1,j,k)+b%r(2,j,k))-brmono
          dbr(j,k)=br_pbv(j,k)-brav
        enddo
!
!-----------------------------------------------------------------------
! ****** Solve the 2D implicit equations for the boundary potential.
!-----------------------------------------------------------------------
!
! ****** Form the RHS.
!
        do concurrent (k=1:npm, j=1:ntm)
          rhs2d(j,k)=0.
        enddo
!
        do concurrent (k=2:npm-1, j=2:ntm-1)
          dv=r0**2*dt(j)*st(j)*dp(k)
          rhs2d(j,k)=dv*dbr(j,k)
        enddo
!
        if (tb0) then
          do concurrent (k=2:npm-1)
            dv=quarter*r0**2*dt(   1)*sth(   2)*dp(k)
            rhs2d(   1,k)=dv*dbr(   1,k)
          enddo
        end if
        if (tb1) then
          do concurrent (k=2:npm-1)
            dv=quarter*r0**2*dt(ntm1)*sth(ntm1)*dp(k)
            rhs2d(ntm1,k)=dv*dbr(ntm1,k)
          enddo
        end if
!
! ****** Use a guess equal to previous time step solution.
!
        do concurrent (k=1:npm, j=1:ntm)
          psi(j,k)=psi_old(j,k)
        enddo
!
! ****** Solve the 2D implicit equations for the boundary potential.
!
        equation_solved=EQ_POT2D_NEWFLUX
!
        call pot2d_solver (psi,rhs2d,ierr)
!
       end if
!
       call check_error_on_any_proc (ierr)
!
       if (rb0) then
!
! ****** Save psi for use as guess in next time-step.
!
        do concurrent (k=1:npm, j=1:ntm)
          psi_old(j,k)=psi(j,k)
        enddo
!
! ****** Set the emerging flux electric field at the r=R0 boundary.
!
        do concurrent (k=2:npm1, j=jm0:jm1)
          eflux_et(j,k)=-(psi(j,k)-psi(j,k-1)) &
                         *dp_mult*dph_i(k)*r_i(1)*st_i(j)/dtime
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          eflux_ep(j,k)=(psi(j,k)-psi(j-1,k)) &
                      *dth_i(j)*r_i(1)/dtime
        enddo
!$acc exit data delete(dbr,rhs2d,psi)
!
! ****** Calculate component due to differential rotation
!
        if (.not.rotation_flux) then
!
! ****** Boundary conditions at the poles
!
          call set_pole_bc_avec_tp (eflux_et,eflux_ep)
!
! ****** Seam the electric field.
!
          call seam_2d_tp (eflux_et,ntm1,np,.false.,.true.)
          call seam_2d_tp (eflux_ep,nt,npm1,.true.,.false.)
!
          return
        end if
!
!$acc enter data create(dvxb,vtaux,vpaux,phi)
        if (prescribe_bv) then
!
! ****** Add in the br monopole.
!
          do concurrent (k=1:npm, j=1:ntm)
            br_pbv(j,k)=br_pbv(j,k)+brmono
          enddo
!
        else if (time_dependent_corona_from_files) then
!
          do concurrent (k=1:np, j=1:ntm)
            bp_pbv(j,k)=b%p(1,j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            bt_pbv(j,k)=b%t(1,j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:ntm)
            br_pbv(j,k)=half*(b%r(1,j,k)+b%r(2,j,k))
          enddo
!
        else
!
          do concurrent (k=1:np, j=1:ntm)
            vt_pbv(j,k)=v_shear_t(j,k)*v_drive_mag
            bp_pbv(j,k)=b%p(1,j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vp_pbv(j,k)=v_shear_p(j,k)*v_drive_mag
            bt_pbv(j,k)=b%t(1,j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:ntm)
            br_pbv(j,k)=half*(b%r(1,j,k)+b%r(2,j,k))
          enddo
        end if
!
! ****** Form the RHS.
!
        do concurrent (k=1:np, j=1:nt)
          dvxb(j,k)=0.
        enddo
!
! ****** Set the electric field at r=R0.
!
        do concurrent (k=1:np, j=1:ntm)
          vtaux(j,k)=0.
        enddo
!
        do concurrent (k=1:npm, j=1:nt)
          vpaux(j,k)=0.
        enddo
!
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr=AVGT2 (vr_pbv,j+1,k)
          av_vp=AVGTP2(vp_pbv,j+1,k)
          av_br=AVGP2 (br_pbv,j,k)
          av_bp=AVG2  (bp_pbv,j,k)
          vtaux(j,k)=av_vp*av_br-av_vr*av_bp
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr=AVGP2 (vr_pbv,j,k+1)
          av_vt=AVGTP2(vt_pbv,j,k+1)
          av_br=AVGT2 (br_pbv,j,k  )
          av_bt=AVG2  (bt_pbv,j,k  )
          vpaux(j,k)=av_vr*av_bt-av_vt*av_br
        enddo
!
        call seam_2d_tp (vtaux,ntm,np,.true.,.true.)
        call seam_2d_tp (vpaux,nt,npm,.true.,.true.)
!
        do concurrent (k=2:npm1, j=2:ntm1)
          dvxb(j,k)=((st(j  )*vtaux(j  ,k) &
                     -st(j-1)*vtaux(j-1,k))*r0*dph(k)+ &
                  (vpaux(j,k)-vpaux(j,k-1))*r0*dth(j))
        enddo
!
! ****** Use the previous time solution for guess.
!
        do concurrent (k=1:np, j=1:nt)
          phi(j,k)=phi_old(j,k)
        enddo
!
        equation_solved=EQ_POT2DH
!
        call pot2dh_solver (phi,dvxb,ierr)
!
      end if
!
      call check_error_on_any_proc (ierr)
!
      if (rb0) then
!
! ****** Save phi for use as guess in next time-step.
!
        do concurrent (k=1:np, j=1:nt)
          phi_old(j,k)=phi(j,k)
        enddo
!
! ****** Set the rotational contribution electric field at
! ****** the r=R0 boundary.
!
!
! ****** Add contribution to phi read from file
!
        if (time_dependent_corona_from_files) then
          do concurrent (k=1:np, j=1:nt)
            phi(j,k)=phi(j,k)+phi_tdc(j,k)*tdc_phi
          enddo
        endif
!
        do concurrent (k=1:np, j=1:nt)
          phi_tdc(j,k)=phi(j,k)
        enddo
!
        do concurrent (k=2:npm1, j=jm0:jm1)
          eflux_et(j,k)=eflux_et(j,k)+(phi(j+1,k)-phi(j,k)) &
                        *dt_i(j)*r_i(1)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          eflux_ep(j,k)=eflux_ep(j,k)+(phi(j,k+1)-phi(j,k)) &
                        *dp_mult*dp_i(k)*r_i(1)*sth_i(j)
        enddo
!$acc exit data delete(dvxb,vtaux,vpaux,phi)
!
! ****** Boundary conditions at the poles
!
        call set_pole_bc_avec_tp (eflux_et,eflux_ep)
!
! ****** Seam the electric field.
!
        call seam_2d_tp (eflux_et,ntm1,np,.false.,.true.)
        call seam_2d_tp (eflux_ep,nt,npm1,.true.,.false.)
!
! ****** Do electric flux corrections according to Slava Titov
! ****** for time dependent corona.
!
        if (time_dependent_corona) then
!
! ****** Allocate temporary arrays.
!
          allocate (et_star(ntm1,np))
          allocate (et_save(ntm1,np))
          allocate (ep_star(nt,npm1))
          allocate (ep_save(nt,npm1))
!$acc enter data create(et_star,ep_star,et_save,ep_save)
!
          do concurrent (k=1:np, j=1:ntm1)
            et_star(j,k)=0.
            et_save(j,k)=0.
          enddo
!
          do concurrent (k=1:npm1, j=1:nt)
            ep_star(j,k)=0.
            ep_save(j,k)=0.
          enddo
!
          if (tdc_edb_correction_trunc) then
!
! ******  Compute Er from Et and Ep to remove E.B
!
            do concurrent (k=2:npm1, j=2:ntm1)
              av_br=AVGTP2(br_pbv,j,k)
              av_bt=AVGP2 (bt_pbv,j,k)
              av_bp=AVGT2 (bp_pbv,j,k)
              av_et=half*(eflux_et(j,k)+eflux_et(j-1,k))
              av_ep=half*(eflux_ep(j,k)+eflux_ep(j,k-1))
              av_b2=av_br**2+av_bt**2+av_bp**2
              eflux_er(j,k)=-(av_et*av_bt+av_ep*av_bp)*sign(one,av_br) &
              /(abs(av_br)+tdc_edb_btp_a*sqrt(av_bt*av_bt+av_bp*av_bp))
            enddo
!
            call set_pole_bc_scalar_tp_hh (eflux_er)
!
            call seam_2d_tp (eflux_er,nt,np,.true.,.true.)
!
          else if (tdc_edb_correction_etmod) then
!
! ****** Modify Et and Ep at the NL for E.B to be ideal, even at the NL.
! ****** First compute Er.
!
            do concurrent (k=1:np, j=1:ntm1)
              et_save(j,k)=eflux_et(j,k)
            enddo
!
            do concurrent (k=1:npm1, j=1:nt)
              ep_save(j,k)=eflux_ep(j,k)
            enddo
!
            epsq=tdc_edb_br_eps*tdc_edb_br_eps
!
            do concurrent (k=2:npm1, j=2:ntm1)
              av_br=AVGTP2(br_pbv,j,k)
              av_bt=AVGP2 (bt_pbv,j,k)
              av_bp=AVGT2 (bp_pbv,j,k)
              av_et=half*(eflux_et(j,k)+eflux_et(j-1,k))
              av_ep=half*(eflux_ep(j,k)+eflux_ep(j,k-1))
              av_b2=av_br**2+av_bt**2+av_bp**2
              btp=sqrt(av_bt*av_bt+av_bp*av_bp)
              er_star=-(av_et*av_bt+av_ep*av_bp)*sign(one,av_br) &
              /(abs(av_br)+tdc_edb_btp_a*btp)
              eflux_er(j,k)=er_star* &
              (one+tdc_edb_btp_a*btp*abs(av_br)/av_b2)
            enddo
!
            call set_pole_bc_scalar_tp_hh (eflux_er)
!
            call seam_2d_tp (eflux_er,nt,np,.true.,.true.)
!
! ****** Get Et but do not update yet.
!
            do concurrent (k=2:npm1, j=jm0:jm1)
              av_br=AVGP2 (br_pbv,j  ,k  )
              av_bt=AVGTP2(bt_pbv,j+1,k  )
              av_bp=AVG2  (bp_pbv,j  ,k  )
              av_et=eflux_et(j,k)
              av_ep=quarter*(eflux_ep(j  ,k  )+eflux_ep(j+1,k  )+ &
                             eflux_ep(j  ,k-1)+eflux_ep(j+1,k-1))
              av_b2=av_br**2+av_bt**2+av_bp**2
              et_dot_bt=av_et*av_bt+av_ep*av_bp
              btp=sqrt(av_bt*av_bt+av_bp*av_bp)
              et_star(j,k)=av_et- &
              tdc_edb_btp_a*btp/(abs(av_br)+tdc_edb_btp_a*btp)* &
              et_dot_bt*av_bt/av_b2
            enddo
!
! ****** Get Ep but do not update yet.
!
            do concurrent (k=1:npm1, j=2:ntm1)
              av_br=AVGT2 (br_pbv,j  ,k  )
              av_bt=AVG2  (bt_pbv,j  ,k  )
              av_bp=AVGTP2(bp_pbv,j  ,k+1)
              av_et=quarter*(eflux_et(j  ,k  )+eflux_et(j-1,k  )+ &
                             eflux_et(j  ,k+1)+eflux_et(j-1,k+1))
              av_ep=eflux_ep(j,k)
              av_b2=av_br**2+av_bt**2+av_bp**2
              et_dot_bt=av_et*av_bt+av_ep*av_bp
              btp=sqrt(av_bt*av_bt+av_bp*av_bp)
              ep_star(j,k)=av_ep- &
              tdc_edb_btp_a*btp/(abs(av_br)+tdc_edb_btp_a*btp)* &
              et_dot_bt*av_bp/av_b2
            enddo
!
! ****** Update both tangential components of E.
!
            do concurrent (k=2:npm1, j=jm0:jm1)
              eflux_et(j,k)=et_star(j,k)
            enddo
!
            do concurrent (k=1:npm1, j=2:ntm1)
              eflux_ep(j,k)=ep_star(j,k)
            enddo
!
          end if
!
! ****** Boundary conditions at the poles
!
          call set_pole_bc_avec_tp (eflux_et,eflux_ep)
!
! ****** Seam the electric field.
!
          call seam_2d_tp (eflux_et,ntm1,np,.false.,.true.)
          call seam_2d_tp (eflux_ep,nt,npm1,.true.,.false.)
!
! ****** Get the boundary flow that corresponds to the boundary
! ****** Electric field through VxB
!
          do concurrent (k=1:np, j=1:nt)
            eflux_vr(j,k)=0.
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            eflux_vt(j,k)=0.
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            eflux_vp(j,k)=0.
          enddo
!
          cs=sqrt(gamma*he_p/he_rho*tbc0/fn_t)
!
! ****** Set the radial component.
!
          do concurrent (k=2:npm1, j=2:ntm1)
            av_et=half*(eflux_et(j,k)+eflux_et(j-1,k))
            av_ep=half*(eflux_ep(j,k)+eflux_ep(j,k-1))
            av_br=AVG2 (br_pbv,j,k)
            av_bt=AVGP2(bt_pbv,j,k)
            av_bp=AVGT2(bp_pbv,j,k)
            av_b2=av_br**2+av_bt**2+av_bp**2
!
            eps_ef=sqrt(av_b2)*sqrt(eflux_er(j,k)*eflux_er(j,k)+ &
            av_et*av_et+av_ep*av_ep)*tdc_edb_btp_d/cs
            eflux_vr(j,k)=(av_et*av_bp-av_ep*av_bt)/(av_b2+eps_ef)
          enddo
!
! ****** Set the theta component.
!
          do concurrent (k=2:npm1, j=jm0:jm1)
            av_er=half*(eflux_er(j+1,k)+eflux_er(j,k))
            av_ep=quarter*(eflux_ep(j  ,k  )+eflux_ep(j+1,k  )+ &
                           eflux_ep(j  ,k-1)+eflux_ep(j+1,k-1))
            av_br=AVGP2 (br_pbv,j  ,k  )
            av_bt=AVGTP2(bt_pbv,j+1,k  )
            av_bp=AVG2  (bp_pbv,j,  k  )
            av_b2=av_br**2+av_bt**2+av_bp**2
!
            eps_ef=sqrt(av_b2)*sqrt(eflux_et(j,k)*eflux_et(j,k)+ &
            av_er*av_er+av_ep*av_ep)*tdc_edb_btp_d/cs
            eflux_vt(j,k)=(av_ep*av_br-av_er*av_bp)/(av_b2+eps_ef)
          enddo
!
! ****** Set the phi component.
!
          do concurrent (k=1:npm1, j=2:ntm1)
            av_er=half*(eflux_er(j,k+1)+eflux_er(j,k))
            av_et=quarter*(eflux_et(j  ,k  )+eflux_et(j-1,k  )+ &
                           eflux_et(j  ,k+1)+eflux_et(j-1,k+1))
            av_br=AVGT2 (br_pbv,j  ,k  )
            av_bt=AVG2  (bt_pbv,j  ,k  )
            av_bp=AVGTP2(bp_pbv,j,  k+1)
            av_b2=av_br**2+av_bt**2+av_bp**2
!
            eps_ef=sqrt(av_b2)*sqrt(eflux_ep(j,k)*eflux_ep(j,k)+ &
            av_et*av_et+av_er*av_er)*tdc_edb_btp_d/cs
            eflux_vp(j,k)=(av_er*av_bt-av_et*av_br)/(av_b2+eps_ef)
          enddo
!
! ****** Set boundary conditions at the poles.
!
          call set_pole_bc_scalar_tp_hh (eflux_vr)
!
          call set_pole_bc_vvec_tp (eflux_vt,eflux_vp)
!
! ****** Seam the flow arrays.
!
          call seam_2d_tp (eflux_vr,nt,np,.true.,.true.)
          call seam_2d_tp (eflux_vt,ntm,np,.false.,.true.)
          call seam_2d_tp (eflux_vp,nt,npm,.true.,.false.)
!
! ****** Determine an effective photospheric resistivity, eflux_eta
!
          if (tdc_edb_correction_etmod) then
!
            do concurrent (k=1:npm, j=1:ntm)
              eflux_eta(j,k)=0.
            enddo
!
            do concurrent (k=1:npm1, j=jm0:jm1)
              curl_old=((sth(j+1)*ep_save(j+1,k) &
                        -sth(j  )*ep_save(j  ,k))*dt_i(j) &
                      -(et_save(j,k+1)-et_save(j,k))*dp_i(k)*dp_mult &
                     )*st_i(j)
              curl_new=((sth(j+1)*eflux_ep(j+1,k) &
                        -sth(j  )*eflux_ep(j  ,k))*dt_i(j) &
                      -(eflux_et(j,k+1)-eflux_et(j,k))*dp_i(k)*dp_mult &
                     )*st_i(j)
              eflux_eta(j,k)=abs(curl_new-curl_old)* &
                             tdc_edb_correction_etmod_eta
            enddo
!
            if (tb0) then
              do concurrent (k=1:npm1)
                curl_old= four*ep_save(   2,k)*dt_i(   1)
                curl_new= four*eflux_ep(   2,k)*dt_i(   1)
                eflux_eta(1,k)=abs(curl_new-curl_old)* &
                               tdc_edb_correction_etmod_eta
              enddo
            end if
!
            if (tb1) then
              do concurrent (k=1:npm1)
                curl_old=-four*ep_save(ntm1,k)*dt_i(ntm1)
                curl_new=-four*eflux_ep(ntm1,k)*dt_i(ntm1)
                eflux_eta(ntm1,k)=abs(curl_new-curl_old)* &
                               tdc_edb_correction_etmod_eta
              enddo
            end if
!
            call set_pole_bc_scalar_tp_mm (eflux_eta)
!
          end if
!
! ****** Deallocate temporary arrays.
!
!$acc exit data delete(et_star,ep_star,et_save,ep_save)
          deallocate (et_star)
          deallocate (ep_star)
          deallocate (et_save)
          deallocate (ep_save)
!
        end if
!
        if (debug_tdc) then
!
! ****** Curl of E Tangential
!
          do concurrent (k=1:npm1, j=jm0:jm1)
            curl_et(j,k)=( ( sth(j+1)*eflux_ep(j+1,k) &
                          -sth(j  )*eflux_ep(j  ,k))*dt_i(j) &
               -(eflux_et(j,k+1)-eflux_et(j,k))*dp_i(k)*dp_mult &
                     )*st_i(j)
          enddo
!
          if (tb0) then
            do concurrent (k=1:npm1)
              curl_et(   1,k)= four*eflux_ep(   2,k)*dt_i(   1)
            enddo
          end if
!
          if (tb1) then
            do concurrent (k=1:npm1)
              curl_et(ntm1,k)=-four*eflux_ep(ntm1,k)*dt_i(ntm1)
            enddo
          end if
!
          call set_pole_bc_scalar_tp_mm (curl_et)
!
! ****** Div of E Tangential
!
          do concurrent (k=2:npm1, j=2:ntm1)
            div_et(j,k)= ( st(j  )*eflux_et(j  ,k) &
                          -st(j-1)*eflux_et(j-1,k) &
                         )*sth_i(j)*dth_i(j) &
                        +( eflux_ep(j,k  ) &
                          -eflux_ep(j,k-1) &
                         )*sth_i(j)*dp_mult*dph_i(k)
          enddo
!
          call seam_2d_tp (div_et,nt,np,.true.,.true.)
          call set_pole_bc_scalar_tp_hh (div_et)
!
        end if
!
      end if
!
  900 format (/,tr1,a,' N=',i5,' |B|=',1pe9.2,' |R|=',1pe9.2)
!
end subroutine
!#######################################################################
subroutine get_flux (targ,brnew)
!
!-----------------------------------------------------------------------
!
! ****** Set the emerged flux at the boundary at the present time.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use emerging_flux_params
      use time_profiles
      use flint_interface
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: brnew
      real(r_typ) :: targ
      integer :: ierr=0
      integer :: ix,nodes,i
      logical, save :: first=.true.
      logical :: exists
!
!-----------------------------------------------------------------------
!
! ****** Array to help in the flux interpolation.
!
      real(r_typ), save :: helper_ef(mx_tp_nodes)
!
! ****** Variables for flux interpolation.
!
      integer :: ifile0,ifile1
      integer :: j,k
      real(r_typ) :: file_no,frac
      character(256) :: fname
      real(r_typ) :: b0_save
      integer :: ip1
      real(r_typ) :: dummy
!
!-----------------------------------------------------------------------
!
      b0_save=b0
      b0=0.
!
      ix=tp_vars(TP_INDEX_EFLUX_BR)%index
!
! ****** Check that the time profile for evolve_flux has been set.
!
      if (first) then
        if (ix.eq.0) then
          ierr=1
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GET_FLUX:'
            write (*,*) '### Attempting to evolve flux without'
            write (*,*) '### setting a linked time profile.'
            write (*,*) '### Either set evolve_flux=.false. or'
            write (*,*) '### define a time profile with'
            write (*,*) '### tprofile(#)%vars="eflux_br"'
          end if
          call check_error_on_p0 (ierr)
        end if
      end if
!
      nodes=tprofile(ix)%nodes
!
! ****** On the first time in:
!
      if (first) then
!
! ****** Check that the specified flux files exist.
!
        if (iamp0) then
          do i=1,nodes
            fname=tprofile(ix)%filename(i)
            inquire (file=trim(fname),exist=exists)
            if (.not.exists) then
              write (*,*)
              write (*,*) '### ERROR in GET_FLUX:'
              write (*,*) '### You have specified a flux file'// &
                          ' that does not exist.'
              write (*,*) 'File name: ',trim(fname)
              write (9,*)
              write (9,*) '### ERROR in GET_FLUX:'
              write (9,*) '### You have specified a flux file'// &
                          ' that does not exist.'
              write (9,*) 'File name: ',trim(fname)
              ierr=1
            end if
          enddo
        end if
        call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the magnetic field arrays that are
! ****** read in.
!
        allocate (br_ef0(ntm,npm))
        allocate (br_ef1(ntm,npm))
        br_ef0=0.
        br_ef1=0.
        ifile0_contents=0
        ifile1_contents=0
!
! ****** Set up the flux interpolation helper array.
!
        do i=1,nodes
          helper_ef(i)=i
        enddo
!
        first=.false.
!
      end if
!
! ****** Interpolate to time TARG.
!
      if (targ.le.tprofile(ix)%t(1)) then
        ef_is_on=tprofile(ix)%on(1)
        ifile0=1
        ifile1=1
        frac=0.
      else if (targ.ge.tprofile(ix)%t(nodes)) then
        ef_is_on=tprofile(ix)%on(nodes)
        ifile0=nodes
        ifile1=nodes
        frac=0.
      else
        call interp (nodes,tprofile(ix)%t,targ,i,ip1,dummy,ierr)
        ef_is_on=tprofile(ix)%on(i)
        file_no=flint(.false.,targ,nodes, &
        tprofile(ix)%t,helper_ef,ierr)
        ifile0=file_no
        ifile1=min(ifile0+1,nodes)
        frac=file_no-ifile0
      end if
!
! ****** If the evolving flux algorithm is on at the present time,
! ****** continue with the reading of the flux files.
! ****** If it has been turned off, return from this routine.
!
      if (.not.ef_is_on) return
!
! ****** Set up the flux in the flux arrays BR_EF0 and BR_EF1
! ****** bounding this interval.
!
! ****** First, check to see if the flux file has changed.
! ****** If it has, check to see if this file has already
! ****** been read in previously; if it has, transfer that
! ****** flux, otherwise read in the new file.
!
      if (ifile0.ne.ifile0_contents) then
        if (ifile0.eq.ifile1_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_FLUX:'
            write (9,*) '### Transferring flux from FILE1 to FILE0.'
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          br_ef0=br_ef1
        else
          fname=tprofile(ix)%filename(ifile0)
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_FLUX:'
            write (9,*) '### Reading a new flux file.'
            write (9,*) 'File name: ',trim(fname)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          call read_flux (trim(fname),br_ef0)
        end if
        ifile0_contents=ifile0
      end if
!
      if (ifile1.ne.ifile1_contents) then
        if (ifile1.eq.ifile0_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_FLUX:'
            write (9,*) '### Transferring flux from FILE0 to FILE1.'
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          br_ef1=br_ef0
        else
          fname=tprofile(ix)%filename(ifile1)
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_FLUX:'
            write (9,*) '### Reading a new flux file.'
            write (9,*) 'File name: ',trim(fname)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          call read_flux (trim(fname),br_ef1)
        end if
        ifile1_contents=ifile1
      end if
!
! ****** Interpolate the flux to time TARG.
!
      do k=1,npm
        do j=1,ntm
          brnew(j,k)=(one-frac)*br_ef0(j,k)+frac*br_ef1(j,k)
        enddo
      enddo
!
      b0=b0_save
!
end subroutine
!#######################################################################
subroutine get_flux_pchip (targ,brnew)
!
!-----------------------------------------------------------------------
!
! ****** PCHIP time interpolation to prescribe the magnetic flux.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use emerging_flux_params
      use time_profiles
      use flint_interface
      use pchip_module
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: brnew
      real(r_typ) :: targ
      real(r_typ) :: wk(8),t_ef(1),dval_ef(1),val_ef(1)
      integer :: ierr=0
      integer :: ix,nodes,i
      logical, save :: first=.true.
      logical :: exists,if_outside
!
!-----------------------------------------------------------------------
!
! ****** Array to help in the flux interpolation.
!
      real(r_typ), save :: helper_ef(mx_tp_nodes)
!
! ****** Variables for flux interpolation.
!
      integer :: ifilem,ifile0,ifile1,ifilep
      integer :: j,k,nbr_ef,i_case
      logical :: skip=.true.
      real(r_typ) :: file_no
      character(256) :: fname
      real(r_typ) :: b0_save
      integer :: ip1,ip2
      real(r_typ) :: dummy
!
!-----------------------------------------------------------------------
!
      b0_save=b0
      b0=0.
!
      ix=tp_vars(TP_INDEX_EFLUX_BR)%index
!
! ****** Check that the time profile for evolve_flux has been set.
!
      if (first) then
        if (ix.eq.0) then
          ierr=1
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in GET_FLUX_ICHIP:'
            write (*,*) '### Attempting to evolve flux without'
            write (*,*) '### setting a linked time profile.'
            write (*,*) '### Either set evolve_flux=.false. or'
            write (*,*) '### define a time profile with'
            write (*,*) '### tprofile(#)%vars="eflux_br"'
          end if
          call check_error_on_p0 (ierr)
        end if
      end if
!
      nodes=tprofile(ix)%nodes
!
! ****** On the first time in:
!
      if (first) then
!
! ****** Check that the specified flux files exist.
!
        if (iamp0) then
          do i=1,nodes
            fname=tprofile(ix)%filename(i)
            inquire (file=trim(fname),exist=exists)
            if (.not.exists) then
              write (*,*)
              write (*,*) '### ERROR in GET_FLUX:'
              write (*,*) '### You have specified a flux file'// &
                          ' that does not exist.'
              write (*,*) 'File name: ',trim(fname)
              write (9,*)
              write (9,*) '### ERROR in GET_FLUX:'
              write (9,*) '### You have specified a flux file'// &
                          ' that does not exist.'
              write (9,*) 'File name: ',trim(fname)
              ierr=1
            end if
          enddo
        end if
        call check_error_on_p0 (ierr)
!
! ****** Allocate memory for the magnetic field arrays that are
! ****** read in.
!
        allocate (br_ef(4,ntm,npm))
        allocate (dbr_ef(4,ntm,npm))
        br_ef=0.
        dbr_ef=0.
        ifile0_contents=0
        ifile1_contents=0
!
! ****** Set up the flux interpolation helper array.
!
        do i=1,nodes
          helper_ef(i)=i
        enddo
!
        first=.false.
!
      end if
!
! ****** Interpolate to time TARG.
!
      if (targ.le.tprofile(ix)%t(1)) then
        ef_is_on=tprofile(ix)%on(1)
        ifile0=1
        ifile1=1
        if_outside=.true.
      else if (targ.ge.tprofile(ix)%t(nodes)) then
        ef_is_on=tprofile(ix)%on(nodes)
        ifile0=nodes
        ifile1=nodes
        if_outside=.true.
      else
        nbr_ef=4
        call interp (nodes,tprofile(ix)%t,targ,i,ip1,dummy,ierr)
        ef_is_on=tprofile(ix)%on(i)
        file_no=int(flint(.false.,targ,nodes, &
        tprofile(ix)%t,helper_ef,ierr))
        ifile0=file_no
        ifilem=file_no-1
        if (ifilem.lt.1) then
          ifilem=1
          nbr_ef=nbr_ef-1
        end if
        ifile1=min(ifile0+1,nodes)
        ifilep=ifile1+1
        if (ifilep.gt.nodes) then
          ifilep=nodes
          nbr_ef=nbr_ef-1
        end if
        if_outside=.false.
      end if
!
! ****** If the evolving flux algorithm is on at the present time,
! ****** continue with the reading of the flux files.
! ****** If it has been turned off, return from this routine.
!
      if (.not.ef_is_on) return
      if (if_outside) then
        if (ifile0.ne.ifile0_contents) then
          if (ifile0.eq.ifile1_contents) then
!
! ****** This should happen when targ moves out of the nodes during
! ****** the execution.
!
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
              write (9,*) '### Transferring flux from FILE1 to FILE0.'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            br_ef(2,:,:)=br_ef(3,:,:)
          else
!
! ****** This should happen when targ is outside of the nodes
! ****** at the first time step.
!
            fname=tprofile(ix)%filename(ifile0)
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
              write (9,*) '### Reading a new ifile0 flux file.'
              write (9,*) 'File name: ',trim(fname)
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            call read_flux (trim(fname),br_ef(2,:,:))
          end if
          ifile0_contents=ifile0
        end if
        do k=1,npm
          do j=1,ntm
            brnew(j,k)=br_ef(2,j,k)
          enddo
        enddo
      else
!
! ****** Set up the flux in the flux arrays BR_EF0 and BR_EF1
! ****** bounding this interval.
!
! ****** First, check to see if the flux file has changed.
! ****** If it has, check to see if this file has already
! ****** been read in previously; if it has, transfer that
! ****** flux, otherwise read in the new file.
!
        if (ifile0.ne.ifile0_contents) then
          if (ifile0.eq.ifile1_contents) then
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
              write (9,*) '### Transferring flux from FILE0 to FILEM.'
              write (9,*) '### Transferring flux from FILE1 to FILE0.'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            br_ef(1,:,:)=br_ef(2,:,:)
            br_ef(2,:,:)=br_ef(3,:,:)
          else
            if (ifilem.lt.ifile0) then
              fname=tprofile(ix)%filename(ifilem)
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
                write (9,*) '### Reading a new ifilem flux file.'
                write (9,*) 'File name: ',trim(fname)
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              call read_flux (trim(fname),br_ef(1,:,:))
            end if
            fname=tprofile(ix)%filename(ifile0)
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
              write (9,*) '### Reading a new ifile0 flux file.'
              write (9,*) 'File name: ',trim(fname)
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            call read_flux (trim(fname),br_ef(2,:,:))
          end if
          ifile0_contents=ifile0
        end if
!
        if (ifile1.ne.ifile1_contents) then
          if (ifile1.eq.ifile0_contents) then
!
! ****** This should never happen. If targ is within the time nodes
! ****** ifile0_contents is either 0 or ifile0, which is always
! ****** less that ifile1. RL
!
            ierr=1
            if (iamp0) then
              write (9,*)
              write (9,*) '### ERROR from GET_FLUX_PCHIP:'
              write (9,*) '### Transferring flux from FILE0 to FILE1.'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            br_ef(3,:,:)=br_ef(2,:,:)
            call check_error_on_p0 (ierr)
          else
            if (ifile1_contents.eq.0) then
!
! ****** This should happen only the
! ****** first time we call the routine. Afterwards we
! ****** copy the content from br_ef(4,:,:) until targ
! ****** moves outside the time nodes.
!
              fname=tprofile(ix)%filename(ifile1)
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
                write (9,*) '### Reading a new ifile1 flux file.'
                write (9,*) 'File name: ',trim(fname)
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              call read_flux (trim(fname),br_ef(3,:,:))
            else
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
                write (9,*) '### Transferring flux from FILEP to FILE1.'
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              br_ef(3,:,:)=br_ef(4,:,:)
            end if
            if (ifilep.gt.ifile1) then
              fname=tprofile(ix)%filename(ifilep)
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_FLUX_PCHIP:'
                write (9,*) '### Reading a new ifilep flux file.'
                write (9,*) 'File name: ',trim(fname)
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              call read_flux (trim(fname),br_ef(4,:,:))
            end if
          end if
          ifile1_contents=ifile1
!
! ****** Calculate new interpolant.
!
          select case (nbr_ef)
          case (2)
            do k=1,npm
              do j=1,ntm
                call dpchim(2,tprofile(ix)%t(ifile0:ifile1), &
                br_ef(2:3,j,k),dbr_ef(2:3,j,k),1,ierr)
              enddo
            enddo
          case (3)
            ip1=2-(ifile0-ifilem)
            ip2=ip1+2
            do k=1,npm
              do j=1,ntm
                call dpchim(3,tprofile(ix)%t(ifilem:ifilep), &
                br_ef(ip1:ip2,j,k),dbr_ef(ip1:ip2,j,k),1,ierr)
              enddo
            enddo
          case default
            do k=1,npm
              do j=1,ntm
                call dpchim(4,tprofile(ix)%t(ifilem:ifilep), &
                br_ef(1:4,j,k),dbr_ef(1:4,j,k),1,ierr)
              enddo
            enddo
          end select
          if (ierr.lt.0) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in GET_FLUX_IPCHP_PCHIP:'
              write (*,*) '### An error occurred within DPCHIM '
              write (*,*) 'IERR   = ',ierr
              write (*,*) 'NBR_EF = ',nbr_ef
              write (*,*) 'IFILEM = ',ifilem
              write (*,*) 'IFILE0 = ',ifile0
              write (*,*) 'IFILE1 = ',ifile1
              write (*,*) 'IFILEP = ',ifilep
            end if
          end if
        end if
!
! ****** Interpolate the flux to time TARG.
!
        t_ef(1)=targ
        select case (nbr_ef)
        case (2)
          do k=1,npm
            do j=1,ntm
              call dpchfd(2,tprofile(ix)%t(ifile0:ifile1), &
                          br_ef(2:3,j,k),dbr_ef(2:3,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              brnew(j,k)=val_ef(1)
            enddo
          enddo
        case (3)
          ip1=2-(ifile0-ifilem)
          ip2=ip1+2
          do k=1,npm
            do j=1,ntm
              call dpchfd(3,tprofile(ix)%t(ifilem:ifilep), &
                          br_ef(ip1:ip2,j,k),dbr_ef(ip1:ip2,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              brnew(j,k)=val_ef(1)
            enddo
          enddo
        case default
          do k=1,npm
            do j=1,ntm
              call dpchfd(4,tprofile(ix)%t(ifilem:ifilep), &
                          br_ef(1:4,j,k),dbr_ef(1:4,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              brnew(j,k)=val_ef(1)
            enddo
          enddo
        end select
        if (ierr.lt.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### WARNING from GET_FLUX_IPCHP_PCHIP:'
            write (*,*) '### Recoverable error within DPCHFD'
            write (*,*) 'IERR   = ',ierr
            write (*,*) 'NBR_EF = ',nbr_ef
            write (*,*) 'IFILEM = ',ifilem
            write (*,*) 'IFILE0 = ',ifile0
            write (*,*) 'IFILE1 = ',ifile1
            write (*,*) 'IFILEP = ',ifilep
          end if
        end if
      end if
!
      b0=b0_save
!
end subroutine
!#######################################################################
subroutine ax_pot2dh (p,q)
!
!-----------------------------------------------------------------------
!
! ****** Set Q = A * P for the potential field 2D solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals, ONLY : nt,np
      use cgcom, ONLY : ps_pot2dh,N_CG
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(N_CG) :: p,q
!
!-----------------------------------------------------------------------
!
! ***** Unpack p into ps_pot2dh.
!
      call unpack_pot2dh (ps_pot2dh,p)
!
! ****** Seam P along edges between processors.
!
      call seam_2d_tp (ps_pot2dh,nt,np,.true.,.true.)
!
! ****** Get the matrix-vector product.
!
      call delsq_perp_pot2dh (ps_pot2dh,q)
!
end subroutine
!#######################################################################
subroutine delsq_perp_pot2dh (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = - dV * delsq_perp P
! ******
! ****** at the internal points, and set all other points
! ****** of Q to zero. Version for semi-integer mesh.
!
!-----------------------------------------------------------------------
!
! ****** This routine is used for the 2D potential field solve for
! ****** the rotational contribution to the boundary electric field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use matrix_storage_pot2dh_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: ps
      real(r_typ), dimension(2:ntm1,2:npm1) :: q
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (j=2:ntm1, k=2:npm1)
        q(j,k)=a_dia(1,j,k)*ps(j  ,k-1) &
              +a_dia(2,j,k)*ps(j-1,k  ) &
              +a_dia(3,j,k)*ps(j  ,k  ) &
              +a_dia(4,j,k)*ps(j+1,k  ) &
              +a_dia(5,j,k)*ps(j  ,k+1)
      enddo
!
end subroutine
!#######################################################################
subroutine delsq_divb (ps,q)
!
!-----------------------------------------------------------------------
!
! ****** Set
! ******
! ******   Q = dV * delsq P
! ******
! ****** at the internal points (including radial BCs),
! ****** and set all other points of Q to zero.
!
!-----------------------------------------------------------------------
!
! ****** This routine is used for the divergence cleaning solve.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use mpidefs
      use matrix_storage_divb_solve
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nrm,ntm,npm) :: ps
      real(r_typ), dimension(i0:nrm1,2:ntm-1,2:npm-1) :: q
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
!
!-----------------------------------------------------------------------
!
      do concurrent (k=2:npm-1, j=2:ntm-1, i=i0:nrm1)
        if (rb0.and.i.eq.1) then
          q(i,j,k)=a_dia(1,i,j,k)*ps(i  ,j  ,k-1) &
                  +a_dia(2,i,j,k)*ps(i  ,j-1,k  ) &
                  +a_dia(4,i,j,k)*ps(i  ,j  ,k  ) &
                  +a_dia(5,i,j,k)*ps(i+1,j  ,k  ) &
                  +a_dia(6,i,j,k)*ps(i  ,j+1,k  ) &
                  +a_dia(7,i,j,k)*ps(i  ,j  ,k+1)
        elseif (rb1.and.i.eq.nrm1) then
          q(i,j,k)=a_dia(1,i,j,k)*ps(i  ,j  ,k-1) &
                  +a_dia(2,i,j,k)*ps(i  ,j-1,k  ) &
                  +a_dia(3,i,j,k)*ps(i-1,j  ,k  ) &
                  +a_dia(4,i,j,k)*ps(i  ,j  ,k  ) &
                  +a_dia(6,i,j,k)*ps(i  ,j+1,k  ) &
                  +a_dia(7,i,j,k)*ps(i  ,j  ,k+1)
        else
          q(i,j,k)=a_dia(1,i,j,k)*ps(i  ,j  ,k-1) &
                  +a_dia(2,i,j,k)*ps(i  ,j-1,k  ) &
                  +a_dia(3,i,j,k)*ps(i-1,j  ,k  ) &
                  +a_dia(4,i,j,k)*ps(i  ,j  ,k  ) &
                  +a_dia(5,i,j,k)*ps(i+1,j  ,k  ) &
                  +a_dia(6,i,j,k)*ps(i  ,j+1,k  ) &
                  +a_dia(7,i,j,k)*ps(i  ,j  ,k+1)
        end if
      enddo
!
end subroutine
!#######################################################################
subroutine calc_eflux_vr
!
!-----------------------------------------------------------------------
!
! ****** Calculate the normal flow corresponding to the emerging flux
! ****** electric field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use emerging_flux_params
      use drive_profile
      use shear_profile
      use field_table
      use write_field_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) ::  bt_here,bp_here,et_here,ep_here,b2_here
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** Form the potential
!
      do k=2,npm1
        do j=2,ntm1
          bt_here=(b%t(1,j,k  )+b%t(1,j,k-1))*0.5_r_typ
          bp_here=(b%p(1,j  ,k)+b%p(1,j-1,k))*0.5_r_typ
          et_here=(eflux_et(j  ,k)+eflux_et(j-1,k))*0.5_r_typ
          ep_here=(eflux_ep(j,k  )+eflux_ep(j,k-1))*0.5_r_typ
          b2_here=bt_here*bt_here+bp_here*bp_here
          if (b2_here.ne.0.) then
            eflux_vr(j,k)=(et_here*bp_here-ep_here*bt_here)/b2_here
          end if
        enddo
      enddo
!
! ****** Write eflux_vr to an HDF file.
!
      call write_field_tp ('eflux_vr.h5',IFLD_VR,eflux_vr,0)
!
end subroutine
!#######################################################################
subroutine read_rtp_interp_mmm (fname,f_g,pole_bc,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 3D field in from HDF file FNAME
! ****** and interpolate it into global array F_G.
!
! ****** Boundary conditions at the poles are set according to
! ****** POLE_BC (1: scalar, 2: theta component of a vector,
! ****** 3: phi component of a vector).
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use rdhdf_3d_interface
      use ucase_interface
      use sum_p_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(nrm1_g,ntm1_g,npm1_g) :: f_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: nx,ny,nz,i
      real(r_typ), dimension(:), pointer, contiguous :: x,y,z
      real(r_typ), dimension(:,:,:), pointer, contiguous :: f
!
      real(r_typ), dimension(1) :: sum0,sum1
      real(r_typ), dimension(1) :: sums0,sums1
      real(r_typ), dimension(1) :: sumc0,sumc1
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** When the file name is the special string '<ZERO>',
! ****** the array F_G is set to 0.
!
      if (ucase(fname).eq.'<ZERO>') then
        f_g=0.
        return
      end if
!
! ****** Read the array and its scales.  This call allocates the
! ****** arrays X, Y, and F.
!
      call rdhdf_3d (fname,scale,nx,ny,nz,f,x,y,z,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_RTP_INTERP_MMM:'
        write (9,*) '### Could not read the specified field.'
        write (9,*) 'IERR (from RDHDF_3D) = ',ierr
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Check that the array has scales.
!
      if (.not.scale) then
        write (9,*)
        write (9,*) '### ERROR in READ_RTP_INTERP_MMM:'
        write (9,*) '### The file does not have scales.'
        write (9,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
! ****** Interpolate the field on the R_G, T_G and P_G mesh into
! ****** array F_G.
!
      f_g=0.
!
      call interp_3d (nx,ny,nz,x,y,z,f,nrm1_g,ntm1_g,npm1_g, &
                      r_g, &
                      t_g, &
                      p_g(1:npm1_g), &
                      f_g, &
                      .false.,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_RTP_INTERP_MMM:'
        write (9,*) '### The scales in the file are not valid:'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Make sure that the array is periodic.
!
      f_g(:,:,1)=half*(f_g(:,:,1)+f_g(:,:,npm1_g))
      f_g(:,:,npm1_g)=f_g(:,:,1)
!
! ****** Set boundary conditions at the poles.
!
      if (pole_bc.eq.1) then
!
! ****** A scalar has only an m=0 component.
!
        do i=1,nrm1_g
          sum0=sum_p(1,npm2_g,f_g(i,     1,2:npm1_g),dp_g(2:npm1_g))
          sum1=sum_p(1,npm2_g,f_g(i,ntm1_g,2:npm1_g),dp_g(2:npm1_g))
!
          f_g(i,     1,:)=sum0(1)
          f_g(i,ntm1_g,:)=sum1(1)
        enddo
!
      else
!
! ****** The theta and phi components of a vector have only
! ****** an m=1 component.
!
        do i=1,nrm1_g
          if (axisymmetric) then
            sums0=0.
            sumc0=0.
            sums1=0.
            sumc1=0.
          else
            sums0=sum_p(1,npm2_g,f_g(i,     1,2:npm1_g), &
                           sp_g(2:npm1_g)*dp_g(2:npm1_g))*two
            sumc0=sum_p(1,npm2_g,f_g(i,     1,2:npm1_g), &
                           cp_g(2:npm1_g)*dp_g(2:npm1_g))*two
            sums1=sum_p(1,npm2_g,f_g(i,ntm1_g,2:npm1_g), &
                           sp_g(2:npm1_g)*dp_g(2:npm1_g))*two
            sumc1=sum_p(1,npm2_g,f_g(i,ntm1_g,2:npm1_g), &
                           cp_g(2:npm1_g)*dp_g(2:npm1_g))*two
          end if
!
          f_g(i,     1,1:npm1_g)= sums0(1)*sp_g(1:npm1_g) &
                               +sumc0(1)*cp_g(1:npm1_g)
          f_g(i,ntm1_g,1:npm1_g)= sums1(1)*sp_g(1:npm1_g) &
                               +sumc1(1)*cp_g(1:npm1_g)
!
        enddo
      end if
!
! ****** Deallocate temporary arrays.
!
      deallocate (x)
      deallocate (y)
      deallocate (z)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine shift_phi (omega_input,phi_old,phi_new)
!
!-----------------------------------------------------------------------
!
! ****** Apply local shift in longitude corresponding to rigid
! ****** rotation over dtime for boundary phi.
!
! ****** Since this is only interpolating locally, it keeps orig values
! ****** if no data is available.  This is not ideal and may/should
! ****** be replaced by a local_to_global call in the future.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use mpidefs
      use flint_interface
      use interplanetary_vars
      use constants
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: phi_old,phi_new
      real(r_typ), dimension(np) :: pvh
      real(r_typ) :: omega_input
!
      real(r_typ), parameter :: pi2=2._r_typ*pi
      real(r_typ), parameter :: one=1._r_typ, half=0.5_r_typ
!
      real(r_typ), dimension(nt) :: term
      real(r_typ) :: phishift,pv,ap,h
      integer :: k,j,klo,khi,ktmp,n,c,c2,i,m,ierr
!
!-----------------------------------------------------------------------
!
      ierr=0
!
      phishift=dtime*omega_input
!
!$acc enter data create(pvh)
      do concurrent (k=1:np)
        pvh(k)=ph(k)-phishift
        pvh(k)=mod(pvh(k),pi2)
        if (pvh(k).lt.0.) pvh(k)=pvh(k)+pi2
      enddo
!
      do concurrent (k=1:np, j=1:nt)
        phi_new(j,k)=0
      enddo
!
      if (ip_bc_interp_order.lt.2) then
!
        do concurrent (k=1:np)
!
          pv=pvh(k)
!
! ****** Find the interval and compute the interpolation factor.
!
          if (ph(np).lt.pv.or.ph(1).gt.pv) then
            do concurrent (j=1:nt)
              phi_new(j,k)=phi_old(j,k)
            end do
            ierr=2
            cycle
          else
            klo=1
            khi=np
            do while (khi-klo.gt.1)
              ktmp=AINT((khi+klo)*half)
              if (ph(ktmp).gt.pv) then
                khi=ktmp
              else
                klo=ktmp
              end if
            enddo
            ap=(pv-ph(klo))/(ph(khi)-ph(klo))
          end if
!
          do concurrent (j=1:nt)
            phi_new(j,k)=(one-ap) * phi_old(j,klo)+ &
                              ap  * phi_old(j,khi)
          enddo
        enddo
!
      else
!
        c=ip_bc_interp_order+1
!
        if (np.lt.c) then
          write (*,*) 'Bad c input to lagint ==> c <= length(x)'
          do concurrent (k=1:np, j=1:nt)
            phi_new(j,k)=phi_old(j,k)
          enddo
          ierr=1
          return
        end if
!
!$acc enter data create(term)
        do concurrent (j=1:nt)
          term(j)=0
        enddo
!
        do concurrent (i=1:np)
!
! ****** Find the right place in the table by means of a bisection.
!
          pv=pvh(i)
!
          if (ph(np).lt.pv.or.ph(1).gt.pv) then
            do j=1,nt
              phi_new(j,i)=phi_old(j,i)
            end do
            ierr=2
            cycle
          else
            klo=1
            khi=np
!
            do while (khi-klo.gt.1)
              k=AINT((khi+klo)*half)
              if (ph(k).gt.pv) then
                khi=k
              else
                klo=k
              end if
            enddo
          end if
!
! ****** Evaluate lagrange polynomial.
!
          if (mod(c,2).eq.0) then  !even
            c2=c/2
            if (klo.lt.c2) then
              klo=c2
            end if
            if (klo.gt.np-c2) then
              klo=np-c2
            end if
            khi=klo+1
            do k=klo-(c2-1),klo+c2
              do j=1,nt
                term(j)=phi_old(j,k)
              enddo
              do m=klo-(c2-1),klo+c2
                if (k.ne.m) then
                  do j=1,nt
                    term(j)=term(j)*(pv-ph(m))/(ph(k)-ph(m))
                  enddo
                end if
              enddo
              do j=1,nt
                phi_new(j,i)=phi_new(j,i)+term(j)
              end do
            enddo
          else   ! odd
            c2=floor(c*half)
            if (klo.lt.c2+1) then
              klo=c2+1
            end if
            if (klo > np-c2) then
              klo=np-c2
            end if
            khi=klo+1
            do k=klo-c2,klo+c2
              do j=1,nt
                term(j)=phi_old(j,k)
              end do
              do m=klo-c2,klo+c2
                if (k.ne.m) then
                  do j=1,nt
                    term(j)=term(j)*(pv-ph(m))/(ph(k)-ph(m))
                  enddo
                end if
              enddo
              do j=1,nt
                phi_new(j,i)=phi_new(j,i)+term(j)
              end do
            enddo
          end if
        enddo
!
!$acc exit data delete(term)
      end if
!
!$acc exit data delete(pvh)
end subroutine
!#######################################################################
subroutine shift_psi (omega_input,psi_old,psi_new)
!
!-----------------------------------------------------------------------
!
! ****** Apply local shift in longitude corresponding to rigid
! ****** rotation over dtime for boundary psi.
!
! ****** Since this is only interpolating locally, it keeps orig values
! ****** if no data is available.  This is not ideal and may/should
! ****** be replaced by a local_to_global call in the future.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use vars
      use mpidefs
      use flint_interface
      use interplanetary_vars
      use constants
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: psi_old,psi_new
      real(r_typ), dimension(npm) :: pvm
      real(r_typ) :: omega_input
!
      real(r_typ), parameter :: pi2=2._r_typ*pi
      real(r_typ), parameter :: one=1._r_typ, half=0.5_r_typ
!
      real(r_typ), dimension(ntm) :: term
      real(r_typ) :: phishift,pv,ap,h
      integer :: k,j,klo,khi,ktmp,n,c,c2,i,m,ierr
!
!-----------------------------------------------------------------------
!
      ierr=0
!
      phishift=dtime*omega_input
!
!$acc enter data create(pvm)
      do concurrent (k=1:npm)
        pvm(k)=p(k)-phishift
        pvm(k)=mod(pvm(k),pi2)
        if (pvm(k).lt.0.) pvm(k)=pvm(k)+pi2
      enddo
!
      do concurrent (k=1:npm, j=1:ntm)
        psi_new(j,k)=0
      enddo
!
      if (ip_bc_interp_order.lt.2) then
!
        do concurrent (k=1:npm)
!
          pv=pvm(k)
!
! ****** Find the interval and compute the interpolation factor.
!
          if (p(np).lt.pv.or.p(1).gt.pv) then
            do concurrent (j=1:ntm)
              psi_new(j,k)=psi_old(j,k)
            enddo
            ierr=2
            cycle
          else
            klo=1
            khi=np
            do while (khi-klo.gt.1)
              ktmp=AINT((khi+klo)*half)
              if (p(ktmp).gt.pv) then
                khi=ktmp
              else
                klo=ktmp
              end if
             enddo
            ap=(pv-p(klo))/(p(khi)-p(klo))
          end if
!
          do concurrent (j=1:ntm)
            psi_new(j,k)=(one-ap) * psi_old(j,klo)+ &
                              ap  * psi_old(j,khi)
          enddo
        enddo
!
      else
!
        c=ip_bc_interp_order+1
!
!$acc enter data create(term)
        do concurrent (j=1:ntm)
          term(j)=0
        enddo
!
        if (np.lt.c) then
          write (*,*) 'Bad c input to lagint ==> c <= length(x)'
          do concurrent (k=1:npm, j=1:ntm)
            psi_new(j,k)=psi_old(j,k)
          enddo
          ierr=1
          return
        end if
!
        do concurrent (i=1:npm)
!
! ****** Find the right place in the table by means of a bisection.
!
          pv=pvm(i)
!
          if (p(np).lt.pv.or.p(1).gt.pv) then
            do j=1,ntm
              psi_new(j,i)=psi_old(j,i)
            enddo
            ierr=2
            cycle
          else
            klo=1
            khi=npm
!
            do while (khi-klo.gt.1)
              k=AINT((khi+klo)*half)
              if (p(k).gt.pv) then
                khi=k
              else
                klo=k
              end if
            enddo
          end if
!
! ****** Evaluate lagrange polynomial.
!
          if (mod(c,2).eq.0) then  !even
            c2=c/2
            if (klo.lt.c2) then
              klo=c2
            end if
            if (klo.gt.np-c2) then
              klo=np-c2
            end if
            khi=klo+1
            do k=klo-(c2-1),klo+c2
              do j=1,ntm
                term(j)=psi_old(j,k)
              enddo
              do m=klo-(c2-1),klo+c2
                if (k.ne.m) then
                  do j=1,ntm
                    term(j)=term(j)*(pv-p(m))/(p(k)-p(m))
                  enddo
                end if
              enddo
              do j=1,ntm
                psi_new(j,i)=psi_new(j,i)+term(j)
              enddo
            enddo
          else   ! odd
            c2=floor(c*half)
            if (klo.lt.c2+1) then
              klo=c2+1
            end if
            if (klo > np-c2) then
              klo=np-c2
            end if
            khi=klo+1
            do k=klo-c2,klo+c2
              do j=1,ntm
                term(j)=psi_old(j,k)
              enddo
              do m=klo-c2,klo+c2
                if (k.ne.m) then
                  do j=1,ntm
                    term(j)=term(j)*(pv-p(m))/(p(k)-p(m))
                  enddo
                end if
              enddo
              do j=1,ntm
                psi_new(j,i)=psi_new(j,i)+term(j)
              enddo
            enddo
          end if
        enddo
!
!$acc exit data delete(term)
      end if
!
!$acc exit data delete(pvm)
end subroutine
!#######################################################################
subroutine get_ip_boundaries
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the present time for an
! ****** interplanetary calculation
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use flint_interface
      use upwind_resistivity
      use interplanetary_vars
      use ucase_interface
      use global_to_local_tp_interface
      use field_table
      use write_field_tp_interface
      use hdf_defs
      use seam_tp_2d_interface
      use seam_t_2d_interface
      use seam_p_2d_interface
      use cgcom
      use timing
      use debug
      use mod_input_parameter
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0
      integer :: ix,nodes,i,j,k
      logical, save :: first_rb0=.true.
      logical :: exists
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: zero=0._r_typ
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: tiny_value=1.e-20_r_typ
!
!-----------------------------------------------------------------------
!
! ****** Variables for interpolation.
!
      integer :: ifile0,ifile1
      real(r_typ) :: file_no,frac
      character(256) :: fname
      character(6) :: seq
!
      real(r_typ) :: av_vt_p,av_vt_m,av_vp_p,av_vp_m
      real(r_typ) :: av_br_p,av_br_m
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: ur,ut,up,brmono
!
! ****** Array for the RHS of the 2D potential solve at
! ****** the lower radial boundary.
!
      real(r_typ), dimension(ntm,npm), target :: rhs2d,psi,dbr,br_nomono
      real(r_typ), dimension(nt,np), target :: dvxb,phi
!
      real(r_typ) :: normrhs,normrhs2,brav,dv
      real(r_typ) :: vtaux(ntm,np),vpaux(nt,npm)
!
!-----------------------------------------------------------------------
!
! ****** Interpolate to time
!
      if (time-deltat_ip.le.ip_node(1)) then
        ifile0=1
        ifile1=1
        frac=0.
      else if (time-deltat_ip.ge.ip_node(n_ip_seq)) then
        ifile0=n_ip_seq
        ifile1=n_ip_seq
        frac=0.
      else
        file_no=flint(.false.,time-deltat_ip,n_ip_seq, &
        ip_node,helper_ip,ierr)
        ifile0=file_no
        ifile1=min(ifile0+1,n_ip_seq)
        frac=file_no-ifile0
      end if
!
! ****** Set up the quantities in their arrays _IP0 and _IP1
! ****** bounding this interval.
!
! ****** First, check to see if the files have changed.
! ****** If they have, check to see if these files have already
! ****** been read in previously; if they have, transfer those
! ****** quantities, otherwise read in the new files.
!
      if (ifile0.ne.ifile0_contents) then
        if (ifile0.eq.ifile1_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_IP_BOUNDARIES:'
            write (9,*) '### Transferring flux from FILE1 to FILE0.'
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          br_ip0_g=br_ip1_g
          bt_ip0_g=bt_ip1_g
          bp_ip0_g=bp_ip1_g
          vr_ip0_g=vr_ip1_g
          vt_ip0_g=vt_ip1_g
          vp_ip0_g=vp_ip1_g
          rho_ip0_g=rho_ip1_g
          t_ip0_g=t_ip1_g
          if (advance_fcs) then
            fcsr0_ip0_g=fcsr0_ip1_g
          end if
          if (advance_pw) then
            ep_ip0_g=ep_ip1_g
            em_ip0_g=em_ip1_g
          end if
          if (advance_zw) then
            zp_ip0_g=zp_ip1_g
            zm_ip0_g=zm_ip1_g
          end if
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_IP_BOUNDARIES:'
            write (9,*) '### Reading new files'
            write (9,*) 'Sequence: ',ip_sequence(ifile0)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          if (long_sequence_numbers_input) then
            write (seq,'(i6.6)') ip_sequence(ifile0)
          else
            write (seq,'(i3.3)') ip_sequence(ifile0)
          end if
          fname=trim(ip_path)//trim(brfile)//trim(seq)//'.h5'
          call read_tp_mm_g (fname,br_ip0_g,1)
          fname=trim(ip_path)//trim(btfile)//trim(seq)//'.h5'
          call read_tp_hm_g (fname,bt_ip0_g,2)
          fname=trim(ip_path)//trim(bpfile)//trim(seq)//'.h5'
          call read_tp_mh_g (fname,bp_ip0_g,3)
          fname=trim(ip_path)//trim(rhofile)//trim(seq)//'.h5'
          call read_tp_hh_g (fname,rho_ip0_g,1)
          fname=trim(ip_path)//trim(tfile)//trim(seq)//'.h5'
          call read_tp_hh_g (fname,t_ip0_g,1)
          fname=trim(ip_path)//trim(vrfile)//trim(seq)//'.h5'
          call read_tp_hh_g (fname,vr_ip0_g,1)
          fname=trim(ip_path)//trim(vtfile)//trim(seq)//'.h5'
          call read_tp_mh_g (fname,vt_ip0_g,2)
          fname=trim(ip_path)//trim(vpfile)//trim(seq)//'.h5'
          call read_tp_hm_g (fname,vp_ip0_g,3)
          if (advance_fcs) then
            fname=trim(ip_path)//trim(fcsfile)//trim(seq)//".h5"
            call read_fcs_g (fname,fcsr0_ip0_g,ncs,1)
          end if
          if (advance_pw) then
            fname=trim(ip_path)//trim(epfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,ep_ip0_g,1)
            fname=trim(ip_path)//trim(emfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,em_ip0_g,1)
          end if
          if (advance_zw) then
            fname=trim(ip_path)//trim(zpfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,zp_ip0_g,1)
            fname=trim(ip_path)//trim(zmfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,zm_ip0_g,1)
          end if
        end if
        ifile0_contents=ifile0
      end if
!
      if (ifile1.ne.ifile1_contents) then
        if (ifile1.eq.ifile0_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_IP_BOUNDARIES:'
            write (9,*) '### Transferring flux from FILE0 to FILE1.'
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          br_ip1_g=br_ip0_g
          bt_ip1_g=bt_ip0_g
          bp_ip1_g=bp_ip0_g
          vr_ip1_g=vr_ip0_g
          vt_ip1_g=vt_ip0_g
          vp_ip1_g=vp_ip0_g
          rho_ip1_g=rho_ip0_g
          t_ip1_g=t_ip0_g
          if (advance_fcs) then
            fcsr0_ip1_g=fcsr0_ip0_g
          end if
          if (advance_pw) then
            ep_ip1_g=ep_ip0_g
            em_ip1_g=em_ip0_g
          end if
          if (advance_zw) then
            zp_ip1_g=zp_ip0_g
            zm_ip1_g=zm_ip0_g
          end if
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_IP_BOUNDARIES:'
            write (9,*) '### Reading new files'
            write (9,*) 'Sequence: ',ip_sequence(ifile1)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          if (long_sequence_numbers_input) then
            write (seq,'(i6.6)') ip_sequence(ifile1)
          else
            write (seq,'(i3.3)') ip_sequence(ifile1)
          end if
          fname=trim(ip_path)//trim(brfile)//trim(seq)//'.h5'
          call read_tp_mm_g (fname,br_ip1_g,1)
          fname=trim(ip_path)//trim(btfile)//trim(seq)//'.h5'
          call read_tp_hm_g (fname,bt_ip1_g,2)
          fname=trim(ip_path)//trim(bpfile)//trim(seq)//'.h5'
          call read_tp_mh_g (fname,bp_ip1_g,3)
          fname=trim(ip_path)//trim(rhofile)//trim(seq)//'.h5'
          call read_tp_hh_g (fname,rho_ip1_g,1)
          fname=trim(ip_path)//trim(tfile)//trim(seq)//'.h5'
          call read_tp_hh_g (fname,t_ip1_g,1)
          fname=trim(ip_path)//trim(vrfile)//trim(seq)//'.h5'
          call read_tp_hh_g (fname,vr_ip1_g,1)
          fname=trim(ip_path)//trim(vtfile)//trim(seq)//'.h5'
          call read_tp_mh_g (fname,vt_ip1_g,2)
          fname=trim(ip_path)//trim(vpfile)//trim(seq)//'.h5'
          call read_tp_hm_g (fname,vp_ip1_g,3)
          if (advance_fcs) then
            fname=trim(ip_path)//trim(fcsfile)//trim(seq)//".h5"
            call read_fcs_g (fname,fcsr0_ip1_g,ncs,1)
          end if
          if (advance_pw) then
            fname=trim(ip_path)//trim(epfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,ep_ip1_g,1)
            fname=trim(ip_path)//trim(emfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,em_ip1_g,1)
          end if
          if (advance_zw) then
            fname=trim(ip_path)//trim(zpfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,zp_ip1_g,1)
            fname=trim(ip_path)//trim(zmfile)//trim(seq)//'.h5'
            call read_tp_hh_g (fname,zm_ip1_g,1)
          end if
        end if
        ifile1_contents=ifile1
      end if
!
! ****** Interpolate the arrays to time TIME.
!
      br_ip_g=(one-frac)*br_ip0_g+frac*br_ip1_g
      bt_ip_g=(one-frac)*bt_ip0_g+frac*bt_ip1_g
      bp_ip_g=(one-frac)*bp_ip0_g+frac*bp_ip1_g
      rho_ip_g=(one-frac)*rho_ip0_g+frac*rho_ip1_g
      t_ip_g=(one-frac)*t_ip0_g+frac*t_ip1_g
      vr_ip_g=(one-frac)*vr_ip0_g+frac*vr_ip1_g
      vt_ip_g=(one-frac)*vt_ip0_g+frac*vt_ip1_g
      vp_ip_g=(one-frac)*vp_ip0_g+frac*vp_ip1_g
      if (advance_fcs) then
        fcsr0_ip_g=(one-frac)*fcsr0_ip0_g+frac*fcsr0_ip1_g
      end if
      if (advance_pw) then
        ep_ip_g=(one-frac)*ep_ip0_g+frac*ep_ip1_g
        em_ip_g=(one-frac)*em_ip0_g+frac*em_ip1_g
      end if
      if (advance_zw) then
        zp_ip_g=(one-frac)*zp_ip0_g+frac*zp_ip1_g
        zm_ip_g=(one-frac)*zm_ip0_g+frac*zm_ip1_g
      end if
!
! ****** Apply corrections needed based on reference frames.
!
      if (boundary_frame.eq."FAKE_COROTATING".and.calculation_frame &
       .eq."COROTATING") then
        call longitude_shift (zero)
        call transform_vp_bc (-omega_corotate)
!
      else if (boundary_frame.eq."COROTATING".and.calculation_frame &
       .eq."COROTATING") then
        call longitude_shift (zero)
!
      else if (boundary_frame.eq."INERTIAL".and.calculation_frame &
       .eq."COROTATING") then
        call longitude_shift (-omega_corotate)
        call transform_vp_bc (-omega_corotate)
!
      else if (boundary_frame.eq."FAKE_COROTATING".and.calculation_frame &
       .eq."INERTIAL") then
        call longitude_shift (omega_corotate)
!
      else if (boundary_frame.eq."COROTATING".and.calculation_frame &
       .eq."INERTIAL") then
        call longitude_shift (omega_corotate)
        call transform_vp_bc (omega_corotate)
!
      else if (boundary_frame.eq."INERTIAL".and.calculation_frame &
       .eq."INERTIAL") then
        call longitude_shift (zero)
      else
        if (iamp0) then
          write (*,*)
          write (*,*) '### ERROR in GET_IP_BOUNDARIES:'
          write (*,*) '### Invalid boundary and/or calculation frame.'
          ierr=1
        end if
        call check_error_on_p0 (ierr)
      end if
!
      call balance_flux2 (br_ip,ierr)
!
      call set_pole_bc_bvec_tp (bt_ip,bp_ip)
      call set_pole_bc_vvec_tp_cpu (vt_ip,vp_ip)
!
      if (advance_pw) then
!$acc update device(epbcr0re,embcr0re)
      end if
      if (advance_fcs) then
!$acc update device(fcsr0)
      end if
      if (advance_zw) then
!$acc update device(zpbcr0re,zmbcr0re)
      end if
!$acc update device(br_ip,bt_ip,bp_ip,vr_ip,vt_ip,vp_ip,t_ip,rho_ip)
      if (ip_bc_use_pot_solves) then
!
!-----------------------------------------------------------------------
! ****** Solve the 2D implicit equations for the boundary potentials.
!-----------------------------------------------------------------------
!
        if (rb0) then
!$acc enter data create(rhs2d,psi,phi,dbr,dvxb,vtaux,vpaux)
!
! ****** Perform preliminary solve if using rotated guess for PSI.
!
          if (first_rb0.and.ip_bc_shift_psi_guess) then
!$acc enter data create(br_nomono)
            brmono=half*br00*r0**2*(rh_i(1)**2+rh_i(2)**2)
            do concurrent (k=1:npm, j=1:ntm)
              rhs2d(j,k)=0.
              br_nomono(j,k)=0.
              psi_n(j,k)=0.
            enddo
!
            do concurrent (k=1:npm1, j=1:ntm1)
              br_nomono(j,k)=half*(b%r(1,j,k)+b%r(2,j,k))-brmono
            enddo
!
            do concurrent (k=2:npm-1)
              do concurrent (j=2:ntm-1)
                dv=r0**2*dt(j)*st(j)*dp(k)
                rhs2d(j,k)=dv*br_nomono(j,k)
              enddo
              if (tb0) then
                dv=quarter*r0**2*dt(   1)*sth(   2)*dp(k)
                rhs2d(   1,k)=dv*br_nomono(   1,k)
              end if
              if (tb1) then
                dv=quarter*r0**2*dt(ntm1)*sth(ntm1)*dp(k)
                rhs2d(ntm1,k)=dv*br_nomono(ntm1,k)
              end if
            enddo
!
            equation_solved=EQ_POT2D_NEWFLUX
            call pot2d_solver (psi_n,rhs2d,ierr)
          end if
        end if
!
        call check_error_on_any_proc (ierr)
!
        if (rb0) then
          if (first_rb0.and.ip_bc_shift_psi_guess) then
            do concurrent (k=1:npm, j=1:ntm)
              psi_rn(j,k)=psi_n(j,k)
            enddo
            first_rb0=.false.
!$acc exit data delete (br_nomono)
          end if
!
! ****** Set up guess for PSI solve.
!
          if (ip_bc_shift_psi_guess) then
            if (   boundary_frame.eq."INERTIAL".and. &
                calculation_frame.eq."COROTATING") then
              call shift_psi (-omega_corotate,psi_n,psi_rnp1)
              do concurrent (k=1:npm, j=1:ntm)
                psi(j,k)=(psi_rnp1(j,k)-psi_rn(j,k))
                psi_rn(j,k)=psi_rnp1(j,k)
              enddo
            else if ((boundary_frame.eq."FAKE_COROTATING".or. &
                      boundary_frame.eq."COROTATING") &
                     .and.calculation_frame.eq."INERTIAL") then
              call shift_psi (omega_corotate,psi_n,psi_rnp1)
              do concurrent (k=1:npm, j=1:ntm)
                psi(j,k)=(psi_rnp1(j,k)-psi_rn(j,k))
                psi_rn(j,k)=psi_rnp1(j,k)
              enddo
            else
              do concurrent (k=1:npm, j=1:ntm)
                psi(j,k)=psi_old(j,k)
              enddo
            end if
          else
            do concurrent (k=1:npm, j=1:ntm)
              psi(j,k)=psi_old(j,k)
            enddo
          end if
!
! ****** Form the RHS.
!
          do concurrent (k=1:npm, j=1:ntm)
            dbr(j,k)=0.
            rhs2d(j,k)=0.
          enddo
          brmono=half*br00*r0**2*(rh_i(1)**2+rh_i(2)**2)
!
          do concurrent (k=1:npm1, j=1:ntm1)
            brav=half*(b%r(1,j,k)+b%r(2,j,k))-brmono
            dbr(j,k)=br_ip(j,k)-brav
          enddo
!
          do concurrent (k=2:npm-1)
            do j=2,ntm-1
              dv=r0**2*dt(j)*st(j)*dp(k)
              rhs2d(j,k)=dv*dbr(j,k)
            enddo
            if (tb0) then
              dv=quarter*r0**2*dt(   1)*sth(   2)*dp(k)
              rhs2d(   1,k)=dv*dbr(   1,k)
            end if
            if (tb1) then
              dv=quarter*r0**2*dt(ntm1)*sth(ntm1)*dp(k)
              rhs2d(ntm1,k)=dv*dbr(ntm1,k)
            end if
          enddo
!
! ****** Solve the 2D implicit equations for the boundary potential.
!
          equation_solved=EQ_POT2D_NEWFLUX
!
          call pot2d_solver (psi,rhs2d,ierr)
!
        end if
!
        call check_error_on_any_proc (ierr)
!
        if (rb0) then
!
! ****** Store psi in psi_old for use in vxb
! ****** and if using rotation guess, compute psi_n.
!
          do concurrent (k=1:npm, j=1:ntm)
            psi_old(j,k)=psi(j,k)
          enddo
!
          if (ip_bc_shift_psi_guess) then
            do concurrent (k=1:npm, j=1:ntm)
              psi_n(j,k)=psi(j,k)+psi_n(j,k)
            enddo
          end if
!
!-----------------------------------------------------------------------
! ****** Start PHI solve.
!-----------------------------------------------------------------------
!
! ****** Set up guess for PHI solve.
!
          if (ip_bc_shift_phi_guess) then
            if (   boundary_frame.eq."INERTIAL".and. &
                calculation_frame.eq."COROTATING") then
              call shift_phi (-omega_corotate,phi_old,phi)
            else if ((boundary_frame.eq."FAKE_COROTATING".or. &
                      boundary_frame.eq."COROTATING") &
                     .and.calculation_frame.eq."INERTIAL") then
              call shift_phi (omega_corotate,phi_old,phi)
            else
              do concurrent (k=1:np, j=1:nt)
                phi(j,k)=phi_old(j,k)
              enddo
            end if
          else
            do concurrent (k=1:np, j=1:nt)
              phi(j,k)=phi_old(j,k)
            enddo
          end if
!
! ****** Form the RHS.
!
          do concurrent (k=1:np, j=1:nt)
            dvxb(j,k)=0.
          enddo
!
! ****** Set the electric field at r=R0.
!
          do concurrent (k=1:np, j=1:ntm)
            vtaux(j,k)=0.
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            vpaux(j,k)=0.
          enddo
!
          do concurrent (k=2:npm1, j=1:ntm1)
            av_vr=AVGT2 (vr_ip,j+1,k)
            av_vp=AVGTP2(vp_ip,j+1,k)
            av_br=AVGP2 (br_ip,j,k)
            av_bp=AVG2  (bp_ip,j,k)
            if (boundary_frame.eq."FAKE_COROTATING") then
              av_vp=av_vp+r0*st(j)*omega_corotate
            end if
            vtaux(j,k)=av_vp*av_br-av_vr*av_bp
          enddo
!
          do concurrent (k=1:npm1, j=2:ntm1)
            av_vr=AVGP2 (vr_ip,j,k+1)
            av_vt=AVGTP2(vt_ip,j,k+1)
            av_br=AVGT2 (br_ip,j,k  )
            av_bt=AVG2  (bt_ip,j,k  )
            vpaux(j,k)=av_vr*av_bt-av_vt*av_br
          enddo
!
          call seam_2d_tp (vtaux,ntm,np,.true.,.true.)
          call seam_2d_tp (vpaux,nt,npm,.true.,.true.)
!
          do concurrent (k=2:npm1, j=2:ntm1)
            dvxb(j,k)=((st(j  )*vtaux(j  ,k) &
                       -st(j-1)*vtaux(j-1,k))*r0*dph(k)+ &
                       (vpaux(j,k)-vpaux(j,k-1))*r0*dth(j))
          enddo
!
! ****** The guess for PHI was set above.
!
          equation_solved=EQ_POT2DH
!
          call pot2dh_solver (phi,dvxb,ierr)
!
        end if
!
        call check_error_on_any_proc (ierr)
!
        if (rb0) then
!
! ****** Save phi for use as guess in next time-step.
!
          do concurrent (k=1:np, j=1:nt)
            phi_old(j,k)=phi(j,k)
          enddo
!
!$acc exit data delete (rhs2d,psi,phi,dbr,dvxb,vtaux,vpaux)
        end if
!
      end if
!$acc exit data delete (phi)
!
end subroutine
!######################################################################
subroutine v_minus_omegaxr_bb (vmomegaxrbb)
!
!-----------------------------------------------------------------------
!
! ****** Compute (omega_corotate x vec )bb.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
      use fields
      use upwind_resistivity
      use seam_rt_interface
      use seam_rp_interface
      use seam_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: vmomegaxrbb
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: beta0=1._r_typ
      real(r_typ), parameter :: dbeta=.25_r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: vdotb,bsq,beta,prof,av_p
      real(r_typ) :: v_perp_r,v_perp_t,v_perp_p
      real(r_typ) :: omval
!
!-----------------------------------------------------------------------
!
! ****** Zero out the array.
!
      call zero_vvec (vmomegaxrbb)
!
! ****** Set omega based on chosen frame.
!
      if (calculation_frame.eq.'COROTATING') then
        omval=omega_corotate
      else
        omval=0.
      end if
!
!-----------------------------------------------------------------------
! ****** Internal points.
!-----------------------------------------------------------------------
!
! ****** Set the r component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm1)
        av_vr=AVG   (v%r,i  ,j,k)
        av_vt=AVGRT (v%t,i+1,j,k)
        av_vp=AVGRP (v%p,i+1,j,k)
        av_vp=av_vp+omval*r(i)*sth(j)
        av_br=AVGRTP(b%r,i+1,j,k)
        av_bt=AVGP  (b%t,i  ,j,k)
        av_bp=AVGT  (b%p,i  ,j,k)
        av_p  =AVGR  (pres,i+1,j,k)
        vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
        bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
        bsq=max(bsq,small_value)
        beta=two*av_p/bsq
        prof=.5_r_typ*(1._r_typ+tanh((beta-beta0)/dbeta))
        vmomegaxrbb%r(i,j,k)=(one-prof)*vdotb*av_br/bsq+prof*av_vr
      enddo
!
! ****** Set the theta component.
!
      do concurrent (k=2:npm1, j=1:ntm1, i=2:nrm1)
        av_vr=AVGRT (v%r,i,j+1,k)
        av_vt=AVG   (v%t,i,j  ,k)
        av_vp=AVGTP (v%p,i,j+1,k)
        av_vp=av_vp+omval*rh(i)*st(j)
        av_br=AVGP  (b%r,i,j  ,k)
        av_bt=AVGRTP(b%t,i,j+1,k)
        av_bp=AVGR  (b%p,i,j  ,k)
        av_p  =AVGT  (pres,i,j+1,k)
        vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
        bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
        bsq=max(bsq,small_value)
        beta=two*av_p/bsq
        prof=.5_r_typ*(1._r_typ+tanh((beta-beta0)/dbeta))
        vmomegaxrbb%t(i,j,k)=(one-prof)*vdotb*av_bt/bsq+prof*av_vt
      enddo
!
! ****** Set the phi component.
!
      do concurrent (k=1:npm1, j=2:ntm1, i=2:nrm1)
        av_vr=AVGRP (v%r,i,j,k+1)
        av_vt=AVGTP (v%t,i,j,k+1)
        av_vp=AVG   (v%p,i,j,k  )
        av_vp=av_vp+omval*rh(i)*sth(j)
        av_br=AVGT  (b%r,i,j,k  )
        av_bt=AVGR  (b%t,i,j,k  )
        av_bp=AVGRTP(b%p,i,j,k+1)
        av_p  =AVGP  (pres,i,j,k+1)
        vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
        bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
        bsq=max(bsq,small_value)
        beta=two*av_p/bsq
        prof=.5_r_typ*(1._r_typ+tanh((beta-beta0)/dbeta))
        vmomegaxrbb%p(i,j,k)=(one-prof)*vdotb*av_bp/bsq+prof*av_vp
      enddo
!
!-----------------------------------------------------------------------
! ****** Boundary values.
!-----------------------------------------------------------------------
!
! ****** Set the theta component at r=R1.
!
      if (rb1) then
        i=nrm1
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr=AVGT  (v%r,i  ,j+1,k)
          av_vt=AVGR  (v%t,i+1,j  ,k)
          av_vp=AVGRTP(v%p,i+1,j+1,k)
          av_vp=av_vp+omval*r(i)*st(j)
          av_br=AVGRP (b%r,i+1,j  ,k)
          av_bt=AVGTP (b%t,i  ,j+1,k)
          av_bp=AVG   (b%p,i  ,j  ,k)
          av_p  =AVGRT (pres,i+1,j+1,k)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          beta=two*av_p/bsq
          prof=.5_r_typ*(1._r_typ+tanh((beta-beta0)/dbeta))
          vmomegaxrbb%t(i,j,k)=two*((one-prof)*vdotb*av_bt/bsq+ &
          prof*av_vt)-vmomegaxrbb%t(i-1,j,k)
        enddo
!
! ****** Set the phi component at r=R1.
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr=AVGP  (v%r,i  ,j,k+1)
          av_vt=AVGRTP(v%t,i+1,j,k+1)
          av_vp=AVGR  (v%p,i+1,j,k  )
          av_vp=av_vp+omval*r(i)*sth(j)
          av_br=AVGRT (b%r,i+1,j,k  )
          av_bt=AVG   (b%t,i  ,j,k  )
          av_bp=AVGTP (b%p,i  ,j,k+1)
          av_p  =AVGRP  (pres,i+1,j,k+1)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          beta=two*av_p/bsq
          prof=.5_r_typ*(1._r_typ+tanh((beta-beta0)/dbeta))
          vmomegaxrbb%p(i,j,k)=two*((one-prof)*vdotb*av_bp/bsq+ &
          prof*av_vp)-vmomegaxrbb%p(i-1,j,k)
        enddo
      end if
!
! ****** Set the field at r=R0.
!
      if (rb0) then
        i=1
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr=AVGT  (v%r,i  ,j+1,k)
          av_vt=AVGR  (v%t,i+1,j  ,k)
          av_vp=AVGRTP(v%p,i+1,j+1,k)
          av_vp=av_vp+omval*r(i)*st(j)
          av_br=AVGRP (b%r,i+1,j  ,k)
          av_bt=AVGTP (b%t,i  ,j+1,k)
          av_bp=AVG   (b%p,i  ,j  ,k)
          av_p  =AVGRT (pres,i+1,j+1,k)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          beta=two*av_p/bsq
          prof=.5_r_typ*(1._r_typ+tanh((beta-beta0)/dbeta))
          vmomegaxrbb%t(i,j,k)=two*((one-prof)*vdotb*av_bt/bsq+ &
          prof*av_vt)-vmomegaxrbb%t(i+1,j,k)
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr=AVGP  (v%r,i  ,j,k+1)
          av_vt=AVGRTP(v%t,i+1,j,k+1)
          av_vp=AVGR  (v%p,i+1,j,k  )
          av_vp=av_vp+omval*r(i)*sth(j)
          av_br=AVGRT (b%r,i+1,j,k  )
          av_bt=AVG   (b%t,i  ,j,k  )
          av_bp=AVGTP (b%p,i  ,j,k+1)
          av_p  =AVGRP  (pres,i+1,j,k+1)
          vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
          bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
          bsq=max(bsq,small_value)
          beta=two*av_p/bsq
          prof=.5_r_typ*(1._r_typ+tanh((beta-beta0)/dbeta))
          vmomegaxrbb%p(i,j,k)=two*((one-prof)*vdotb*av_bp/bsq+ &
          prof*av_vp)-vmomegaxrbb%p(i+1,j,k)
        enddo
      end if
!
! ****** Set b.c. at the poles and seam the array.
!
      call set_pole_bc_vvec (vmomegaxrbb)
      call seam_vvec (vmomegaxrbb)
!
end subroutine
!#######################################################################
subroutine add_inertial_force (jxb,vec)
!
!-----------------------------------------------------------------------
!
! ****** Compute and add fictitious force to JxB
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
      use fields
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: jxb, vec
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vecp,av_vecr,av_vect,avrho
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
!  ****** R component.
!
      do concurrent (k=2:npm1, j=2:ntm1, i=1:nrm-1)
        avrho=AVGR(rho,i+1,j,k)
        av_vecp=AVGRP(vec%p,i+1,j  ,k  )
        jxb%r(i,j,k)= jxb%r(i,j,k)+avrho*( &
        two*omega_corotate*sth(j)*av_vecp &
        +r(i)*(omega_corotate*sth(j))**2)
      enddo
!
! ****** Theta component.
!
      do concurrent (k=2:npm1, j=2:ntm-1, i=2:nrm1)
        avrho=AVGT(rho,i,j+1,k)
        av_vecp=AVGTP(vec%p,i  ,j+1,k  )
        jxb%t(i,j,k)= jxb%t(i,j,k)+avrho* &
        two*omega_corotate*ct (j)*av_vecp
      enddo
!
! ****** Phi component.
!
      do concurrent (k=2:npm-1, j=2:ntm1, i=2:nrm1)
        avrho=AVGP(rho,i,j,k+1)
        av_vecr=AVGRP(vec%r,i  ,j  ,k+1)
        av_vect=AVGTP(vec%t,i  ,j  ,k+1)
        jxb%p(i,j,k)= jxb%p(i,j,k)-avrho* &
        two*omega_corotate*(sth(j)*av_vecr+cth(j)*av_vect)
      enddo
!
end subroutine
!#######################################################################
subroutine bc_vcrossb_interplanetary (v,b,vxb,vxb_b)
!
!-----------------------------------------------------------------------
!
! ****** Compute (v x B) boundary conditions, interplanetary case.
!
!-----------------------------------------------------------------------
!
! ****** On input, V contains the velocity, and B contains
! ****** the magnetic field.
! ****** On return, the r component of VXB  (v x B) is modified at r0
! ****** and VXB_B contains (v x B) at the tangential boundary
! ****** points.
! ****** Interplanetary version
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use vars
      use mesh
      use upwind_resistivity
      use interplanetary_vars
      use field_table
      use write_field_tp_interface
      use mpidefs
      use seam_t_2d_interface
      use seam_p_2d_interface
      use cgcom
      use timing
      use debug
      use fields, ONLY : psi_old,phi_old
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      type(bvec) :: b
      type(avec) :: vxb
      type(avec_bc) :: vxb_b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: tiny_value=1.e-20_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vt_p,av_vt_m,av_vp_p,av_vp_m
      real(r_typ) :: av_br_p,av_br_m
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: ur,ut,up,brmono
!
!-----------------------------------------------------------------------
!
! ****** Boundary values at r=R0.
!
!-----------------------------------------------------------------------
!
      if (rb0) then
! ****** Set the r component.
!
        do concurrent (k=2:npm1, j=2:ntm1)
          av_vt=AVGT2(vt_ip,j,k)
          av_vp=AVGP2(vp_ip,j,k)
          ut=sign(upwind_at,av_vt)
          up=sign(upwind_ap,av_vp)
          av_bt=ADVP2(bt_ip,j,k,up)
          av_bp=ADVT2(bp_ip,j,k,ut)
          vxb%r(1,j,k)=(av_vt*av_bp-av_vp*av_bt)
        enddo
!
! ****** Set the emerging flux electric field at the r=R0 boundary.
!
        if (ip_bc_use_pot_solves) then
!
          do concurrent (k=2:npm1, j=jm0:jm1)
            vxb_b%r0%t(j,k)=(psi_old(j,k)-psi_old(j,k-1)) &
                            *dph_i(k)*r_i(1)*st_i(j)/dtime &
              -(phi_old(j+1,k)-phi_old(j,k))*dt_i(j)*r_i(1)
          enddo
!
          do concurrent (k=1:npm1, j=2:ntm1)
            vxb_b%r0%p(j,k)=-(psi_old(j,k)-psi_old(j-1,k)) &
                            *dth_i(j)*r_i(1)/dtime &
              -(phi_old(j,k+1)-phi_old(j,k))*dp_i(k)*r_i(1)*sth_i(j)
          enddo
!
        else
!
          do concurrent (k=2:npm1, j=jm0:jm1)
            av_vr=AVGT2 (vr_ip,j+1,k)
            av_vp=AVGTP2(vp_ip,j+1,k)
            av_br=AVGP2 (br_ip,j,k)
            av_bp=AVG2  (bp_ip,j,k)
            if (boundary_frame.eq."FAKE_COROTATING") then
              av_vp=av_vp+r0*st(j)*omega_corotate
            end if
            vxb_b%r0%t(j,k)=av_vp*av_br-av_vr*av_bp
          enddo
!
          do concurrent (k=1:npm1, j=2:ntm1)
            av_vr=AVGP2 (vr_ip,j,k+1)
            av_vt=AVGTP2(vt_ip,j,k+1)
            av_br=AVGT2 (br_ip,j,k  )
            av_bt=AVG2  (bt_ip,j,k  )
            vxb_b%r0%p(j,k)=av_vr*av_bt-av_vt*av_br
          enddo
!
        end if
!
      end if
!
!-----------------------------------------------------------------------
! ****** Boundary values at r=R1.
!-----------------------------------------------------------------------
!
      if (rb1) then
!
! ****** Set the theta component.
!
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr  =AVGT (v%r,nrm1  ,j+1,k  )
          av_vp_p=AVGRT(v%p,nrm1+1,j+1,k  )
          av_vp_m=AVGRT(v%p,nrm1+1,j+1,k-1)
          av_br_p=AVGR (b%r,nrm1+1,j  ,k  )
          av_br_m=AVGR (b%r,nrm1+1,j  ,k-1)
          av_bp  =AVG  (b%p,nrm1  ,j  ,k  )
          vxb_b%r1%t(j,k)= half*(av_vp_p*av_br_p+av_vp_m*av_br_m) &
                          -av_vr*av_bp
        enddo
!
! ****** Set the phi component.
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr  =AVGP (v%r,nrm1  ,j  ,k+1)
          av_vt_p=AVGRP(v%t,nrm1+1,j  ,k+1)
          av_vt_m=AVGRP(v%t,nrm1+1,j-1,k+1)
          av_br_p=AVGR (b%r,nrm1+1,j  ,k  )
          av_br_m=AVGR (b%r,nrm1+1,j-1,k  )
          av_bt  =AVG  (b%t,nrm1  ,j  ,k  )
          vxb_b%r1%p(j,k)= av_vr*av_bt &
                          -half*(av_vt_p*av_br_p+av_vt_m*av_br_m)
        enddo
!
      end if
!
end subroutine
!#######################################################################
subroutine bc_vcrossb (v,b,vxb,vxb_b)
!
!-----------------------------------------------------------------------
!
! ****** Compute boundary conditions for (v x B).
!
!-----------------------------------------------------------------------
!
! ****** On input, V contains the velocity, and B contains
! ****** the magnetic field.
!
! ****** On return, the r component of VXB  (v x B) is modified at r0
! ****** and VXB_B contains (v x B) at the tangential boundary
! ****** points.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use vars
      use shear_profile
      use drive_profile
      use flow_profile
      use upwind_resistivity
      use prescribe_b_v_at_r0_vars
      use emerging_flux_params
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      type(bvec) :: b
      type(avec) :: vxb
      type(avec_bc) :: vxb_b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vt_p,av_vt_m,av_vp_p,av_vp_m
      real(r_typ) :: av_br_p,av_br_m
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: cr,ct,cp
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: v_norm_r0
      real(r_typ), dimension(ntm,np) :: v_trans_r0_t
      real(r_typ), dimension(nt,npm) :: v_trans_r0_p
!
!-----------------------------------------------------------------------
!
!$acc enter data create(v_norm_r0,v_trans_r0_t,v_trans_r0_p)
      if (rb0) then
!
! ****** Set the normal and transverse velocity at r=R0.
!
        do concurrent (k=1:np, j=1:nt)
          v_norm_r0(j,k)=0.
        enddo
!
        do concurrent (k=1:np, j=1:ntm)
          v_trans_r0_t(j,k)=0.
        enddo
!
        do concurrent (k=1:npm, j=1:nt)
          v_trans_r0_p(j,k)=0.
        enddo
!
        if (shear%active) then
          do concurrent (k=1:np, j=1:ntm)
            v_trans_r0_t(j,k)=v_trans_r0_t(j,k) &
                             +v_drive_mag*v_shear_t(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            v_trans_r0_p(j,k)=v_trans_r0_p(j,k) &
                             +v_drive_mag*v_shear_p(j,k)
          enddo
        end if
!
        if (flow%active) then
          do concurrent (k=1:np, j=1:nt)
            v_norm_r0(j,k)=v_norm_r0(j,k) &
                          +v_flow_norm_mag*v_flow_r(j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            v_trans_r0_t(j,k)=v_trans_r0_t(j,k) &
                             +v_flow_trans_mag*v_flow_t(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            v_trans_r0_p(j,k)=v_trans_r0_p(j,k) &
                             +v_flow_trans_mag*v_flow_p(j,k)
          enddo
        end if
!
        if (prescribe_bv) then
          do concurrent (k=1:np, j=1:nt)
            v_norm_r0(j,k)=v_norm_r0(j,k)+vr_pbv(j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            v_trans_r0_t(j,k)=v_trans_r0_t(j,k)+vt_pbv(j,k)
          enddo
!
          do concurrent (k=1:npm, j=1:nt)
            v_trans_r0_p(j,k)=v_trans_r0_p(j,k)+vp_pbv(j,k)
          enddo
        end if
!
        if (.not.prescribe_bv) then
          do concurrent (k=1:npm, j=1:nt)
            bt_pbv(j,k)=b%t(1,j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm)
            bp_pbv(j,k)=b%p(1,j,k)
          enddo
        end if
!
! ****** Set the r component of VXB at r0.
!
        do concurrent (k=2:npm1, j=2:ntm1)
          av_vt=half*(v_trans_r0_t(j,k)+v_trans_r0_t(j-1,k))
          av_vp=half*(v_trans_r0_p(j,k)+v_trans_r0_p(j,k-1))
          ct=sign(upwind_at,av_vt)
          cp=sign(upwind_ap,av_vp)
          av_bt=ADVP2(bt_pbv,j,k,cp)
          av_bp=ADVT2(bp_pbv,j,k,ct)
          vxb%r(1,j,k)=(av_vt*av_bp-av_vp*av_bt)
        enddo
!
! ****** Set the electric field at r=R0.
!
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr=half*( v_norm_r0(j  ,k) &
                      +v_norm_r0(j+1,k))
          av_vt=v_trans_r0_t(j,k)
          av_vp=quarter*( v_trans_r0_p(j  ,k  ) &
                         +v_trans_r0_p(j+1,k  ) &
                         +v_trans_r0_p(j  ,k-1) &
                         +v_trans_r0_p(j+1,k-1))
          av_br=AVGRP (b%r,2,j  ,k)
          av_bp=bp_photo_in
          vxb_b%r0%t(j,k)=av_vp*av_br-av_vr*av_bp
        enddo
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr=half*( v_norm_r0(j,k  ) &
                      +v_norm_r0(j,k+1))
          av_vt=quarter*( v_trans_r0_t(j  ,k+1) &
                         +v_trans_r0_t(j-1,k+1) &
                         +v_trans_r0_t(j  ,k  ) &
                         +v_trans_r0_t(j-1,k  ))
          av_vp=v_trans_r0_p(j,k)
          av_br=AVGRT (b%r,2,j,k  )
          av_bt=bt_photo_in
          vxb_b%r0%p(j,k)=av_vr*av_bt-av_vt*av_br
        enddo
!
! ****** If we are driving with a specified electric field at r=R0,
! ****** add the normal electric field to (v x B) at r=R0.
!
        if (emerging_flux.and.ef%edrive%active) then
          do concurrent (k=2:npm1, j=2:ntm1)
            vxb%r(1,j,k)= vxb%r(1,j,k)-ef%edrive%e0*ef%edrive%er(j,k)
          enddo
        end if
!
! ****** If we are driving with er from remove E.B then
! ****** set the normal electric field to (v x B) at r=R0.
! ****** Notice that in versions prior to 0.5.13.6 we added
! ****** it as a correction to the previously calculated
! ****** value.
!
        if (time_dependent_corona) then
          do concurrent (k=2:npm1, j=2:ntm1)
            vxb%r(1,j,k)=-eflux_er(j,k)
          enddo
        end if
!
        if (debug_tdc) then
!
          do concurrent (k=1:np, j=1:nt)
            vxbbr0r(j,k)=vxb%r(1,j,k)
          enddo
!
          do concurrent (k=1:np, j=1:ntm1)
            vxbbr0t(j,k)=vxb_b%r0%t(j,k)
          enddo
!
          do concurrent (k=1:npm1, j=1:nt)
            vxbbr0p(j,k)=vxb_b%r0%p(j,k)
          enddo
!
        end if
!
      end if
!
      if (rb1) then
!
! ****** Set the theta component at r=R1.
!
        do concurrent (k=2:npm1, j=1:ntm1)
          av_vr  =AVGT (v%r,nrm1  ,j+1,k  )
          av_vp_p=AVGRT(v%p,nrm1+1,j+1,k  )
          av_vp_m=AVGRT(v%p,nrm1+1,j+1,k-1)
          av_br_p=AVGR (b%r,nrm1+1,j  ,k  )
          av_br_m=AVGR (b%r,nrm1+1,j  ,k-1)
          av_bp  =AVG  (b%p,nrm1  ,j  ,k  )
          vxb_b%r1%t(j,k)= half*(av_vp_p*av_br_p+av_vp_m*av_br_m) &
                          -av_vr*av_bp
        enddo
!
! ****** Set the phi component at r=R1.
!
        do concurrent (k=1:npm1, j=2:ntm1)
          av_vr  =AVGP (v%r,nrm1  ,j  ,k+1)
          av_vt_p=AVGRP(v%t,nrm1+1,j  ,k+1)
          av_vt_m=AVGRP(v%t,nrm1+1,j-1,k+1)
          av_br_p=AVGR (b%r,nrm1+1,j  ,k  )
          av_br_m=AVGR (b%r,nrm1+1,j-1,k  )
          av_bt  =AVG  (b%t,nrm1  ,j  ,k  )
          vxb_b%r1%p(j,k)= av_vr*av_bt &
                          -half*(av_vt_p*av_br_p+av_vt_m*av_br_m)
        enddo
      end if
!
!$acc exit data delete(v_norm_r0,v_trans_r0_t,v_trans_r0_p)
end subroutine
!#######################################################################
subroutine bc_vcrossb_centered (v,b,vxb,vxb_b)
!
!-----------------------------------------------------------------------
!
! ****** Compute boundary conditions for (v x B). Solar, centered case
!
!-----------------------------------------------------------------------
!
! ****** On input, V contains the velocity, and B contains
! ****** the magnetic field.
!
! ****** On return, the r component of VXB  (v x B) is modified at r0
! ****** and VXB_B contains (v x B) at the tangential boundary
! ****** points.
!
!-----------------------------------------------------------------------
!
! ****** This routine computes centered (v x B).
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
      use vars
      use shear_profile
      use drive_profile
      use flow_profile
      use upwind_resistivity
      use seam_rt_interface
      use seam_rp_interface
      use seam_tp_interface
      use emerging_flux_params
      use prescribe_b_v_at_r0_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      type(vvec) :: v
      type(bvec) :: b
      type(avec) :: vxb
      type(avec_bc) :: vxb_b
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: small_value=tiny(one)
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: av_vr,av_vt,av_vp
      real(r_typ) :: av_br,av_bt,av_bp
      real(r_typ) :: vdotb,bsq
      real(r_typ) :: v_perp_r,v_perp_t,v_perp_p
      real(r_typ) :: eta_uw_rt,eta_uw_rp
      real(r_typ) :: eta_uw_tr,eta_uw_tp
      real(r_typ) :: eta_uw_pr,eta_uw_pt
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,np) :: v_norm_r0
      real(r_typ), dimension(ntm,np) :: v_trans_r0_t
      real(r_typ), dimension(nt,npm) :: v_trans_r0_p
!
!-----------------------------------------------------------------------
!
      if (rb0) then
!
! ****** Set the normal and transverse velocity at r=R0.
!
        v_norm_r0=0.
        v_trans_r0_t=0.
        v_trans_r0_p=0.
!
        if (shear%active) then
          v_trans_r0_t=v_trans_r0_t+v_drive_mag*v_shear_t
          v_trans_r0_p=v_trans_r0_p+v_drive_mag*v_shear_p
        end if
!
        if (flow%active) then
          v_norm_r0=v_norm_r0+v_flow_norm_mag*v_flow_r
          v_trans_r0_t=v_trans_r0_t+v_flow_trans_mag*v_flow_t
          v_trans_r0_p=v_trans_r0_p+v_flow_trans_mag*v_flow_p
        end if
!
        if (prescribe_bv) then
          v_norm_r0=v_norm_r0+vr_pbv
          v_trans_r0_t=v_trans_r0_t+vt_pbv
          v_trans_r0_p=v_trans_r0_p+vp_pbv
        end if
!
        if (.not.prescribe_bv) then
          bt_pbv=b%t(1,:,:)
          bp_pbv=b%p(1,:,:)
        end if
!
! ****** Set the r component of VxBr at r0
!
        i=1
        do k=2,npm1
          do j=2,ntm1
            av_vr=AVG   (v%r,i  ,j,k)
            av_vt=half*(v_trans_r0_t(j,k)+v_trans_r0_t(j-1,k))
            av_vp=half*(v_trans_r0_p(j,k)+v_trans_r0_p(j,k-1))
            av_br=AVGRTP(b%r,i+1,j,k)
            av_bt=AVGP2 (bt_pbv, j,k)
            av_bp=AVGT2 (bp_pbv, j,k)
            vdotb=av_vr*av_br+av_vt*av_bt+av_vp*av_bp
            bsq=av_br*av_br+av_bt*av_bt+av_bp*av_bp
            bsq=max(bsq,small_value)
            v_perp_r=av_vr-vdotb*av_br/bsq
            v_perp_t=av_vt-vdotb*av_bt/bsq
            v_perp_p=av_vp-vdotb*av_bp/bsq
            vxb%r(i,j,k)=av_vt*av_bp-av_vp*av_bt
            eta_uw%rt(i,j,k)=half*abs(v_perp_t)*r(i)*dth(j)
            eta_uw%rp(i,j,k)=half*abs(v_perp_p)*r(i)*sth(j)*dph(k)
          enddo
        enddo
!
! ****** Set the electric field at r=R0.
! ****** This is not upwinded.  Should it be?
!
        do k=2,npm1
          do j=1,ntm1
            av_vr=half*( v_norm_r0(j  ,k) &
                        +v_norm_r0(j+1,k))
            av_vt=v_trans_r0_t(j,k)
            av_vp=quarter*( v_trans_r0_p(j  ,k  ) &
                           +v_trans_r0_p(j+1,k  ) &
                           +v_trans_r0_p(j  ,k-1) &
                           +v_trans_r0_p(j+1,k-1))
            av_br=AVGRP (b%r,i+1,j  ,k)
            av_bt=bt_photo_in
            av_bp=bp_photo_in
            vxb_b%r0%t(j,k)=av_vp*av_br-av_vr*av_bp
          enddo
        enddo
        do k=1,npm1
          do j=2,ntm1
            av_vr=half*( v_norm_r0(j,k  ) &
                        +v_norm_r0(j,k+1))
            av_vt=quarter*( v_trans_r0_t(j  ,k+1) &
                           +v_trans_r0_t(j-1,k+1) &
                           +v_trans_r0_t(j  ,k  ) &
                           +v_trans_r0_t(j-1,k  ))
            av_vp=v_trans_r0_p(j,k)
            av_br=AVGRT (b%r,i+1,j,k  )
            av_bt=bt_photo_in
            av_bp=bp_photo_in
            vxb_b%r0%p(j,k)=av_vr*av_bt-av_vt*av_br
          enddo
        enddo
!
! ****** If we are driving with a specified electric field at r=R0,
! ****** add the normal electric field to (v x B) at r=R0.
!
        if (emerging_flux.and.ef%edrive%active) then
          do k=2,npm1
            do j=2,ntm1
              vxb%r(1,j,k)= vxb%r(1,j,k) &
                           -ef%edrive%e0*ef%edrive%er(j,k)
            enddo
          enddo
        end if
!
      end if
!
! ****** Set the theta component at r=R1.
! ****** This is not upwinded.  Should it be?
!
      if (rb1) then
        i=nrm1
        do k=2,npm1
          do j=1,ntm1
            av_vr=AVGT  (v%r,i  ,j+1,k)
            av_vt=AVGR  (v%t,i+1,j  ,k)
            av_vp=AVGRTP(v%p,i+1,j+1,k)
            av_br=AVGRP (b%r,i+1,j  ,k)
            av_bt=AVGTP (b%t,i  ,j+1,k)
            av_bp=AVG   (b%p,i  ,j  ,k)
            vxb_b%r1%t(j,k)=av_vp*av_br-av_vr*av_bp
          enddo
        enddo
!
! ****** Set the phi component at r=R1.
! ****** This is not upwinded.  Should it be?
!
        do k=1,npm1
          do j=2,ntm1
            av_vr=AVGP  (v%r,i  ,j,k+1)
            av_vt=AVGRTP(v%t,i+1,j,k+1)
            av_vp=AVGR  (v%p,i+1,j,k  )
            av_br=AVGRT (b%r,i+1,j,k  )
            av_bt=AVG   (b%t,i  ,j,k  )
            av_bp=AVGTP (b%p,i  ,j,k+1)
            vxb_b%r1%p(j,k)=av_vr*av_bt-av_vt*av_br
          enddo
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine read_tp_hh_g (fname,field_g,pole_bc)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field in the (t,p) plane from HDF file FNAME
! ****** and return the global array FIELD_G.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      real(r_typ), dimension(nt_g,np_g) :: field_g
      integer :: pole_bc
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Read the boundary file.
!
      if (iamp0) then
!
        call read_tp_interp_hh (fname,field_g,pole_bc,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_TP_HH_G:'
          write (*,*) '### Error while reading the boundary field:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_TP_HH_G::'
          write (9,*) '### Error while reading the boundary field:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast FIELD_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (field_g,nt_g*np_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
end subroutine
!#######################################################################
subroutine read_tp_mh_g (fname,field_g,pole_bc)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field_g in the (t,p) plane from HDF file FNAME
! ****** and return the global array FIELD_G.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
      use global_to_local_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1_g,np_g) :: field_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Read the boundary file.
!
      if (iamp0) then
!
        call read_tp_interp_mh (fname,field_g,pole_bc,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_TP_MH:'
          write (*,*) '### Error while reading the boundary field_g:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_TP_MH::'
          write (9,*) '### Error while reading the boundary field_g:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast FIELD_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (field_g,ntm1_g*np_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
end subroutine
!#######################################################################
subroutine read_tp_hm_g (fname,field_g,pole_bc)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field_g in the (t,p) plane from HDF file FNAME
! ****** and return the global array FIELD_G.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
      use global_to_local_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt_g,npm1_g) :: field_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Read the boundary file.
!
      if (iamp0) then
!
        call read_tp_interp_hm (fname,field_g,pole_bc,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_TP_HM_G:'
          write (*,*) '### Error while reading the boundary field_g:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_TP_HM_G::'
          write (9,*) '### Error while reading the boundary field_g:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast FIELD_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (field_g,nt_g*npm1_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
end subroutine
!#######################################################################
subroutine read_tp_mm_g (fname,field_g,pole_bc)
!
!-----------------------------------------------------------------------
!
! ****** Read a 2D field_g in the (t,p) plane from HDF file FNAME
! ****** and return the global array FIELD_G.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
      use global_to_local_tp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1_g,npm1_g) :: field_g
      integer :: pole_bc
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Read the boundary file.
!
      if (iamp0) then
!
        call read_tp_interp_mm (fname,field_g,pole_bc,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_TP_MM_G:'
          write (*,*) '### Error while reading the boundary field_g:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_TP_MM_G::'
          write (9,*) '### Error while reading the boundary field_g:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast FIELD_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (field_g,ntm1_g*npm1_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
end subroutine
!#######################################################################
subroutine longitude_shift (omega_input)
!
!-----------------------------------------------------------------------
!
! ****** Apply the shift in longitude corresponding to rigid
! ****** rotation and load local copies of bc arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use flint_interface
      use interplanetary_vars
      use constants
      use interp_interface
      use mod_input_parameter
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: omega_input
      real(r_typ) :: phishift,pv,ap
      real(r_typ), dimension(np) :: pvh
      real(r_typ), dimension(npm) :: pvm
      real(r_typ), parameter :: pi2=2._r_typ*pi
      real(r_typ), parameter :: one=1._r_typ
!
      integer :: k,j,ierr,kp,kpp1,c,i
!
!-----------------------------------------------------------------------
!
      phishift=(time-corotating_relaxation_time)*omega_input
!
! ****** Shift local phi array for half-mesh and main-mesh.
!
      do k=1,np
        pvh(k)=ph(k)-phishift
        pvh(k)=mod(pvh(k),pi2)
        if (pvh(k).lt.0.) pvh(k)=pvh(k)+pi2
      enddo
!
      do k=1,npm
        pvm(k)=p(k)-phishift
        pvm(k)=mod(pvm(k),pi2)
        if (pvm(k).lt.0.) pvm(k)=pvm(k)+pi2
      enddo
!
      if (ip_bc_interp_order.lt.2.or.omega_input.eq.0.) then
!
        do k=1,np
!
          pv=pvh(k)
!
          call interp (np_g,ph_g,pv,kp,kpp1,ap,ierr)
!
          do j=1,nt
            vr_ip(j,k) =(one-ap)* vr_ip_g(j0_g+j-1,kp)+ &
                             ap * vr_ip_g(j0_g+j-1,kpp1)
            rho_ip(j,k)=(one-ap)*rho_ip_g(j0_g+j-1,kp)+ &
                             ap *rho_ip_g(j0_g+j-1,kpp1)
            t_ip(j,k)  =(one-ap)*  t_ip_g(j0_g+j-1,kp)+ &
                             ap *  t_ip_g(j0_g+j-1,kpp1)
            if (advance_pw) then
              epbcr0re(j,k)=(one-ap)*ep_ip_g(j0_g+j-1,kp)+ &
                                  ap*ep_ip_g(j0_g+j-1,kpp1)
              embcr0re(j,k)=(one-ap)*em_ip_g(j0_g+j-1,kp)+ &
                                  ap*em_ip_g(j0_g+j-1,kpp1)
            end if
            if (advance_zw) then
              zpbcr0re(j,k)=(one-ap)*zp_ip_g(j0_g+j-1,kp)+ &
                                  ap*zp_ip_g(j0_g+j-1,kpp1)
              zmbcr0re(j,k)=(one-ap)*zm_ip_g(j0_g+j-1,kp)+ &
                                  ap*zm_ip_g(j0_g+j-1,kpp1)
            end if
            if (advance_fcs) then
              do i=1,ncs
                fcsr0(j,k,i)=(one-ap)*fcsr0_ip_g(j0_g+j-1,kp,i)+ &
                                  ap *fcsr0_ip_g(j0_g+j-1,kpp1,i)
              enddo
            end if
          enddo
          do j=1,ntm
            vt_ip(j,k) =(one-ap)* vt_ip_g(j0_g+j-1,kp)+ &
                             ap * vt_ip_g(j0_g+j-1,kpp1)
            bp_ip(j,k)=(one-ap)*bp_ip_g(j0_g+j-1,kp)+ &
                            ap *bp_ip_g(j0_g+j-1,kpp1)
          enddo
        enddo
!
        do k=1,npm
!
          pv=pvm(k)
!
          call interp (np_g,p_g,pv,kp,kpp1,ap,ierr)
          if (kpp1.eq.np_g) kpp1=1
!
          do j=1,nt
            vp_ip(j,k) =(one-ap)* vp_ip_g(j0_g+j-1,kp)+ &
                             ap * vp_ip_g(j0_g+j-1,kpp1)
            bt_ip(j,k)=(one-ap)*bt_ip_g(j0_g+j-1,kp)+ &
                            ap *bt_ip_g(j0_g+j-1,kpp1)
          enddo
          do j=1,ntm
            br_ip(j,k)=(one-ap)* br_ip_g(j0_g+j-1,kp)+ &
                            ap * br_ip_g(j0_g+j-1,kpp1)
          enddo
        enddo
      else
!
        c=ip_bc_interp_order+1
!
        call lagint1D_2Dphi (ph_g,vr_ip_g(j0_g:j0_g+ntm1,:), &
                             np_g,pvh,vr_ip,np,nt,c,ierr)
!
        call lagint1D_2Dphi (ph_g,rho_ip_g(j0_g:j0_g+ntm1,:), &
                             np_g,pvh,rho_ip,np,nt,c,ierr)
!
        call lagint1D_2Dphi (ph_g,t_ip_g(j0_g:j0_g+ntm1,:), &
                             np_g,pvh,t_ip,np,nt,c,ierr)
!
        if (advance_pw) then
          call lagint1D_2Dphi (ph_g,ep_ip_g(j0_g:j0_g+ntm1,:), &
                               np_g,pvh,epbcr0re,np,nt,c,ierr)
!
          call lagint1D_2Dphi (ph_g,em_ip_g(j0_g:j0_g+ntm1,:), &
                               np_g,pvh,embcr0re,np,nt,c,ierr)
        end if
!
        if (advance_zw) then
          call lagint1D_2Dphi (ph_g,zp_ip_g(j0_g:j0_g+ntm1,:), &
                               np_g,pvh,zpbcr0re,np,nt,c,ierr)
!
          call lagint1D_2Dphi (ph_g,zm_ip_g(j0_g:j0_g+ntm1,:), &
                               np_g,pvh,zmbcr0re,np,nt,c,ierr)
        end if
!
        call lagint1D_2Dphi (ph_g,vt_ip_g(j0_g:j0_g+ntm-1,:), &
                             np_g,pvh,vt_ip,np,ntm,c,ierr)
!
        call lagint1D_2Dphi (ph_g,bp_ip_g(j0_g:j0_g+ntm-1,:), &
                             np_g,pvh,bp_ip,np,ntm,c,ierr)
!
        call lagint1D_2Dphi_ip_pm (p_g,vp_ip_g(j0_g:j0_g+ntm1,:), &
                                   npm1_g,pvm,vp_ip,npm,nt,c,ierr)
!
        call lagint1D_2Dphi_ip_pm (p_g,bt_ip_g(j0_g:j0_g+ntm1,:), &
                                   npm1_g,pvm,bt_ip,npm,nt,c,ierr)
!
        call lagint1D_2Dphi_ip_pm (p_g,br_ip_g(j0_g:j0_g+ntm-1,:), &
                                   npm1_g,pvm,br_ip,npm,ntm,c,ierr)
!
      end if
!
end subroutine
!#######################################################################
subroutine lagint1D_2Dphi (x,y,n,xi,yi,ni,nd1,c,ierr)
!
!-----------------------------------------------------------------------
!
! ******  lagint1D_2Dphi: 1-D piecewise lagrange interpolation
! ******  along ridged rotation of PHI of a 2D field.
! ******  This routine is for an array global in PHI, and assumes
! ******  the unique values are from 2:n-1 where n=np_g:
!         Whether p_g or ph_g, unique indices are 2:npm1_g:
!         p_g(2)=dphi(1)      p_g(npm1_g)=2pi
!         ph_g(2)=dphi(1)/2   ph_g(npm1_g)=2pi-dphi(np_g)/2
!
! ****** The algorithm is adapted from the LAGINT MATLAB
! ****** code by Joe Henning (Fall 2011)
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr,c,nd1,n,ni
      real(r_typ), dimension(nd1,n) :: y
      real(r_typ), dimension(nd1,ni) :: yi
      real(r_typ), dimension(n) :: x
      real(r_typ), dimension(ni) :: xi
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: pi2=2._r_typ*pi
!
!-----------------------------------------------------------------------
!
      integer :: khi,klo,k,i,m,c2,next,nm1,nm2
      real(r_typ) :: h
      real(r_typ), dimension(nd1) :: term
      real(r_typ), dimension(:,:), allocatable :: yext
      real(r_typ), dimension(:), allocatable :: xext
!
!-----------------------------------------------------------------------
!
      ierr=0
      term(:)=0
      yi(:,:)=0.
!
! ****** Extend input data to handle periodicity gracefully.
!
      nm1=n-1
      nm2=n-2
      next=nm2+2*c
      allocate(xext(next))
      xext(c+1:c+nm2)      =x(2:nm1)
      xext(1:c)            =x(nm1-c+1:nm1)-pi2
      xext(c+nm2+1:nm2+2*c)=x(2:2+c-1)+pi2
!
      allocate(yext(nd1,next))
      yext(:,c+1:c+nm2)      =y(:,2:nm1)
      yext(:,1:c)            =y(:,nm1-c+1:nm1)
      yext(:,c+nm2+1:nm2+2*c)=y(:,2:2+c-1)
!
! ****** Now loop over new domain array and interpolate.
!
      do i=1,ni
!
! ****** First find the right place in the table by bisection.
!
        klo=1
        khi=next
        do while (khi-klo.gt.1)
          k=AINT((khi+klo)*half)
          if (xext(k).gt.xi(i)) then
            khi=k
          else
            klo=k
          end if
        enddo
!
! ****** Check for problems.
!
        h=xext(khi)-xext(klo)
        if (h.eq.0.) then
      write (*,*) "ERROR Bad input to lagint: x values must be distinct"
          ierr=1
          return
        end if
!
! ****** Evaluate lagrange polynomial.
!
        if (mod(c,2).eq.0) then  !even
          c2=c/2
          if (klo.lt.c2) then
            klo=c2
          end if
          if (klo.gt.next-c2) then
            klo=next-c2
          end if
          khi=klo+1
          do k=klo-(c2-1),klo+c2
            term(:)=yext(:,k)
            do m=klo-(c2-1),klo+c2
              if (k.ne.m) then
                term(:)=term(:)*(xi(i)-xext(m))/(xext(k)-xext(m))
              end if
            enddo
            yi(:,i)=yi(:,i)+term(:)
          enddo
        else   !odd
          c2=floor(c*half)
          if (klo.lt.c2+1) then
            klo=c2+1
          end if
          if (klo.gt.next-c2) then
            klo=next-c2
          end if
          khi=klo+1
          do k=klo-c2,klo+c2
            term(:)=yext(:,k)
            do m=klo-c2,klo+c2
              if (k.ne.m) then
                term(:)=term(:)*(xi(i)-xext(m))/(xext(k)-xext(m))
              end if
            enddo
            yi(:,i)=yi(:,i)+term(:)
          enddo
        end if
      enddo
!
      deallocate(xext)
      deallocate(yext)
!
end subroutine
!#######################################################################
subroutine lagint1D_2Dphi_ip_pm (x,y,n,xi,yi,ni,nd1,c,ierr)
!
!-----------------------------------------------------------------------
!
! ******  lagint1D_2Dphi_ip_pm: 1-D piecewise lagrange interpolation
! ******  along ridged rotation of PHI of a 2D field.
! ******  This routine is for an array on the global PHI main mesh,
! ******  and assumes the unique values are from 2:n where n=npm1_g:
!
! ****** The algorithm is adapted from the LAGINT MATLAB
! ****** code by Joe Henning (Fall 2011)
!
!-----------------------------------------------------------------------
!
      use number_types
      use constants
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr,c,nd1,n,ni
      real(r_typ), dimension(nd1,n) :: y
      real(r_typ), dimension(nd1,ni) :: yi
      real(r_typ), dimension(n+1) :: x
      real(r_typ), dimension(ni) :: xi
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: half=0.5_r_typ
      real(r_typ), parameter :: pi2=2._r_typ*pi
!
!-----------------------------------------------------------------------
!
      integer :: khi,klo,k,i,m,c2,nm1,next
      real(r_typ) :: h
      real(r_typ), dimension(nd1) :: term
      real(r_typ), dimension(:,:), allocatable :: yext
      real(r_typ), dimension(:), allocatable :: xext
!
!-----------------------------------------------------------------------
!
      ierr=0
      term(:)=0
      yi(:,:)=0.
!
! ****** Extend input data to handle periodicity gracefully.
!
      nm1=n-1
      next=nm1+2*c
      allocate(xext(next))
      xext(c+1:c+nm1)      =x(2:n)
      xext(1:c)            =x(n-c+1:n)-pi2
      xext(c+nm1+1:nm1+2*c)=x(2:2+c-1)+pi2
!
      allocate(yext(nd1,next))
      yext(:,c+1:c+nm1)      =y(:,2:n)
      yext(:,1:c)            =y(:,n-c+1:n)
      yext(:,c+nm1+1:nm1+2*c)=y(:,2:2+c-1)
!
!
! ****** Now loop over new domain array and interpolate.
!
      do i=1,ni
!
! ****** First find the right place in the table by bisection.
!
        klo=1
        khi=next
        do while (khi-klo.gt.1)
          k=AINT((khi+klo)*half)
          if (xext(k).gt.xi(i)) then
            khi=k
          else
            klo=k
          end if
        enddo
!
! ****** Check for problems.
!
        h=xext(khi)-xext(klo)
        if (h.eq.0.) then
      write (*,*) "ERROR Bad input to lagint: x values must be distinct"
          ierr=1
          return
        end if
!
! ****** Evaluate lagrange polynomial.
! ****** This version does not know about phi being periodic.
! ****** Therefore, the interpolations near phi=0 are 1-sided.
!
        if (mod(c,2).eq.0) then  !even
          c2=c/2
          if (klo.lt.c2) then
            klo=c2
          end if
          if (klo.gt.next-c2) then
            klo=next-c2
          end if
          khi=klo+1
          do k=klo-(c2-1),klo+c2
            term(:)=yext(:,k)
            do m=klo-(c2-1),klo+c2
              if (k.ne.m) then
                term(:)=term(:)*(xi(i)-xext(m))/(xext(k)-xext(m))
              end if
            enddo
            yi(:,i)=yi(:,i)+term(:)
          enddo
        else   !odd
          c2=floor(c*half)
          if (klo.lt.c2+1) then
            klo=c2+1
          end if
          if (klo.gt.next-c2) then
            klo=next-c2
          end if
          khi=klo+1
          do k=klo-c2,klo+c2
            term(:)=yext(:,k)
            do m=klo-c2,klo+c2
              if (k.ne.m) then
                term(:)=term(:)*(xi(i)-xext(m))/(xext(k)-xext(m))
              end if
            enddo
            yi(:,i)=yi(:,i)+term(:)
          enddo
        end if
      enddo
!
      deallocate(xext)
      deallocate(yext)
!
end subroutine
!#######################################################################
subroutine transform_vp_bc (omega_input)
!
!-----------------------------------------------------------------------
!
! ****** Shift vp boundary by a co-rotating frame velocity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use interplanetary_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: omega_input
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** Change of frame of reference for vp
!
      do k=1,npm
        do j=1,nt
          vp_ip(j,k)=vp_ip(j,k)+omega_input*sth(j)*r0
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine transform_vp (omega_input)
!
!-----------------------------------------------------------------------
!
! ****** Shift vp by the local co-rotating frame velocity.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: i,j,k
      real(r_typ) :: fac,omega_input
!
!-----------------------------------------------------------------------
!
! ****** Change of frame of reference for vp
!
      if (iamp0) then
        write (9,*)
        write (9,*) '### COMMENT from TRANSFORM_VP:'
        write (9,*) '### Modifying the frame transformation from vp.'
      end if
!
      do k=1,npm
        do j=1,nt
          do i=1,nr
            fac = omega_input*sth(j)*rh(i)
            v%p(i,j,k)=v%p(i,j,k)+fac
            v_old%p(i,j,k)=v_old%p(i,j,k)+fac
          enddo
        enddo
      enddo
!
      do k=1,np
        do j=1,nt
          fac = omega_input*sth(j)*r0
          vb%r0%p(j,k)=vb%r0%p(j,k)+fac
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine initialize_from_file_2d
!
!-----------------------------------------------------------------------
!
! ****** Load in a theta-file boundary values and extrapolate them
! ****** inside the domain for the gas variable.
!
!-----------------------------------------------------------------------
!
! ****** Values for vr, rho, and t are read from files.
! ****** All other variables are set to zero.
!
!-----------------------------------------------------------------------
!
! ****** Note that the main real arrays for v, rho, and t are set
! ****** by this routine.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use seam_interface
      use characteristics
      use interplanetary_vars
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
      real(r_typ), parameter :: half=.5_r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt_g  ,np_g  ) :: vr_r0_g,rho_r0_g,t_r0_g
      real(r_typ) ::  alpha,beta
      integer :: ierr,np1d,ir,irp1,i,j,k
!
!-----------------------------------------------------------------------
!
      call read_tp_hh_g (twodfile_vr,vr_r0_g,1)
      call read_tp_hh_g (twodfile_rho,rho_r0_g,1)
      call read_tp_hh_g (twodfile_t,t_r0_g,1)
!
      rho0i(:,:)=0.
      rho0f(:,:)=0.
      pr0i(:,:)=0.
      pr0f(:,:)=0.
!
      if (const_t_rho) then
        alpha=0.
        beta=0.
      else
        alpha=two*gamma-two
        beta=two
      end if
      if (rb0) then
        do k=1,np
          do j=1,nt
            rho0i(j,k)=rho_r0_g(j0_g+j-1,k0_g+k-1)
            tr0v(j,k)=t_r0_g(j0_g+j-1,k0_g+k-1)
            pr0i(j,k)=(he_p/he_rho)*rho0i(j,k)*tr0v(j,k)
            do i=2,nrm1
              v%r(i,j,k)=vr_r0_g(j0_g+j-1,k0_g+k-1)
              rho(i,j,k)=rho0i(j,k)*(r0*rh_i(i))**beta
              temp_e(i,j,k)=tr0v(j,k)*(r0*rh_i(i))**alpha
              pres(i,j,k)=(he_p/he_rho)*rho(i,j,k)*temp_e(i,j,k)
            enddo
            i=nr
            rho(i,j,k)=rho0i(j,k)*(r0*rh_i(i))**beta
            temp_e(i,j,k)=tr0v(j,k)*(r0*rh_i(i))**alpha
            pres(i,j,k)=(he_p/he_rho)*rho(i,j,k)*temp_e(i,j,k)
            i=1
            v%r(i,j,k)=vr_r0_g(j0_g+j-1,k0_g+k-1)
            rho(1,j,k)=two*rho0i(j,k)-rho(2,j,k)
            temp_e(1,j,k)=two*tr0v(j,k)-temp_e(2,j,k)
            pres(1,j,k)=two*(he_p/he_rho)*rho0i(j,k)*tr0v(j,k) &
                        -pres(2,j,k)
          enddo
        enddo
      else
        do k=1,np
          do j=1,nt
            rho0i(j,k)=rho_r0_g(j0_g+j-1,k0_g+k-1)
            tr0v(j,k)=t_r0_g(j0_g+j-1,k0_g+k-1)
            do i=1,nrm1
              v%r(i,j,k)=vr_r0_g(j0_g+j-1,k0_g+k-1)
              rho(i,j,k)=rho0i(j,k)*(r0*rh_i(i))**beta
              temp_e(i,j,k)=tr0v(j,k)*(r0*rh_i(i))**alpha
              pres(i,j,k)=(he_p/he_rho)*rho(i,j,k)*temp_e(i,j,k)
            enddo
            i=nr
            rho(i,j,k)=rho0i(j,k)*(r0*rh_i(i))**beta
            temp_e(i,j,k)=tr0v(j,k)*(r0*rh_i(i))**alpha
            pres(i,j,k)=(he_p/he_rho)*rho(i,j,k)*temp_e(i,j,k)
          enddo
        enddo
      end if
!
      v%t(:,:,:)=0.
      v%p(:,:,:)=0.
!
! ****** Set pressure and mean temperature.
! ****** In order to use setpt() here, need to
! ****** set cbc1_pb and/or ip bc arrays.
!
      if (rb1.and.char_bc1) then
        cbc1_pb(:,:)=half*(pres(nr,:,:)+pres(nrm1,:,:))
!$acc update device(cbc1_pb)
      end if
!
      if (rb0.and.interplanetary_run) then
        rho_ip(:,:)=rho0i(:,:)
        t_ip(:,:)=tr0v(:,:)
!$acc update device(rho_ip,t_ip)
      end if
!
!$acc update device(temp_e,rho)
      if (advance_tp) then
!$acc update device(temp_p)
      end if
      call setpt
!$acc update self(pres,temp)
!
end subroutine
!#######################################################################
subroutine setup_ip_boundaries
!
!-----------------------------------------------------------------------
!
! ****** Set up machinery for the boundary conditions for an
! ****** interplanetary calculation
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use flint_interface
      use interplanetary_vars
      use ucase_interface
      use global_to_local_tp_interface
      use field_table
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0
      integer :: ix,nodes,i,j,k
      logical :: exists
!
!-----------------------------------------------------------------------
!
! ****** Variables for interpolation.
!
      integer :: ifile0,ifile1
      real(r_typ) :: file_no,frac
      character(256) :: fname
      character(6) :: seq
!
!-----------------------------------------------------------------------
!
! ****** Check that the specified flux files exist.
!
      do i=1,mx_ip_seq
         if (ip_sequence(i).eq.NULL_VALUE_IP_SEQUENCE) exit
      enddo
      n_ip_seq=i-1
      if (iamp0) then
        do i=1,n_ip_seq
          if (long_sequence_numbers_input) then
            write (seq,'(i6.6)') ip_sequence(i)
          else
            write (seq,'(i3.3)') ip_sequence(i)
          end if
          fname=trim(ip_path)//trim(brfile)//trim(seq)//'.h5'
          inquire (file=trim(fname),exist=exists)
          if (.not.exists) then
            write (*,*)
            write (*,*) '### ERROR in SETUP_IP_BOUNDARIES:'
            write (*,*) '### You have specified a file'// &
                          ' that does not exist.'
            write (*,*) 'File name: ',trim(fname)
            write (9,*)
            write (9,*) '### ERROR in SETUP_IP_BOUNDARIES:'
            write (9,*) '### You have specified a file'// &
                          ' that does not exist.'
            write (9,*) 'File name: ',trim(fname)
            ierr=1
          end if
        enddo
      end if
      call check_error_on_p0 (ierr)
!
      allocate (br_ip (ntm,npm))
      allocate (br_ip_g (ntm1_g,npm1_g))
      allocate (br_ip0_g(ntm1_g,npm1_g))
      allocate (br_ip1_g(ntm1_g,npm1_g))
      br_ip=0.
      br_ip_g=0.
      br_ip0_g=0.
      br_ip1_g=0.
      allocate (bt_ip (nt,npm))
      allocate (bt_ip_g (nt_g,npm1_g))
      allocate (bt_ip0_g(nt_g,npm1_g))
      allocate (bt_ip1_g(nt_g,npm1_g))
      bt_ip=0.
      bt_ip_g=0.
      bt_ip0_g=0.
      bt_ip1_g=0.
      allocate (bp_ip (ntm,np))
      allocate (bp_ip_g (ntm1_g,np_g))
      allocate (bp_ip0_g(ntm1_g,np_g))
      allocate (bp_ip1_g(ntm1_g,np_g))
      bp_ip=0.
      bp_ip_g=0.
      bp_ip0_g=0.
      bp_ip1_g=0.
      allocate (rho_ip (nt,np))
      allocate (rho_ip_g (nt_g,np_g))
      allocate (rho_ip0_g(nt_g,np_g))
      allocate (rho_ip1_g(nt_g,np_g))
      rho_ip=0.
      rho_ip_g=0.
      rho_ip0_g=0.
      rho_ip1_g=0.
      allocate (t_ip (nt,np))
      allocate (t_ip_g (nt_g,np_g))
      allocate (t_ip0_g(nt_g,np_g))
      allocate (t_ip1_g(nt_g,np_g))
      t_ip=0.
      t_ip_g=0.
      t_ip0_g=0.
      t_ip1_g=0.
      allocate (vr_ip (nt,np))
      allocate (vr_ip_g (nt_g,np_g))
      allocate (vr_ip0_g(nt_g,np_g))
      allocate (vr_ip1_g(nt_g,np_g))
      vr_ip=0.
      vr_ip_g=0.
      vr_ip0_g=0.
      vr_ip1_g=0.
      allocate (vt_ip (ntm,np))
      allocate (vt_ip_g (ntm1_g,np_g))
      allocate (vt_ip0_g(ntm1_g,np_g))
      allocate (vt_ip1_g(ntm1_g,np_g))
      vt_ip=0.
      vt_ip_g=0.
      vt_ip0_g=0.
      vt_ip1_g=0.
      allocate (vp_ip (nt,npm))
      allocate (vp_ip_g (nt_g,npm1_g))
      allocate (vp_ip0_g(nt_g,npm1_g))
      allocate (vp_ip1_g(nt_g,npm1_g))
      vp_ip=0.
      vp_ip_g=0.
      vp_ip0_g=0.
      vp_ip1_g=0.
      if (advance_pw) then
        allocate (ep_ip_g (nt_g,np_g))
        allocate (ep_ip0_g(nt_g,np_g))
        allocate (ep_ip1_g(nt_g,np_g))
        ep_ip_g=0.
        ep_ip0_g=0.
        ep_ip1_g=0.
        allocate (em_ip_g (nt_g,np_g))
        allocate (em_ip0_g(nt_g,np_g))
        allocate (em_ip1_g(nt_g,np_g))
        em_ip_g=0.
        em_ip0_g=0.
        em_ip1_g=0.
      end if
      if (advance_zw) then
        allocate (zp_ip_g (nt_g,np_g))
        allocate (zp_ip0_g(nt_g,np_g))
        allocate (zp_ip1_g(nt_g,np_g))
        zp_ip_g=0.
        zp_ip0_g=0.
        zp_ip1_g=0.
        allocate (zm_ip_g (nt_g,np_g))
        allocate (zm_ip0_g(nt_g,np_g))
        allocate (zm_ip1_g(nt_g,np_g))
        zm_ip_g=0.
        zm_ip0_g=0.
        zm_ip1_g=0.
      end if
!
! ****** Allocate vectors to use as initial guesses for psi and phi.
!
      ifile0_contents=0
      ifile1_contents=0
!
! ****** Set up the flux interpolation helper array.
!
      do i=1,n_ip_seq
        helper_ip(i)=i
      enddo
!
end subroutine
!#######################################################################
subroutine calc_v_eflux
!
!-----------------------------------------------------------------------
!
! ****** Calculate the normal flow corresponding to the emerging flux
! ****** electric field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use emerging_flux_params
      use drive_profile
      use shear_profile
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ) ::  avbr,avbt,avbp,bsq,avet,avep,fac
      real(r_typ), parameter :: bminsq=0.025_r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k,ierr
!
!-----------------------------------------------------------------------
!
! ****** Form the potential
!
!
      do k=2,npm1
        do j=2,ntm1
          avbr=AVGRTP(b%r,2  ,j,k)
          avbt=AVGP  (b%t,1  ,j,k)
          avbp=AVGT  (b%p,1  ,j,k)
          bsq=avbr**2+avbt**2+avbp**2
          fac=(1.-exp(-4.*bsq/bminsq))
          bsq=max(bminsq,bsq)
          avet=(eflux_et(j  ,k)+eflux_et(j-1,k))*0.5_r_typ
          avep=(eflux_ep(j,k  )+eflux_ep(j,k-1))*0.5_r_typ
          ef%vr(j,k)=(avet*avbp-avep*avbt)*fac/bsq
        enddo
      enddo
      do k=2,npm1
        do j=1,ntm1
          avbr=AVGRP (b%r,2  ,j  ,k)
          avbt=AVGTP (b%t,1  ,j+1,k)
          avbp=AVG   (b%p,1  ,j  ,k)
          bsq=avbr**2+avbt**2+avbp**2
          fac=(1.-exp(-4.*bsq/bminsq))
          bsq=max(bminsq,bsq)
          avep=(eflux_ep(j,k  )+eflux_ep(j+1,k-1) &
               +eflux_ep(j,k-1)+eflux_ep(j+1,k  ))*0.25_r_typ
          ef%vt(j,k)=(avep*avbr)*fac/bsq
        enddo
      enddo
      do k=1,npm1
        do j=2,ntm1
          avbr=AVGRT (b%r,2  ,j,k  )
          avbt=AVG   (b%t,1  ,j,k  )
          avbp=AVGTP (b%p,1  ,j,k+1)
          bsq=avbr**2+avbt**2+avbp**2
          fac=(1.-exp(-4.*bsq/bminsq))
          bsq=max(bminsq,bsq)
          avet=(eflux_et(j  ,k  )+eflux_et(j-1,k  ) &
               +eflux_et(j  ,k+1)+eflux_et(j-1,k+1))*0.25_r_typ
          ef%vp(j,k)=-avet*avbr*fac/bsq
        enddo
      enddo
!
end subroutine
!#######################################################################
subroutine set_pole_bc_bvec_tp (bt,bp)
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the poles for a vector
! ****** in the (t,p) plane defined on the B mesh.
!
!-----------------------------------------------------------------------
!
      use number_types
      use types
      use globals
      use mesh
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(nt,npm) :: bt
      real(r_typ), dimension(ntm,np) :: bp
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: sums0,sumc0
      real(r_typ) :: sums1,sumc1
      real(r_typ), dimension(2) :: buf0,buf1
!
!-----------------------------------------------------------------------
!
! ****** Get the local sums (on this processor).
!
! ****** Bt and Bp have only an m=1 component.
!
      if (tb0) then
        if (axisymmetric) then
          sums0=0.
          sumc0=0.
        else
          sums0=two*sum(bt(2,2:npm1)*sp(2:npm1)*dp(2:npm1))*pl_i
          sumc0=two*sum(bt(2,2:npm1)*cp(2:npm1)*dp(2:npm1))*pl_i
        end if
      end if
!
      if (tb1) then
        if (axisymmetric) then
          sums1=0.
          sumc1=0.
        else
          sums1=two*sum(bt(ntm1,2:npm1)*sp(2:npm1)*dp(2:npm1))*pl_i
          sumc1=two*sum(bt(ntm1,2:npm1)*cp(2:npm1)*dp(2:npm1))*pl_i
        end if
      end if
!
      buf0=(/sums0,sumc0/)
      buf1=(/sums1,sumc1/)
!
! ****** Sum over all processors.
!
      call sum_over_phi (2,buf0,buf1)
!
      sums0=buf0(1)
      sumc0=buf0(2)
      sums1=buf1(1)
      sumc1=buf1(2)
!
! ****** Set the boundary conditions.
!
      if (tb0) then
        bp(1,1:np)=-sumc0*sph(1:np)+sums0*cph(1:np)
        bt(1,1:npm1)= two*( sums0*sp(1:npm1) &
                           +sumc0*cp(1:npm1)) &
                     -bt(2,1:npm1)
      end if
!
      if (tb1) then
        bp(ntm1,1:np)= sumc1*sph(1:np)-sums1*cph(1:np)
        bt(nt,1:npm1)= two*( sums1*sp(1:npm1) &
                              +sumc1*cp(1:npm1)) &
                      -bt(ntm1,1:npm1)
      end if
!
end subroutine
!#######################################################################
subroutine balance_flux2 (br0,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Normalize the normal magnetic field Br at r=R0 and balance
! ****** the flux.
!
!-----------------------------------------------------------------------
!
! ****** This routine is designed to be called from all processors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
      use mesh
      use vars
      use debug
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: br0
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: quarter=.25_r_typ
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      integer :: j,k
      real(r_typ) :: surface,fluxp,fluxm,da_t,da_p,br00err
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** Calculate the total flux.
!
      surface=0.
      fluxp=0.
      fluxm=0.
      do j=1,ntm1
        if (j.eq.1) then
          if (tb0) then
            da_t=quarter*sth(2)*dt(1)
          else
            da_t=half*st(j)*dt(j)
          end if
        else if (j.eq.ntm1) then
          if (tb1) then
            da_t=quarter*sth(ntm1)*dt(ntm1)
          else
            da_t=half*st(j)*dt(j)
          end if
        else
          da_t=st(j)*dt(j)
        end if
        do k=1,npm1
          if (k.eq.1.or.k.eq.npm1) then
            da_p=half*dp(k)
          else
            da_p=dp(k)
          end if
          if (br0(j,k).gt.0.) then
            fluxp=fluxp+br0(j,k)*da_t*da_p
          else
            fluxm=fluxm+br0(j,k)*da_t*da_p
          end if
          surface=surface+da_t*da_p
        enddo
      enddo
      call global_sum_tp (surface)
      call global_sum_tp (fluxp)
      call global_sum_tp (fluxm)
!
      if(iamp0.and.idebug.gt.0) then
        write (9,*)
        write (9,*) '### COMMENT from BALANCE_FLUX2:'
        write (9,*) '### Computed flux balance:'
        write (9,*)
        write (9,*) 'Positive flux = ',fluxp*r0*r0
        write (9,*) 'Negative flux = ',fluxm*r0*r0
        write (9,*) 'Area = ',surface
      end if
!
! ****** Fix the magnetic field so that the total flux is zero.
!
      br00err=(fluxp+fluxm)/surface
!
      br0(:,:)=br0(:,:)-br00err
!
      if (iamp0.and.idebug.gt.0) then
        write (9,*)
        write (9,*) '### COMMENT from BALANCE_FLUX2:'
        write (9,*) '### Flux balance correction:'
        write (9,*)
        write (9,*) 'Monopole Br field magnitude = ',br00err
      end if
!
end subroutine
!#######################################################################
subroutine read_a_file (fname)
!
!-----------------------------------------------------------------------
!
! ****** Load in the vector potential for a 2D field.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use cgcom
      use dissipation_profiles
      use field_table
      use write_field_tp_interface
      use write_field_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: j0,i0,i,j,ierr,nrelax,k
      real(r_typ) :: rr, theta, psi,norm_j
      real(r_typ), allocatable, dimension(:,:) :: atr,apr,jpr,brav
      type(avec),target :: eta_jzero,jzero,dj
      type(cg_3d), dimension(3) :: dj_cg
      real(r_typ), parameter :: half=.5_r_typ
      real(r_typ), parameter :: zero=0
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Compute A in real space.
! ****** Note that this sets boundary points next to the poles.
!
      allocate (atr(nr_g,ntm1_g))
      allocate (apr(nr_g,nt_g))
      atr(:,:)=0.
      apr(:,:)=0.
!
      if (iamp0) then
        call ffopen (20,trim(fname),'r',ierr)
        do j0=1,ntm1_g
          do i0=1,nr_g
            read (20,*)  i, j, rr, theta, psi, atr(i0,j0)
          enddo
        enddo
        do j0=1,nt_g
          do i0=1,nr_g
            read (20,*)  i, j, rr, theta, psi, apr(i0,j0)
          enddo
        enddo
        close(20)
!
        write (9,*)
        write (9,*) '### COMMENT from READ_A_FILE:'
        write (9,*) '### 2D A field was loaded.'
        write (9,*) 'FILENAME = ',fname
      end if
!
! ****** Broadcast the values to all processors.
!
      call MPI_Bcast (atr,nr_g*ntm1_g,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (apr,nr_g*nt_g,ntype_real,0,MPI_COMM_WORLD,ierr)
      do j=1,ntm
        do i=1,nr
          a%t(i,j,:)=atr(i0_g+i-1,j0_g+j-1)
        enddo
      enddo
      do j=1,nt
        do i=1,nr
          a%p(i,j,:)=apr(i0_g+i-1,j0_g+j-1)
        enddo
      enddo
!
      deallocate(atr)
      deallocate(apr)
!
end subroutine
!#######################################################################
subroutine get_pbv_boundaries
!
!-----------------------------------------------------------------------
!
! ****** Set the boundary conditions at the present time for when
! ****** we read B and V evolution at the lower boundary
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use flint_interface
      use prescribe_b_v_at_r0_vars
      use ucase_interface
      use global_to_local_tp_interface
      use field_table
      use write_field_tp_interface
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ix,nodes,i,j,k
      logical, save :: first=.true.
      logical :: exists
!-----------------------------------------------------------------------
!
      real(r_typ) :: ap,pv
      real(r_typ), parameter :: pi2=2._r_typ*pi
      real(r_typ), parameter :: one=1._r_typ
      integer :: ierr,kp,kpp1
!
!-----------------------------------------------------------------------
!
! ****** Array to help in the interpolation.
!
      real(r_typ), save :: helper_pbv(mx_pbv_seq)
!
! ****** Variables for interpolation.
!
      integer :: ifile0,ifile1
      real(r_typ) :: file_no,frac
      character(256) :: fname
      character(6) :: seq
!
!-----------------------------------------------------------------------
!
! ****** On the first time in:
!
      if (first) then
        call setup_pbv_boundaries (helper_pbv)
        first=.false.
      end if
!
! ****** Interpolate to time
!
      if (time-deltat_pbv.le.pbv_node(1)) then
        ifile0=1
        ifile1=1
        frac=0.
      else if (time-deltat_pbv.ge.pbv_node(n_pbv_seq)) then
        ifile0=n_pbv_seq
        ifile1=n_pbv_seq
        frac=0.
      else
        file_no=flint(.false.,time-deltat_pbv,n_pbv_seq, &
        pbv_node,helper_pbv,ierr)
        ifile0=file_no
        ifile1=min(ifile0+1,n_pbv_seq)
        frac=file_no-ifile0
      end if
!
! ****** Set up the quantities in their arrays _PBV0 and _PBV1
! ****** bounding this interval.
!
! ****** First, check to see if the files have changed.
! ****** If they have, check to see if these files have already
! ****** been read in previously; if they have, transfer those
! ****** quantities, otherwise read in the new files.
!
      if (ifile0.ne.i_pbv_file0_contents) then
        if (ifile0.eq.i_pbv_file1_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_PBV_BOUNDARIES:'
            write (9,*) '### Transferring flux from FILE1 to FILE0.'
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          br_pbv0_g=br_pbv1_g
          bt_pbv0_g=bt_pbv1_g
          bp_pbv0_g=bp_pbv1_g
          vr_pbv0_g=vr_pbv1_g
          vt_pbv0_g=vt_pbv1_g
          vp_pbv0_g=vp_pbv1_g
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_PBV_BOUNDARIES:'
            write (9,*) '### Reading new files'
            write (9,*) 'Sequence: ',pbv_sequence(ifile0)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          if (long_sequence_numbers_input) then
            write (seq,'(i6.6)') pbv_sequence(ifile0)
          else
            write (seq,'(i3.3)') pbv_sequence(ifile0)
          end if
          fname=trim(pbv_path)//trim(br_pbv_file)//trim(seq)//".h5"
          call read_tp_mm_g (fname,br_pbv0_g,1)
          fname=trim(pbv_path)//trim(bt_pbv_file)//trim(seq)//".h5"
          call read_tp_hm_g (fname,bt_pbv0_g,2)
          fname=trim(pbv_path)//trim(bp_pbv_file)//trim(seq)//".h5"
          call read_tp_mh_g (fname,bp_pbv0_g,3)
          fname=trim(pbv_path)//trim(vr_pbv_file)//trim(seq)//".h5"
          call read_tp_hh_g (fname,vr_pbv0_g,1)
          fname=trim(pbv_path)//trim(vt_pbv_file)//trim(seq)//".h5"
          call read_tp_mh_g (fname,vt_pbv0_g,2)
          fname=trim(pbv_path)//trim(vp_pbv_file)//trim(seq)//".h5"
          call read_tp_hm_g (fname,vp_pbv0_g,3)
        end if
        i_pbv_file0_contents=ifile0
      end if
!
      if (ifile1.ne.i_pbv_file1_contents) then
        if (ifile1.eq.i_pbv_file0_contents) then
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_PBV_BOUNDARIES:'
            write (9,*) '### Transferring flux from FILE0 to FILE1.'
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          br_pbv1_g=br_pbv0_g
          bt_pbv1_g=bt_pbv0_g
          bp_pbv1_g=bp_pbv0_g
          vr_pbv1_g=vr_pbv0_g
          vt_pbv1_g=vt_pbv0_g
          vp_pbv1_g=vp_pbv0_g
        else
          if (iamp0) then
            write (9,*)
            write (9,*) '### COMMENT from GET_PBV_BOUNDARIES:'
            write (9,*) '### Reading new files'
            write (9,*) 'Sequence: ',pbv_sequence(ifile1)
            write (9,*) 'NTIME = ',ntime
            write (9,*) 'TIME = ',time
          end if
          if (long_sequence_numbers_input) then
            write (seq,'(i6.6)') pbv_sequence(ifile1)
          else
            write (seq,'(i3.3)') pbv_sequence(ifile1)
          end if
          fname=trim(pbv_path)//trim(br_pbv_file)//trim(seq)//".h5"
          call read_tp_mm_g (fname,br_pbv1_g,1)
          fname=trim(pbv_path)//trim(bt_pbv_file)//trim(seq)//".h5"
          call read_tp_hm_g (fname,bt_pbv1_g,2)
          fname=trim(pbv_path)//trim(bp_pbv_file)//trim(seq)//".h5"
          call read_tp_mh_g (fname,bp_pbv1_g,3)
          fname=trim(pbv_path)//trim(vr_pbv_file)//trim(seq)//".h5"
          call read_tp_hh_g (fname,vr_pbv1_g,1)
          fname=trim(pbv_path)//trim(vt_pbv_file)//trim(seq)//".h5"
          call read_tp_mh_g (fname,vt_pbv1_g,2)
          fname=trim(pbv_path)//trim(vp_pbv_file)//trim(seq)//".h5"
          call read_tp_hm_g (fname,vp_pbv1_g,3)
        end if
        i_pbv_file1_contents=ifile1
      end if
!
! ****** Interpolate the arrays to time TIME.
!
      br_pbv_g=(1.-frac)*br_pbv0_g+frac*br_pbv1_g
      bt_pbv_g=(1.-frac)*bt_pbv0_g+frac*bt_pbv1_g
      bp_pbv_g=(1.-frac)*bp_pbv0_g+frac*bp_pbv1_g
      vr_pbv_g=(1.-frac)*vr_pbv0_g+frac*vr_pbv1_g
      vt_pbv_g=(1.-frac)*vt_pbv0_g+frac*vt_pbv1_g
      vp_pbv_g=(1.-frac)*vp_pbv0_g+frac*vp_pbv1_g
!
      call MPI_Bcast (br_pbv_g,ntm1_g*npm1_g,ntype_real, &
                      iproc0,comm_all,ierr)
      do k=1,np
!
        pv=ph(k)
        pv=mod(pv,pi2)
        if (pv.lt.0.) pv=pv+2.*pi
!
        call interp (np_g,ph_g,pv,kp,kpp1,ap,ierr)
        do j=1,nt
          vr_pbv(j,k) =(one-ap)* vr_pbv_g(j0_g+j-1,kp)+ &
                           ap * vr_pbv_g(j0_g+j-1,kpp1)
        enddo
        do j=1,ntm
          vt_pbv(j,k) =(one-ap)* vt_pbv_g(j0_g+j-1,kp)+ &
                           ap * vt_pbv_g(j0_g+j-1,kpp1)
          bp_pbv(j,k)=(one-ap)*bp_pbv_g(j0_g+j-1,kp)+ &
                          ap *bp_pbv_g(j0_g+j-1,kpp1)
        enddo
      enddo
      do k=1,npm
!
        pv=p(k)
        pv=mod(pv,pi2)
        if (pv.lt.0.) pv=pv+2.*pi
!
        call interp (np_g,p_g,pv,kp,kpp1,ap,ierr)
        if (kpp1.eq.np_g) kpp1=1
!
        do j=1,nt
          vp_pbv(j,k) =(one-ap)* vp_pbv_g(j0_g+j-1,kp)+ &
                           ap * vp_pbv_g(j0_g+j-1,kpp1)
          bt_pbv(j,k)=(one-ap)*bt_pbv_g(j0_g+j-1,kp)+ &
                          ap *bt_pbv_g(j0_g+j-1,kpp1)
        enddo
        do j=1,ntm
          br_pbv(j,k)=(one-ap)* br_pbv_g(j0_g+j-1,kp)+ &
                          ap * br_pbv_g(j0_g+j-1,kpp1)
        enddo
      enddo
!
      call balance_flux2 (br_pbv,ierr)
!
      call set_pole_bc_bvec_tp (bt_pbv,bp_pbv)
      call set_pole_bc_vvec_tp_cpu (vt_pbv,vp_pbv)
!
end subroutine
!#######################################################################
subroutine setup_pbv_boundaries (helper_pbv)
!
!-----------------------------------------------------------------------
!
! ****** Set up machinery for the boundary conditions for when
! ****** we read B and V to drive the boundaries
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use flint_interface
      use prescribe_b_v_at_r0_vars
      use ucase_interface
      use global_to_local_tp_interface
      use field_table
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0
      integer :: ix,nodes,i,j,k
      logical :: exists
!
!-----------------------------------------------------------------------
!
! ****** Array to help in the interpolation.
!
      real(r_typ) :: helper_pbv(mx_pbv_seq)
!
! ****** Variables for interpolation.
!
      integer :: ifile0,ifile1
      real(r_typ) :: file_no,frac
      character(256) :: fname
      character(6) :: seq
!
!-----------------------------------------------------------------------
!
! ****** Check that the specified flux files exist.
!
      do i=1,mx_pbv_seq
         if (pbv_sequence(i).eq.NULL_VALUE_PBV_SEQUENCE) exit
      enddo
      n_pbv_seq=i-1
      if (iamp0) then
!
        if (pbv_node(n_pbv_seq).lt.0) then
          write (*,*)
          write (*,*) '### ERROR in SETUP_PBV_BOUNDARIES:'
          write (*,*) '### You have specified fewer nodes than times.'
          ierr=1
        end if
!
        if (n_pbv_seq.lt.mx_pbv_seq.and.pbv_node(n_pbv_seq+1).gt.0) then
          write (*,*)
          write (*,*) '### ERROR in SETUP_PBV_BOUNDARIES:'
          write (*,*) '### You have specified more nodes than times.'
          ierr=1
        end if
!
        do i=1,n_pbv_seq
          if (long_sequence_numbers_input) then
            write (seq,'(i6.6)') pbv_sequence(i)
          else
            write (seq,'(i3.3)') pbv_sequence(i)
          end if
          fname=trim(pbv_path)//trim(br_pbv_file)//trim(seq)//".h5"
          inquire (file=trim(fname),exist=exists)
          if (.not.exists) then
            write (*,*)
            write (*,*) '### ERROR in SETUP_PBV_BOUNDARIES:'
            write (*,*) '### You have specified a file'// &
                          ' that does not exist.'
            write (*,*) 'File name: ',trim(fname)
            write (9,*)
            write (9,*) '### ERROR in SETUP_PBV_BOUNDARIES:'
            write (9,*) '### You have specified a file'// &
                          ' that does not exist.'
            write (9,*) 'File name: ',trim(fname)
            ierr=1
          end if
        enddo
      end if
      call check_error_on_p0 (ierr)
!
      allocate (br_pbv_g (ntm1_g,npm1_g))
      allocate (br_pbv0_g(ntm1_g,npm1_g))
      allocate (br_pbv1_g(ntm1_g,npm1_g))
      br_pbv_g =0.
      br_pbv0_g=0.
      br_pbv1_g=0.
      allocate (bt_pbv_g (nt_g,npm1_g))
      allocate (bt_pbv0_g(nt_g,npm1_g))
      allocate (bt_pbv1_g(nt_g,npm1_g))
      bt_pbv_g =0.
      bt_pbv0_g=0.
      bt_pbv1_g=0.
      allocate (bp_pbv_g (ntm1_g,np_g))
      allocate (bp_pbv0_g(ntm1_g,np_g))
      allocate (bp_pbv1_g(ntm1_g,np_g))
      bp_pbv_g =0.
      bp_pbv0_g=0.
      bp_pbv1_g=0.
      allocate (vr_pbv_g (nt_g,np_g))
      allocate (vr_pbv0_g(nt_g,np_g))
      allocate (vr_pbv1_g(nt_g,np_g))
      vr_pbv_g =0.
      vr_pbv0_g=0.
      vr_pbv1_g=0.
      allocate (vt_pbv_g (ntm1_g,np_g))
      allocate (vt_pbv0_g(ntm1_g,np_g))
      allocate (vt_pbv1_g(ntm1_g,np_g))
      vt_pbv_g =0.
      vt_pbv0_g=0.
      vt_pbv1_g=0.
      allocate (vp_pbv_g (nt_g,npm1_g))
      allocate (vp_pbv0_g(nt_g,npm1_g))
      allocate (vp_pbv1_g(nt_g,npm1_g))
      vp_pbv_g =0.
      vp_pbv0_g=0.
      vp_pbv1_g=0.
      i_pbv_file0_contents=0
      i_pbv_file1_contents=0
!
! ****** Set up the flux interpolation helper array.
!
      do i=1,n_pbv_seq
        helper_pbv(i)=i
      enddo
!
end subroutine
!#######################################################################
subroutine initialize_field_line
!
!-----------------------------------------------------------------------
!
! ****** Load field line from 1D files.
!
!-----------------------------------------------------------------------
!
! ****** Values for B are read from file br_file.
! ****** Values for cos(theta) are read from file cos_file.
!
! ****** NP1D is the number of radial points in the file.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use seam_interface
      use io_units
      use interp_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), allocatable ::  rt(:),bt(:),cost(:),rt_true(:)
      real(r_typ) ::  alpha,fac,bhere,br01
      integer :: ierr,np1d,ir,irp1,i,j,k
!
!-----------------------------------------------------------------------
!
      if (iamp0) then
        call ffopen (IO_INPUT,fl_file,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        np1d=-1
        do
          read (IO_INPUT,'(a)',err=100,end=100)
          np1d=np1d+1
        enddo
  100   continue
        close(IO_INPUT)
      end if
!
! ****** Broadcast the number of lines to all processors.
!
      call MPI_Bcast (np1d,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
!
! ****** Allocate storage for the fields to be read.
!
      allocate (rt(np1d))
      allocate (bt(np1d))
      allocate (cost(np1d))
      allocate (rt_true(np1d))
!
! ****** Read the input file (only on processor IPROC0).
!
      if (iamp0) then
        call ffopen (IO_INPUT,fl_file,'r',ierr)
      end if
      call check_error_on_p0 (ierr)
!
      if (iamp0) then
        read (IO_INPUT,*)
        do i=1,np1d
          read (IO_INPUT,*) rt(i),bt(i),cost(i),rt_true(i)
        enddo
        close(IO_INPUT)
      end if
!
! ****** Broadcast the values to all processors.
!
      call MPI_Bcast (rt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (bt,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (cost,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
      call MPI_Bcast (rt_true,np1d,ntype_real,0,MPI_COMM_WORLD,ierr)
!
! ****** Interpolate to the code mesh.
!
      do i=1,nrm
        call interp (np1d,rt,r(i),ir,irp1,alpha,ierr)
        grav(i)=(one-alpha)*cost(ir)+alpha*cost(irp1)
        bhere=(one-alpha)*bt(ir)+alpha*bt(irp1)
        fl_fac_i(i)=bhere
        fl_fac(i)=one/fl_fac_i(i)
        r_true(i)=(one-alpha)*rt_true(ir)+alpha*rt_true(irp1)
      enddo
!
      do i=2,nrm1
        call interp (np1d,rt,rh(i),ir,irp1,alpha,ierr)
        br_mono(i)=(one-alpha)*bt(ir)+alpha*bt(irp1)
        fl_fach_i(i)=br_mono(i)
        fl_fach(i)=one/fl_fach_i(i)
        rh_true(i)=(one-alpha)*rt_true(ir)+alpha*rt_true(irp1)
      enddo
!
! ****** Set boundary values.
!
      br00=0.
      br01=0.
!
! ****** Set the initial and final base br_mono
!
      call interp (np1d,rt,r0,ir,irp1,alpha,ierr)
      br00=((one-alpha)*bt(ir)+alpha*bt(irp1))
!
      if (rb0) then
        br_mono(1)=two*br00-br_mono(2)
        fl_fach(1)=two*fl_fac(1)-fl_fach(2)
        fl_fach_i(1)=two*fl_fac_i(1)-fl_fach_i(2)
        rh_true(1)=two*r_true(1)-rh_true(2)
      end if
!
      call interp (np1d,rt,r1,ir,irp1,alpha,ierr)
      br01=((one-alpha)*bt(ir)+alpha*bt(irp1))
!
      if (rb1) then
        br_mono(nr)=two*br01-br_mono(nrm1)
        fl_fach(nr)=two*fl_fac(nrm1)-fl_fach(nrm1)
        fl_fach_i(nr)=two*fl_fac_i(nrm1)-fl_fach_i(nrm1)
        rh_true(nr)=two*r_true(nrm1)-rh_true(nrm1)
      end if
!
      fl_fac_i(:)=fl_fac_i(:)/br00*r(:)*r(:)
      fl_fac(:)=fl_fac(:)*br00*r_i(:)*r_i(:)
      fl_fach_i(:)=fl_fach_i(:)/br00*rh(:)*rh(:)
      fl_fach(:)=fl_fach(:)*br00*rh_i(:)*rh_i(:)
      r_true_i(:)=one/r_true(:)
      rh_true_i(:)=one/rh_true(:)
!
      deallocate (rt)
      deallocate (bt)
      deallocate (cost)
      deallocate (rt_true)
!$acc update device(fl_fac,fl_fach,fl_fac_i,fl_fach_i, &
!$acc              r_true,rh_true,r_true_i,rh_true_i)
!
end subroutine
!#######################################################################
subroutine setup_fcs
!-----------------------------------------------------------------------
!
! ****** Set up machinery for the fractional charge states. We read from
! ****** an input file, allocate arrays, and solve the equilibrium.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use restart
      use seam_interface
      use mod_input_parameter
      use mod_eigen_matrix
      use interplanetary_vars
      use vmod_fcs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0,i,j,k,ichemi,natom,jelem,jj,ln1,ln2,ii,jcs
      real(r_typ), dimension(max_atom,max_atom):: conce_ini,conce_nei
      real(r_typ), dimension(2):: te_arr, ne_arr
      real(r_typ), parameter :: two=2._r_typ, half=0.5_r_typ, &
       one=1._r_typ
!
!-----------------------------------------------------------------------
!
! ****** Setup array to modify vr in advfcs
!
      allocate(vmod(nr,nt,np))
      if (if_vmod) then
        do i=1,nr
          vmod(i,:,:)=half*(one+tanh((rh_true(i)-r_vmod)/dr_vmod))
        enddo
      else
        vmod(:,:,:)=one
      end if
!$acc enter data copyin(vmod)
!
! ****** Array to help in the interpolation.
!
      i_chemi_eigen(:)=0
!
! ****** Find the index 'ichemi' of atom in eigen matrix.
!
      do jelem=1,nelem
        natom=natom_list(jelem)
        do ii=1,15
          if(natom.eq.index_element(ii)) i_chemi_eigen(jelem)=ii
        end do
!
! ****** Check the atom index.
!
        if(i_chemi_eigen(jelem) .eq. 0)then
          if (iamp0) then
            write (*,*)
            write (*,*) '### ERROR in SETUP_FCS:'
            write (*,*) '### unmatched atom number "',natom,'"'
            call endrun (.true.)
          end if
        end if
      enddo
!$acc enter data copyin(i_chemi_eigen)
      if(iamp0) then
        call sub_read_eigen_matrix(path_eigen)
      else
        do ichemi=1,n_element
          natom=index_element(ichemi)
          allocate(eigen(ichemi)%eqis(natom+1,nte), &
                   eigen(ichemi)%evalues(natom+1,nte), &
                   eigen(ichemi)%evector(natom+1,natom+1,nte), &
                   eigen(ichemi)%evector_invers(natom+1,natom+1,nte), &
                   eigen(ichemi)%c(natom+1,nte), &
                   eigen(ichemi)%r(natom+1,nte))
!
        enddo
      end if
      do ichemi=1,n_element
        natom=index_element(ichemi)
        ln1=(natom+1)*nte
        ln2=ln1*(natom+1)
        call MPI_Bcast (eigen(ichemi)%eqis,ln1, &
        ntype_real,0,MPI_COMM_WORLD,ierr)
        call MPI_Bcast (eigen(ichemi)%evalues,ln1, &
        ntype_real,0,MPI_COMM_WORLD,ierr)
        call MPI_Bcast (eigen(ichemi)%evector,ln2, &
        ntype_real,0,MPI_COMM_WORLD,ierr)
        call MPI_Bcast (eigen(ichemi)%evector_invers,ln2, &
        ntype_real,0,MPI_COMM_WORLD,ierr)
        call MPI_Bcast (eigen(ichemi)%c,ln1, &
        ntype_real,0,MPI_COMM_WORLD,ierr)
        call MPI_Bcast (eigen(ichemi)%r,ln1, &
        ntype_real,0,MPI_COMM_WORLD,ierr)
!$acc enter data copyin(eigen(ichemi)%eqis,eigen(ichemi)%evalues, &
!$acc       eigen(ichemi)%evector,eigen(ichemi)%evector_invers, &
!$acc       eigen(ichemi)%c,eigen(ichemi)%r)
      enddo
      ncs=0
      do jelem=1,nelem
        ncs=ncs+natom_list(jelem)+1
      enddo
      allocate (fcs(nr,nt,np,ncs))
      allocate (fcsr0(nt,np,ncs))
      if (interplanetary_run) then
        allocate (fcsr0_ip_g(nt_g,np_g,ncs))
        allocate (fcsr0_ip0_g(nt_g,np_g,ncs))
        allocate (fcsr0_ip1_g(nt_g,np_g,ncs))
      end if
      if (restart_run.and.fname_restart_fcs.ne.' ') then
        call read_fcs_restart
        if (rb0) then
          jcs=0
          do jelem=1,nelem
            natom=natom_list(jelem)
            do jj=1,natom+1
              jcs=jcs+1
              fcsr0(:,:,jcs)=half*(fcs(1,:,:,jcs)+fcs(2,:,:,jcs))
            enddo
          enddo
        end if
      else
        do k=2,npm1
          do j=2,ntm1
            do i=2,nrm1
              jcs=0
              do jelem=1,nelem
                natom=natom_list(jelem)
                call func_equilibrium_eigen(i_chemi_eigen(jelem), &
                natom,fn_t*temp_e(i,j,k)*max(one,tmod1*temp_e0(i,j,k) &
                +tmod0),conce_ini(1:natom+1,natom))
                do jj=1,natom+1
                  jcs=jcs+1
                  fcs(i,j,k,jcs)=conce_ini(jj,natom)
                enddo
              enddo
            enddo
          enddo
        enddo
        if (rb0) then
          jcs=0
          do jelem=1,nelem
            natom=natom_list(jelem)
            call func_equilibrium_eigen(i_chemi_eigen(jelem), &
            natom,tbc0,conce_ini(1:natom+1,natom))
            do jj=1,natom+1
              jcs=jcs+1
              fcsr0(:,:,jcs)=conce_ini(jj,natom)
            enddo
          enddo
        end if
      end if
!
!$acc enter data copyin(fcs,fcsr0)
      do jcs=1,ncs
!
! ****** Set boundary conditions.
!
        if (rb0) then
          do concurrent(k=2:npm1,j=2:ntm1)
            fcs(1,j,k,jcs)=two*fcsr0(j,k,jcs)-fcs(2,j,k,jcs)
          enddo
        end if
!
        if (rb1) then
          do concurrent(k=2:npm1,j=2:ntm1)
            fcs(nr,j,k,jcs)=fcs(nrm1,j,k,jcs)
          enddo
        end if
!
        call set_pole_bc_scalar_hhh (fcs(:,:,:,jcs))
        call seam_scalar (fcs(:,:,:,jcs),nr,nt,np)
!
      enddo
!
      rhoold(:,:,:)=rho(:,:,:)
      temp_e0(:,:,:)=temp_e(:,:,:)
!$acc update device(rhoold,temp_e0)
!
end subroutine
!#######################################################################
subroutine advfcs
!
!-----------------------------------------------------------------------
!
! ****** Advance the fractional charge states.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use seam_interface
      use mod_input_parameter
      use mod_eigen_matrix
      use sub_solve_ionic_onestep_interface
      use vmod_fcs
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0,i,j,k,ichemi,natom,jelem,jj,ln1,ln2,ii,jcs
      real(r_typ), parameter :: two=2._r_typ,one=1._r_typ
      real(r_typ), dimension(max_atom,max_atom):: conce_ini,conce_nei
      real(r_typ), dimension(2):: te_arr, ne_arr
!
! ****** Temporary fields.
!
      real(r_typ), dimension(nr,nt,np) :: vdg,divv
      real(r_typ), dimension(nr,nt,np,ncs) :: fcsstar
!
!-----------------------------------------------------------------------
!$acc enter data create(vdg,divv,fcsstar)
!
! ****** Dynamical advancement
!
      call get_divv (v,divv)
!
      do jcs=1,ncs
!
        call divqv (upwind_rho,fcs(:,:,:,jcs),v,vdg)
!
        do concurrent (k=1:np, j=1:nt, i=1:nr)
          fcsstar(i,j,k,jcs)= fcs(i,j,k,jcs) &
              -dtime*vmod(i,j,k)*(vdg(i,j,k)-fcs(i,j,k,jcs)*divv(i,j,k))
        enddo
!
! ****** Set boundary conditions.
!
        if (rb0) then
          do concurrent (k=2:npm1, j=2:ntm1)
            fcsstar(1,j,k,jcs)=two*fcsr0(j,k,jcs)-fcsstar(2,j,k,jcs)
          enddo
        end if
        if (rb1) then
          do concurrent (k=2:npm1, j=2:ntm1)
            fcsstar(nr,j,k,jcs)=fcsstar(nrm1,j,k,jcs)
          enddo
        end if
!
! ****** Theta boundaries.
!
        call set_pole_bc_scalar_hhh (fcsstar(:,:,:,jcs))
!
        call seam_scalar (fcsstar(:,:,:,jcs),nr,nt,np)
!
      enddo
!
! ***** Advance the ionization.
!
!$acc parallel loop collapse(3) default(present) &
!$acc  private(conce_ini,conce_nei,te_arr,ne_arr)
      do k=2,npm1
        do j=2,ntm1
          do i=2,nrm1
!
            te_arr(1)=fn_t*temp_e0(i,j,k)* &
                                    MAX(one,tmod1*temp_e0(i,j,k)+tmod0)
            te_arr(2)=fn_t*temp_e(i,j,k)* &
                                    MAX(one,tmod1*temp_e(i,j,k)+tmod0)
            ne_arr(1)=fn_n*rhoold(i,j,k)
            ne_arr(2)=fn_n*rho(i,j,k)
!
            jcs=0
!$acc loop seq
            do jelem=1,nelem
              natom=natom_list(jelem)
!$acc loop seq
              do jj=1,natom+1
                jcs=jcs+1
                conce_ini(jj,natom)=fcsstar(i,j,k,jcs)
              enddo
            enddo
!
            call sub_solve_ionic_onestep (nelem,natom_list, &
                 i_chemi_eigen,te_arr,ne_arr,fnormt*dtime, &
                 conce_ini,conce_nei)
!
            jcs=0
!$acc loop seq
            do jelem=1,nelem
              natom=natom_list(jelem)
!$acc loop seq
              do jj=1,natom+1
                jcs=jcs+1
                fcs(i,j,k,jcs)=conce_nei(jj,natom)
              enddo
            enddo
!
          enddo
        enddo
!
      enddo
!
      do jcs=1,ncs
!
! ****** Set boundary conditions.
!
        if (rb0) then
          do concurrent (k=2:npm1, j=2:ntm1)
            fcs(1,j,k,jcs)=two*fcsr0(j,k,jcs)-fcs(2,j,k,jcs)
          enddo
        end if
        if (rb1) then
          do concurrent (k=2:npm1, j=2:ntm1)
            fcs(nr,j,k,jcs)=fcs(nrm1,j,k,jcs)
          enddo
        end if
!
        call set_pole_bc_scalar_hhh (fcs(:,:,:,jcs))
!
        call seam_scalar (fcs(:,:,:,jcs),nr,nt,np)
!
      enddo
!
!$acc exit data delete(vdg,divv,fcsstar)
end subroutine
!#######################################################################
subroutine sub_read_eigen_matrix (path_eigen)
!
!-----------------------------------------------------------------------
!
      use number_types
      use mod_eigen_matrix
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(150) :: datafile,path_eigen
      integer :: ichemi, natom
      integer :: ierr=0
!
!-----------------------------------------------------------------------
!
      do ichemi=1,n_element
        natom=index_element(ichemi)
!
        allocate(eigen(ichemi)%eqis(natom+1,nte), &
                 eigen(ichemi)%evalues(natom+1,nte), &
                 eigen(ichemi)%evector(natom+1,natom+1,nte), &
                 eigen(ichemi)%evector_invers(natom+1,natom+1,nte), &
                 eigen(ichemi)%c(natom+1,nte), &
                 eigen(ichemi)%r(natom+1,nte))
!
        datafile=trim(path_eigen)//trim(char_element(ichemi))// &
                 'eigen.dat'
        open(11,file=trim(datafile),form='unformatted',action='read', &
             iostat=ierr)
!
        if (ierr.ne.0) then
          write (*,*) '### WARNING from SUB_READ_EIGEN_MATRIX:'
          write (*,*) '### Missing/problematic eigenvalue matrixi file'
          write (*,*) '### File name: ',trim(datafile)
          close(11)
          continue
        end if
!
        read(11)eigen(ichemi)%eqis
        read(11)eigen(ichemi)%evalues
        read(11)eigen(ichemi)%evector
        read(11)eigen(ichemi)%evector_invers
        read(11)eigen(ichemi)%c
        read(11)eigen(ichemi)%r
!
        close(11)
      enddo
!
end subroutine
!#######################################################################
pure subroutine sub_solve_ionic_onestep (nelem,natom_array, &
              i_chemi_eigen,te_arr, ne_arr,dt_input,conce_ini,conce_nei)
!$acc routine(sub_solve_ionic_onestep) seq
!$acc routine(func_solveionization_eigen) seq
!
!-----------------------------------------------------------------------
!
! ****** Performing one-step time-dependent ionization calculations.
! ****** The time-step is from the input argument 'dt_input'. If
! ****** 'dt_input' is larger than the requirement for time-dependent
! ****** ionization progress, the sub-timestep will be actived based on
! ****** the Temperature tables. The time-step estimation using density
! ****** then can be removed in this routine.
! ****** Author: Chengcai Shen
! ****** Update: 2017-02-28
! ****** initialize: set the inputs using two time nodes.
!-----------------------------------------------------------------------
!
      use number_types
      use mod_eigen_matrix
      use func_solveionization_eigen_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, parameter:: ntime=2
      integer, intent(in) :: nelem
      integer, intent(in) :: natom_array(nelem),i_chemi_eigen(nelem)
      real(r_typ), intent(in) ::dt_input
      real(r_typ), intent(in) :: te_arr(ntime), ne_arr(ntime)
      real(r_typ), intent(in) :: conce_ini(max_atom,max_atom)
      real(r_typ), intent(out) :: conce_nei(max_atom,max_atom)
!
      real(r_typ) :: conce_temp_ini(max_atom,max_atom)
      real(r_typ) :: eval_arr(max_atom),dt_est_elem(nelem)
!
      integer:: i, n_inter, jelem
      integer:: natom
      real(r_typ):: te_sta,te_end,te_now,dd_te,ne_now,ne_s,ne_e,dt_sub
!
!-----------------------------------------------------------------------
!
! ****** Check if the dt_input is suitable?
!
      te_sta=log10(te_arr(1))
      te_end=log10(te_arr(ntime))
      dd_te =te_end-te_sta
      ne_now=0.5_r_typ*(ne_arr(1)+ne_arr(ntime))
!
      n_inter=int(abs(dd_te)/dlogte)+2
!
      conce_temp_ini(:,:)=conce_ini(:,:)
!
      if (n_inter.le.2) then
!
! ****** single timestep
!
!$acc loop seq
        do jelem=1,nelem
          natom=natom_array(jelem)
          call func_solveionization_eigen (i_chemi_eigen(jelem), &
                 natom,te_arr(1),ne_now,conce_temp_ini(1:natom+1,natom), &
                 dt_input,conce_nei(1:natom+1,natom))
        end do
      else
!
! ****** sub-timestep
!
        dt_sub=dt_input/real(n_inter-1,r_typ)
!$acc loop seq
        do i=1, n_inter-1
          te_now=real(i-1,r_typ)*(te_arr(2)-te_arr(1))/ &
          float(n_inter-1)+te_arr(1)
          ne_s=float(i-1)*(ne_arr(2)-ne_arr(1))/ &
          float(n_inter-1)+ne_arr(1)
          ne_e=float(i)*(ne_arr(2)-ne_arr(1))/ &
          float(n_inter-1)+ne_arr(1)
          ne_now=0.5_r_typ*(ne_s+ne_e)
!$acc loop seq
          do jelem=1,nelem
            natom=natom_array(jelem)
            call func_solveionization_eigen (i_chemi_eigen(jelem), &
                    natom,te_now,ne_now,conce_temp_ini(1:natom+1,natom), &
                    dt_sub,conce_nei(1:natom+1,natom))
          enddo
          conce_temp_ini(:,:)=conce_nei(:,:)
        enddo
      end if
!
end subroutine
!#######################################################################
subroutine func_equilibrium_eigen (ichemi,natom,te,ft)
!
!-----------------------------------------------------------------------
!
! ****** Input: ichemi, natom,te
! ****** Output: ion charge state in equilibrium case
!-----------------------------------------------------------------------
!
      use number_types
      use mod_eigen_matrix
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: natom,ichemi,index_te
      real(r_typ) te,ft(natom+1)
!
!-----------------------------------------------------------------------
!
! ****** Get eigen matrix according to the inputted te
!
!-----------------------------------------------------------------------
!
      index_te=max(int(anint((log10(te)-4.0_r_typ)* &
      (1.0_r_typ/dlogte))+1),1)
!
      ft(1:natom+1)=eigen(ichemi)%eqis(1:natom+1,index_te)
!
end subroutine
!#######################################################################
pure subroutine func_solveionization_eigen (ichemi,natom,te,rho, &
                                                  f0,dt,ft)
!$acc routine(func_solveionization_eigen) seq
!
!-----------------------------------------------------------------------
!
! ****** Input:
! ******    natom, atom index of this chemical element.
! ******    ichemi, index of element
! ******    rho, electron density.
! ******    te, temperature.
! ******    f0, ion fraction at initial time for this element.
! ******    dt, advanced time step.
! ****** Output:
! ******    ft, ion fraction at finnal time for this element.
! ****** Use:
! ******    mod_eigen_matrix, the eigenvalues and eigenvectors.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mod_eigen_matrix
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer, intent(in) :: ichemi,natom
      real(r_typ), intent(in) :: te,rho,dt
      real(r_typ), intent(in) :: f0(natom+1)
      real(r_typ), intent(out) :: ft(natom+1)
!
!-----------------------------------------------------------------------
!
      real(r_typ) :: f1(natom+1),f2(natom+1)
      real(r_typ) :: ene
      integer :: i,j,index_te
!
!-----------------------------------------------------------------------
!
!  ****** Get eigen matrix according to the inputted te
!
!-----------------------------------------------------------------------
!
      index_te=max(int(anint((log10(te)-4.0_r_typ)* &
                                               (1.0_r_typ/dlogte))+1),1)
!
      do j=1,natom+1
        f1(j)=DOT_PRODUCT(eigen(ichemi)%evector_invers(:,j,index_te),f0)
      enddo
!
      do j=1,natom+1
        f2(j)=dexp(eigen(ichemi)%evalues(j,index_te)*dt*rho)*f1(j)
      enddo
!
      do j=1,natom+1
        ft(j)=DOT_PRODUCT(eigen(ichemi)%evector(:,j,index_te),f2)
        if(ft(j).le.0.) ft(j)=0.
      enddo
!
end subroutine
!#######################################################################
subroutine read_fcs_g (fname,field_g,ncs,pole_bc)
!
!-----------------------------------------------------------------------
!
! ****** Read a 3D field in the (t,p,ncs) cube from HDF file FNAME
! ****** and return the global array FIELD_G.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: ncs
      real(r_typ) :: field_g(nt_g,np_g,ncs)
      integer :: pole_bc
!
!-----------------------------------------------------------------------
!
      integer :: ierr
!
!-----------------------------------------------------------------------
!
! ****** Read the boundary file.
!
      if (iamp0) then
!
        call read_fcs_interp (fname,field_g,ncs,pole_bc,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_FCS_G:'
          write (*,*) '### Error while reading the boundary field:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_FCS_G::'
          write (9,*) '### Error while reading the boundary field:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast FIELD_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (field_g,nt_g*np_g*ncs,ntype_real, &
                      iproc0,comm_all,ierr)
!
end subroutine
!#######################################################################
subroutine read_fcs_interp (fname,f_g,ncs,pole_bc,ierr)
!
!-----------------------------------------------------------------------
!
! ****** Read a 3D field in the (t,p,nfcs) cube from HDF file FNAME
! ****** and interpolate it into global array F_G.
!
! ****** Boundary conditions at the poles are set according to
! ****** POLE_BC (1: scalar, 2: theta component of a vector,
! ****** 3: phi component of a vector).
!
! ****** This routine is designed to be called from processor
! ****** IPROC0 only.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use rdhdf_3d_interface
      use ucase_interface
      use sum_p_interface
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: pole_bc,ncs
      real(r_typ) :: f_g(nt_g,np_g,ncs)
      integer :: ierr
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: two=2._r_typ
!
!-----------------------------------------------------------------------
!
      logical :: scale
      integer :: nx,ny,nz,i
      real(r_typ), dimension(:), pointer, contiguous :: x,y,z
      real(r_typ), dimension(:,:,:), pointer, contiguous :: f
!
      real(r_typ), dimension(1) :: sum0,sum1
      real(r_typ), dimension(1) :: sums0,sums1
      real(r_typ), dimension(1) :: sumc0,sumc1
!
!-----------------------------------------------------------------------
!
      ierr=0
!
! ****** When the file name is the special string '<ZERO>',
! ****** the array F_G is set to 0.
!
      if (ucase(fname).eq.'<ZERO>') then
        f_g=0.
        return
      end if
!
! ****** Read the array and its scales.  This call allocates the
! ****** arrays X, Y, Z and F.
!
      call rdhdf_3d (fname,scale,nx,ny,nz,f,x,y,z,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_FCS_INTERP:'
        write (9,*) '### Could not read the specified field.'
        write (9,*) 'IERR (from RDHDF_3D) = ',ierr
        write (9,*) 'File name: ',trim(fname)
        ierr=1
        return
      end if
!
! ****** Check that the array has scales.
!
      if (.not.scale) then
        write (9,*)
        write (9,*) '### ERROR in READ_FCS_INTERP:'
        write (9,*) '### The file does not have scales.'
        write (9,*) 'File name: ',trim(fname)
        ierr=2
        return
      end if
!
! ****** Interpolate the field on the TH_G and PH_G mesh into
! ****** array F_G.
!
! ****** First, interpolate the field on a mesh that does not
! ****** include the points outside the interval [0:pi,0:2*pi],
! ****** and then set these points using boundary conditions.
!
      f_g=0.
!
      call interp_3d (nx,ny,nz,x,y,z,f,ntm2_g,npm2_g,ncs, &
                      th_g(2:ntm1_g), &
                      ph_g(2:npm1_g), &
                      z, &
                      f_g(2:ntm1_g,2:npm1_g,:), &
                      .false.,ierr)
!
      if (ierr.ne.0) then
        write (9,*)
        write (9,*) '### ERROR in READ_FCS_INTERP:'
        write (9,*) '### The scales in the file are invalid.'
        write (9,*) 'File name: ',trim(fname)
        ierr=3
        return
      end if
!
! ****** Set the phi boundary points periodically.
!
      f_g(:,   1,:)=f_g(:,npm1_g,:)
      f_g(:,np_g,:)=f_g(:,     2,:)
!
! ****** Set boundary conditions at the poles.
!
      do i=1,ncs
        if (pole_bc.eq.1) then
!
! ****** A scalar has only an m=0 component.
!
          sum0=sum_p(1,npm2_g,f_g(     2,2:npm1_g,i),dph_g(2:npm1_g))
          sum1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g,i),dph_g(2:npm1_g))
!
          f_g(   1,:,i)=two*sum0(1)-f_g(     2,:,i)
          f_g(nt_g,:,i)=two*sum1(1)-f_g(ntm1_g,:,i)
!
        else
!
! ****** The theta and phi components of a vector have only
! ****** an m=1 component.
!
          if (axisymmetric) then
            sums0=0.
            sumc0=0.
            sums1=0.
            sumc1=0.
          else
            sums0=sum_p(1,npm2_g,f_g(     2,2:npm1_g,i), &
                         sph_g(2:npm1_g)*dph_g(2:npm1_g))*two
            sumc0=sum_p(1,npm2_g,f_g(     2,2:npm1_g,i), &
                         cph_g(2:npm1_g)*dph_g(2:npm1_g))*two
            sums1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g,i), &
                         sph_g(2:npm1_g)*dph_g(2:npm1_g))*two
            sumc1=sum_p(1,npm2_g,f_g(ntm1_g,2:npm1_g,i), &
                         cph_g(2:npm1_g)*dph_g(2:npm1_g))*two
          end if
!
          f_g(   1,1:np_g,i)= two*( sums0(1)*sph_g(1:np_g) &
                               +sumc0(1)*cph_g(1:np_g)) &
                         -f_g(     2,1:np_g,i)
          f_g(nt_g,1:np_g,i)= two*( sums1(1)*sph_g(1:np_g) &
                               +sumc1(1)*cph_g(1:np_g)) &
                         -f_g(ntm1_g,1:np_g,i)
!
        end if
      enddo
!
! ****** Deallocate temporary arrays.
!
      deallocate (x)
      deallocate (y)
      deallocate (z)
      deallocate (f)
!
end subroutine
!#######################################################################
subroutine remove_eflux_v_from_vb
!
!-----------------------------------------------------------------------
!
! ****** Remove eflux_v from vb, if some conditions are true.
!
!-----------------------------------------------------------------------
!
      use fields
      use emerging_flux_params
      use globals
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: j,k
!
!-----------------------------------------------------------------------
!
! ****** Remove the newflux psi/phi driven velocity.
!
      do concurrent (k=1:np, j=1:nt)
        vb%r0%r(j,k)=vb%r0%r(j,k)-eflux_vr(j,k)
      enddo
!
      do concurrent (k=1:np, j=1:ntm)
        vb%r0%t(j,k)=vb%r0%t(j,k)-eflux_vt(j,k)
      enddo
!
      do concurrent (k=1:npm, j=1:nt)
        vb%r0%p(j,k)=vb%r0%p(j,k)-eflux_vp(j,k)
      enddo
!
end subroutine
!#######################################################################
subroutine read_vbr0_from_restart (fname)
!
!-----------------------------------------------------------------------
!
! ****** Read the components of vb%r0 from the restart files, if
! ****** they are there.
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use global_to_local_tp_interface
      use field_table
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: fname
      integer :: ix,nodes,i,j,k,ierr
      real(r_typ), dimension(:,:), allocatable :: atp_g
      logical :: field_present
!
!-----------------------------------------------------------------------
!
      logical, external :: rs_array_present
!
!-----------------------------------------------------------------------
!
! ****** Open the restart file.
!
      call open_restart_file (fname)
!
! ****** Check to see if the vbr0 field is present in the file.
!
      if (iamp0) then
        field_present=rs_array_present('vbr0r')
      end if
      call MPI_Bcast (field_present,1,MPI_LOGICAL, &
                      iproc0,comm_all,ierr)
!
! ****** If the field is not present, use averages for the fields
!
      if (.not.field_present) then
        call close_restart_file
        if (rb0) then
          vb%r0%r(:,:)=AVG(v%r,1,:,:)
          vb%r0%t(:,:)=AVGR(v%t,2,:,:)
          vb%r0%p(:,:)=AVGR(v%p,2,:,:)
        end if
        if (iamp0) then
          write (*,*)
          write (*,*) '### WARNING from READ_VBR0_FROM_RESTART:'
          write (*,*) '### vb%r0 fields are not present.'
          write (*,*) '### Using averages instead.'
        end if
        return
      end if
!
      allocate (atp_g(nt_g,np_g))
      if (iamp0) then
        call rdrsh5_2d ('vbr0r',nt_g,np_g,atp_g,ierr)
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast ATP_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (atp_g,nt_g*np_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
! ****** Copy from global to local array.
!
      do k=1,np
        do j=1,nt
          vb%r0%r(j,k)=atp_g(j0_g+j-1,k0_g+k-1)
        enddo
      enddo
!
      deallocate (atp_g)
!
      allocate (atp_g(ntm1_g,np_g))
      if (iamp0) then
        call rdrsh5_2d ('vbr0t',ntm1_g,np_g,atp_g,ierr)
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast ATP_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (atp_g,ntm1_g*np_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
! ****** Copy from global to local array.
!
      do k=1,np
        do j=1,ntm
          vb%r0%t(j,k)=atp_g(j0_g+j-1,k0_g+k-1)
        enddo
      enddo
!
      deallocate (atp_g)
!
      allocate (atp_g(nt_g,npm1_g))
      if (iamp0) then
        call rdrsh5_2d ('vbr0p',nt_g,npm1_g,atp_g,ierr)
      end if
      call check_error_on_p0 (ierr)
!
! ****** Broadcast ATP_G from processor IPROC0 to all the processors.
!
      call MPI_Bcast (atp_g,nt_g*npm1_g,ntype_real, &
                      iproc0,comm_all,ierr)
!
! ****** Copy from global to local array.
!
      do k=1,npm
        do j=1,nt
          vb%r0%p(j,k)=atp_g(j0_g+j-1,k0_g+k-1)
        enddo
      enddo
!
      deallocate (atp_g)
!
! ****** Close the restart file.
!
      call close_restart_file
!
end subroutine
!#######################################################################
subroutine get_all_pchip (targin,brnew,vtnew,vpnew,phinew)
!
!-----------------------------------------------------------------------
!
! ****** PCHIP time interpolation to prescribe Br, Vt, Vp, and extra
! ****** phi potential
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use emerging_flux_params
      use time_profiles
      use flint_interface
      use pchip_module
      use prescribe_tdc_from_file_r0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      real(r_typ), parameter :: one=1._r_typ
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm,npm) :: brnew
      real(r_typ), dimension(ntm,np ) :: vtnew
      real(r_typ), dimension(nt ,npm) :: vpnew
      real(r_typ), dimension(nt ,np ) :: phinew
      real(r_typ) :: targ,targin
      real(r_typ) :: wk(8),t_ef(1),dval_ef(1),val_ef(1)
      integer :: ierr=0
      integer :: ix,i
      integer, save :: nodes
      logical, save :: first=.true.
      logical :: exists,if_outside
!
!-----------------------------------------------------------------------
!
! ****** Array to help in the flux interpolation.
!
      real(r_typ), save :: helper_ef(mx_tp_nodes)
!
! ****** Variables for flux interpolation.
!
      integer :: ifilem,ifile0,ifile1,ifilep
      integer :: j,k,nbr_ef,i_case
      logical :: skip=.true.
      real(r_typ) :: file_no
      character(256) :: fname
      character(6) :: seq
      real(r_typ) :: b0_save
      integer :: ip1,ip2
      real(r_typ) :: dummy
!
!-----------------------------------------------------------------------
!
      b0_save=b0
      b0=0.
!
! ****** On the first time in:
!
      if (first) then
        call check_tdc_from_files (nodes)
!
! ****** Allocate memory for the magnetic field arrays that are
! ****** read in.
!
        allocate (br_ef(4,ntm,npm))
        allocate (dbr_ef(4,ntm,npm))
        allocate (vt_ef(4,ntm,np ))
        allocate (dvt_ef(4,ntm,np ))
        allocate (vp_ef(4,nt ,npm))
        allocate (dvp_ef(4,nt ,npm))
        allocate (phi_ef(4,nt ,np ))
        allocate (dphi_ef(4,nt ,np ))
        br_ef=0.
        dbr_ef=0.
        vt_ef=0.
        dvt_ef=0.
        vp_ef=0.
        dvp_ef=0.
        phi_ef=0.
        dphi_ef=0.
        ifile0_contents=0
        ifile1_contents=0
!
! ****** Set up the flux interpolation helper array.
!
        do i=1,nodes
          helper_ef(i)=i
        enddo
!
        first=.false.
!
      end if
!
! ****** Interpolate to time TARG.
!
      targ=targin-deltat_tdcff
      if (targ.le.tdcff_node(1)) then
        ifile0=1
        ifile1=1
        if_outside=.true.
      else if (targ.ge.tdcff_node(nodes)) then
        ifile0=nodes
        ifile1=nodes
        if_outside=.true.
      else
        nbr_ef=4
        call interp (nodes,tdcff_node,targ,i,ip1,dummy,ierr)
        file_no=int(flint(.false.,targ,nodes, &
        tdcff_node,helper_ef,ierr))
        ifile0=file_no
        ifilem=file_no-1
        if (ifilem.lt.1) then
          ifilem=1
          nbr_ef=nbr_ef-1
        end if
        ifile1=min(ifile0+1,nodes)
        ifilep=ifile1+1
        if (ifilep.gt.nodes) then
          ifilep=nodes
          nbr_ef=nbr_ef-1
        end if
        if_outside=.false.
      end if
      if (if_outside) then
        if (ifile0.ne.ifile0_contents) then
          if (ifile0.eq.ifile1_contents) then
!
! ****** This should happen when targ moves out of the nodes during
! ****** the execution.
!
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_ALL_PCHIP:'
              write (9,*) '### Transferring flux from FILE1 to FILE0.'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            br_ef(2,:,:)=br_ef(3,:,:)
            vt_ef(2,:,:)=vt_ef(3,:,:)
            vp_ef(2,:,:)=vp_ef(3,:,:)
            phi_ef(2,:,:)=phi_ef(3,:,:)
          else
!
! ****** This should happen when targ is outside of the nodes
! ****** at the first time step.
!
            if (long_sequence_numbers_input) then
              write (seq,'(i6.6)') tdcff_sequence(ifile0)
            else
              write (seq,'(i3.3)') tdcff_sequence(ifile0)
            end if
            fname=trim(tdcff_path)//trim(br_tdcff_file)//trim(seq)// &
            "."//'h5'
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_ALL_PCHIP:'
              write (9,*) '### Reading a new ifile0 flux file.'
              write (9,*) 'File name: ',trim(fname)
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            call read_flux (trim(fname),br_ef(2,:,:))
            call read_tdc_from_files &
            (seq,vt_ef(2,:,:),vp_ef(2,:,:),phi_ef(2,:,:))
          end if
          ifile0_contents=ifile0
        end if
        brnew(:,:)=br_ef(2,:,:)
        vtnew(:,:)=vt_ef(2,:,:)
        vpnew(:,:)=vp_ef(2,:,:)
        phinew(:,:)=phi_ef(2,:,:)
      else
!
! ****** Set up the flux in the flux arrays BR_EF0 and BR_EF1
! ****** bounding this interval.
!
! ****** First, check to see if the flux file has changed.
! ****** If it has, check to see if this file has already
! ****** been read in previously; if it has, transfer that
! ****** flux, otherwise read in the new file.
!
        if (ifile0.ne.ifile0_contents) then
          if (ifile0.eq.ifile1_contents) then
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_ALL_PCHIP:'
              write (9,*) '### Transferring flux from FILE0 to FILEM.'
              write (9,*) '### Transferring flux from FILE1 to FILE0.'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            br_ef(1,:,:)=br_ef(2,:,:)
            br_ef(2,:,:)=br_ef(3,:,:)
            vt_ef(1,:,:)=vt_ef(2,:,:)
            vt_ef(2,:,:)=vt_ef(3,:,:)
            vp_ef(1,:,:)=vp_ef(2,:,:)
            vp_ef(2,:,:)=vp_ef(3,:,:)
            phi_ef(1,:,:)=phi_ef(2,:,:)
            phi_ef(2,:,:)=phi_ef(3,:,:)
          else
            if (ifilem.lt.ifile0) then
              if (long_sequence_numbers_input) then
                write (seq,'(i6.6)') tdcff_sequence(ifilem)
              else
                write (seq,'(i3.3)') tdcff_sequence(ifilem)
              end if
              fname=trim(tdcff_path)//trim(br_tdcff_file)//trim(seq)// &
              "."//'h5'
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_ALL_PCHIP:'
                write (9,*) '### Reading a new ifilem flux file.'
                write (9,*) 'File name: ',trim(fname)
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              call read_flux (trim(fname),br_ef(1,:,:))
              call read_tdc_from_files &
              (seq,vt_ef(1,:,:),vp_ef(1,:,:),phi_ef(1,:,:))
            end if
            if (long_sequence_numbers_input) then
              write (seq,'(i6.6)') tdcff_sequence(ifile0)
            else
              write (seq,'(i3.3)') tdcff_sequence(ifile0)
            end if
            fname=trim(tdcff_path)//trim(br_tdcff_file)//trim(seq)// &
            "."//'h5'
            if (iamp0) then
              write (9,*)
              write (9,*) '### COMMENT from GET_ALL_PCHIP:'
              write (9,*) '### Reading a new ifile0 flux file.'
              write (9,*) 'File name: ',trim(fname)
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            call read_flux (trim(fname),br_ef(2,:,:))
            call read_tdc_from_files &
            (seq,vt_ef(2,:,:),vp_ef(2,:,:),phi_ef(2,:,:))
          end if
          ifile0_contents=ifile0
        end if
!
        if (ifile1.ne.ifile1_contents) then
          if (ifile1.eq.ifile0_contents) then
!
! ****** This should never happen. If targ is within the time nodes
! ****** ifile0_contents is either 0 or ifile0, which is always
! ****** less that ifile1. RL
!
            ierr=1
            if (iamp0) then
              write (9,*)
              write (9,*) '### ERROR from GET_ALL_PCHIP:'
              write (9,*) '### Transferring flux from FILE0 to FILE1.'
              write (9,*) 'NTIME = ',ntime
              write (9,*) 'TIME = ',time
            end if
            br_ef(3,:,:)=br_ef(2,:,:)
            vt_ef(3,:,:)=vt_ef(2,:,:)
            vp_ef(3,:,:)=vp_ef(2,:,:)
            phi_ef(3,:,:)=phi_ef(2,:,:)
            call check_error_on_p0 (ierr)
          else
            if (ifile1_contents.eq.0) then
!
! ****** This should happen only the
! ****** first time we call the routine. Afterwards we
! ****** copy the content from br_ef(4,:,:) until targ
! ****** moves outside the time nodes.
!
              if (long_sequence_numbers_input) then
                write (seq,'(i6.6)') tdcff_sequence(ifile1)
              else
                write (seq,'(i3.3)') tdcff_sequence(ifile1)
              end if
              fname=trim(tdcff_path)//trim(br_tdcff_file)//trim(seq)// &
              "."//'h5'
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_ALL_PCHIP:'
                write (9,*) '### Reading a new ifile1 flux file.'
                write (9,*) 'File name: ',trim(fname)
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              call read_flux (trim(fname),br_ef(3,:,:))
              call read_tdc_from_files &
              (seq,vt_ef(3,:,:),vp_ef(3,:,:),phi_ef(3,:,:))
            else
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_ALL_PCHIP:'
                write (9,*) '### Transferring flux from FILEP to FILE1.'
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              br_ef(3,:,:)=br_ef(4,:,:)
              vt_ef(3,:,:)=vt_ef(4,:,:)
              vp_ef(3,:,:)=vp_ef(4,:,:)
              phi_ef(3,:,:)=phi_ef(4,:,:)
            end if
            if (ifilep.gt.ifile1) then
              if (long_sequence_numbers_input) then
                write (seq,'(i6.6)') tdcff_sequence(ifilep)
              else
                write (seq,'(i3.3)') tdcff_sequence(ifilep)
              end if
              fname=trim(tdcff_path)//trim(br_tdcff_file)//trim(seq)// &
              "."//'h5'
              if (iamp0) then
                write (9,*)
                write (9,*) '### COMMENT from GET_ALL_PCHIP:'
                write (9,*) '### Reading a new ifilep flux file.'
                write (9,*) 'File name: ',trim(fname)
                write (9,*) 'NTIME = ',ntime
                write (9,*) 'TIME = ',time
              end if
              call read_flux (trim(fname),br_ef(4,:,:))
              call read_tdc_from_files &
              (seq,vt_ef(4,:,:),vp_ef(4,:,:),phi_ef(4,:,:))
            end if
          end if
          ifile1_contents=ifile1
!
! ****** Calculate new interpolant.
!
          select case (nbr_ef)
          case (2)
            do k=1,npm
              do j=1,ntm
                call dpchim(2,tdcff_node(ifile0:ifile1), &
                br_ef(2:3,j,k),dbr_ef(2:3,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,np
              do j=1,ntm
                call dpchim(2,tdcff_node(ifile0:ifile1), &
                vt_ef(2:3,j,k),dvt_ef(2:3,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,npm
              do j=1,nt
                call dpchim(2,tdcff_node(ifile0:ifile1), &
                vp_ef(2:3,j,k),dvp_ef(2:3,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,np
              do j=1,nt
                call dpchim(2,tdcff_node(ifile0:ifile1), &
                phi_ef(2:3,j,k),dphi_ef(2:3,j,k),1,ierr)
              enddo
            enddo
          case (3)
            ip1=2-(ifile0-ifilem)
            ip2=ip1+2
            do k=1,npm
              do j=1,ntm
                call dpchim(3,tdcff_node(ifilem:ifilep), &
                br_ef(ip1:ip2,j,k),dbr_ef(ip1:ip2,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,np
              do j=1,ntm
                call dpchim(3,tdcff_node(ifilem:ifilep), &
                vt_ef(ip1:ip2,j,k),dvt_ef(ip1:ip2,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,npm
              do j=1,nt
                call dpchim(3,tdcff_node(ifilem:ifilep), &
                vp_ef(ip1:ip2,j,k),dvp_ef(ip1:ip2,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,np
              do j=1,nt
                call dpchim(3,tdcff_node(ifilem:ifilep), &
                phi_ef(ip1:ip2,j,k),dphi_ef(ip1:ip2,j,k),1,ierr)
              enddo
            enddo
          case default
            do k=1,npm
              do j=1,ntm
                call dpchim(4,tdcff_node(ifilem:ifilep), &
                br_ef(1:4,j,k),dbr_ef(1:4,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,np
              do j=1,ntm
                call dpchim(4,tdcff_node(ifilem:ifilep), &
                vt_ef(1:4,j,k),dvt_ef(1:4,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,npm
              do j=1,nt
                call dpchim(4,tdcff_node(ifilem:ifilep), &
                vp_ef(1:4,j,k),dvp_ef(1:4,j,k),1,ierr)
              enddo
            enddo
!
            do k=1,np
              do j=1,nt
                call dpchim(4,tdcff_node(ifilem:ifilep), &
                phi_ef(1:4,j,k),dphi_ef(1:4,j,k),1,ierr)
              enddo
            enddo
          end select
          if (ierr.lt.0) then
            if (iamp0) then
              write (*,*)
              write (*,*) '### ERROR in GET_ALL_PCHIP:'
              write (*,*) '### An error occurred within DPCHIM '
              write (*,*) 'IERR   = ',ierr
              write (*,*) 'NBR_EF = ',nbr_ef
              write (*,*) 'IFILEM = ',ifilem
              write (*,*) 'IFILE0 = ',ifile0
              write (*,*) 'IFILE1 = ',ifile1
              write (*,*) 'IFILEP = ',ifilep
            end if
          end if
        end if
!
! ****** Interpolate the flux to time TARG.
!
        t_ef(1)=targ
        select case (nbr_ef)
        case (2)
          do k=1,npm
            do j=1,ntm
              call dpchfd(2,tdcff_node(ifile0:ifile1), &
                          br_ef(2:3,j,k),dbr_ef(2:3,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              brnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,np
            do j=1,ntm
              call dpchfd(2,tdcff_node(ifile0:ifile1), &
                          vt_ef(2:3,j,k),dvt_ef(2:3,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              vtnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,npm
            do j=1,nt
              call dpchfd(2,tdcff_node(ifile0:ifile1), &
                          vp_ef(2:3,j,k),dvp_ef(2:3,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              vpnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,np
            do j=1,nt
              call dpchfd(2,tdcff_node(ifile0:ifile1), &
                          phi_ef(2:3,j,k),dphi_ef(2:3,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              phinew(j,k)=val_ef(1)
            enddo
          enddo
        case (3)
          ip1=2-(ifile0-ifilem)
          ip2=ip1+2
          do k=1,npm
            do j=1,ntm
              call dpchfd(3,tdcff_node(ifilem:ifilep), &
                          br_ef(ip1:ip2,j,k),dbr_ef(ip1:ip2,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              brnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,np
            do j=1,ntm
              call dpchfd(3,tdcff_node(ifilem:ifilep), &
                          vt_ef(ip1:ip2,j,k),dvt_ef(ip1:ip2,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              vtnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,npm
            do j=1,nt
              call dpchfd(3,tdcff_node(ifilem:ifilep), &
                          vp_ef(ip1:ip2,j,k),dvp_ef(ip1:ip2,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              vpnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,np
            do j=1,nt
              call dpchfd(3,tdcff_node(ifilem:ifilep), &
                        phi_ef(ip1:ip2,j,k),dphi_ef(ip1:ip2,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              phinew(j,k)=val_ef(1)
            enddo
          enddo
        case default
          do k=1,npm
            do j=1,ntm
              call dpchfd(4,tdcff_node(ifilem:ifilep), &
                          br_ef(1:4,j,k),dbr_ef(1:4,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              brnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,np
            do j=1,ntm
              call dpchfd(4,tdcff_node(ifilem:ifilep), &
                          vt_ef(1:4,j,k),dvt_ef(1:4,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              vtnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,npm
            do j=1,nt
              call dpchfd(4,tdcff_node(ifilem:ifilep), &
                          vp_ef(1:4,j,k),dvp_ef(1:4,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              vpnew(j,k)=val_ef(1)
            enddo
          enddo
!
          do k=1,np
            do j=1,nt
              call dpchfd(4,tdcff_node(ifilem:ifilep), &
                        phi_ef(1:4,j,k),dphi_ef(1:4,j,k),1,skip, &
                          1,t_ef,val_ef,dval_ef,ierr)
              phinew(j,k)=val_ef(1)
            enddo
          enddo
        end select
        if (ierr.lt.0) then
          if (iamp0) then
            write (*,*)
            write (*,*) '### WARNING from GET_ALL_PCHIP:'
            write (*,*) '### Recoverable error within DPCHFD'
            write (*,*) 'IERR   = ',ierr
            write (*,*) 'NBR_EF = ',nbr_ef
            write (*,*) 'IFILEM = ',ifilem
            write (*,*) 'IFILE0 = ',ifile0
            write (*,*) 'IFILE1 = ',ifile1
            write (*,*) 'IFILEP = ',ifilep
          end if
        end if
      end if
!
      b0=b0_save
!
end subroutine
!#######################################################################
subroutine check_tdc_from_files (nodes)
!
!-----------------------------------------------------------------------
!
! ****** Check machinery for the boundary conditions for when
! ****** we read B and V and drive TDC from files
!
!-----------------------------------------------------------------------
!
      use number_types
      use globals
      use mesh
      use fields
      use vars
      use mpidefs
      use flint_interface
      use prescribe_tdc_from_file_r0
      use ucase_interface
      use global_to_local_tp_interface
      use field_table
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      integer :: ierr=0
      integer :: ix,nodes,i,j,k
      logical :: exists
!
!-----------------------------------------------------------------------
!
! ****** Variables for interpolation.
!
      character(256) :: fname
      character(6) :: seq
!
!-----------------------------------------------------------------------
!
! ****** Check that the specified flux files exist.
!
      do i=1,mx_tdcff_seq
         if (tdcff_sequence(i).eq.NULL_VALUE_TDCFF_SEQUENCE) exit
      enddo
      n_tdcff_seq=i-1
      if (iamp0) then
!
        if (tdcff_node(n_tdcff_seq).lt.0) then
          write (*,*)
          write (*,*) '### ERROR in CHECK_TDC_FROM_FILES:'
          write (*,*) '### You have specified fewer nodes than times.'
          ierr=1
        end if
!
        if (n_tdcff_seq.lt.mx_tdcff_seq.and. &
        tdcff_node(n_tdcff_seq+1).gt.0) then
          write (*,*)
          write (*,*) '### ERROR in CHECK_TDC_FROM_FILES:'
          write (*,*) '### You have specified more nodes than times.'
          ierr=1
        end if
!
        do i=1,n_tdcff_seq
          if (long_sequence_numbers_input) then
            write (seq,'(i6.6)') tdcff_sequence(i)
          else
            write (seq,'(i3.3)') tdcff_sequence(i)
          end if
          fname=trim(tdcff_path)//trim(br_tdcff_file)//trim(seq)// &
          "."//'h5'
          inquire (file=trim(fname),exist=exists)
          if (.not.exists) then
            write (*,*)
            write (*,*) '### ERROR in SETUP_TDC_FROM_FILES:'
            write (*,*) '### You have specified a file'// &
                          ' that does not exist.'
            write (*,*) 'File name: ',trim(fname)
            write (9,*)
            write (9,*) '### ERROR in SETUP_TDC_FROM_FILES:'
            write (9,*) '### You have specified a file'// &
                          ' that does not exist.'
            write (9,*) 'File name: ',trim(fname)
            ierr=1
          end if
        enddo
      end if
      call check_error_on_p0 (ierr)
!
      nodes=n_tdcff_seq
!
end subroutine
!#######################################################################
subroutine read_tdc_from_files (seq,vt0,vp0,phi0)
!
!-----------------------------------------------------------------------
!
! ****** Read the rest of the TDC fields need for TDC from fileME,
! ****** normalize it, and balance the flux
!
! ****** The magnetic field is returned in the local arrays.
!
!-----------------------------------------------------------------------
!
      use number_types
      use mpidefs
      use globals
      use vars
      use io_units
      use global_to_local_tp_interface
      use prescribe_tdc_from_file_r0
!
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      character(*) :: seq
      character(256) :: fname
      real(r_typ), dimension(ntm,np ) :: vt0
      real(r_typ), dimension(nt ,npm) :: vp0
      real(r_typ), dimension(nt ,np ) :: phi0
!
!-----------------------------------------------------------------------
!
      real(r_typ), dimension(ntm1_g,np_g) :: vt0_g
      real(r_typ), dimension(nt_g,npm1_g) :: vp0_g
      real(r_typ), dimension(nt_g,np_g) :: phi0_g
      integer :: ierr=0
!
!-----------------------------------------------------------------------
!
! ****** Read the Vt file
!
      if (iamp0) then
!
        fname=trim(tdcff_path)//trim(vt_tdcff_file)//trim(seq)// &
        "."//'h5'
        call read_tp_interp_mh (fname,vt0_g,1,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_TDC_FROM_FILES:'
          write (*,*) '### Error while reading the boundary flux:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_TDC_FROM_FILES:'
          write (9,*) '### Error while reading the boundary flux:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
      call global_to_local_tp (vt0_g,vt0)
!
! ****** Read the Vp file
!
      if (iamp0) then
!
        fname=trim(tdcff_path)//trim(vp_tdcff_file)//trim(seq)// &
        "."//'h5'
        call read_tp_interp_hm (fname,vp0_g,1,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_TDC_FROM_FILES:'
          write (*,*) '### Error while reading the boundary flux:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_TDC_FROM_FILES:'
          write (9,*) '### Error while reading the boundary flux:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
      call global_to_local_tp (vp0_g,vp0)
!
! ****** Read the Phi file
!
      if (iamp0) then
!
        fname=trim(tdcff_path)//trim(phi_tdcff_file)//trim(seq)// &
        "."//'h5'
        call read_tp_interp_hh (fname,phi0_g,1,ierr)
!
        if (ierr.ne.0) then
          write (*,*)
          write (*,*) '### ERROR in READ_TDC_FROM_FILES:'
          write (*,*) '### Error while reading the boundary flux:'
          write (*,*) 'File name: ',trim(fname)
          write (9,*)
          write (9,*) '### ERROR in READ_TDC_FROM_FILES:'
          write (9,*) '### Error while reading the boundary flux:'
          write (9,*) 'File name: ',trim(fname)
        end if
!
      end if
      call check_error_on_p0 (ierr)
!
! ****** Load the local array from the global array.
!
      call global_to_local_tp (phi0_g,phi0)
!
end subroutine
!#######################################################################
!
! #########  CS LOG #########
!
! ### Version 0.3.8.0-RO, 03/29/2017
! ### modified by RL
!      - Added fractional charge state evolution.
!
! ### Version 0.3.8.1-RO, 04/04/2017
! ### modified by RL
!      - Added capability to write and read restart files
!        for fractional charge state evolution.
!
! ### Version 0.3.8.2-RO, 04/05/2017
! ### modified by RL
!      - Bug fixes: dt was used instead of dtime
!        for fractional charge state evolution.
!
! ### Version 0.3.8.3-RO, 04/10/2017
! ### modified by RL
!      - Added no-rho viscosity (set visc_ro=.true. to activate.
!      - Added viscosity sub-cycling
!        (set n_visc_substeps=n to use n substeps
!
! ### Version 0.3.8.4-RO, 04/21/2017
! ### modified by RL
!      -  Fractional charge state routines and modules incorporated
!         into the main code.
!
! ### Version 0.3.8.5-RO, 04/25/2017
! ### modified by RL
!      -  Remove the input.txt file for charge state evolution and use
!         namelist instead.
!
! ### Version 0.3.8.5-RO, 04/25/2017
! ### modified by RL
!      -  Fixed bug in reading and writing of restart fcs files.
!
! ### Version 0.3.8.0-RO, 05/04/2017
! ### modified by RL
!      - Added two temperature advance.
!
! ### Version 0.4.1.1-CS1.0, 05/29/2017
! ### modified by RL
!
!      - Added charge states to heliospheric section
!
! ### Version 0.4.1.2-CS, 11/13/2017
! ### modified by RL
!
!      - Fixed bug in initialization of temperature
!
! ### Version 0.4.1.3-CS, 05/10/2018
! ### modified by RL
!
!      - Prescribe Alfven wave pressure in the heliosphere
!
! ### Version 0.4.1.4-CS, 05/15/2018
! ### modified by RL
!
!      - Heliospheric Alfven wave pressure can be prescribed from ep em.
!
! ### Version 0.4.9.1_CS1.1, 10/16/2019, modified by RL:
!
!      - Added module with parameters for velocity modifier in advfcs.
!        See 2019SoPh..294...13L for rationale.
!
! ### Version 0.4.9.1_CS1.2, 11/26/2019, modified by RC:
!
!     - Fixed bug with temp_e0.
! #######################
!
! ****** Revision history:
!
! ### Version 1.00_v21_test, 10/10/2003, file mas50v21_test.f,
! ### modified by ZM:
!
!       - Test version to do the uniform advection problem (vr=vr00)
!         with the three-level time algorithm.
!
! ### Version 1.00_v22_test, 10/10/2003, file mas50v22_test.f,
! ### modified by ZM:
!
!       - This version has more streamlined SEAM routines.
!         This ought to simplify future changes to the MPI
!         communication algorithm.
!
! ### Version 1.00_v23, 11/06/2003, file mas50v23.f,
! ### modified by ZM:
!
!       - This version has the original two-step time advance.
!
! ### Version 1.00_v24, 11/27/2003, file mas50v24.f,
! ### modified by ZM:
!
!       - Fixed a problem with reading restart files.  This required
!         a reorganization of the way field attributes are stored
!         in the field table.
!
! ### Version 1.00_v25, 12/02/2003, file mas50v25.f,
! ### modified by ZM:
!
!       - Added the ability to shear a streamer by restarting
!         from a streamer run.
!
! ### Version 1.00_v26, 12/04/2003, file mas50v26.f,
! ### modified by ZM and JL:
!
!       - Added the ability to specify a radially-dependent
!         resistivity profile.  See routine LOAD_RESISTIVITY
!         to see the options.
!
! ### Version 1.00_v27, 02/10/2004, file mas50v27.f,
! ### modified by ZM:
!
!       - Added the ability to specify multiple sub-surface dipoles.
!       - Added a small fix to prevent errors in the compiler on
!         DEC/Alpha machines.
!
! ### Version 1.00_v28, 02/19/2004, file mas50v28.f,
! ### modified by ZM:
!
!       - Changed the mesh generation routine GENMESH to improve
!         the specification of non-uniform meshes.
!
! ### Version 1.00_v29, 02/24/2004, file mas50v29.f,
! ### modified by ZM:
!
!       - Improved the specification of the initial state.
!
! ### Version 1.00_v30, 02/25/2004, file mas50v30.f,
! ### modified by ZM:
!
!       - Put in the explicit characteristics along B.
!
! ### Version 1.00_v31, 03/06/2004, file mas50v31.f,
! ### modified by ZM:
!
!       - Added a mask for the shear flow specification.
!       - Fixed a bug in the mesh specification routines.
!
! ### Version 1.00_v32, 06/04/2004, file mas50v32.f,
! ### modified by ZM:
!
!       - Fixed a small bug with the declaration of "n_ssdip".
!
! ### Version 1.00_v33, 06/04/2004, file mas50v33.f,
! ### modified by ZM:
!
!       - Corrected div(V) in the parallel characteristics.
!
! ### Version 1.00_v34, 06/15/2004, file mas50v34.f,
! ### modified by ZM:
!
!       - Implemented parallel characteristics at r=R0 using
!         only the momentum equation.
!       - Added filtering to the characteristics.
!
! ### Version 1.00_v35, 06/22/2004, file mas50v35.f,
! ### modified by ZM:
!
!       - Test of nonuniform density and pressure at r=R0.
!
! ### Version 1.00_v36, 06/23/2004, file mas50v36.f,
! ### modified by ZM:
!
!       - Continued test of nonuniform density and pressure
!         at r=R0.
!
! ### Version 1.00_v37, 06/25/2004, file mas50v37.f,
! ### modified by ZM:
!
!       - Implemented the "UBZERO" switch in the characteristics.
!
! ### Version 1.00_v38, 06/25/2004, file mas50v38.f,
! ### modified by ZM:
!
!       - Added the ability to request diagnostics and plots for
!         all fields by using the field specifier 'all'.
!
! ### Version 1.00_v39, 06/25/2004, file mas50v39.f,
! ### modified by ZM:
!
!       - Try an initialization with p=constant at r=R0 but
!         with rho varying.
!
! ### Version 1.00_v40, 08/04/2004, file mas50v40.f,
! ### modified by ZM:
!
!       - Added the infrastructure to use time profiles to control
!         specific variables.  This makes it easy to add time profile
!         control for a new variable.
!       - Minor cleanup of the FLINT function.
!
! ### Version 1.00_v41, 08/27/2004, file mas50v41.f,
! ### modified by ZM:
!
!       - First cut at adding the 3D potential field solve.
!
! ### Version 1.00_v42, 08/29/2004, file mas50v42.f,
! ### modified by ZM:
!
!       - Implemented the 3D potential field solve.
!
! ### Version 1.00_v43, 09/01/2004, file mas50v43.f,
! ### modified by ZM:
!
!       - Converted the 2D and 3D potential field solves to
!         use a matrix with stored coefficients.
!       - Fixed the characteristic BC routines to handle
!         error conditions more robustly.  The previous code
!         could cause MPI to deadlock in certain situations when
!         an error occured in the characteristic BC routines.
!
! ### Version 1.00_v44, 09/15/2004, file mas50v44.f,
! ### modified by ZM:
!
!       - Added timers for the potential field solves.
!       - Improved the initialization of the hydrostatic
!         equilibrium with nonuniform density.
!
! ### Version 1.00_v45, 09/17/2004, file mas50v45.f,
! ### modified by ZM:
!
!       - Further improvements to the hydrostatic equilibrium
!         initialization.
!
! ### Version 1.00_v46, 10/22/2004, file mas50v46.f,
! ### modified by ZM:
!
!       - Added the ability to write the matrix for the momentum
!         equation implicit solve and the implicit resistivity
!         solve to a file.  This is useful for debugging.
!
! ### Version 1.00_v47, 11/01/2004, file mas50v47.f,
! ### modified by ZM:
!
!       - Changed advection in GETVDGV to implement Roberto's
!         improved algorithm which ought to have the correct
!         behavior at the poles.
!
! ### Version 1.00_v48, 12/08/2004, file mas50v48.f,
! ### modified by ZM:
!
!       - Kluge to fix rho and p boundary conditions in restarts.
!       - Added emerging flux.  To use this, set the following:
!
!           EMERGING_FLUX=.T.
!           EFLUX_PSI_FILE=<name of psi file>
!           EFLUX_E0=fractional change in B_z/time E is applied
!           TPROFILE(N)%T=<time values>
!           TPROFILE(N)%F=<profile values>
!           TPROFILE(N)%VARS='eflux_factor'
!
! ### Version 1.00_v49, 02/10/2005, file mas50v49.f,
! ### modified by ZM:
!
!       - Fixed a bug in routine ADVANCE_A_B which resulted in an
!         incorrect tangential boundary electric field for cases
!         in which BETAPC_A was not equal to 1.
!
! ### Version 1.00_v49jl01, 03/04/2005, file mas50v49jl01.f,
! ### modified by JL:
!
!       - Added option to input 2D shearing profiles as in the old
!         MAS code.  Use SHEAR_TYPE='CLASSIC_SHEAR' to obtain this
!         profile, with namelist variables TH0 and DTHMAX.
!         Use SHEAR_TYPE='VERTICAL' for v along b contours.
!       - Generalized the specification of the initial state.  Use
!         INITIAL_FIELD to specify the magnetic field (options are
!         'DIPOLE', 'POTENTIAL_FIELD','ALFVEN_WAVE1', 'ALFVEN_WAVE2').
!         Use INITIAL_PLASMA for the fluid state, with options
!         'ZERO-BETA','STREAMER', and 'HYDROSTATIC'.
!       - Added EPSCGA to allow a separate solve tolerance for the
!         potential field and A solves.  EPSCG still sets the tolerance
!         for the semi-implicit and viscous solves.
!
! ### Version 1.00_v49jl02, 03/22/2005, file mas50v49jl01.f,
! ### modified by JL:
!
!       - Added the capability to specify a nonuniform density for
!         zero-beta runs.  A combination of an exponential and a
!         power-law fall-off with radius can be specified, with
!         the base density for the exponential profile determined
!         by |B|.  The parameters for controlling the density are
!         specified in the structure ZB_VAR.
!
! ### Version 1.00_v49jl02rl01, 04/11/2005, file mas50v49jl02rl01.f,
! ### modified by RL:
!
!       - Added thermal conduction
!
! ### Version 1.00_v49jl02rl02, 08/20/2005, file mas50v49jl02rl02.f,
! ### modified by RL:
!
!       - Fixed a couple of bugs in the thermal conduction algorithm.
!         Now it is self-adjoint even for non axysimmetric flux
!         distributions.
!
! ### Version 1.00_v49jl02rl03, 08/28/2005, file mas50v49jl02rl03.f,
! ### modified by RL:
!
!       - Fixed another bug that appeared only with the pgf90 compiler.
!         Functions need to be declared externals in order to work.
!
! ### Version 1.00_v49jl02rl04, 09/05/2005, file mas50v49jl02rl04.f,
! ### modified by RL:
!
!       - Advance temperature instead of pressure. Advancing pressure
!         and thermal conduction makes the code unstable.
!
! ### Version 1.00_v49jl02rl06, 10/05/2005, file mas50v49jl02rl06.f,
! ### modified by RL:
!
!       - Added old vdgv calculation. The new one has problems.
!       - Added collisionless thermal conduction
!
! ### Version 1.00_v49jl02rl07, 10/14/2005, file mas50v49jl02rl07.f,
! ### modified by RL:
!
!       - Added filtering in the thermal conduction coefficients.
!       - Fixed bug in FILTER_TP_HH_2D (a multiplying factor was
!         missing)
!
! ### Version 1.00_v49jl02rl08, 10/25/2005, file mas50v49jl02rl08.f,
! ### modified by RL:
!
!       - Added capability of calculating the heat flux for the
!         specified heating
!
! ### Version 1.00_v49jl02rl09, 11/08/2005, file mas50v49jl02rl09.f,
! ### modified by ZM:
!
!       - Added heating type 4 (with a B cutoff).
!       - Added time profile control to some of the heating
!         parameters.
!
! ### Version 1.00_v49jl02rl10, 11/15/2005, file mas50v49jl02rl10.f,
! ### modified by ZM and RL:
!
!       - Added capability of dumping the volumetric heating that is
!         in the "heat" field.
!       - Added the ability of starting with a source-surface
!         field with a specified source-surface radius R_SS
!         that is not necessarily equal to the outer domain
!         radius R1.  The default is to use R_SS=R1, as before.
!
! ### Version 1.00_v49jl02rl10a, 11/20/2005, file mas50v49jl02rl10a.f,
! ### modified by ZM and RL:
!
!       - Changed the defaults of the parameters for the energy
!         equation so that the default behavior is to use the
!         polytropic model.
!       - Fixed the temperature boundary condition so that it works
!         in the polytropic case.
!       - Made aborts more graceful.  An attempt is made to
!         write final diagnostics and a restart file in many
!         aborts.
!
! ### Version 1.00_v49jl02rl10b, 11/23/2005, file mas50v49jl02rl10b.f,
! ### modified by ZM:
!
!       - Fixed a bug in the potential field solve introduced
!         in version 1.00_v49jl02rl10a that prevented the closed
!         wall B.C. from working for the potential solve.
!
! ### Version 1.00_v49jl02rl10c, 11/25/2005, file mas50v49jl02rl10c.f,
! ### modified by ZM:
!
!       - Temporary fix of BC at r=R1.  This is a test version.
!       - Removed the write to "fluxmap.h5", which was programmed
!         incorrectly.
!
! ### Version 1.00_v49jl02rl10d, 11/28/2005, file mas50v49jl02rl10d.f,
! ### modified by RL:
!
!       - Added another exponential to the heating.
!
! ### Version 1.00_v49jl02rl10e, 12/07/2005, file mas50v49jl02rl10e.f,
! ### modified by ZM:
!
!       - Added the new exponential to heating type 3 also.
!        (RL had only added it to heating type 4 in the previous
!        version.)
!
! ### Version 1.00_v49jl02rl10f, 02/19/2006, file mas50v49jl02rl10f.f,
! ### modified by ZM:
!
!      - Changed the averaging for the (J x B) term.  This new
!        method should behave much better in current sheets,
!        and also is self-adjoint.  The default is to use this new
!        average (i.e., USE_OLD_JXB=.false.).
!      - Took out the "new" (v x B) routine, since it is not
!        useful.  The "old" routine should be used exclusively,
!        since, in combination with the new (J x B) averaging, it
!        gives a self-adjoint algorithm.  In addition, the old
!        (v x B) allows for upwinding of the vector potential.
!        The variable USE_OLD_VXB has thus been removed.
!
! ### Version 1.00_v49jl02rl10f2, 03/11/2006,
! ### file mas50v49jl02rl10f2.f, modified by ZM:
!
!      - Quick fix to prevent the code from going into an infinite
!        loop during a code abort.
!
! ### Version 1.00_v49jl02rl10f3, 03/17/2006,
! ### file mas50v49jl02rl10f3.f, modified by JL:
!
!      - Modified char_bc_0 to solve a characteristic equation for
!        v_parallel (previously 1d momentum along B was solved).
!      - Changed defaults for predictor switches to be stable for
!        upwinding.
!
! ### Version 1.00_v49jl02rl10f4, 03/21/2006,
! ### file mas50v49jl02rl10f4.f, modified by ZM:
!
!      - Added the ability of setting a wall-clock time limit
!        for a run.  This ought to make running the code in
!        environments with hard time limits much easier.
!        This is a long-awaited feature.
!
! ### Version 1.00_v49jl02rl10f5, 04/17/2006,
! ### file mas50v49jl02rl10f5.f, modified by JL:
!
!      - Added the ability of adding a cell resistivity,
!        specified by DYNAMIC_ETA=.true. and RMCELL.
!
! ### Version 1.00_v49jl02rl10f6, 04/21/2006,
! ### file mas50v49jl02rl10f6.f, modified by ZM:
!
!      - Fixed the initialization of Alfven wave tests.  This
!        was broken during a previous code update.
!
! ### Version 1.00_v49jl02rl11f6, 05/17/2006,
! ### File mas50v49jl02rl11f6.f, modified by PR:
!
!       - Merged the two versions *rl11.f and *rl10f6.f to produce
!         a version that has all the latest fixes but also includes
!         Alfven wave pressure.
!
! ### Version 1.00_v49jl02rl12, 06/08/2006,
! ### File mas50v49jl02rl12.f, modified by RL:
!
!       - New semi-implicit operator
!
! ### Version 1.00_v49jl02rl13, 06/20/2006,
! ### File mas50v49jl02rl13.f, modified by RL:
!
!       - Ohmic heating is added when OHMIC_HEATING is .true.
!
! ### Version 1.00_v49jl02rl14, 07/18/2006,
! ### File mas50v49jl02rl14.f, modified by RL:
!
!       - Added capability to read flow profile from file
!         when FLOW is .true.
!       - Added Alfven wave pressure profile
!
! ### Version 1.00_v49jl02rl15, 07/26/2006,
! ### File mas50v49jl02rl15.f, modified by JL:
!
!       - Added capability to upwind A at the r0
!         boundary in the case of a flow profile.
!         Set UPWIND_A_R0=1.  Default is UPWIND_A_R0=0.
!
! ### Version 1.00_v49jl02rl16, 07/27/2006,
! ### File mas50v49jl02rl15.f, modified by JL:
!
!       - Added capability floor temperature switch
!         Set IFTFLOOR to true (default is false) and choose
!         a TFLOOR in K to make sure that T will never fall
!         below TFLOOR.
!
! ### Version 1.00_v49jl02rl16a, 10/02/2006,
! ### File mas50v49jl02rl16a.f, modified by JL:
!
!       - Added capability: use IFHEAT_MASK and HEAT_MASK_FILE
!         to specify a heat mask file
!       - IFHEAT=5 uses a heat flux (times an exponential) and
!         a background exponential heating
!
! ### Version 1.00_v49jl02rl16b, 10/09/2006,
! ### File mas50v49jl02rl16b.f, modified by JL:
!
!       - Added IFCHECK0TEMP (default true) and stop code if
!         temperature is negative. Don't stop if IFTFLOOR is true.
!
! ### Version 1.00_v49jl02rl16c, 10/11/2006,
! ### File mas50v49jl02rl16c.f, modified by JL:
!
!       - Added new heating according to Jon.
!
! ### Version 1.00_v49jl02rl16d, 11/17/2006,
! ### File mas50v49jl02rl16d.f, modified by JL:
!
!       - Fixed upwinding in A at the boundary when
!         a flow profile is specified such that flux
!         cancels at neutral lines.
!
! ### Version 1.00_v49jl02rl16e, 12/01/2006,
! ### File mas50v49jl02rl16e.f, modified by JL:
!
!       - Added capability to diffuse Br at the boundary
!         by adding a diffusive term to Atheta.  IFETA_PHOT=.true.
!         turns on this option.  ETA_PHOT_FILE specifies ETA_PHOT
!         on the mesh, and ETA_PHOT_FAC multiplies ETA_PHOT.
!
! ### Version 1.00_v49jl02rl16f, 12/04/2006,
! ### File mas50v49jl02rl16f.f, modified by JL and ZM:
!
!       - Generalized the photospheric diffusion of A tangential
!         to diffuse both components.
!       - Corrected a bug in the reading in of data files in
!         which a missing file would hang the code.
!
! ### Version 1.00_v49jl02rl16g, 12/05/2006,
! ### File mas50v49jl02rl16g.f, modified by ZM:
!
!       - Added the ability to apply shear and converging flow
!         simultaneously.  Note that the variables that control
!         shear and flow have been changed.  The input variables
!         are not compatible with previous use.
!
! ### Version 1.00_v49jl02rl16h, 12/06/2006,
! ### File mas50v49jl02rl16h.f, modified by ZM:
!
!       - Added the ability to read the flow at r=R0 from
!         input files.
!
! ### Version 1.00_v49jl02rl16i, 12/19/2006,
! ### File mas50v49jl02rl16i.f, modified by ZM:
!
!       - Added the ability to control the photospheric diffusion
!         coefficient via a time profile.
!         To control the photospheric diffusion, set
!
!           IFETA_PHOT=.true.
!           ETA_PHOT_FILE=<file name for diffusion profile>
!           ETA_PHOT=value of diffusion coefficient
!           TPROFILE(N)%T=<time values>
!           TPROFILE(N)%F=<profile values>
!           TPROFILE(N)%VARS='eta_photosphere'
!
! ### Version 1.00_v49jl02rl16j, 03/16/2007,
! ### File mas50v49jl02rl16j.f, modified by RL:
!
!       - Added the capability of reading a 3D hdf file to specify
!         the heating.
!       - Added another iftfloor check in advtc.
!
! ### Version 1.00_v49jl02rl16k, 03/19/2007,
! ### File mas50v49jl02rl16k.f, modified by RL:
!
!       - Added new heating type with Jon's heating only in the region
!         specified by HEAT_MASK.
!       - Modifications to vcrossb: now to calculate the
!         components at the r0 boundary we only use v_shear and/or
!         v_flow.
!
! ### Version 1.00_v49jl02rl16l, 04/03/2007,
! ### File mas50v49jl02rl16l.f, modified by RL:
!
!       - Added new flux emergence algorithm that accounts
!         also for the rotational contribution. Set
!         EMERGING_FLUX2 to true and also ROTATION_FLUX, if needed.
!       - Modified advance_a_b so that at the lower boundary it
!         either uses the electric field from emerging flux or
!         the vxb contribution.
!
! ### Version 1.00_v49jl02rl16m, 04/11/2007,
! ### File mas50v49jl02rl16m.f, modified by RL:
!
!       - Fixed bug in load_heat_mask. Now HEAT_MASK is known to all
!         processors and not only to those at r=r0.
!
! ### Version 1.00_v49jl02rl16n, 04/20/2007,
! ### file mas50v49jl02rl16n.f, modified by ZM:
!
!       - Added the ability to specify normal flows at the
!         r=R0 boundary.  These flows advect transverse magnetic
!         fields into the corona from the photosphere with
!         magnitude BT_PHOTO_IN and BP_PHOTO_IN (in code units).
!
! ### Version 1.00_v49jl02rl16o, 04/20/2007,
! ### file mas50v49jl02rl16o.f, modified by ZM:
!
!       - Re-wrote the computation of the normal component of
!         v x B at r=R0.  This version is the same as the previous
!         version.
!
! ### Version 1.00_v49jl02rl16p, 05/25/2007,
! ### file mas50v49jl02rl16p.f, modified by RL:
!
!       - Added new emerging flux potential routine:
!         initialize_phi_potential. It adds a potential
!         that does not change Br at R=1.
!
! ### Version 1.00_v49jl02rl16q, 07/03/2007,
! ### file mas50v49jl02rl16q.f, modified by RL:
!
!       - Calculate the radial velocity associated with emerging flux
!         and add it to the boundary.
!       - Variable density and pressure at the boundary is broken
!
! ### Version 1.00_v49jl02rl16r, 07/06/2007,
! ### file mas50v49jl02rl16r.f, modified by RL:
!
!       - Add a new option to calculate  the radial velocity
!         associated with emerging flux: use the Gaussian
!         specified for the electric potential.
!       - The characteristic velocity is set to zero if
!         the calculated radial velocity exceeds a threshold.
!
! ### Version 1.00_v49jl02rl16s, 08/27/2007,
! ### file mas50v49jl02rl16s.f, modified by ZM and RL:
!
!       - Fixed an interpolation error in LOAD_HEAT_MASK and
!         simplified the logic in routines LOAD_ETA_PHOT
!         and LOAD_HEAT_AUX.
!       - Fixed the output of the HEAT array in routine
!         ADVT so that the actual heating is now dumped out
!         in the HDF file.
!
! ### Version 1.00_v49jl02rl16t, 08/30/2007,
! ### file mas50v49jl02rl16t.f, modified by RL:
!
!       - Fixed a couple of bugs in NEWFLUX
!       - Added a new option for the resistivity profile:
!         set it to HIGH_SLUND_REGION and specify where the
!         Lundquist number should be higher with
!         PHI_0, PHI_1, THETA_0, and THETA_1.
!       - Added a new option for the viscosity profile:
!         set it to LOW_VISC_REGION and specify where the
!         viscosity should be higher with
!         PHI_0, PHI_1, THETA_0, and THETA_1.
!
!
! ### Version 1.00_v49jl02rl16u, 02/09/2008,
! ### file mas50v49jl02rl16u.f, modified by ZM:
!
!       - Rewrote the heating specification to simplify the
!         parameterization.  This makes this version of the
!         code incompatible with previous input files.  It is
!         still possible to run previous cases, but this requires
!         changes to the input file.
!       - Removed the "heat boxes", a complication that is best
!         done outside the code.
!       - Removed the 2D heat mask array.  To put it back, see
!         version "mas50v49jl02rl16t.f".
!       - Changed the name of the variable that adds Ohmic
!         heating from OHMIC_HEATING to ADD_OHMIC_HEATING.
!       - Fixed the code to compute the initial heat flux so
!         that it works on multiple processors.
!       - Removed the time profile variables that controlled the
!         heating parameters, since the heating specification has
!         now been streamlined.  These can be put back once we figure
!         out how we intend to use them, if at all.
!       - Added a timer for the Alfven wave advance.
!       - Cleaned up some code in the Alfven wave advance.
!       - Corrected a bug in the Alfven wave advance in which the
!         wave energy density boundary arrays were not
!         dimensioned properly.
!       - Corrected an improper starting index for the phi
!         dimension in the North and South pole evaluation
!         in routine DIV_GRAD_V.
!
! ### Version 1.00_zoran, 04/15/2008,
! ### file mas50_zoran01.f, modified by RL:
!
!       - Added RADIALLY_DEPENDENT viscosity profile
!       - Added more general capability to write 2D files.
!       - Write files in NEWFLUX. Dimensions of eflux arrays
!         changed from nxm1 to nxm.
!
! ### Version 2.00_zoran, 04/21/2008,
! ### file mas50_zoran02.f, modified by RL:
!
!       - Added capability to read files with tangential magnetic
!         field emerging at the lower boundary through routine
!         BTBPFLUX.
!       - The contribution of Bt and Bp emerging at the lower
!         boundaries with a flow specified in v_flow_r is
!         added to the source term to calculate the Phi potential
!         in routine NEWFLUX.
!
! ### Version 3.00_zoran, 05/07/2008,
! ### file mas50_zoran03.f, modified by RL:
!
!       - In routine NEWFLUX we know broadcast the right hand
!         side in the emerging flux solve to all processors,
!         calculate its norm, and, if it is tiny, consider it
!         noise and set it to zero. Otherwise the solve would be very
!         difficult for noise.
!
! ### Version 0.2.0.3, 05/23/2008, file mas_0.2.0.3.f,
! ### modified by ZM:
!
!       - Changed the centering of (v x B).
!         We now center (v x B) and calculate the upwind resistivity
!         at the new time level (i.e., implicit).
!
! ### Version 0.2.0.4, 06/03/2008, file mas_0.2.0.4.f,
! ### modified by ZM:
!
!       - Version with isotropic implicit upwind resistivity.
!
! ### Version 0.2.0.5, 06/04/2008, file mas_0.2.0.5.f,
! ### modified by ZM:
!
!       - Fixed the seaming of the implicit upwind resistivity.
!       - Added the ability to dump out the upwind resistivity.
!
! ### Version 0.2.0.6, 06/04/2008, file mas_0.2.0.6.f,
! ### modified by ZM:
!
!       - Made the implicit upwind resistivity proportional
!         to v_perp.
!
! ### Version 0.2.0.7, 06/07/2008, file mas_0.2.0.7.f,
! ### modified by ZM:
!
!       - Made the implicit upwind resistivity proportional
!         to v_perp.  This uses interpolated upwind resistivity
!         rather than maxima over neighboring cells.
!
! ### Version 0.2.0.8, 06/12/2008, file mas_0.2.0.8.f,
! ### modified by ZM:
!
!       - Corrected an indexing bug in the new (J x B) routine.
!         This was found by Jon Linker.  He gets free beer
!         during the whole week of the SHINE conference if this
!         cures our averaging problems.
!
! ### Version 0.2.0.9, 06/22/2008, file mas_0.2.0.9.f,
! ### modified by ZM:
!
!       - Added the ability to flat-top the heating to a maximum
!         value.  To use this option, set HEATING_FLAT_TOPPED=.true.
!         and set the variable HEAT_MAX to the maximum allowed value
!         (in normalized MAS units).  This option is off by default.
!       - Added a missing error check in routine READ_BR0.
!
! ### Version 0.2.0.10, 04/13/2009, file mas_0.2.0.10.f,
! ### modified by ZM:
!
!       - Corrected a bug in routine CELLETA in which array ETACEL
!         was not being seamed.  Thanks to RL for finding this!
!
! ### Version 0.2.0.11, 06/04/2009, file mas_0.2.0.11.f,
! ### modified by ZM:
!
!       - Corrected a bug in the heating routine discovered by
!         Roberto that used R(I) and T(J) instead of RH(I)
!         and TH(J).
!       - Added a routine to write 2D (t,p) HDF files when running
!         on multiple processors.  The routine WRITE_FIELD_TP
!         can now be used to write 2D HDF files of fields in the
!         (t,p) plane.
!       - Cleaned up the emerging flux specification.  The main
!         way to emerge flux now is via the PHI and PSI potentials.
!       - Cleaned up the code to streamline reading and interpolation
!         of 2D files for fields in the (t,p) plane, such as various
!         BC arrays at r=R0.
!       - Cleaned up the operation of BC routines at the poles
!         to minimize the number of routines used.
!
! ### Version 0.2.0.12, 06/06/2009, file mas_0.2.0.12.f,
! ### modified by ZM:
!
!       - Further improvements to emerging flux specification.
!
! ### Version 0.2.0.13, 06/10/2009, file mas_0.2.0.13.f,
! ### modified by ZM:
!
!       - Put the standard algorithm for advancing A back in.
!         The previous version had the experimental algorithm
!         based on centered (v x B) and implicit upwind
!         diffusion in the A equation.  This is still experimental,
!         and is now an option, which can be requested by setting
!         the option EXPERIMENTAL_A_ADVANCE=.TRUE..
!         The default is EXPERIMENTAL_A_ADVANCE=.FALSE., which
!         gives the standard method for advancing A.
!         It is presently NOT RECOMMENDED to use this experimental
!         advance of A.
!
! ### Version 0.2.0.14, 06/11/2009, file mas_0.2.0.14.f,
! ### modified by ZM:
!
!       - Corrected a bug in ADVA that was introduced in the
!         previous version.  The switch to call the appropriate
!         version of VCROSSB was not implemented properly.
!       - Added the ability to zero out the parallel part of the
!         velocity.  Set flag ZERO_V_PARALLEL=.TRUE. to select
!         this.  This may be useful in zero-beta runs to eliminate
!         artificial behavior related to parallel flows.
!       - Made some small optimization improvements for the implicit
!         resistivity solve in which the resistivity arrays are
!         pre-calculated to increase efficiency.
!
! ### Version 0.2.0.15, 06/12/2009, file mas_0.2.0.15.f,
! ### modified by ZM:
!
!       - Fixed the code to allow emerging flux and converging flow
!         to be activated at the same time.  The previous version
!         had short-circuited the setting of the BCs on A transverse.
!
! ### Version 0.2.0.16, 07/11/2009, file mas_0.2.0.16.f,
! ### modified by ZM:
!
!       - Added a two-exponential heating.  This is an attempt to
!         simplify the quiet-sun heating.  We'll see!
!
! ### Version 0.2.0.17, 07/16/2009, file mas_0.2.0.17.f,
! ### modified by ZM:
!
!       - Added the ability to use multi-part restart files.  This is
!         required when running large cases due to the 2Gbyte file
!         size limit in HDF4.  To output a multi-part restart file,
!         set the flag SPLIT_OUTPUT_RESTART_FILE=.true..  The
!         default is to use a single output restart file,
!         SPLIT_OUTPUT_RESTART_FILE=.false..
!         To read a multi-part restart file, set RSIFILE=' '
!         and specify the three parts using the variables
!         RSIFILE_PART1, RSIFILE_PART2, and RSIFILE_PART3.
!       - Fixed a possible bug in the reading of Alfven wave
!         pressure from restart files.  A seaming operation may
!         have been omitted in previous versions.
!
! ### Version 0.2.0.18, 12/08/2009, file mas_0.2.0.18.f,
! ### modified by ZM:
!
!       - Added a "safety factor" when computing the time step limit
!         for the advance of Alfven wave pressure.  Experience has
!         shown that the time step limit for the Alfven wave
!         pressure advance is half of what we expect from a
!         stability analysis.  So I put in the factor of .5
!         in the computation of the time step.  This may allow us
!         to use CFL closer to 1 for the whole computation.
!         (Previously, setting CFL greater than .5 made the Alfven
!         waves unstable.)
!
! ### Version 0.2.0.19, 04/16/2010, file mas_0.2.0.19.f,
! ### modified by ZM:
!
!       - Fixed bugs in the routines that extracted local arrays from
!         global arrays.  There was an error in how the last point in
!         the phi dimension was treated for arrays that are defined
!         on the main phi mesh, in the case of a periodic phi
!         dimension (which is the only case possible at present).
!       - Fixed routine WRRS_C so that if the user attempts to
!         write an empty string, the routine actually writes a
!         string with a single space instead.  Apparently this was
!         preventing the HDF library from properly closing the
!         restart file in such a situation!
!
! ### Version 0.2.0.20, 04/26/2010, file mas_0.2.0.20.f,
! ### modified by ZM:
!
!       - Added the ability to specify a heat mask for the coronal
!         heating source.  The heat mask is read from the file in
!         variable HEAT_MASK_FILE, and its dimensions must match
!         those of the run.  Each heat source can be multiplied
!         by the heat mask by setting HEATSOURCE(N)%USE_MASK=.true.
!         which is by default off.
!
! ### Version 0.2.0.21, 06/18/2010, file mas_0.2.0.21.f,
! ### modified by ZM:
!
!       - Added a new heating type in which the strength is
!         dependent on a power of the photospheric magnetic
!         field strength, with an optional neutral line mask.
!         This can be used to generalize the two-exponential
!         heating to make the heat flux depend on B-photo.
!       - Added a name field in the heat source definition.
!         This is strictly for purposes of labelling.
!
! ### Version 0.2.0.22, 04/22/2011, file mas_0.2.0.22.f,
! ### modified by ZM:
!
!       - Added the option of reading in a density profile
!         from a file for a zero-beta run.  Set
!         ZB_RHO_PROFILE='READ_FROM_FILE' to select this, and
!         set ZB_RHO_FILE to the HDF file containing the density.
!
! ### Version 0.2.0.23, 04/29/2011, file mas_0.2.0.23.f,
! ### modified by ZM:
!
!       - Fixed a bug in the way the zero-beta density profile
!         is loaded.  The previous version used more memory than
!         was necessary.
!       - Changed the way the density profile is loaded for
!         zero beta runs.  When the user requests the density
!         to be loaded from a file (by selecting the option
!         ZB_RHO_PROFILE='READ_FROM_FILE'), the density is
!         loaded even for restart cases.  This allows the ability
!         to change the density profile at restarts.
!         Previously this was not the case.
!
! ### Version 0.2.0.24, 05/21/2011, file mas_0.2.0.24.f,
! ### modified by ZM:
!
!       - Added custom resitivity and viscosity profiles.
!         The resistivity is specified by setting:
!
!           ETA_PROFILE='CUSTOM_TP+R_PROFILE'
!
!         and setting the values of the radial profile in
!         ETA_PROFILE_R and an HDF file for the (t,p) profile in
!         variable ETA_PROFILE_TP_FILE.
!         The viscosity is specified by setting:
!
!           VISC_PROFILE='CUSTOM_TP+R_PROFILE'
!
!         and setting the values of the radial profile in
!         VISC_PROFILE_R and an HDF file for the (t,p) profile in
!         variable VISC_PROFILE_TP_FILE.
!
! ### Version 0.2.0.25, 05/25/2011, file mas_0.2.0.25.f,
! ### modified by ZM:
!
!       - Added the option to evolve the flux according to values
!         defined by input files.  Set EVOLVE_FLUX=.TRUE. to
!         activate this option.  Set the option ROTATE_FLUX=.true.
!         to activate the evolution due to differential rotation.
!         The default is ROTATE_FLUX=.false., which ignores the
!         evolution due to differetial rotation.
!         To specify the flux, set
!
!           EVOLVE_FLUX=.true.
!           TPROFILE(N)%T=<time values>
!           TPROFILE(N)%VARS='eflux_br'
!           TPROFILE(N)%FILENAME=<br files>
!
! ### Version 0.2.0.26, 11/15/2011, file mas_0.2.0.26.f,
! ### modified by ZM:
!
!       - Initialized some new file names to default values
!         to prevent nulls from appearing in the output file.
!         This is a minor update.  This version is essentially
!         the same as version 0.2.0.25.
!
! ### Version 0.2.0.27, 11/29/2011, file mas_0.2.0.27.f,
! ### modified by ZM:
!
!       - Added the ability to turn the evolving flux algorithm
!         on and off during a run.  Previously, evolving flux
!         was either always on during a run or always off.
!         Now, it can be turned on only during a part of the run.
!         For example, suppose you want to use the evolving flux
!         scheme to change Br from the distribution specified by
!         file "br0.h5" at t=10 to that specified by file
!         "br1.h5" at t=20, and then you want to cancel flux
!         later from t=50 to t=70 (i.e., turn the evolving flux
!         scheme off after t=20).  You would set:
!
!           EVOLVE_FLUX=.true.
!           TPROFILE(N)%T=0.,10.,20.
!           TPROFILE(N)%VARS='eflux_br'
!           TPROFILE(N)%FILENAME='br0.h5','br0.h5','br1.h5'
!           TPROFILE(N)%ON=.false.,.true.,.false.
!
!         The default is to have the evolving flux algorithm on
!         all the time when EVOLVE_FLUX=.true..
!
! ### Version 0.2.0.28, 12/02/2011, file mas_0.2.0.28.f,
! ### modified by ZM:
!
!       - Special version with the ability to specify the error
!         criterion for the 2D CG solve for the elliptic solve
!         in routine NEWFLUX.  This was misbehaving when the
!         change in Br was very small, since it was trying to
!         achieve an unreasonably small error.  This needs to be
!         fixed properly.  For now, set EPSCG_NEWFLUX to a
!         higher value (e.g., 1.e-8) when it fails to converge.
!         The default is the previous value, 1e-9.
!
! ### Version 0.2.0.29, 12/03/2011, file mas_0.2.0.29.f,
! ### modified by ZM:
!
!       - Added the ablity to specify whether the converging
!         flow arrays are normalized to unit magnitude after
!         being read in.  Previously, they were always
!         normalized to unit magnitude.  Now, that is an
!         option.  Note that the normal flow and transverse flow
!         are normalized separately.  To normalize the flows,
!         set the flags:
!
!           FLOW%NORMALIZE_VNORM=.true.
!           FLOW%NORMALIZE_VTRANS=.true.
!
!         To leave the flows the way they are read in, set:
!
!           FLOW%NORMALIZE_VNORM=.false.
!           FLOW%NORMALIZE_VTRANS=.false.
!
!         This can also be used for the shear flows, using
!         the flags SHEAR%NORMALIZE_VNORM and
!         SHEAR%NORMALIZE_VTRANS.  The default is to normalize
!         the flows, as before.
!
! ### Version 0.2.0.30, 02/19/2012, file mas_0.2.0.30.f,
! ### modified by ZM, TT, and CD:
!
!       - Implemented the ability to add a modified Titov-Demoulin
!         flux rope.  The parameters are specified via the
!         structure TDM_FLUXROPE.
!
! ### Version 0.2.0.31, 02/29/2012, file mas_0.2.0.31.f,
! ### modified by ZM and TT:
!
!       - Added the option to preserve Br at r=R0 when adding a TDM
!         flux rope.  Set TDM_FLUXROPE%PRESERVE_BR0=.TRUE. to
!         request this.
!       - Removed the discontinuity in the poloidal component of
!         the vector potential at the flux rope boundary for the
!         TDM model.  This now varies smoothly in a narrow layer
!         in a manner that is similar to that used for the toroidal
!         component.  The width of this layer is set by
!         TDM_FLUXROPE%DELTA.
!       - Changed the name of routine INITIALIZE_MAGNETIC_FIELD to
!         INITIALIZE_MAGNETIC_FIELD_FROM_DIPOLES, since that is
!         more appropriate.
!
! ### Version 0.2.0.32, 03/29/2012, file mas_0.2.0.32.f,
! ### modified by ZM:
!
!       - Added the ability to read and write 15-part restart files.
!         This is required to run very large cases due to the
!         2 GByte/file size limit of HDF4.  Restart files can
!         now be single-part, three-part, or fifteen-part.
!         This required a complete rewrite of the restart file
!         reading and writing code to streamline its operation.
!
!       - The way restarts now work is as follows.
!         For example, to read a single-part restart file, set:
!
!           RSIFILE='rsrun01.h5'
!
!         To read a three-part restart file, set:
!
!           N_RS_INPUT_FILE_PARTS=3
!           RSIFILE_PREFIX='../run01/'
!           RSIFILE_ROOT='run01'
!
!         or specify the names explicitly:
!
!           N_RS_INPUT_FILE_PARTS=3
!           RSIFILE_PARTS(1)='../run01/rs_p1_run01.h5'
!           RSIFILE_PARTS(2)='../run01/rs_p2_run01.h5'
!           RSIFILE_PARTS(3)='../run01/rs_p3_run01.h5'
!
!         To read a fifteen-part restart file, set:
!
!           N_RS_INPUT_FILE_PARTS=15
!           RSIFILE_PREFIX='../run01/'
!           RSIFILE_ROOT='run01'
!
!         or specify the names explicitly:
!
!           N_RS_INPUT_FILE_PARTS=15
!           RSIFILE_PARTS( 1)='../run01/rs_p01_run01.h5'
!           RSIFILE_PARTS( 2)='../run01/rs_p02_run01.h5'
!           ...
!           RSIFILE_PARTS(15)='../run01/rs_p15_run01.h5'
!
!       - The variable N_RS_OUTPUT_FILE_PARTS controls the
!         number of parts in the output restart file (default=1).
!
! ### Version 0.2.0.33, 04/20/2012, file mas_0.2.0.33.f,
! ### modified by ZM:
!
!       - Corrected boundary conditions on the flow velocity in
!         routine INITIALIZE_FLOW.  These were not being set
!         properly.
!
! ### Version 0.2.0.34, 04/21/2012, file mas_0.2.0.34.f,
! ### modified by ZM:
!
!       - Corrected a bug in routine PACK_1D_ADD, in which the
!         buffer was not being expanded properly.  This routine
!         is used in setting boundary conditions at the poles.
!         The problem did not show up in the code as written, but
!         had the potential to cause an error if this routine were
!         to be used for other purposes in the future.
!
! ### Version 0.2.0.35, 05/02/2012, file mas_0.2.0.35.f,
! ### modified by ZM:
!
!       - This version has the capability to produce results with
!         a precision that is independent of the variation in
!         round-off between MPI runs.  To use this capability,
!         set the extended precision kind R_TYP_EP in module
!         NUMBER_TYPES to R16.  This has a significant performance
!         impact.  It is only intended for debugging purposes.
!         When using this capability, it is also necessary to use
!         a compiler option to preserve the accuracy of floating
!         point operations.  For the Intel IFORT compiler, this
!         can be achieved by using option "-fp-model precise".
!
! ### Version 0.2.0.36, 05/09/2012, file mas_0.2.0.36.f,
! ### modified by ZM:
!
!       - Added the ability to interpolate the heat mask and the
!         heat array to the run mesh.  Previously, the heat mask
!         and heat array dimensions needed to match those of the
!         run.
!       - Streamlined the routine LOAD_RHO_FROM_FILE (which was
!         previously named LOAD_ZB_EQUIL_RHO_FROM_FILE) so that
!         it uses code that is similar to the routines that read
!         the heat and heat mask from a file.
!       - Fixed the routines READ_TP_INTERP_XX so that the BCs
!         at the poles are applied properly.  The interpolation
!         was also made more robust by allowing for round-off
!         error in the scales of input files.
!       - Corrected a bug in routine ZERO_PARALLEL_FLOW.  The
!         computation of the parallel flow was flawed.  Perhaps
!         this will give smoother time histories now when this
!         option is being used.
!
! ### Version 0.2.0.37, 05/10/2012, file mas_0.2.0.37.f,
! ### modified by ZM:
!
!       - Added the ability to dump the electric field to HDF
!         files.
!
! ### Version 0.2.0.38, 05/18/2012, file mas_0.2.0.38.f,
! ### modified by ZM:
!
!       - Corrected a bug in the output restart file code that
!         resulted in a core dump if an error occurred during
!         the run setup process.
!       - Put the coefficients of the matrix that is inverted in
!         the v solve into explicit arrays in an attempt to
!         improve the efficiency of the code.  This is also a
!         first step to implementing a better preconditioning
!         for the v solve.
!
! ### Version 1.0 REV 1, 07/24/2013, file mas.f
! ### mas version 0.2.0.38 added to SVN repository by JW:
!       - All future filenames are mas.f, use SVN -r to obtain whatever
!         revision number desired.
!       - REV number is that of the full repository,
!         so gaps in the number in this changelog do not represent
!         missing changelog updates, rather non-code
!         updates were done in those revisions.
!       - REV numbers do not reset when new version number is made.
!       - This changelog will only be very quick summaries
!         of updates, except for new feature instructions
!         and compatibility updates.  For detailed changelog
!         of all updates, see the SVN repository log.
!
! ### Version 1.0 REV 2, 07/26/2013
! ### modified by RC:
!
!       - BUG FIX: tr0v could be accessed without allocation - fixed.
!       - Small updates to allow mas to be compatible with gfortran.
!       - Small update to advt to avoid reallocation of arrays.
!
! ### Version 1.0 REV 5, 07/29/2013
! ### modified by RC:
!
!       - Updated cgdot routines to be optimized, including MPI.
!       - Modified storage array structure for v and t solve matrices,
!         as well as added inverse-diagonal preconditioner arrays.
!       - Updated timers so cgdot and global_sum not reporting the same
!         information.  Reordered timer list and renamed "thermal cond"
!         to "advtc".  Added more time metrics to t-file.
!
! ### Version 1.0 REV 8, 08/07/2013
! ### modified by RC:
!
!       - BUG FIX: Changed global_max_v to global_min_v in setdt()
!         at implicit radiation loss section.  Time step was not (ever)
!         being set by this criteria!
!       - Updated MPI in seam calls and changed location of timers
!         to include buffer load/write in seam time.
!       - Added a dt set reason text to end of time-step output line.
!
! ### Version 1.0 REV 9, 08/22/2013
! ### modified by RC:
!
!       - Added MAS logo to code output.
!
! ### Version 1.0 REV 10, 09/01/2013
! ### modified by RC:
!
!       - Changed solver matrix alloc size to allow stride-1 mem access.
!
! ### Version 1.0 REV 11, 09/12/2013
! ### modified by RC:
!
!       - Small MPI update to global_sum_eq.
!       - Put thermal conduction solve into matrix coefficients.
!       - Re-ordered advv solve matrix coefficients to be in row-order.
!         This caused extra noise in axisymmetric runs in "0" components
!         which was later solved in REV 25.
!       - Eliminated string comparisons in heating()
!       - Cleaned up advt a bit.
!
! ### Version 1.0 REV 14, 11/25/2013
! ### modified by RC:
!
!       - Added SGS and IBLU0 preconditioning to v and t solvers.
!         To use the preconditioners, set
!         if_prec=2 (SGS) or if_prec=3 (IBLU0), default is now set to 3.
!       - Updated MPI in allreduce calls to use MPI_IN_PLACE.
!       - Updated timer in sum_over_phi_ep to include buffering.
!       - Cleaned up v-solver matrix coefficient code.
!
! ### Version 1.0 REV 15, 12/06/2013
! ### modified by RC:
!
!       - Rewrote advt to be more readable.
!       - Replaced check_negative_temperature() with more general
!         check_negative_field().
!       - Added routine floor_field() to replace in-line flooring
!         code in advt.
!       - Minor touch-ups and fixed small bug in new timer outputs.
!
! ### Version 1.0 REV 16, 12/17/2013
! ### modified by RC:
!
!       - More cleanup of advt.
!       - Modified IO timer to include all hdf reads and writes.
!       - Modified floor_field() to output some diagnostic information.
!
! ### Version 1.0 REV 17, 12/29/2013
! ### modified by RC:
!
!       - Small cosmetic and compile-warning avoidance modifications.
!       - Added RIBLU0(w) and MBILU0 preconditioners.  To use them,
!         set if_prec=3 and w_tc and w_v to a value between 0 and 1.
!         1:MIBLU, (0,1):RIBLU0, 0:IBLU0
!
! ### Version 0.3.0.1 REV 18, 01/10/2014
! ### modified by RC and ZM:
! ### This update is a merge of REV 17 and mas 0.2.0.43 plus extra.
!
!       - COMPATIBILITY CHANGE:  Added ability to select cg tolerance
!         per solver.  The new input variables are
!         EPSCG_A, EPSCG_V, EPSCG_T, EPSCG_POTFLD, and EPSCG_NEWFLUX.
!         The following is a conversion table to set the new values
!         according to the old values in an input file:
!           epscg_v <== epscg
!           epscg_a <== epscga
!           epscg_t <== epscg
!           epscg_potfld <== epscga
!           (epscg_newflux is the same)
!       - Added the ability to apply an evolving electric field and
!         apply the components of the velocity at the r=R0 boundary to
!         drive the evolution.
!         This could be used to emerge flux, to emerge transverse
!         magnetic field, to cancel flux, or to apply shear.
!         The new electric field drive can be specified in the
!         input file as follows:
!
!           EMERGING_FLUX=.TRUE.
!           EFLUX%E_DRIVEN=.TRUE.
!           TPROFILE(1)%VARS='edrive_er'
!           TPROFILE(1)%T=0.,5.,10.
!           TPROFILE(1)%FILENAME='er0_001.h5','er0_002.h5',
!                                'er0_003.h5'
!           TPROFILE(2)%VARS='edrive_et'
!           TPROFILE(2)%T=0.,5.,10.
!           TPROFILE(2)%FILENAME='et0_001.h5','et0_002.h5',
!                                'et0_003.h5'
!           TPROFILE(3)%VARS='edrive_ep'
!           TPROFILE(3)%T=0.,5.,10.
!           TPROFILE(3)%FILENAME='ep0_001.h5','ep0_002.h5',
!                                'ep0_003.h5'
!           TPROFILE(4)%VARS='edrive_e0'
!           TPROFILE(4)%T=0.,5.,10.
!           TPROFILE(4)%F=1.,1.,1.
!
!           TPROFILE(5)%VARS='edrive_vr'
!           TPROFILE(5)%T=0.,5.,10.
!           TPROFILE(5)%FILENAME='vr0_001.h5','vr0_002.h5',
!                                'vr0_003.h5'
!           TPROFILE(6)%VARS='edrive_vt'
!           TPROFILE(6)%T=0.,5.,10.
!           TPROFILE(6)%FILENAME='vt0_001.h5','vt0_002.h5',
!                                'vt0_003.h5'
!           TPROFILE(7)%VARS='edrive_vp'
!           TPROFILE(7)%T=0.,5.,10.
!           TPROFILE(7)%FILENAME='vp0_001.h5','vp0_002.h5',
!                                'vp0_003.h5'
!
!         The variable 'edrive_e0' specifies the overall multiplier for
!         the electric field and velocities.
!         The fields read in from the files are multiplied by the
!         profile specified by 'edrive_e0'.
!         Quantities that are not specified are assumed to be zero.
!         For example, to omit the specification of Er, do not
!         specify the profile for 'edrive_er'.
!       - Updated routines GLOBAL_TO_LOCAL and GLOBAL_TO_LOCAL_TP to be
!         more robust. The functionality remains the same, though they
!         are now less prone to misuse.
!       - Added the ability to use 6-digit sequence numbers in the
!         output HDF file names.  To request this, set the variable
!         LONG_SEQUENCE_NUMBERS=.true.. By default, this is off
!         (i.e., 3-digit sequence numbers are used).
!       - Removes MIBLU0/RIBLU0 preconditioners since their advantages
!         did not outweigh their possible misuse.
!       - A bunch of comment deletions, etc.
!       - Updated MAS version number from 1.0 to 0.3.0.1 (no tag issued)
!       - Moved advtc inside of advt and eliminated flooring in advtc.
!       - Revised global_min and global_max
!       - Makefile/sed replacements updated to show SVN revision #.
!
! ### Version 0.3.0.1 REV 19, 01/14/2014
! ### modified by RC and ZM:
!
!       - COMPATIBILITY CHANGE: Removed if_prec input parameter and
!         replaced it with individual parameters per solve.
!         The new parameters are IFPREC_T,IFPREC_V,IFPREC_POT2D,
!         IFPREC_POT3D. The default values are all 1 except for
!         t and v which are set to 3.
!       - BUG FIX:  Minor input file checking issue was calling
!         MPI_Allgather on comm_all before it was initialized.  Fixed
!         by using MPI_COMM_WORLD in write_timing(), which may
!         make individual processor timings be associated with
!         the wrong MPI rank number.
!       - Removed linv() and uinv() and replaced them with Minv().
!       - Moved preconditioner loading into new routines
!         load_preconditioner_*_solve().
!       - Set up code to use MPI timer by default.
!
! ### Version 0.3.0.1 REV 20, 01/14/2014
! ### modified by RC:
!
!       - Added new timing output
!         "micro-sec/mesh-point/weighted-cg-iters" for use with
!         comparisons to Zoran's large mas timings list.
!       - Fixed write_timing() to output proper
!         micro-sec/mesh-point/normalized-time when using a restart run.
!
! ### Version 0.3.0.1 REV 21, 01/22/2014
! ### modified by RC and CD:
! ### This update is a partial merge of REV 20 and
!     Tibor's mas_0.2.0.38_RL_ZM plus more.
!       - COMPATIBILITY CHANGE:  Old form of specifying a TDM fluxrope
!         in input file is no longer valid.
!         "tdm_fluxrope%preserve_br0" logical parameter is now a global
!         parameter (not part of tdm_fluxrope structure) and is called
!         "tdm_preserve_br0".
!         All of the fields of the tdm_fluxrope input structure are the
!         same, but you now must specify the index of the fluxrope.
!         For example, instead of "tdm_fluxrope%add=.true.", you would
!         put "tdm_fluxrope(1)%add=.true.", etc for all parameters.
!         To add more tdm fluxropes, use the next index (i.e.
!         "tdm_fluxrope(2)%add=.true.") etc.
!       - Added code to read in the vector potential
!         from a file and add it to the existing vector potential.
!       - Renamed all Minv*() routines to prec_inv*()
!       - Eliminated omega1 and omega2 as these inputs were never used.
!
! ### Version 0.3.0.1 REV 22, 01/30/2014
! ### modified by RC:
!
!       - BUG FIX: Fixed issue with IBLU0 preconditioner for
!         the thermal conduction solve which would make it not work
!         in axisymmetric mode (np=3).
!       - Updated much of new code to conform to MAS style guide.
!       - Added ability to place TDm fluxrope at arbitrary r0.
!         To use, simple set %origin_r in the tdm_fluxrope input.
!         (default is 1).
!
! ### Version 0.3.0.1 REV 23-25, 02/11/2014->03/19/2014
! ### modified by RC:
!
!       - BUG FIX: Moved initialize_heating() call in start() back down
!         to where it was originally (right before call to diag()).
!         Having it called earlier caused a problem when running
!         restart runs with B-dependent heating models (heatflux.h5
!         would be 0-valued).  Hat tip to Zoran for catching this.
!       - Added sign checker in convergence err_norm() to avoid
!         false convergence indications if residual flips sign.
!       - Fixed axisymmetric tc fix in getM_nnz_tc().
!       - Fixed floor_field() output problem.
!
! ### Version 0.3.0.1 REV 26, 05/15/2014
! ### modified by RC:
!
!       - Added dp_mult multipliers to phi-derivatives in the solvers of
!         MAS in order for axisymmetric mode to not rely on floating-
!         point subtraction for the 0-derivatives.  This also
!         eliminates noise in 0-valued components caused by the
!         previous (REV 11) re-ordering of the v-solver matrix multiply.
!
! ### Version 0.3.0.1 REV 29, 07/07/2014
! ### modified by RC:
!
!       - Added new output file w<RUN_ID>.  Currently this is only used
!         for floor_field() warnings.
!       - Output of histories in h<RUN_ID> and v<RUN_ID> changed to use
!         append mode so they are now written to a single file
!         eliminating the need to run "combine" after a run.
!         The buffer for the output has been lowered from 2001 to 101.
!       - The o<RUN_ID> file is now flushed each time-step to allow
!         inspection mid-simulation.
!
! ### Version 0.3.0.1 REV 30, 07/16/2014
! ### modified by ZM:
!
!       - Updated heat function selection to conform with 1D code and
!         other selection portions of MAS.
!
! ### Version 0.3.0.1 REV 31, 07/17/2014
! ### modified by CD, TT, and ST:
!
!       - Added new TDm flux rope models from Titov et al. Apj. (2014).
!         The "tdm_def" input structure now has a field
!         called "rope_type" which can be set to 'parabolic',
!         'hollow', or 'hollow_nonff' (the default is 'parabolic').
!         These correspond to a rope with a parabolic current profile,
!         a rope with a "hollow-core" current profile, and an
!         original TDm model which has a hollow-core current
!         distribution that is not quite force free respectively.
!       - COMPATIBILITY CHANGE:  The unit definition of
!         tdm_fluxrope%delta in now defined as the unit-less relative
!         ratio of the transition length divided by the minor radius,
!         instead of being in solar radii.  This new definition agrees
!         with Titov et al. (2014). The default value is set to 0.2.
!
! ### Version 0.3.0.1 REV 32, 07/21/2014
! ### modified by RC:
!
!       - Added the ability to use characteristic boundary
!         conditions (BCs) at the outer radial boundary (r1) without
!         using them at the lower radial boundary where static
!         boundary conditions are used instead.  This modification
!         is necessary to run the shear tests in the testsuite.
!       - To use the new feature, set char_bc=.true. and the new input
!         parameter no_special_char_bc0=.false. (default .true.).
!         Note that this update is temporary and this feature should
!         not generally be used.
!       - BUG FIX: The code seg-faults when attempting to run
!         a polytropic simulation with char_bc=.false.  Temporary
!         static boundary conditions have been added to allow the code
!         to function in this case, which should be revised at a later
!         date.
!
! ### Version 0.3.0.1 REV 33, 07/24/2014
! ### modified by RC:
!
!       - This update reworks how the radiative loss function is
!         selected internally, and cleans up the involved codes.
!         It eliminates string comparisons in the qrad() function and
!         moves near-zero smoothing to an external function called by
!         all loss functions. The new code is heavily based on those
!         from the 1D loop code mhd1_loop_RL.  This is a first step
!         to adding the new near-zero smoothing and additional rad loss
!         functions to MAS.
!       - Changed preconditioner matrix information output to go in
!         the output file instead of stdout and included a memory size
!         estimation.
!
! ### Version 0.3.0.1 REV 34, 07/25/2014
! ### modified by RC:
!
!       - BUG FIX (?):  The POT2D solver was leading to different
!         initial A-fields in axisymmetric mode based on the number of
!         processors.  Removing the dp_mults added in REV 26 seems to
!         fix this issue.  Therefore, all dp_mults in POT2D,POT2DH, and
!         POT3D have been taken out as a precaution.  Further analysis
!         shows that this may not be an issue with dp_mults, so this
!         change may be temporary.
!
! ### Version 0.3.1.0, 08/18/2014
! ### modified by RC:
!
!       - Restored this changelog, and continued it to current revision.
!       - Updated version number to 0.3.1.0 as part of new version
!         procedures for SVN updates.  From now on, we will use
!         version number updates for all code revisions except
!         for comment changes which may remain at the current version.
!         This way, this changelog will not have REV numbers, and it
!         will be easier to refer to different versions.  The file name
!         will remain mas.f, and detailed changelogs are still
!         required for SVN commits.
!
! ### Version 0.3.1.1, 12/25/2014
! ### modified by RC+CD+TT:
!
!      - Added a negative density checker to advrho.  To use, set:
!           ifcheck0rho=.true.
!      - Added TT+CD's density limiter.  To use, set:
!           ifrholimit=.true.
!           rho_limit_factor=# (default 0.001).
!           rho_limit_file='file_name' (default 'rho_limit.h5').
!           tprofile(1)%vars='rho_limit'
!      - Added TT's Alfven speed limiter (density modifier). To use,set:
!           max_alfven_speed_rho_mod=# (default 0 [no limiter]).
!      - All limiters and checks output warning into the wmas file.
!
! ### Version 0.3.1.2, 12/26/2014
! ### modified by RC+RL+TT+CD:
!       - Added custom profile for eta and visc read from files.
!         (visc_profile_file,eta_profile_file -
!         ETA_PROFILE=CUSTOM_PROFILE, VISC_PROFILE=CUSTOM_PROFILE)
!       - Introduced constant background resistivity eta_bg which allows
!         the use of a temporal profile for eta that affects only a
!         limited spatial region. eta_bg is zero per default and
!         should be set otherwise only if a custom profile for
!         eta is used. In that case, it should be set to 1/slund.
!       - Introduced constant background viscosity visc_bg. visc_bg is
!         zero by default and only be used with custom viscosity
!         profile.
!       - Added TDm rope ramping [in gfortran-bug-fix way (no tprofile
!         structures inside tdm struct, instead individual params used)]
!         The ramp options are independent for each rope.
!         This means you can have a mixture of ropes that are
!         inserted instantly or gradually and a different timescale
!         for each.
!         The time profiles for the ramping are similar to those used
!         in the other time profiles of MAS.
!         The new input parameters are:
!
!         tdm_fluxrope(i)%use_ramp    ![.true./.false.]
!         tdm_fluxrope(i)%tprofile_t  ![Note the underscore, not %]
!         tdm_fluxrope(i)%tprofile_f  ![Note the underscore, not %]
!
!         NOTE: tdm_fluxrope(i)%add and tdm_fluxrope(i)%use_ramp are
!         mutually exclusive settings. If you want to add the rope
!         immediately use %add=.true., if you want to ramp it
!         make %add=.false. and %use_ramp=.true.
!
! ### Version 0.3.1.3, 03/13/2015
! ### modified by RC
!
!      - Added expert_user_overide input structure.
!      - Added "expert_user_overide%limit_supersonic_inflow" logical,
!        when set to .true., if there is supersonic inflow, the
!        velocity at the point is set to the sound speed.
!      - Warning/error messages for supersonic inflow now written to
!        the w-file.
!
! ### Version 0.3.1.4, 03/23/2015
! ### modified by RC
!
!      - Added CHIANTI v71 radaitive loss functions.
!        to use, set rad_law in input file to "CHIANTI_v71_CORONA" or
!        "CHIANTI_v71_PHOTO".
!      - Added new near-zero smoothing to radiative loss.  To use the
!        old method, set legacy_q_chromo_reduction=.true.
!      - Added solver iteration count for pot2dh and added to output.
!
! ### Version 0.3.1.5, 03/30/2015
! ### modified by RC
!
!      - The pot2d and pot2dh solvers now have the SGS and IBLU0
!        preconditioners, are only solved on processors containing the
!        lower radial boundary, the pot2d solver sets one pole to 0 to
!        avoid the arbitrary constant, and for newflux, the solvers use
!        the previous timestep's psi and phi as initial guesses.
!      - A new heating model ('gaussian') has been added which allows
!        guassian heating at specified grid positions.
!      - A time profile has been added to the heating structure,
!        allowing multiple heating functions to be turned on and off
!        within a simulation.
!      - Added r0^2 to balance flux calculation.
!
! ### Version 0.3.2.0, 04/02/2015
! ### modified by RC
!
!      - Added ability to run simulation in the co-rotating frame.
!        Set "calculation_frame='COROTATING'" to use the co-rotating
!        frame, and set "omega_corotate" to the desired Omega value
!        (default is for the sun, i.e. omega_corotate=0.004144).
!      - Added proper v-omxr projected on b for collisionless
!        thermal conduction.  Added "use_radial_nocoll" logical
!        which can be set to .true. to use the original radial-only
!        version.
!      - Added ability to set initial field in axisymmetric cases
!        from a 2D (r-theta) A-file or a 2D J-file which is then
!        used to solve for A in a relaxation.
!        Set initial_filed='A-FILE' to use.
!      - Added ability to specify a 2D (theta-phi) vr, rho, and t
!        as an initial plasma condition with is polytropically
!        tailed off in r, or if "const_t_rho" is set, they are kept
!        constant for all r.
!        Set initial_plasma='2DFILE' to use.
!      - Added ability to dissipate and modulate the Alfven wave
!        pressure advance.
!        Set dissipate_aw and/or modulate_pw0 to .true. to use.
!        The parameters to tweak are dbob_aw, wdbob_aw, and tau_aw.
!      - Added a new shear type 'FLUX_TRANSPORT' which shears for
!        differential rotation and meridional flows.
!        Set v_north and v_south to set the northern and southern
!        hemisphere shear.
!      - Added new potential field boundary condition 'MHDSS' to set
!        the upper radial boundary to a source surface for A.
!        Set potential_field_bc.eq.'MHDSS' to use.
!
! ### Version 0.3.2.1, 11/06/2015
! ### modified by RC
!
!      - Updated check_negative_field() routine to only check internal
!        points.  This avoids false errors for averaged inner
!        boundary values.
!      - Updated text formatting in relaxa() to avoid compile warnings.
!
! ### Version 0.3.3.0, 05/19/2016
! ### modified by RC
!
!      - BUG FIX:  The solution to the velocity predictor (vp)
!        was not being used in the corrector step's getvdgv()
!        (i.e. no predictor was being done).  This has now been fixed.
!
! ### Version 0.3.4.0, 06/01/2016
! ### modified by RC
!
!      - Added new time step parameters and features as follows:
!        - dt_init: Set this to desired inital time step.  It will be
!             used if it is smaller than the other limits.  It is not
!             used for restart runs.
!             Default: 0 (not used at all).
!        - dt_max_wave_cfl: Set this to the desired maximum wave CFL.
!             The time step is reduced in order to keep the wave CFL
!             below the limit.
!             Default: 1000
!        - dt_max_increase_fac: Set this to indicate how quickly the
!             time step can grow as: dt_new<(1+dt_increase_fac)*dt_old.
!             Default: 0.05 (5%).
!      - Implemented more accurate 1/sin(t) terms in computing the
!        time steps.
!      - Increased maximum length of the runid
!        from 16 to 64 characters.
!      - Replaced compatible-sketchy iargc and getarg with
!        newer FORTRAN standard COMMAND_ARGUMENT_COUNT()
!        and GET_COMMAND_ARGUMENT().
!      - Cleaned up vars module.
!      - Changed default of use_old_vdgv to .true.
!      - Added some input sanity checking to load_temp_advance.
!
! ### Version 0.3.4.1, 06/17/2016
! ### modified by RL
!
!      - Added new variables to specify fixed expanding radial field
!        for monopole specified with br00:
!        - fmaxef: Maximum expansion factor of the radial field.
!             Default: 1 (radial expansion).
!        - r1ef: Radius where super-radial expansion ceases.
!             Default: 1.3
!        - sigmaef: Interval over which the expansion switches
!             from super-radial to radial.
!             Default: 0.5
!
! ### Version 0.3.4.2, 07/20/2016
! ### modified by RC
!
!      - Moved MPIFinalize so it is called after closing files.
!        This may solve an issue on Stampede of jobs
!        continuing to run after the code has stopped.
!      - Updated precision type variables to avoid problems
!        with default types.
!
! ### Version 0.3.4.3, 07/29/2016
! ### modified by RC
!
!      - Made some bug fixes to the Alfven wave tests.
!      - Added new "rotated" Alfven wave test.
!        This is a wave-p test rotated in the theta direction in 3D.
!        To activate the test set: initial_field='ALFVEN_WAVE2_ROTATED'.
!        Set the new parameter "wave_rotation_t" in the input file
!        to the desired theta rotation (default 0).
!
! ### Version 0.3.4.4, 08/04/2016
! ### modified by RC
!
!      - Reformulated method of setting the pole to 0 in the
!        pot2d solvers.  The new way results in unique Psi
!        solutions but still uses the Br rhs at the pole.
!
! ### Version 0.3.5.0, 08/09/2016
! ### modified by RC
!
!      - Fixed major bug in the semi-implicit/viscosity operator.
!        All coefficients involving phi-derivatives had the wrong sign.
!        It is recommended to re-run any unstable simulations...
!
! ### Version 0.3.6.0, 09/08/2016
! ### modified by RC
!
!      - Added initial hdf5 support.
!        You can now use .h5 files for inputs (such as br)
!        (the code auto-detects hdf5 form the file extension ".h5").
!        Setting hdf5=.true. in the input file will make the code
!        write all output into hdf5 files with a ".h5" extension.
!        The default is hdf5=.false. (original hdf4 output).
!        [Restart files are always in hdf4 (for now)].
!      - Due to hdf5 options, the code must be compiled with hdf5
!        (specifically, "-lhdf5_fortran" and "-lhdf5hl_fortran")
!      - Updated rdhdf routine to be able to read SD API hdf4 files.
!
! ### Version 0.3.6.1, 09/19/2016
! ### modified by RC
!
!      - Bug fix for new RDHDF (files with no scales had garbage scales)
!
! ### Version 0.3.6.2, 09/20/2016
! ### modified by RC
!
!      - Reworked Br monopole and bfroma() routine.
!        bfroma() now has a different syntax: bfroma(a,b,br_mono_fac)
!        where br_mono_fac multiplies the monopole if one is being used.
!        All calls to bfroma have been updated accordingly.
!        Added new routine set_brmono() to set up monopole in
!        start().
!
! ### Version 0.3.6.3, 09/29/2016
! ### modified by RC
!
!      - Small bug fix in error checking in hdf5 read routine RDH5().
!
! ### Version 0.3.6.4, 11/04/2016
! ### modified by RC,CD
!
!      - Added "restart_calculation_frame" input parameter.
!        This allows the code to properly handle
!        running from a restart file computed in a
!        different reference frame than the current computation_frame.
!        DEFAULT: INERTIAL
!
! ### Version 0.3.6.5, 11/10/2016
! ### modified by CD
!      - Added a new radiative loss function: 'CHIANTI_v713_HYBRID'
!      - This is based off of Schmelz et al. 2012, ApJ, 755, 33
!
! ### Version 0.3.6.6, 11/11/2016
! ### modified by CD
!      - Change nmseg to 50 (was 20). Allows for more mesh segments to
!        be specified (required for some complex autogenerated meshes).
!
! ### Version 0.3.6.7, 11/23/2016
! ### modified by RC
!      - Updated presision type variables (again) since PGI does not
!        support real(16).  Instead, the code now uses the intrinsic
!        (and portable) "iso_fortran_env" module to check and
!        set types.  This module is part of the Fortran 2008 standard
!        so very out-of-date compilers are no longer supported.
!      - Small change to sum_over_phi_ep.
!
! ### Version 0.3.6.8, 01/05/2017
! ### modified by RC
!      - Added the ability to turn on or off characteristic
!        boundary conditions at r0 and r1 independently.
!        The new parameters to set are "char_bc0" and "char_bc1".
!        The old "char_bc" is still compatible but its use
!        is discouraged as it will be deprecated in the future.
!        This change eliminates the "use_special_bc_r0" parameter.
!        If use_special_bc_r0 was true in a run, set char_bc0=.false.
!      - Cleaned up char_bc-related code.
!
! ### Version 0.3.6.9, 01/09/2017
! ### modified by RL
!      - Fixed corotating terms in collisionless thermal conduction.
!      - Implemented corotation terms into Alfven wave speed
!        calculation (getvaw).
!      - Added corotation velocity in vp for initial conditions
!        when using calculation_frame='COROTATING' inside
!        initialize_from_file().  This should be kept in mind
!        when adding future 2D and/or 3D IC-from-file features.
!
! ### Version 0.3.7.0, 02/10/2017
! ### modified by RC
!      - Added the ability to trace particles during a simulation.
!        The tracing is activated by setting
!           trace_particles=.true.
!           trace_seed_file='your_seed_file'
!        where 'your_seed_file' is an hdf/h5 file of size Nx3 containing
!        the [r,t,p] locations of N seed particles.
!      - By default, particle locations will be output at the same
!        cadence as field dumps (in files named tracers_pos###.h5)
!        but can be modified by setting
!          trace_ixint=# to an iteration interval or
!          trace_txint=# to a time interval.
!      - In addition to position, one can output the total path length
!        the particles traveled in-between file dumps by setting:
!          trace_track_ds=.true.
!      - By default, the particles will freeze their position if they
!        try to leave the domain.  This default setting is
!          "trace_reseed_type='none'".
!        Another option is to re-seed the particle at a choice of
!        radius (leaving theta and phi unchanged).  To use this, set:
!          "trace_reseed_type='r_periodic'" and
!          "trace_reseed_r0=#"
!        where # is the desired re-seed radius (default 1.0).
!      - Added particle tracing timer.
!      - Updated MPI_Init call to current standard.
!      - Added MPI_Barrier before final wall clock timer to obtain
!        more acurate overall run time.
!
! ### Version 0.3.7.1, 02/28/2017
! ### modified by RC
!      - Fixed timer bug.  advpw and advparticles were swapped.
!
! ### Version 0.3.7.2, 03/03/2017
! ### modified by RC
!      - Fixed some input checking.
!
! ### Version 0.3.7.3, 04/20/2017
! ### modified by CD
!      - Added some new TDm fluxrope functionality/options.
!      1) Monopole charges can be placed for TDm rope strapping field.
!          - This allows you to easily setup idealized/stable configs.
!      2) You can override the footpoint_halfdistance variable by
!           setting the major_radius directly. This is used for placing
!           ropes with a center above the inner boundary.
!      - The comments in tdm_structure_def has info on the new vars:
!          - add_charges
!          - charge_magnitude
!          - charge_halflength
!          - get_bp_from_charge
!          - charge_to_bp_factor
!          - use_major_radius
!          - major_radius
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccc  BEGIN MAS_RO CHANGELOG (UNIQUE)  ccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! c
! c ### Version 0.2.1.0, 11/11/2009, file mas_0.2.1.0.f,
! c ### modified by RL:
! c
! c      - The code does interplanetary runs when INTERPLANETARY_RUN
! c         is .true..
! c      - According to the value of CALCULATION_FRAME, computation
! c         can be in an INERTIAL or COROTATING frame. OMEGA_COROTATE
! c         has the angula speed in code units.
! c      - The BOUNDARY_FRAME value is read from the IP_CATALOG_FILE
! c         and can be INERTIAL or COROTATING. We assume that the
! c         angular speed is the same in both calculations.
! c      - Changed predictor steps in the advancement of Alfven waves
! c
! c ### Version 0.2.1.1, 12/14/2009, file mas_0.2.1.1.f,
! c ### modified by RL:
! c
! c      - EVOLVE_FLUX option added to calculate psi and phi potentials
! c         and electric field from them
! c
! c ### Version 0.2.1.2, 08/16/2010, file mas_0.2.1.2.f,
! c ### modified by RL:
! c
! c      - New definition of v_minus_omegaxr_bb
! c
! c ### Version 0.2.1.3, 09/03/2010, file mas_0.2.1.3.f,
! c ### modified by RL:
! c
! c      - Added reading of interplanetary data as a namelist
! c
! c ### Version 0.2.1.4, 09/09/2010, file mas_0.2.1.4.f,
! c ### modified by RL:
! c
! c      - Added fake_corotation flag for interplanetary run
! c         to be used when the inner solution is calculated
! c         in the inertial frame but we pretend is calculated
! c         in the corotating frame. When true, we do not add WxR part
! c         to vp at the boundary but we addd WxR wehen calculating
! c         VxB_theta at the boundary.
! c
! c ### Version 0.2.1.5, 09/10/2010, file mas_0.2.1.5.f,
! c ### modified by RL:
! c
! c       - For interplanetary run, we now rotate the magnetic
! c         field at the boundaries.
! c
! c ### Version 0.2.1.6, 10/19/2010, file mas_0.2.1.6.f,
! c ### modified by RL:
! c
! c       - Added E x B / B^2 velocity at the lower boundary when
! c         emerging flux.
! c       - Now the code can read B=0 magnetic flux files.
! c
! c ### Version 0.2.1.7, 12/06/2010, file mas_0.2.1.7.f,
! c ### modified by RL:
! c
! c       - Fixed bugs in the routines that extracted local arrays from
! c         global arrays.  There was an error in how the last point in
! c         the phi dimension was treated for arrays that are defined
! c         on the main phi mesh, in the case of a periodic phi
! c         dimension (which is the only case possible at present).
! c       - Fixed routine WRRS_C so that if the user attempts to
! c         write an empty string, the routine actually writes a
! c         string with a single space instead.  Apparently this was
! c         preventing the HDF library from properly closing the
! c         restart file in such a situation!
! c       - Introduced temporal profile in the heatsource structure.
! c       - Introduced Alfven wave pressure dissipation in routines
! c         ADVEM and ADVEP
! c       - Introduced OMEGA_DRIVE to make the shear flow periodic
! c
! c ### Version 0.2.1.8, 01/12/2011, file mas_0.2.1.8.f,
! c ### modified by RL:
! c
! c       - Using old routines ADVEM and ADVEP
! c
! c ### Version 0.2.1.9, 05/26/2011, file mas_0.2.1.9.f,
! c ### modified by RL:
! c
! c       - Option to add Gaussian heating source
! c
! c ### Version 0.2.1.11, 09/02/2011, file mas_0.2.1.11.f,
! c ### modified by RL:
! c
! c       - Option to modulate the Alfven wave pressure at the base
! c         as a function of Br at the base.
! c       - NB: the version 0.2.1.10 has different pole boundary
! c         conditions for the interplanetary input fields. It is
! c         not used in this modification.
! c
! c ### Version 0.2.1.12, 04/24/2012, file mas_0.2.1.12.f,
! c ### modified by RL:
! c
! c       - Fixed bug in read_tp_interp_xx routines, which did not
! c         calculate the boundary conditions at the poles correctly.
! c
! c
! c ### Version 0.2.1.13, 04/25/2012, file mas_0.2.1.13.f,
! c ### modified by RL:
! c
! c       - Now we solve for the two potentials to calculate the
! c         electric field at the lower boundary  in the
! c         interplanetary case.
! c
! c ### Version 0.2.1.14, 06/04/2012, file mas_0.2.1.14.f,
! c ### modified by RL:
! c
! c       - New balance flux routine that works in parallel. It
! c         is used to balance the flux obtained after
! c         LONGITUDE_SHIFT.
! c
! c ### Version 0.2.1.15, 07/05/2012, file mas_0.2.1.15.f,
! c ### modified by RL:
! c
! c       - Added option to read initial 2D A file.
! c       - Fixed bug in BC_VCROSSB_INTERPLANETARy
! c
! c ### Version 0.2.1.16, 09/11/2012, file mas_0.2.1.16.f,
! c ### modified by RL:
! c
! c       - Added option to read current with 2D A file and
! c         relax A until its J is equal to the read current.
! c
! c ### Version 0.2.1.17, 05/01/2013, file mas_0.2.1.17.f,
! c ### modified by RL:
! c
! c       - Small modification in NEWFLUX to make it like
! c         BC_VCROSSB_INTERPLANETARY.
! c
! c ### Version 0.2.1.18, 08/14/2013, file mas_0.2.1.18.f,
! c ### modified by RL:
! c
! c       - Commented out CALLS to CALC_V_EFLUX in NEWFLUX.
! c         They were adding the flows twice.
! c
! c ### Version 0.2.1.19, 08/14/2013, file mas_0.2.1.19.f,
! c ### modified by RL:
! c
! c       - Added MHDSS options for potential_field_bc. It is like
! c         SOURCE_SURFACE, but allows for the evolution of
! c         flux at the boundary in SET_BC_A.
! c       - Added calls to flux balancing in NEWFLUX and
! c         BC_VCROSSB_INTERPLANETARY.
! c
! c ### Version 0.2.1.20, 10/18/2013, file mas_0.2.1.20.f,
! c ### modified by RL:
! c
! c       - Added FLUX_TRANSPORT option for meridional flows and
! c         differential rotation.
! c       - Added the ability to use 6-digit sequence numbers in
! c         the output HDF file names.  To request this, set the
! c         variable LONG_SEQUENCE_NUMBERS=.true..  By default,
! c         this is off (i.e., 3-digit sequence numbers are used).
! c
! c ### Version svnR16_RL_2, 01/20/2014, file mas_svnR16_RL_2.f
! c ### modified by RL:
! c
! c       - Removed calls to flux balancing in NEWFLUX and
! c         BC_VCROSSB_INTERPLANETARY.
! c
! c ### Version 0.2.1.21, 08/18/2014, file mas_helio.f,
! c ### modified by RC:
! c
! c       - Implemented gfortran compatibility updates from SVN mas.
! c       - Implemented this version of MAS as proper SVN branch
! c         with file name mas_helio.f.
!
! c ### Version 0.3.0.1-H, 08/18/2014
! c ### modified by RC:
! c
! c       - Implemented many of the updates from main MAS code,
! c         including the IBLU0 preconditioner and other
! c         optimizations and bug fixes.
! c
! c ### Version 0.3.0.2-H, 09/04/2014, file mas_helio.f
! c ### modified by RL:
! c
! c       - New option to prescribe B and V at the lower boundary
! c         with the two potential methods.
! c         PRESCRIBE_BV=.true.
! c         EVOLVE_FLUX=.true.
! c         ROTATION_FLUX=.true.
! c
! c ### Version 0.3.0.3-H, 01/19/2015, file mas_helio.f
! c ### modified by RL and RC:
! c
! c       - Commented out 4 lines in BC_VCROSSB_INTERPLANETARY to
! c         make it like NEWFLUX. The lines set the values at the
! c         poles before calling the c.g. solver.
! c       - Commented out 2 lines in CHAR_BC_0 not to stop
! c         when there is supersonic inflow.
! c
! c ### Version 0.3.0.4-H, 01/29/2015, file mas_helio.f
! c ### modified by RL
! c
! c       - Now we add the eventual monopole in the calculation
! c         of the electric field in NEWFLUX
! c
! c ### Version 0.3.0.5-H, 01/30/2015, file mas_helio.f
! c ### modified by RL
! c
! c       - Inserted INITIALIZE_ZB_EQUILIBRIUM and LOAD_RHO_FROM_FILE
! c
! c ### Version 0.3.0.6-H, 02/06/2015, file mas_helio.f
! c ### modified by RL
! c
! c       - Option LONG_SEQUENCE_NUMBERS_INPUT allows now long sequence
! c         numbers for interplanetary and lower-boundary-two-potentials
! c         runs
! c
! c ### Version 0.3.0.7-H, 02/06/2015
! c ### modified by RC
! c
! c       - Added a couple of speed improvements to the
! c         2D potential solves in bc_vcrossb_interplanetary()
! c         used in interplanetary moving-boundary runs.
! c
! c ### Version 0.3.0.8-H, 02/19/2015
! c ### modified by RC
! c
! c       - Added SGS and IBLU0 preconditioners to
! c         pot2d and pot2dh solves. Set
! c           ifprec_pot2d=2   (SGS)
! c           ifprec_pot2d=3   (IBLU0)
! c       - Setup pot2d and pot2dh solves to load the matrix and
! c         preconditioner once at startup, and use throughout
! c         simulation.
! c       - Added pot2dh iteration counter, written to o-file.
! c
! c ### Version 0.3.0.9-H, 02/23/2015
! c ### modified by RC
! c
! c      - Fixed bug introduced in last version.
! c
! c ### Version 0.3.0.10-H, 02/24/2015
! c ### modified by RC
! c
! c      - Fixed memory leak in newflux().  This was causing
! c        long runs to crash by filling up the RAM.
! c
! c ### Version 0.3.0.11-H, 02/26/2015
! c ### modified by RC
! c
! c      - Added pot2d speed improvements to pbv in newflux.
! c      - Fixed small memory leak in rdhdf_2d().
! c
! c ### Version 0.3.0.12-H, 03/13/2015
! c ### modified by RC
! c
! c      - Added expert_user_overide input structure.
! c      - Added "expert_user_overide%limit_supersonic_inflow" logical,
! c        when set to .true., if there is supersonic inflow, the
! c        velocity at the point is set to the sound speed.
! c      - Warning/error messages for supersonic inflow now written to
! c        the w-file.
! c
! c ### Version 0.3.0.13-H, 03/23/2015
! c ### modified by RC
! c
! c      - Added rho limiter and alfven-speed limiter.  For details,
! c        see mas.f in trunk.
! c
! c ### Version 0.3.0.14-RO, 03/24/2015
! c ### modified by RC
! c
! c      - Added tdm fluxropes from mas into mas-ro.  See mas code for
! c        input file details.
! c      - Updated bfroma() to allow optional monopole.
! c      - Set default preconditioner for pot2d solves to ilu0.
! c
! c ### Version 0.3.0.15-RO, 03/24/2015
! c ### modified by RC
! c
! c      - Updated restart file code with that found in mas.f.
! c        All old restarts can still be read in (1 and 3-part)
! c        but the input file must be updated to reflect the new way to
! c        specify restart file names (see mas.f for details).
! c      - Renamed code file to mas_ro.f.
! c
! c ### Version 0.3.0.16-RO, 03/30/2015
! c ### modified by RC and ZM
! c
! c      - Added use_special_bc_r0 parameter and capability.  Set to
! c        true to use static (no flow) boundary conditions at r=R0.
! c      - Added CHIANTI photo/coronal radiative loss functions.
! c      - Added new near-zero smoothing for radiative loss functions.
! c        Set legacy_q_chromo_reduction=.true. to use old smoothing.
! c      - Added new heating function "exponential-b-photo-dependent".
! c      - Added heat mask from file functionality.
! c      - Modified read_input_file() to allow mas_ro to run input files
! c        missing the interplanetary section.  This allows this code
! c        to run the testsuite.
! c
! c ### Version 0.3.1.0-RO, 04/02/2015
! c ### modified by RC and RL
! c
! c      - Added option to turn off normalization of shear
! c        by setting shear%normalize_vtrans=.false..
! c      - Added option to turn off normalization of flow
! c        by setting flow%normalize_vnorm=.false.
! c      - Added e-field to fields for optional output.
! c      - Added option to set collisionless thermal conduction to old
! c        radial version with input use_radial_nocoll.
! c      - Added 'RADIALLY_DEPENDENT', 'CUSTOM_TP+R_PROFILE',
! c        and 'CUSTOM_PROFILE' to VISC_PROFILE.
! c
! c ### Version 0.3.1.1-RO, 10/13/2015
! c ### modified by RC
! c
! c       - Updated namelist error checking for interplanetary section
! c         to allow its omission, but still fail if there is a true
! c         error within the section itself.
! c       - Updated some mas-ro additional output formatting to
! c         the standard width requirements as done in MAS.
! c
! c ### Version 0.3.1.2-RO, 11/06/2015
! c ### modified by RC
! c
! c       - Updated check_negative_field() routine to only check
! c         internal points.  This avoids false errors for averaged
! c         inner boundary values.
! c       - Fixed bug with use of use_special_bc_r0 parameter.
! c
! c ### Version 0.3.1.3-RO, 11/08/2015
! c ### modified by RC
! c
! c       - Added a fix to bc_vcrossb to update pbv arrays
! c         with new predictor b values.  This solves
! c         the differences in run results for the poly_2d_shear
! c         test compared to the MAS code.
! c
! c ### Version 0.3.1.4-RO, 02/08/2016
! c ### modified by RC and RL
! c
! c       - Added input file error checking for pbv boundary driving.
! c
! c ### Version 0.3.1.5-RO, 02/19/2016
! c ### modified by RC and RL
! c
! c       - COMPATIBILITY CHANGE:  The code no longer allows
! c         setting flow%active=.true. and prescribe_bv=.true. at
! c         the same time.  The code displays an error and shuts down
! c         if this is attempted. (The code was not doing what the
! c         input file implied in such a case).
! c       - Added new routine "check_inputs" and added the above input
! c         file checking for pbv boundary driving.
! c       - It is no longer necessary to set evolve_flux=.true.
! c         when using prescribe_bv=.true..
! c       - Changed the way prescribing bv works under the hood.
! c         It now uses its own velocity arrays instead of using
! c         the v_flow arrays.
! c
! c ### Version 0.3.5.1-RO, 09/19/2016
! c ### modified by RC+RL
! c      - Added new parameter (pbv_bcvfac) to prescribe_bv runs.
! c        Factor multipies boundary velocity values in load_bc_v.
! c        DEFAULT: 1.0
! c
! c ### Version 0.3.5.2-RO, 09/20/2016
! c ### modified by RC
! c
! c      - Bug fix for prescribe_bv runs.  The Br monopole was
! c        being computed differently in newflux versus bfroma.
! c
! c ### Version 0.3.5.4-RO, 11/07/2016
! c ### modified by RC,CD,RL
! c
! c      - COMPATIBILITY CHANGE:
! c        The input parameter "fake_corotation" no longer exists.
! c        Instead, use: boundary_frame='FAKE_COROTATING'
! c      - Added "restart_calculation_frame" input parameter.
! c        This allows the code to properly handle
! c        running from a restart file computed in a
! c        different reference frame than the current computation_frame.
! c        DEFAULT: INERTIAL
! c      - Added default value: boundary_frame='FAKE_COROTATING'
! c      - Re-worked frame-of-reference handling for boundary driving.
! c        The code now properly handles the following cases:
! c           boundary_frame   calculation_frame
! c           ----------------------------------
! c           INERTIAL         COROTATING
! c           INERTIAL         INERTIAL
! c           COROTATING       COROTATING
! c           COROTATING       INERTIAL
! c           FAKE_COROTATING  COROTATING
! c           FAKE_COROTATING  INERTIAL
! c       - Added new "corotating_relaxation_time" input parameter to
! c         interplanetary section. Use this when you have a simulation
! c         that was initially relaxed in a corotating frame, and
! c         subsequent restarts are to be computed in the inertial
! c         frame. Operationally, this corrects the time used to
! c         calculate the phi-shift of the boundary driving files. Set
! c         it to reflect the end time of the corotating relaxation.
! c         DEFAULT: 0.
! c
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccc  END OF MAS_RO CHANGELOG cccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! ### Version 0.4.0.0, 05/19/2017
! ### modified by RC
!
!      - Merge of MAS_RO into MAS.
!      - COMPATIBILITY CHANGE FOR MAS_RO EVOLVE_FLUX RUNS:
!        To run an evolve_flux run (driving with Br), you
!        must set time profile %vars
!        to 'eflux_br' instead of 'eflux_psi_e0'.
!        (Note that the units of the input Br and that of the
!        boundary driving Br files must be the same).
!      - Fixed MAS_RO bugs that would occur when using evolve_flux.
!      - Added new "dryrun" option.
!        This will check the input file for errors and then stop.
!        Activate by running mas as:  "./mas ifile_root -dryrun"
!        (This can be done from a login node)
!      - Added MAS_RO changelog above.
!      - Added more input file parameter checking.
!
! ### Version 0.4.0.1, 05/28/2017
! ### modified by RC
!
!      - Bug fix for newflux (bug caused by last update).
!        PBV and newflux runs were stalling
!        when using more than 1 processor in the r direction.
!
! ### Version 0.4.0.2, 06/04/2017
! ### modified by RC
!
!      - Added option to integrate viscosity with density
!        outside the operator (i.e. treat rho as homogeneous).
!        To use this experimental option, set:
!        visc_rho_outside=.true.
!      - Added option to sub-cycle the viscosity advance.
!        This can make the viscosity more effective on grid-level
!        oscillations (i.e. can clean up transition region wiggles).
!        To sub-cycle viscosity N number of times, set:
!        visc_subcycles=N
!
! ### Version 0.4.1.0, 06/05/2017
! ### modified by RC
!
!      - Major overhaul of PCG solvers.  They are now streamlined
!        and more vectorizable.  This change speeds up the code
!        by up to 30% depending on the run.
!      - The A, POT2D, POT2DH, and POT3D solves are now more modular
!        and invoked by calling the a_solver(), pot2d_solver(),
!        pot2dh_solver(), and pot3d_solver() respectively.
!      - Updated seam_vvec() to use 3X less MPI synchronizations.
!
! ### Version 0.4.1.1, 06/21/2017
! ### modified by RC
!
!      - Improved namelist error checking.  Now if there is a problem,
!        the code will output the offending line in the input file.
!
! ### Version 0.4.1.2, 09/07/2017
! ### modified by RC
!
!      - Updated polar boundary conditions in solver to not use
!        the sum_p_ep function as this was causing temporary
!        array copies (and the loop order was not ideal).
!        Instead, the polar averages are done directly.
!      - Updated sum_p_ep to be more efficient for the few
!        routines that still use it.
!
! ### Version 0.4.1.3, 09/28/2017
! ### modified by RC,ZM
!
!      - BUG FIX:  Fixed problem with evolve_flux runs introduced in
!        Version 0.4.0.0.
!      - Added new error checking in get_flux to make sure time
!        profiles have been set when using evolve_flux.
!
! ### Version 0.4.1.4, 10/25/2017
! ### modified by RC
!
!      - BUG FIX:  Fixed a bug in set_pole_bc_bvec introduced in
!        Version 0.4.1.2.  The compilers seemed to be smart enough
!        to avoid crashing due to the bug, so results should be
!        equivalent.
!
! ### Version 0.4.2.0, 11/22/2017
! ### modified by RC
!
!      - BUG FIX: Fixed a bug introduced in 0.4.0.0 in newflux that
!        was causing evolving_flux runs to have zero-valued vr,vt,vp.
!      - Modified array declerations to allow for better vectorization.
!        This makes the code faster.
!      - Optimized seam_avec.
!
! ### Version 0.4.3.0, 03/14/2018
! ### modified by RC
!
!      - Added HDF5 support for restarts.
!        To output HDF5 restarts, set rsh5out=.true. in the input file.
!        Reading HDF5 restarts is automatic if you specify the filename.
!        If you are using 'rsiroot', you must also set rsh5in=.true..
!        The HDF5 restarts can be written/read in multiple parts,
!        but since there is no file-size limit on HDF5 files,
!        it is recommended to use the (default) single-file restarts.
!      - COMPATIBILITY CHANGE:  Renamed input parameter 'hdf5' to 'h5'
!                             (it was clobbering with the hdf5 module)
!      - Fixed some comments and the error messages in char_bc_0.
!      - Modified some authorship comments per request.
!
! ### Version 0.4.3.1, 05/15/2018
! ### modified by RL
!
!      - Heliospheric Alfven wave pressure can be prescribed from ep em.
!        cfr. Version 0.4.1.4-CS, 05/15/2018
!
! ### Version 0.4.3.2, 05/30/2018
! ### modified by RC
!
!      - Small performance updates to polar boundary conditions
!        and added vector copy routines.
!
! ### Version 0.4.3.3, 05/31/2018
! ### modified by RC
!
!      - Follow up from last update.  The small changes here
!        cause floating-point differences due to re-ordering.
!
! ### Version 0.4.3.4, 07/16/2018
! ### modified by CD
!
!      - Bugfix in open_restart_file. After 0.4.3.0 ierr wasn't defined
!        for hdf4 rst reads. This could cause failure on some compilers.
!
! ### Version 0.4.3.5, 09/27/2018
! ### modified by CD
!
!      - Cleanup up of TDm fluxrope interface before RBSL changes.
!       - Removed TDm fluxrope ramping feature.
!       - Cleaned up TDm logic inside the "start" subroutine.
!
! ### Version 0.4.4.0, 10/05/2018
! ### modified by CD, VT
!
!      NEW FEATURE: RBSL Fluxropes.
!      - Can add fluxropes based on Regularized Biot-Savart Laws (RBSL).
!
!      - This is model uses arbitrary paths and generalized kernels.
!        - It is described by Titov et al. 2018, ApJL, 852, L21.
!
!      - Implementation is based off of the fortran code APATH, which
!        was designed, written, and tested by Viacheslav Titov.
!
!      - The parameters are set via the "rbsl_fluxrope" structure. The
!        specification style mirrors what we did for TDm (tdm_fluxrope).
!        - See rbsl_structure_def for a description of parameters.
!        - See the test case "zb_3d_fr_rbsl" for an example input file.
!
!      - Most importantly, the axis path is specified by a 2D hdf file.
!        - The coordinates are rtp, and the dimensions are (N,3).
!        - The path can be completely arbitrary, one requirement is that
!          it must be a closed loop (first and last point match).
!        - We do not check path resolution. It is up to the user
!          to use enough points to resolve the fluxrope path.
!          - N of order a few thousand is no problem for MAS.
!
!      RELATED CODE CHANGES:
!      - The way flux ropes are handled in MAS was generalized.
!        - The code footprint in "start" is three lines, and the vector
!          potentials for the fluxropes are setup and added by the
!          fluxrope_setup and fluxrope_add routines.
!
!      - There are three primary ways flux-rope vector potentials (A)
!        are specified: read A from a file, RBSL, or TDm. The main MAS
!        structures (and modules) for specifying the parameters, are:
!        - rope_from_file (fluxrope_file_structure_def).
!        - rbsl_fluxrope (rbsl_structure_def).
!        - tdm_fluxrope (tdm_structure_def).
!
!      - potfld no longer needs a vector potential as input.
!
!      - initialize_potential_field was just a wrapper -> deleted.
!
!      COMPATIBILITY CHANGES
!      - The option to read vector potentials from files was moved from
!        tdm_fluxrope structure to a new structure: "rope_from_file".
!        - This structure is set up with the same options as before.
!          - See the test zb_3d_fr_test2 for an example.
!        - MAS ifiles that use the old way WILL NO LONGER WORK.
!
!      - tdm_preserve_br0 is depreciated, now set fluxrope_preserve_br0.
!        - tdm_preserve_br0 is there for backwards compatibility, but
!          you will get a warning from "CHECK_INPUTS" if using it.
!
! ### Version 0.4.4.1, 10/24/2018
! ### modified by RC
!
!      - Fixed bug that prevented e-driven runs from working.
!
! ### Version 0.4.4.2, 10/25/2018
! ### modified by RC
!
!      - Fixed bug in creating restart file.
!
! ### Version 0.4.4.3, 10/26/2018
! ### modified by RC
!
!      - Fixed bug in intialize_from_file_2d which caused runs
!        using 1 rank in r getting different results than those
!        using >1 rank in r.
!      - Fixed bug in floor_field.  This could cause runs to hang
!        in MPI if the temperature was floored on proc 0.
!      - Fixed bug where POT2DH (phi bc solves) iterations were not
!        being recorded and printed in the ofile.
!
! ### Version 0.4.4.4, 10/29/2018
! ### modified by RC
!
!     - Fixed similar bug in floor_field_v that was in floor_field.
!     - Updated hdf4 error message.
!     - Fixed normalized PCG iteration timing information in t-file.
!
! ### Version 0.4.4.5, 11/27/2018
! ### modified by CD
!
!     - Small changes to tracer particles.
!     - Particles initially outside the domain won't stop the run.
!     - Tweaked logic for domain detection in advparticles.
!
! ### Version 0.4.5.0, 12/19/2018,
! ### modified by ZM,RC:
!
!      - Added the ability to supply a mask that transitions kappa
!        from a field-aligned tensor to an isotropic thermal
!        conductivity.  To activate this mask, set KAPPA_MASK_FILE
!        to the name of the file that contains the mask.  The
!        mask should equal 1 in the regions in which the thermal
!        conductivity is field-aligned, and 0 in regions where it
!        becomes isotropic.
!      - Added the option to allow unbalanced flux in the input
!        magnetogram.  This is useful when using a source-surface
!        solution.  By default, the flux is balanced, as before.
!        To invoke this option, set ALLOW_UNBALANCED_FLUX=.true..
!        This request generates an error if a source-surface
!        solution has not been requested (otherwise it would
!        prevent the convergence of the potential field solve).
!      - Added contribution of the monopole to br_photo output file.
!      - Added the ability to supply a mask that transitions b-hat
!        from being aligned along B to being aligned along the
!        radial direction.  To activate this mask, set BHAT_MASK_FILE
!        to the name of the file that contains the mask.  The
!        mask should equal 1 in the regions in which b-hat is
!        field-aligned, and 0 in regions where it becomes radial.
!      - Added the ability to read in a density and/or temperature
!        profile at the beginning of a run.  This replaces the
!        density and temperature profiles from a restart run or
!        from the regular initialization.  Specify the HDF files
!        containing the profiles via the variables LOAD_RHO_FILE
!        and LOAD_TEMP_FILE.
!      - Added parallel flow model.  To activate, set FREEZE_B=.true.
!        To output the parallel velocity, add V_PAR to the output list.
!
! ### Version 0.4.6.0, 01/10/2019, modified by RC:
!
!      - Added automatic topology.  Now, nprocs is optional.
!        One can specify one or more topology dimensions and
!        use the flag value "-1" to indicate dimensions to auto-set.
!        It is recommended to simply delete nprocs from input files.
!
! ### Version 0.4.6.1, 02/14/2019, modified by CD:
!
!      - Fix for GCC 8.2.0 compiler version. Error due to contiguous
!        vs. non-contiguous pointers/targets.
!      - Ron's fix was to remove contiguous definition from some things
!        regarding sds library and field_table structure.
!
! ### Version 0.4.7.0, 02/26/2019, modified by RC:
!
!      - Updated thermal conduction/radiative loss cutoff to be smooth
!        as per Zoran's prescription.
!      - Modified check on magnitude of B for activating isotropic
!        conduction to use a tiny tolerence instead of 0.
!
!      COMPATIBILITY CHANGES
!      - The modifications here will (slightly?) change results of
!        thermodynamic runs.
!
! ### Version 0.4.7.1, 05/03/2019, modified by RC,CD:
!
!      - Bug fix for reading HDF5 files (wrong size arrays were being
!        used in an h5 library call causing stack faults).
!      - Bug fix for freeze_b (radial boundaries of the velocity vector
!        were not being set initially).
!
! ### Version 0.4.8.0, 05/24/2019, modified by RC:
!
!      - Implemented ability to override or add to 3D initial conditions
!        from loaded HDF files.  If the loaded field is on a different
!        mesh, it will be linearly interpolated.
!
!        To load fields, add the LOAD_FIELDS structure in the
!        input file.  The structure has three components:
!           LOAD_FIELDS(#)%field=''
!           LOAD_FIELDS(#)%fname=''
!           LOAD_FIELDS(#)%action=''
!        The "#" should be a sequential number incremented for
!          each field starting with 1.
!        The "field" can be any of the supported fields in MAS.
!        The "fname" is the filename of the loaded field (HDF4 or HDF5).
!        The "action" can either be "initial" or "add".  Initial will
!          overwrite the field with the loaded field, while "add" will
!          add the loaded field to the field.
!
!        When loading a B-field (initial or add), the code will
!        automatically derive A using pot2d and pot2dh solves
!        for every radial slice in the domain.
!        There are three options on how to pre-process the loaded B-field
!        set by the new LOADED_B_CLEAN_METHOD parameter:
!          LOADED_B_CLEAN_METHOD=0    B is used in the solves as-is.
!          LOADED_B_CLEAN_METHOD=1    B is divergence-cleaned with a 3D
!                                     solve.  The solve has standard
!                                     solver options of EPSCG_DIVB and
!                                     IFPREC_DIVB (defaults 1e-9 and 3).
!          LOADED_B_CLEAN_METHOD=2    Each r-slice of Br is
!                                     flux balanced.
!        By default, LOADED_B_CLEAN_METHOD=1.
!
!        Example use of LOAD_FIELDS:
!         - Adding an energized B-field to the initial condition:
!           load_fields(1)%field='br'
!           load_fields(1)%fname='br_energized.h5'
!           load_fields(1)%action='add'
!           load_fields(2)%field='bt'
!           load_fields(2)%fname='bt_energized.h5'
!           load_fields(2)%action='add'
!           load_fields(3)%field='bp'
!           load_fields(3)%fname='bp_energized.h5'
!           load_fields(3)%action='add'
!         - Loading initial temperature:
!           load_fields(4)%field='t'
!           load_fields(4)%fname='t_init.h5'
!           load_fields(4)%action='initial'
!
!      - Removed LOAD_RHO_FILE and LOAD_TEMPERATURE_FILE as this
!        functionality can now be done using LOAD_FIELDS.
!      - Small code cleaning updates to pot2d solver.
!      - Made output restart file to be single HDF5 by default.
!        To override, set: rsh5out=.false.
!        The default input format for multi-file restarts is still HDF4.
!        To use multi-file HDF5 restarts, set rsh5in=.true.
!        Single-file input restarts do not need any special parameters
!        to be set when using HDF4 or HDF5.
!      - Removed optimization module since use_f90_loops
!        is no longer used.
!
! ### Version 0.4.9.0, 08/29/2019, modified by RC:
!
!      - Small bug fix in fixing loaded fields.
!      - Added super time-stepping and sub-cycled explicit Euler options
!        to thermal conduction and viscosity solvers.
!        To use super time-stepping, set
!                    USE_STS_VISC=.TRUE.  and/or
!                    USE_STS_TC=.TRUE.
!        To select STS type,
!        set STS_TYPE=1 for RKL1 and STS_TYPE=2 for RKL2.
!        The default is RKL2 and RKL1 should not be used (testing only).
!        NOTE!  The STS method does not damp high-frequency oscillations
!               efficiently.  Therefore, care must be taken when using
!               STS for viscosity.  Make sure to validate solution
!               before using in a production setting.
!        To use the explicit Euler sub-cycling, set
!                 USE_EXP_VISC=.TRUE. and/or
!                 USE_EXP_TC=.TRUE.
!        The Euler method is slow and for testing purposes only.
!        For either STS or EXP methods, setting a debug level or ncghist
!        will output diagnostics of the method.
!        Note that the STS and EXP methods are NOT currently implemented
!        for the freeze-b viscosity solves.
!      - Added ability to sub-cycle thermal conduction solve step.
!        To sub-cycle N number of times, set tc_subcycles=N.
!
! ### Version 0.4.9.1, 09/03/2019, modified by RC:
!
!      - Removed unused extended precison option (cgdot and sums).
!      - Made 2D solver arrays really 2D instead of (:,:,1).
!      - Some minor code cleaning.
!
! ### Version 0.4.9.2, 12/25/2019, modified by RC:
!
!      - Optimized boundary solvers for interplanetary runs.
!        PSI and PHI solves are now computed outside the predictor-corr
!        of adva, in get_ip_boundaries.  Additionally, the PHI solve
!        uses a guess that is rotated depending on the reference frame.
!        For steady-state helio runs, these changes improve
!        the boundary solve performance by up to 3x.
!        Results of interplanetary runs will change by PCG tolerance.
!
! ### Version 0.4.9.3, 01/08/2020, modified by RC:
!
!      - Added higher-order interpolaters for 2D IP boundaries.
!        To use, set IP_BC_INTERP_ORDER (default 2).
!      - Added option to not use IP 2D boundary potential solves,
!        and use VxB directly.  This is only stable in the
!        case of FAKE_COROTATING with zero-valued transverse magnetic
!        and velocity fields (such as in a CORHEL solar wind run).
!        To disable the solves, set IP_USE_BC_POT_SOLVES=.FALSE.
!
! ### Version 0.4.9.4, 01/21/2020, modified by RC:
!
!      - Added more optimization options to 2D IP boundary solves.
!        The following input parameters are added with their defaults:
!           IP_BC_SHIFT_PHI_GUESS=.true.
!           IP_BC_SHIFT_PSI_GUESS=.false.
!        It is recommended for most users to leave these alone.
!        To minimize solver iterations when running with a rotating
!        boundary, set IP_BC_SHIFT_PSI_GUESS=.true. along with
!        IP_BC_INTERP_ORDER=N where N is larger than 3 (7 works well).
!     - Renamed IP_USE_BC_POT_SOLVES to IP_BC_USE_POT_SOLVES.
!
! ### Version 0.4.9.5, 03/19/2020, modified by RL:
!
!      - Added capability to read files with the magnetic field
!        and cosine of the angle of a field line
!        Set BR00=0. but provide FL_FILE (3-columm file) with
!        r,B,cos(theta) along the field line.
!
! ### Version 0.5.0.0, 04/02/2020, modified by RL,CD,RC:
!
!      - Only single-file HDF5 restarts are now written.
!      - Multi-file and HDF4 restarts are still able to be read in.
!        However, RSH5IN=.TRUE. is now the default, so it must be set
!        to .FALSE. to use old hdf4 restarts.
!      - RSH5OUT is deprecated from input files and is
!        no longer used in the code.
!      - N_RS_OUTPUT_FILE_PARTS is deprecated from input files and
!        is no longer used in the code.
!      - Added two-temperature model.
!        To activate, set ADVANCE_TP=.TRUE.
!        For IO, add temp_e and temp_p to write the electron
!        and proton temperatures. Writing temp performs a proper
!        average of the two.
!        WARNING! Restarts still use pressure and set temp_e and temp_p
!        automatically so they currently do NOT work correctly
!        for two-temperature runs and require a future update.
!      - Added ability to advance charge states.
!        The chargestates feature has its own (optional)
!        section in input files, and its own additional restart file.
!        To activate charge states, set ADVANCE_FCS=.true.
!        To restart a charge states run, set FNAME_RESTART_FCS
!        to the name FCS restart file (seperate from the MAS restart).
!        If not specified, the run starts from equilibrium.
!        The FCS can also run in a fixed magnetic field and plasma
!        by setting ADVANCE_V, ADVANCE_A, ADVANCE_T, ADVANCE_RHO,
!        ADVANCE_TC, and ADVANCE_PW to .false.
!        In the FCS_NL namelist, specify the value of NELEM to the
!        number of elements to be evolved. The NATOM_LIST array
!        must have NELEM values listed, containing the atomic number
!        of each element.
!        The PATH_EIGEN should be set to the directory where
!        the Chianti ionization files are stored.
!        For interplanetary runs, in the INTERPLANETARY namelist,
!        specify FCSFILE to the header of the FCS files to be read and
!        whose values are prescribed at the lower boundaries.
!        Specify IF_VMOD=.true. if you want to slow down the ions in the
!        lower corona and increase their ionization level.
!        R_VMOD specifies the radius below which the ion velocity is
!        switched off and DR_VMOD sets the radial interval over
!        which this occurs.
!      - Note that this update breaks symmetry with the GPU OpenACC
!        branch so future updates need to be manually merged into
!        that branch until it is updated to handle
!        the two-temperature model.
!
! ### Version 0.5.0.1, 04/07/2020, modified by RL:
!
!      - Fixed bugs in the magnetic field line advancement.
!      - Introduced srfc,srfch,srfc_i,srfch_i variables to contain
!        the expansion factors on the grids and its inverse.
!
! ### Version 0.5.0.2, 04/22/2020, modified by RL and RC:
!
!      - Added logical FL_COMPUTE to activate field line computation.
!        It must be used in conjunction with FL_FILE which
!        specifies the file containing the field line.
!      - Removed interface for expansion factor variables and cleaned
!        up expansion factor variables.
!
! ### Version 0.5.0.3, 04/29/2020, modified by RC:
!
!      - BUG FIX: Fixed bug in grav(i) array access in char_bc0.
!                 This was causing seg faults and possibly
!                 wrong BC values for FL mode.
!      - Cleaned up comment with wierd character encoding.
!      - Synchronized style for all MPI calls.
!      - Fixed possible chargestates IO bug.
!
! ### Version 0.5.0.4, 05/11/2020, modified by RL and RC:
!
!      - Replaced area factor arrays with multiplicative factors
!        for r**2, rh**2, or their reciprocals.
!
! ### Version 0.5.0.5, 05/11/2020, modified by RL and RC:
!
!      - Introduced r_true and rh_true for field line computations.
!        When FL_COMPUTE is false, they are equal to r and rh
!        respectively.
!      - Introduced also inverse r_true_i and rh_true_i to ensure
!        the code reproduce past results.
! ### Version 0.5.0.6, 05/11/2020, modified by RL:
!
!      - F_HEATING (percentage of heating that goes to electrons vs.
!        protons in 2T model) is now a namelist input variable.
!
! ### Version 0.5.0.7, 05/16/2020, modified by RC:
!
!      - Minor code changes to keep code in sync with OpenACC branch.
!
! ### Version 0.5.0.8, 07/01/2020, modified by CD:
!
!      - Refactor + Bugfixes for 2T electron-ion coupling.
!      - New routines: GET_2T_COUPLING_CONSTANT, SOLVE_2T_COUPLING.
!      - Update is summarized as:
!        - Fixed the coupling constant (off by gamma-1).
!        - 2T properly accounts for helium (coupling const and solver).
!        - New 2T coupling solver: non-linear point-implicit method.
!        - Fixed/formalized the time-levels of Te and Tp to be at
!          the same place (after both advte, advtp).
!        - Refactored all temperature updates into "ADVT" wrapper.
!      - Added detailed comments in the subroutines on the origin of
!        the constants and solve terms.
!
! ### Version 0.5.0.9, 07/02/2020, modified by RC:
!
!      - Added thermal conduction to proton+alpha temperature advance.
!        It is activated with "advance_tc" as in the electron case.
!      - A new input parameter "tcondp" is added to be able to modify
!        the proton thermal conduction coeff.  The default is 0.
!
! ### Version 0.5.0.10, 07/07/2020, modified by RL:
!
!      - Added capabiblity to write and read restart files for 2T runs.
!        2T runs can still restart from 1T runs.
!      - DTIME is now saved in restart files.
!      - Now soubroutine "set_brmono" is called within "start"
!
! ### Version 0.5.0.11, 07/08/2020, modified by RL:
!
!      - Added collisionless thermal conduction for proton temperature
!        advance. When "alpha_nocoll_p" is 1., the multiplying value
!        is that of 2009ApJ...702.1604C
!
! ### Version 0.5.0.12, 07/13/2020, modified by RL:
!
!      - BUG FIX: In "advtp": the divergence of the velocity used
!        in calculating the collisionless thermal conduction was
!        always zero.
!
! ### Version 0.5.0.13, 07/22/2020, modified by RC:
!
!      - BUG FIX: involving restarts and auto-topology when
!        resolution in ifile differed from that in the restart file.
!      - Added polar filtering for scalar quantities.
!        To activate ALL filters, set <filter_poles=.true.>
!        To activate individual filters, set from the following:
!          <pole_filter_t=.true.>   (temperature - e and p)
!          <pole_filter_rho=.true.> (density)
!          <pole_filter_pw=.true.>  (e+ and e-)
!      - Added <use_dt_init_on_restart> logical.
!        Use this to restart a run with dt_init as the first timestep.
!
! ### Version 0.5.0.14, 09/17/2020, modified by CD/RC:
!
!      - BUG FIX: changed load_fields feature to work correctly with new
!        two-temperature model and new temperature arrays.
!
! ### Version 0.5.0.15, 09/22/2020, modified by RL:
!
!      - Added tmod1, tmod2 parameters to modify the
!        temperature in calculating charge states.
!
! ### Version 0.5.0.16, 10/26/2020, modified by RL:
!
!      - Give warning if charge states eigenvalues file is missing
!        but continue with the calculation.
!
! ### Version 0.5.0.17, 12/21/2020, modified by CD:
!
!      - BUG FIX: order of temperature initialization & remesh field
!        loading changed so a 2T remesh run is possible.
!
! ### Version 0.5.0.18, 01/07/2021, modified by RC:
!
!      - BUG FIX: In ep/em Alfven wave pressure (PW) advance,
!        scheme now uses correct stage of arrays.
!      - Optimized PW advance by combining and refactoring
!        ep and em advances.   Note that now both equations
!        are integrated for the same number of steps and with
!        the same radial artificial density function.
!      - Small modification to an array in write_restart_header() to
!        avoid compiler warning.
!
! ### Version 0.5.0.19, 01/13/2021, modified by RC:
!
!      - Small changes to sync with GPU version.
!
! ### Version 0.5.1.0, 01/19/2021, modified by RC,CD,RL,JL:
!
!      - BUG FIX: PW (ep,em) boundary condition extrapolation used
!                 wrong macro.
!      - BUG FIX: Code would try to write tracers when tracers were
!                 not activated if tracer plot cadence was set.
!      - COMPATIBILITY CHANGE:
!        Added USE_PW_THETA_PROFILE logical input parameter.
!        This must be set to .TRUE. to use the PW latitude profile.
!        The default is .FALSE. (old default was to use the profile).
!      - COMPATIBILITY CHANGE:
!        Changed the way pressure is set at the radial boundaries
!        and poles.  The new method should avoid negative pressures.
!        Solutions will change slightly due to this modification.
!      - Added IFCHECK0PW parameter to tell the code to check for
!        any negative EP and EM internal values, and stop the run if
!        any are found.  The default is .TRUE.
!      - Added IFCHECK0PRES parameter to tell the code to check for
!        any negative PRES internal values, and stop the run if
!        any are found.  The default is .TRUE.
!      - Changed CHECK_NEGATIVE_FIELD to check for negative values
!        only, and allow zero-values (.lt. instead of .le.).
!      - Fixed dt_init issue with restarts that do not have DTIME.
!
! ### Version 0.5.1.1, 02/05/2021, modified by RC,RL:
!
!      - Changed default of restart_calculation_frame.
!        Now, if the user does not specify it in the input file,
!        it is set to the current run's calculation_frame.
!
! ### Version 0.5.1.2, 03/03/2021, modified by RC:
!
!      - COMPATIBILITY CHANGE:  Changed way kappa mask is requested.
!        Now one must set use_kappa_mask=.true. to have the code
!        use the kappa mask file.
!        (Previously, the non-empty file name was used to activate).
!      - Merged getkappa into load_matrix_t_solve and eliminated some
!        temporary arrrays.
!      - Some minor code cleanup.
!
! ### Version 0.5.1.3, 03/11/2021, modified by RC:
!
!      - Cosmetic and simplification modifications to sync code
!        to OpenACC branch.
!
! ### Version 0.5.2.0, 04/27/2021, modified by RC:
!
!      - Added ability to output theta-phi slices at specified radii.
!        These slices are output on their own cadence controlled by
!        the parameters SLICE_IXINT and SLICE_TXINT.
!        Set SLICE_PLOTLIST to the list of fields to output.
!        Set SLICE_TP_RADII to a list of radii of the desired tp slices.
!        The slices will be output with the
!        names SLICE_TP###_<FIELD><###>.<EXT> where the last number
!        is either a 3 or 6 digit time index, and the first number is a
!        slice index. The list of slice indices and their corresponding
!        radii is written to the "o" file.
!      - Added time profiles for time-based output cadences.
!        To use, set tprofile(#)%vars to either 'io_dump_3d'
!        'io_dump_slices', and/or 'io_dump_tracers' and set the "t" and
!        "f" to the desired values. This can be used to change the
!        output cadence over time as well as start/stop output at
!        specific times.
!      - Added new output text files that list the index and time of
!        output dumps.  The files are named "mas_dumps_3d.txt",
!        "mas_dumps_slices.txt", "mas_dumps_tracers.txt", and
!        "mas_dumps_restarts.txt".  They are only written if they
!        are relevant to the run.
!      - Added a new IO_UNITS module to keep track of Fortran file
!        units. It is suggested to use this from now on.
!      - Updated write_field_2d() to not use a 3D temporary field.
!        The routine now requires you give the MPI rank you want to
!        do the file IO in the comm_r communicator as an input.
!
! ### Version 0.5.2.1, 05/04/2021, modified by RC:
!
!      - Updated floor_field() and floor_field_v() to use Fortran
!        intrinsics.
!      - Bug fix in supersonic inflow messages.  Seperate output text
!        files are now made for each MPI rank.
!
! ### Version 0.5.2.2, 05/07/2021, modified by RC:
!
!      - Small fix to allow setting t_cutoff1 to 0.  If requested,
!        it will be set to a TINY() value to avoid a NaN in boost().
!      - Modified some tp bc routines to be more OpenACC friendly.
!
! ### Version 0.5.2.3, 06/11/2021, modified by RC:
!
!      - Fixed small bug in the mas_dumps_restarts.txt file writing.
!
! ### Version 0.5.2.4, 07/08/2021, modified by RC:
!
!      - Refactored radiative loss function to be array-based.
!        This was to allow easier/better GPU implementation.
!      - Fixed code line that was past 73 characters in SETDT.
!
! ### Version 0.5.3.0, 07/21/2021, modified by RL,CD,RC:
!
!      - New features added for time-dependent coronal boundary driving.
!       - Set TIME_DEPENDENT_CORONA=.true. to activate.
!         This will set boundary velocity based on E at BC from NEWFLUX.
!         NOTE! One must have EVOLVE_FLUX=.true. to use!
!       - Additionally, one can add to this method a correction to the
!         electric field so E.B~0. Two methods are provided, both
!         will truncate their terms based on a limiting Br value set by
!         TDC_EDB_BR_EPS (in MAS B units). The current default is 0.05.
!         The two choices are:
!         1) TDC_EDB_CORRECTION_TRUNC=.true. which will preserve Br
!            evolution but truncate at neutral lines.
!         2) TDC_EDB_CORRECTION_ETMOD=.true. which will apply Slava's
!            correction to E-tangential at neutral lines to better
!            enforce E.B~0.
!            Note that this will not strictly preserve Br evolution at
!            neutral lines.  This issue is mitigated by applying a
!            photospheric resistivity whose amplitude is controlled
!            by TDC_EDB_CORRECTION_ETMOD_ETA (in MAS eta units) with a
!            current default of 2e-7.
!       - BUG FIXES for divB cleaning solver.  The RHS now has the
!         correct polar computation and boundary condition, although
!         they might not be being used.  Updated diagnostic routine
!         to output full divb for testing the divb cleaning.
!       - Small change to restart writing routine.
!
! ### Version 0.5.4.0, 08/26/2021, modified by CD:
!
!      - Fix bug/unintended behavior with TDm model when specifying Bp
!        and strapping field based on magnetic charges.
!      - No new parameters, but no more accidental flips of handedness
!        or strapping polarities based on parameter choices.
!      - All stable permutations of orientation & handedness can
!        now be realized with a positive charge_magnitude.
!      - See tdm_structure_def module for full parameter definitions.
!
! ### Version 0.5.4.1, 09/09/2021, modified by RL:
!
!      - In NEWFLUX set eps_ef=tdc_edb_br_eps instead of being fixed
!        at 1e-16.
!
! ### Version 0.5.4.2, 10/06/2021, modified by RL:
!
!      - Added capability to dump slices of all the charge states.
!        The cadence and location are controlled by the same
!        variables used for the output of the filed slices
!        (see comment for 0.5.2.0). SLICE_DUMP_FCS is true by
!        default.
!      - Added PLOT_DUMP_FCS, which control whether to dump
!        all the charge states fields.
!
! ### Version 0.5.5.0, 10/14/2021, modified by CD:
!
!      - New MAS feature: Helicity Pumping!
!      - The energized part of the vector potential can now be
!        be periodically "pumped" by adding a specified fraction
!        of A-A_pot, to A. Here A_pot is the vector potential of
!        thr potential field computed from Br at r=r0.
!      - Pumping is activated by setting HELICITY_PUMPING=.true.
!      - If active, the background potential field is calculated
!        from an extra potfld call at the start of the run.
!      - This uses Br0 computed from the actual MAS A field, and
!        after *after* any flux-ropes are inserted.
!      - The overall multiplier is set by HPUMP_CONSTANT.
!      - The spatial profile for pumping is specified in a similar
!        way to the visc and eta profiles. The profile is always
!        multiplied by your choice for HPUMP_CONSTANT.
!      - Currently the options for HPUMP_PROFILE are:
!          'UNIFORM', 'RADIALLY_DEPENDENT', 'CUSTOM_TP+R_PROFILE'
!          and 'CUSTOM_PROFILE'. Default is UNIFORM.
!        Note: Use caution with spatial profiles! Anything but a
!        uniform spatial profile will introduce spuriuous B & J.
!      - A time-profile can also be used to multiply the pump
!        fraction, specified by the tprof var: 'helicity_pumping'.
!        This time profile multiplies the HPUMP_PROFILE.
!      - The cadence of the pumps is set similarly to the plot
!        dump mechanism in MAS. Use HPUMP_CADENCE to specify the
!        interval of MAS times to apply the pumping.
!      - Use HPUMP_TIME_OFFSET (default 0.0) to add a fixed
!        offset to the cadence (e.g. cadence of 0.04 and offset
!        of 0.002 would pump (0.042, 0.082, 0.122, etc)
!      - Pumps based on iterations aren't implemented on purpose.
!      - NOTE: unlike dumps, pumping is NOT automatically done
!        on startup. Instead the criteria is checked AFTER the
!        first iteration --> set the offset and/or cadence
!        appropriately to get it to happen on the 2nd iteration.
!
! ### Version 0.5.6.0, 12/09/2021, modified by RC:
!
!      - Added RKG2 super time stepping option.  RKG2 is more
!        robust than RKL1 or RKL2, and only slightly slower.
!        To use, set STS_TYPE=3.
!        So now:
!          STS_TYPE=1 ->  RKL1
!          STS_TYPE=2 ->  RKL2
!          STS_TYPE=3 ->  RKG2
!
! ### Version 0.5.7.0, 01/05/2022, modified by RC:
!
!      - Added TIME_AT_START to input file.  This will set the initial
!        time in the code, overwriting the default time=0 for
!        non-restart runs, or the restart time.
!      - Added "insertion_time" field to all flux rope structures.
!        This defines when to insert the flux rope defined as the
!        the time (in MAS units) relative to the start of the run.
!
! ### Version 0.5.7.1, 01/07/2022, modified by RC:
!
!      - Bug fix for adding fluxropes.  a_fr was not being reset.
!
! ### Version 0.5.8.0, 03/09/2022, modified by RL/RC:
!
!      - The velocity at r=r0 in char_bc_0 is evaluated using
!        the vb%r0 2D structure instead of v.
!        This required initializing it for restart runs in start.
!      - Added routine REMOVE_EFLUX_V_FROM_VB to do that when
!        EVOLVE_FLUX and TIME_DEPENDENT_CORONA are both true.
!      - Added READ_VBR0_FROM_RESTART routine to write vb%r0 in the
!        restart file and calls to read it from file.
!      - NOTE: These changes are needed to avoid contaminations
!        of the velocity parallel to the magnetic field at the
!        boundary from flows derived from evolving boundary magnetic
!        fields.
!      - Fixed issue with rdh5 and wrh5.
!      - Made some code more in sync with ACC branch.
!
! ### Version 0.5.9.0, 04/04/2022, modified by RL/RC:
!
!      - Introduced new way to compute the boundary electric field
!       in NEWFLUX according to the two methods tdc_edb_correction_trunc
!        and tdc_edb_correction_etmod. tdc_edb_btp_a has been introduced
!        to limit the size of E_r/E_t at the neutral line.
!      - An analogous method using tdc_edb_btp_d is used to limit
!        the perpendicular velocity as a fraction of the sound speed.
!
! ### Version 0.5.10.0, 05/02/2022, modified by RL/RC:
!
!      - Introduced PCHIP high order interpolation to read magnetic
!        flux files in NEW_FLUX. One can turn it off by setting
!        IF_PCHIP=.FALSE., but no one ever should...
!        This change adds the requirement to have the PCHIP library
!        to compile MAS. The version copied to the MAS repo is from
!        https://github.com/predsci/PCHIP and the Makefiles have been
!        updated.
!
! ### Version 0.5.11.0, 05/19/2022, modified by RC:
!
!      - The indices in mas_dump_X.txt files now match the
!        file output sequence number length (3 or 6 digit).
!        This allows for the index list to be used to construct
!        proper filenames for reading data by external scripts.
!
! ### Version 0.5.12.0, 05/23/2022, modified by CD/RC:
!
!      - Added pole smoothing for Vr. Set with <pole_filter_vr=.true.>.
!        Setting FILTER_POLES=.TRUE. sets this as well.
!      - Added output of potential field in files POTFLD_B[RTP].H[5|DF].
!        This will help with remesh runs, and is useful for diagnistics.
!
! ### Version 0.5.13.0, 05/23/2022, modified by RL:
!
!      - Added FLUX_TRANSPORT2 surface flow shear type.
!
! ### Version 0.5.13.1, 05/25/2022, modified by RC:
!
!      - BUG FIX.  Error checking on writing 2D files and
!        writing vb to restarts was not being called by all procs.
!        This was causing MPI hangs.
!        Removed check_error_on_any_tpproc() as this was done wrong and
!        can be done with check_error_on_any_proc().
!
! ### Version 0.5.13.2, 05/27/2022, modified by RC:
!
!      - Made restart writing of 2D vb arrays more robust to
!        re-ordered MPI ranks.  This involved sending the array to
!        rank 0 from the "corner" rank.
!
! ### Version 0.5.13.3, 05/30/2022, modified by RC:
!
!      - BUG FIX:  Last update inadvertantly made a new bug in slice
!        slice output.   The fix requires more collective MPI ops
!        during slice writes, but otherwise some error-checking
!        would have be taken out.
!
! ### Version 0.5.13.4, 06/02/2022, modified by RC:
!
!      - BUG FIX:  Charge states slices had an MPI bug.
!
! ### Version 0.5.13.5, 06/09/2022, modified by RC/RL:
!
!      - BUG FIX:  Slices had a bug if the requested slice was
!        within or equal to a proc_r boundary.
!
! ### Version 0.5.13.6, 06/13/2022, modified by RL:
!
!      - In BC_VCROSSB, when TIME_DEPENDENT_CORONA is true,
!        set the normal electric field to (v x B) at r=R0.
!        In versions prior to 0.5.13.6 we added it
!        as a correction to the previously calculated
!        value.
!
! ### Version 0.5.14.0, 07/13/2022, modified by RL/RC:
!
!      - Added DEBUG_TDC input logical.  If set,
!        for TDC runs, the code will output
!        electric fields (and other quantities)
!        at the R0 boundary at the slice cadence.
!
! ### Version 0.5.14.1, 07/20/2022, modified by RL:
!
!      - In NEWFLUX, moved the calculation of the divergence and curl of
!        tangential electric field arrays out of the if statement for
!        TIME_DEPENDENT_CORONA.
!
! ### Version 0.5.14.2, 08/15/2022, modified by RC:
!
!      - Minor changes to further synchronize trunk and OpenACC branch.
!
! ### Version 0.5.14.3, 08/26/2022, modified by RC:
!
!      - Minor changes to further synchronize trunk and OpenACC branch.
!        (again).
!
! ### Version 0.5.14.4, 08/29/2022, modified by RC:
!
!      - Updated MPI setup to use MPI module instead of mpif.h.
!      - Fixed bug in MPI_Wait calls to use MPI_STATUS_IGNORE
!        instead of the incorrect MPI_STATUSES_IGNORE.
!
! ### Version 0.6.0.0, 09/12/2022, modified by CD/RC/RL:
!
!      Wave Turbulence Driven (WTD) merge + other updates!
!      - The WTD model branch has been merged with MAS and cleaned up.
!      - Other functionality in MAS is remains the same.
!      - Some other new options, including the chromospheric heating
!        method have also been added.
!      - NOTE: A refactor of wave pressures in addv means old runs
!        using advance_pw can differ up to floating point/CG tolerance.
!      ---------------------------------
!      WTD MODEL
!      ---------------------------------
!      - To advance Z+ and Z- waves set ADVANCE_ZW=.true.
!        - Refer to See Lionello+ 2014, Downs+ 2016, Mikic+ 2018 for
!          details on the implementation.
!      - The free WTD parameters are:
!        - WTD_Z0: Amplitude of outgoing waves at the inner boundary.
!        - WTD_B0: Reference value of B in the dissipation constant.
!        - WTD_LAMBDA0: Reference length scale in dissipation constant.
!      ---------------------------------
!      WTD equation flags:
!        - ZW_DISSP: Turn the dissipation term on/off (true).
!        - ZW_REFLECTION: Turn the reflection term on/off (true).
!        - WTD_ADD_ZW_HEATING: Add WTD heating to temperature advance.
!        - WTD_ADD_ZW_PRESSURE: Add WTD pressure term to the velocity
!              advance. This refers to zp,zm ONLY, which are seperate
!              pressures from the ep,em advance.
!      ---------------------------------
!      WTD Boundary Conditions:
!        - WTD_REFLECT_BC: The BC for the wave leaving the domain at r0.
!          - 'NONE': let the wave pass through (default).
!          - 'CONS': reflect the wave such that the net Poynting flux
!                    is ALWAYS matching the outward Poynting flux.
!          - 'AMPL': reflect the amplitude, adding it to the outgoing
!                    wave.
!        - WTD_USE_ZW_FLUX_MASK: Set to TRUE to read a 2D profile that
!            specifies a fractional reduction to the outward Poynting
!            flux. This will hit the outward z0 amplitude by sqrt of the
!            profile. The file is specified by Z0_FLUX_MASK_TP_FILE.
!      ---------------------------------
!      WTD Initial Conditions:
!        - These are Applied when not a restart or remesh run.
!        - WTD_ICOND: sets the 3D initial condition of zp,zm.
!          'CONSTANT': Set zp/zm to a constant value (default).
!          'WKB': Use 3D rho and WKB approx w/ v=0 set+zp and -zm.
!          'WKB_BR': Like WKB_BR but check Br to assign zp or zm only.
!          'EPEM': Use the wave energies in ep and em to get zp and zm.
!          'FROM_FILE': Set the radial zp, zm profiles from a 1D file.
!                       The filename is set by WTD_IC1DFILE.
!        - WTD_ICFAC: This constant multiplies all the initial
!                     conditions except 'constant' where instead the
!                     value is set directly this param (default 0.0).
!      ---------------------------------
!      WTD solver options:
!        - ZW_UWC_S: Upwind coefficient when computing the gradients
!              in the propagation and Dissipation terms (default 0.0).
!        - ZW_UWC_Z: Upwind coefficient when computing the gradients
!              in v dot grad z term (default 1.0).
!        - *NOTE* upwinding and ZW_UWC constants are not used if
!              flux-limiting is on for the corresponding term.
!        - WTD_USE_FLUX_LIMITER_GRADZW: Logical to use 2nd order
!              flux-limiting scheme for the v dot grad z term (TRUE).
!        - WTD_USE_FLUX_LIMITER_GRADSRC: Logical to use 2nd order
!              flux-limiting scheme for the propagation and reflection
!              terms (FALSE).
!        - ZW_FLUX_LIMITER_TYPE: Flux limiting function to use, either
!              'OSPRE' (default) or 'MINMOD'.
!        - ZW_CFL: CFL for the ZW advance (default=0.9).
!      ---------------------------------
!      WTD Physics Modifiers:
!        WTD_USE_ZW_EFFECTIVE_RHO_LIMIT: Create a "fake" base density
!          for the corona as seen by zw. This works by turning off
!          reflection and dissipation smoothy above a certain density
!          value to avoid over-reflection w/ smooth Br0. It is set by:
!          ZW_EFFECTIVE_RHO_LIMIT_LR: log(rho0) for the center
!             of the smooth tanh profile (MAS Units).
!          ZW_EFFECTIVE_RHO_LIMIT_LW: log(rho_width) to set the width
!             of the tanh profile in log-space (natural log, not log10)
!      ---------------------------------
!      WTD Solver, Kludges & Tricks:
!        ZW_RHO_AW: Slow down the time scale of WTD evolution by this
!          factor (e.g. 3 is 3x slower). This is to speed up the ZW
!          advance but can be suspect if you z has comparable dynamic
!          timescales to your evolution (default = 1.0).
!        WTD_USE_ZW_LIMIT: Logical to impose limits to the maxium
!          absolute values of zp and zm. This can be done as a constant
!          and/or as a radial profile.
!          ZW_LIMIT_AMPLITUDE: Maximum value for zp & zm (MAS UNITS).
!          ZW_LIMIT_RADIAL_FILE: 1D file with a radial profile for the
!            maximum absolute value of wave amplitude.
!        WTD_USE_ZW_HORHO_LIMIT: Logical to limit the heating per mass
!          density to avoid blowing up in the solar wind when something
!          is suspect with zp,zm evolution at these heights (e.g. CME).
!          ZW_HORHO_LIMIT_RLIM: Radius above which to apply the limiter.
!          ZW_HORHO_LIMIT_VALUE: max value of heat/rho (MAS Units).
!        WTD_BC_EXTRAP_FAC_R1: Dimensionless constant to limit the
!          extrapolation of va in getva_zw past the radial boundaries.
!          This works by making va_outside no less than va_inside and
!          it can be used to prevent negative extrapolated values.
!        POLE_FILTER_Z: Flag to use our scalar field pole filtering
!          scheme for zp and zm (default=False).
!      ---------------------------------
!      WTD Time Profiles:
!        - These are variables that can be controlled by using the
!          time profile funcitonality in MAS. These are used to
!          transition between one term or another --> they must
!          always be between 0 and 1. The profile names are:
!        ZW_HEAT_FACTOR: Transition between heating from the empirical
!          heat sources (0) or the WTD heating term (1). The only
!          empirical heatsource that will remain in both is the
!          'zw-exponential' style.
!        ZW_PRESSURE_FACTOR: Transition between pressure forces from
!           the WKB equation (ep,em, advance_pw, 0) and the pressure
!           forces from the WTD equation (zp,zm, advance_zw, 1).
!           If one of the terms is off then their corresponding
!           contribution is always zero.
!      ---------------------------------
!      CHROMOSPHERIC HEATING TERM:
!      ---------------------------------
!      - As described in Downs et al. 2016, we can modify our approach
!        for heating/radlosses in the chromosphere to better maintain
!        a constant temperature profile there as the large densities
!        fall of rapidly with height.
!      - This works by applying a fixed exponential heating term that
!        has its base heating scaled to match the radiative losses at
!        the base density and temperature and its scale height decaying
!        with the temperature scale height of the base temperature.
!      - The key is then modifying the radiative loss function cutoff
!        to not exactly go to zero at the base temperature, which means
!        you will have to correspondingly modify the ZQC cutoff options.
!      - USE_CHROMO_HEAT: Flag to turn this term on/off (default false).
!      - CHROMO_HEAT_T_ZQC_0: Minimum temperature of the cutoff. This is
!          where the radiative losses go to zero exactly (MAS Units).
!      - CHROMO_HEAT_T_ZQC_1: Upper temperature of the modification
!          polynomial (MAS Units).
!      ---------------------------------
!       OTHER NEW FEATURES:
!      ---------------------------------
!      - USE_PW_RCUT: Logical to manually cutoff the wave pressure
!          force below a certain height. This applies to both the
!          waves from the WKB advance (ep,em) and the waves from the
!          WTD advance (zp,zm).
!        - PW_RCUT_R0: Center radius for the tanh cutoff function.
!        - PW_RCUT_WIDTH: Width of the tanh cutoff function.
!      - RHOBC_MAXFAC_R1: Similar to WTD_BC_EXTRAP_FAC_R1, setting this
!          dimensionless constant will limit the values of rho as it
!          is extraplated beyond the half mesh boundaries. This can
!          prevent the extrapolated rho from ever going negative.
!      ---------------------------------
!      FEATURES REMOVED:
!      ---------------------------------
!      - The defunct A from J remesh solver for 2D vector potentials has
!        been removed (SOLVE_FOR_A, JFILE, NRELAX_MAX).
!      - CDs WTD branch version of reading 3D files after a remesh
!        has been removed. It is superceded by the LOAD_FIELDS
!        functionality, which has been updated for zp, zm.
!      - Many of the experimental WTD options from the WTD branch have
!        also been removed. See the tagged version before the merge
!        (mas_wtd_dev_0.5.14.4) for the code/implementation.
!        This includes:
!        - The Reynolds stress terms (full and field aligned versions).
!        - Various cutoffs based on J and beta for the Reflection term.
!        - ZW diffusion scheme.
!        - An extra exponent in the dissipation term.
!        - A modification to run the amplitude equation like the
!          Michigan equation for wave reflection (remove flow).
!
! ### Version 0.7.0.0, 01/12/2023, modified by RC/MS:
!
!      - Replaced many "do" loops with "do concurrent"
!        to synchronize with GPU branch.
!        The makes MAS only work with compilers that support
!        Fortan 2008 and up (all of them do at this point).
!      - NOTE TO DEVELOPERS:  Please use "do concurrent"
!        for all future development in main computation parts of the
!        code if allowed (i.e. no reductions or data dependencies).
!        For things added to setup, keep using "do" as usual (for now).
!      - Added some minimal OpenACC and OpenMP to enable
!        hybrid threaded mode on supported compilers, as well
!        as GPU acceleration when using unified managed memory
!        with NVIDIA.  For good GPU performance, OpenACC data
!        directives are needed.  This is done in the GPU branch.
!
! ### Version 0.7.1.0, 01/16/2023, modified by RC:
!
!      - Added "do concurrent" to WTD advance,"freeze_b" mode,
!        and charge states.
!
! ### Version 0.7.1.1, 01/19/2023, modified by RC:
!
!      - Small modifications to get code to work for WTD runs
!        on GPUs using unified managed memory.
!        Note that charge states still do not work on GPUs.
!
! ### Version 0.7.1.2, 01/23/2023, modified by RC:
!
!      - Some fixes to running in GPU mode.  Some
!        cosmetic changes to sync to acc branch.
!
! ### Version 0.7.1.3, 01/24/2023, modified by RC:
!
!      - Some minor changes to charge states to
!        synch with ACC branch.
!        NOTE! Charge states currently do NOT
!        work with trunk code compiled to GPUs.
!        They DO work with the ACC branch.
!        Charge states could use a modification
!        to use non-static data and 1D arrays
!        instead of local 2D matrices.
!        This would make the GPU ACC runs faster, and
!        may allow the trunk to work on GPUs as well.
!
! ### Version 0.7.1.4, 02/01/2023, modified by RC:
!
!      - BUG FIX: In remesh routines / divb solver.
!
! ### Version 0.7.1.5, 02/02/2023, modified by RC:
!
!      - BUG FIX: seam_bvec only seams in directions
!        needed for jfromb.  So the two newer uses were
!        not correct as all the components may need
!        seaming.
!      - BUG FIX: The projection routines for v_par
!        were using a mix of the input field and the
!        global field.  May have messed up pred-corr.
!      - BUG FIX: Vpar (freezeb) preconditioner was wrong.
!
! ### Version 0.7.1.6, 02/09/2023, modified by RC/CD:
!
!      - BUG FIX: the dimensions used in adding a loaded
!        field other than b were wrong.
!      - Updated divb cleaner routines to be consistent with
!        each other and easier-to-read indices.
!      - Added new b-cleaning option: LOADED_B_CLEAN_METHOD=3
!        This does the divb cleaning solve but then ALSO
!        flux balances the slices of Br (like method 2)
!        This removes the unwanted small north pole error
!        in Br at the lower boundary.
!        It is now the default.
!        Eventually, the divb cleaner should be refined to
!        work on its own.
!      - It is observed that the Ar that comes out of remeshing
!        is more sensitive to changes in solver parameters
!        (pc/ifprec, epscg, etc.) that it is expected to be.
!        This may be due to the pot2dh solver's (non) treatment
!        of the poles.  This should be investigated.
!
! ### Version 0.7.2.0, 06/09/2023, modified by RC:
!
!      - Added automatic subcycling of viscosity and thermal conduction.
!        Not implemented for STS/EXP when using vpar.
!        Implemented for both temp_e and temp_p TC.
!        Can also auto-subcycle PCG solvers as well.
!      - Added more output file flushers.
!      - Added viscosity timer.
!
! ### Version 0.7.3.0, 07/11/2023, modified by RC:
!
!      - Updated automatic subcycling of viscosity and
!        thermal conduction. The cycle dt can no longer go lower
!        within the cycle. This should stabalize the method.
!
! ### Version 0.7.3.1, 08/16/2023, modified by RC:
!
!      - Code will enable automatic subcycling
!        for viscosity and/or thermal conduction if an STS method
!        is being used.  This is to ensure robustness.
!        Use tc/visc_subcycles_max=1 to override this feature.
!      - The RKG2 STS method is now the default STS method type.
!
! ### Version 0.7.3.2, 08/23/2023, modified by RC:
!
!      - Updated automatic subcycling (PTL) time step calculation
!        to avoid small steps near zero-valued fields.
!
! ### Version 0.7.3.3, 09/14/2023, modified by RC:
!
!      - Small updates to field limiter and floor field.
!      - Slice output bug fix for ACC branch.
!
! ### Version 0.7.3.4, 09/15/2023, modified by RC:
!
!      - Fixed MPI bug introduced in previous update.
!      - Updated PTL. This may be updated again soon.
!        The new update may make PTL runs a bit slower,
!        but with more robust solutions.
!
! ### Version 0.7.3.5, 09/18/2023, modified by RC:
!
!      - The method for flushing the output files
!        was causing hangs on some supercomputers.
!        This has been changed to a new method that avoids the issues.
!
! ### Version 0.7.3.6, 10/12/2023, modified by RC:
!
!      - Yet another update to the PTL method.
!        This will probably stick around for some time.
!
! ### Version 0.7.3.7, 11/07/2023, modified by RC:
!
!      - Small bug fix that was preventing the
!        sts methods to run without the PTL cycles.
!
! ### Version 0.7.4.0, 01/31/2024, modified by RL:
!
!      - Added capability to run time dependent corona runs
!        from files. TIME_DEPENDENT_CORONA_FROM_FILES must be
!        set to true, The syntax is similar to PRESCRIBE_BV runs,
!        although only Br, Vt, Vp, and a Phi potential are read.
!        The prefix are respectively BR_TDCFF_FILE,VT_TDCFF_FILE,
!        and VP_TDCFF_FILE. The arrays of sequences and nodes are
!        TDCFF_SEQUENCE and TDCFF_NODE. Optionally, one can use
!        DELTAT_TDCFF to specify a time interval difference between
!        the calculation time and the nodes (default is zero).
!        Note: set  EVOLVE_FLUX=.true.,ROTATION_FLUX=.true.,
!        and IF_PCHIP=.false.
!
! ### Version 0.7.5.0, 03/06/2024, modified by CD:
!      - Added a Poynting flux limiter to the WTD model that will
!        limit the amount of heat dumped into open field lines.
!      - It uses the WKB wave energies (ep,em) to determine if
!        the boundary is connected to an open or closed field line.
!        ---> ADVANCE_PW. = .true. is required!
!      - Activate this feature with WTD_USE_OPEN_FIELD_CUTOFF=.true.
!      - The approximate flux limit is set in CGS units, e.g. for
!        max ~10^6 erg s-1 cm-2, set WTD_OPEN_CUTOFF_MAXFLUX=1.e6
!      - The limiter smooths the cutoff around this value and uses
!        sqrt of the grid spacing to allow more for flux to enter
!        high-res grids (see the implementation for details).
!      - Because we don't want the limiter to oscillate in time it,
!        "equilibrates" slowly at a timescale specified in seconds by
!        updating a moving average. E.g. WTD_OPEN_CUTOFF_DT_EQ_S=120.
!        will set the desired timescale to two minutes.
!      - For this reason, the limiter field is saved in restarts when
!        this option is on and will be used upon restarting if present.
!      - ALSO added a debugging option for WTD, which currently will
!        dump the boundary slices for the WTD Poynting flux and the
!        limiter fields. Activate with DEBUG_WTD =.true. and
!        DEBUG_WTD_OPEN_FIELD_CUTOFF =.true.
!
! ### Version 0.7.5.1, 03/18/2024, modified by CD:
!      - TDC file sequence can use .h5 files now. Specify the
!        file extension by setting TDCFF_EXTENSION='h5' or 'hdf'
!
! ### Version 0.7.5.2, 03/19/2024, modified by RL:
!      - Increased maximum number of nodes in a time profile.
!        MX_TP_NODES=5000
!      - Added time profile for tdc_phi, which hits phi_tdc
!
! ### Version 0.7.5.3, 03/20/2024, modified by RL:
!      - Now we write in the supersonic flow files only for the
!        first occurrence.
!
! ### Version 0.7.5.4, 03/28/2024, modified by RC:
!      - Fixed bug in char_bc0.  Was doing redundent computations
!        that was causing a slowdown/stall on some GPU runs.
!
! ### Version 0.7.5.5, 08/09/2024, modified by RL:
!      - Fixed bug in setup_ip_boundaries. Was expecting hdf files
!        even if helioh5in=.true.
!
! ### Version 0.7.5.6, 08/14/2024, modified by RC:
!      - Reworked some hdf5 restart routines to make them
!        more compatible with different versions of the hdf5 library.
!
! ### Version 0.7.5.7, 08/16/2024, modified by RC:
!      - Small fix to wtd mask output to make sure the filename
!        correctly conforms to the chosen output format with the
!        chosen filename.
!
! ### Version 0.7.6.0, 08/20/2024, modified by RC:
!      - Update to PTL method (taken from HipFT).
!
! ### Version 0.8.0.0, 12/13/2024, modified by RC:
!      - MAJOR CHANGE:  MAS no longer supports hdf4.
!        All default filenames that were hard-coded
!        have been changed from ".hdf" to ".h5".
!        All hdf4 routines and variables have been removed.
!        All references to selecting hdf format must be taken
!        out of all input files, and all input hdf4 files
!        (e.g. BCs) should be converted to h5 using the PSI tool
!        hdfh5 or psi_hdf2hdf.py.
!        NOTE: This means that MAS no longer requires
!              custom-compiled hdf4, zlib, nor jpeg to compile and run.
!              Only MPI and HDF5 are now required.
!
! ### Version 0.8.1.0, 03/31/2025, modified by RC:
!      - Removed SVN sed variables.
!      - Removed need for compile-time sed command for system name and
!        type as MAS now uses Fortran standard commands to get that
!        information at run time.
!      - Added compiler and compiler flag information to run output.
!        This info is not (yet) included in restart files.
!      - Removed seam_vvec_cpu() and replaced last few calls of it
!        with calls to seam() on each component.
!
! ### Version 0.9.0.0, 04/02/2025, modified by RC:
!      - SUPER MAJOR CHANGE: MAS is now a Fortran 90 code with free-form
!                       and Fortran 90 style continuations and comments.
!                       The EXPMAC tool in the github has been updated
!                       to handle the new format.
!
! ### Version 0.9.0.1, 04/03/2025, modified by RC:
!      - Many small changes to make code Fortran 2018 compliant.
!
! ### Version 0.9.1.0, 04/04/2025, modified by RC:
!      - Added a check for GPU runs that detects the NVIDIA compiler
!        and sets the if_prec parameters correctly for a GPU run.
!        If/when we implement the cuSparse ILU0, this check will have to
!        be modified.
!      - Cleaned up namelist reading since we don't use Absoft anymore.
!
! ### Version 0.9.2.0, 04/07/2025, modified by RC:
!      - Updated default of upwind_a to 1.0 instead of 0.
!      - Increased default max solver iterations and # of time steps.
!      - Added legacy_output_filenames logical parameter to
!        determine if updated output filenames should be used or not.
!      - Some code cleanup.
!      - Namelist parameters are now output after processing them so the
!        resulting information is true to the run.
!
! ### Version 0.9.2.1, 04/23/2025, modified by RC:
!      - GPU optimizations.
!
! ### Version 0.9.3.0, 04/28/2025, modified by RC:
!      - Default changed to not use implicit radiation loss.method
!        (ifimplrad=0).
!
! ### Version 0.9.3.1, 05/07/2025, modified by RC:
!      - BUG FIX:  The GPU ifprec detection was only happening on
!                  process 0, so multi-GPU runs were stalling.
!                  Also, fixed mismatch in char size of cmd line arg.
!
! ### Version 0.9.4.0, 05/12/2025, modified by RC:
!      - Made some quality of life changes to output file.
!        More writes are flushed.
!      - Added periodic solver output to initial pot2d and pot3d solves.
!
! ### Version 0.9.4.1, 05/19/2025, modified by MS:
!      - Updated solvers to allocate and set IA for PC 2 and 3
!        at the start of the code.  This allows the diacsr routines
!        to be vectorized (and offloaded to gpus).
!
! ### Version 0.9.4.2, 05/20/2025, modified by RC:
!      - Fixed error checking on 2D solves.
!
! ### Version 0.9.4.3, 05/23/2025, modified by MS:
!      - Changed "p" and "ap" temporary arrays in CG solver to be
!        allocatable instead of local stack arrays.
!
! ### Version 0.9.5.0, 05/27/2025, modified by MS+RC:
!      - Added IFPREC_32 input parameter.  If set,
!        the preconditioner for the solves will use
!        single precision instead of double.
!
! ### Version 0.9.6.0, 06/19/2025, modified by RC:
!      - Started adding optimizations for GPU runs by using pointers
!        instead of derived type redirection within DC loops.
!
! ### Version 0.9.7.0, 07/07/2025, modified by RC:
!      - Added basic documentation to namelist declaration for all
!        input parameters.  Moved namelist in code right after
!        program MAS.  This is a work in progress and more
!        details will be added later.
!      - Removed the following depricated and/or unused parameters:
!          - UPWIND_A_R0
!          - OLD_JXB_DIAG
!          - CHAR_BC
!          - P_CUTOFF1
!          - THPROF_TH
!          - THPROF_DTH
!          - BHAT_FACTOR_BR0
!          - BHAT_FACTOR_MULT
!          - TDM_PRESERVE_BR0
!          - IP_RADIUS
!      - Fixed some typos.
!
!#######################################################################
